var D2Reader = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateWrapper = (obj, member, setter, getter) => ({
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  });
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/process/browser.js"(exports2, module2) {
      init_polyfills();
      var process2 = module2.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop() {
      }
      process2.on = noop;
      process2.addListener = noop;
      process2.once = noop;
      process2.off = noop;
      process2.removeListener = noop;
      process2.removeAllListeners = noop;
      process2.emit = noop;
      process2.prependListener = noop;
      process2.prependOnceListener = noop;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module2.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "node_modules/has-proto/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var test = {
        foo: {}
      };
      var $Object = Object;
      module2.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module2.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var implementation = require_implementation();
      module2.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var bind = require_function_bind();
      module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module2.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module2.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var hasSymbols = require_shams();
      module2.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module2.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module2.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module2.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? globalThis : globalThis;
      module2.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module2.exports = $gOPD;
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? globalThis : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          cache["$" + typedArray] = callBind(arr.slice);
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(cache, function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        });
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(cache, function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {
            }
          }
        });
        return found;
      };
      module2.exports = function whichTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var whichTypedArray = require_which_typed_array();
      module2.exports = function isTypedArray(value) {
        return !!whichTypedArray(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports2) {
      "use strict";
      init_polyfills();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction;
      exports2.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports2, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
      init_polyfills();
      module2.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module2) {
      init_polyfills();
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports2) {
      init_polyfills();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports2.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports2.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports2.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports2.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports2.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      exports2.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports2.isDate = isDate;
      exports2.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports2.isError = isError;
      exports2.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = require_inherits_browser();
      exports2._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports2.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports2.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports2.callbackify = callbackify;
    }
  });

  // polyfills.js
  var process, util;
  var init_polyfills = __esm({
    "polyfills.js"() {
      process = require_browser();
      util = require_util();
    }
  });

  // node_modules/r2-shared-js/node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function")
        throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn)
        context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access)
        context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_ = accept(result.get))
          descriptor.get = _;
        if (_ = accept(result.set))
          descriptor.set = _;
        if (_ = accept(result.init))
          initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field")
          initializers.unshift(_);
        else
          descriptor[key] = _;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol")
      name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m, o) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
        __createBinding(o, m, p);
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
      throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "node_modules/r2-shared-js/node_modules/tslib/tslib.es6.mjs"() {
      init_polyfills();
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign3(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources
      };
    }
  });

  // node_modules/r2-shared-js/node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/r2-shared-js/node_modules/ms/index.js"(exports2, module2) {
      init_polyfills();
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/r2-shared-js/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/r2-shared-js/node_modules/debug/src/common.js"(exports2, module2) {
      init_polyfills();
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index2 = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index2++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index2];
                match = formatter.call(self2, val);
                args.splice(index2, 1);
                index2--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup;
    }
  });

  // node_modules/r2-shared-js/node_modules/debug/src/browser.js
  var require_browser2 = __commonJS({
    "node_modules/r2-shared-js/node_modules/debug/src/browser.js"(exports2, module2) {
      init_polyfills();
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index2++;
          if (match === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load2() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/ta-json-x/dist/cjs/types.js
  var require_types2 = __commonJS({
    "node_modules/ta-json-x/dist/cjs/types.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/ta-json-x/dist/cjs/classes/property-definition.js
  var require_property_definition = __commonJS({
    "node_modules/ta-json-x/dist/cjs/classes/property-definition.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PropertyDefinition = void 0;
      var PropertyDefinition = class {
        constructor() {
          this.array = false;
          this.set = false;
          this.readonly = false;
          this.writeonly = false;
        }
      };
      exports2.PropertyDefinition = PropertyDefinition;
    }
  });

  // node_modules/ta-json-x/dist/cjs/classes/object-definition.js
  var require_object_definition = __commonJS({
    "node_modules/ta-json-x/dist/cjs/classes/object-definition.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTypedInheritanceChain = exports2.getInheritanceChain = exports2.getDefinition = exports2.objectDefinitions = exports2.ObjectDefinition = void 0;
      var property_definition_1 = require_property_definition();
      var ObjectDefinition = class {
        constructor() {
          this.ctr = () => {
          };
          this.beforeDeserialized = () => {
          };
          this.onDeserialized = () => {
          };
          this.properties = /* @__PURE__ */ new Map();
        }
        getProperty(key) {
          let property = this.properties.get(key);
          if (!property) {
            property = new property_definition_1.PropertyDefinition();
            this.properties.set(key, property);
          }
          return property;
        }
      };
      exports2.ObjectDefinition = ObjectDefinition;
      exports2.objectDefinitions = /* @__PURE__ */ new Map();
      function getDefinition(target) {
        let definition = exports2.objectDefinitions.get(target);
        if (!definition) {
          definition = new ObjectDefinition();
          exports2.objectDefinitions.set(target, definition);
        }
        return definition;
      }
      exports2.getDefinition = getDefinition;
      function getInheritanceChain(type) {
        if (!type) {
          return [];
        }
        const parent = Object.getPrototypeOf(type);
        return [type.constructor].concat(getInheritanceChain(parent));
      }
      exports2.getInheritanceChain = getInheritanceChain;
      function getChildClassDefinitions(parentType) {
        const childDefs = [];
        exports2.objectDefinitions.forEach((def, type) => {
          const superClass = Object.getPrototypeOf(type.prototype).constructor;
          if (superClass === parentType) {
            childDefs.push([type, def]);
          }
        });
        return childDefs;
      }
      function getTypedInheritanceChain(type, object) {
        const parentDef = exports2.objectDefinitions.get(type);
        let childDefs = [];
        if (object && parentDef && parentDef.discriminatorProperty) {
          childDefs = childDefs.concat(getChildClassDefinitions(type));
        }
        let actualType;
        while (childDefs.length !== 0 && !actualType) {
          const [t, def] = childDefs.shift();
          if (def.hasOwnProperty("discriminatorValue")) {
            if (object && parentDef && def.discriminatorValue === object[parentDef.discriminatorProperty]) {
              if (def.hasOwnProperty("discriminatorProperty")) {
                return getTypedInheritanceChain(t, object);
              }
              actualType = t;
            }
          } else {
            childDefs = childDefs.concat(getChildClassDefinitions(t));
          }
        }
        if (!actualType) {
          actualType = type;
        }
        const inheritanceChain = new Set(getInheritanceChain(Object.create(actualType.prototype)));
        return Array.from(inheritanceChain).filter((t) => exports2.objectDefinitions.has(t));
      }
      exports2.getTypedInheritanceChain = getTypedInheritanceChain;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-object.js
  var require_json_object = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-object.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonObject = void 0;
      var object_definition_1 = require_object_definition();
      function JsonObject3() {
        return function(constructor) {
          object_definition_1.getDefinition(constructor);
        };
      }
      exports2.JsonObject = JsonObject3;
    }
  });

  // node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "node_modules/reflect-metadata/Reflect.js"() {
      init_polyfills();
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
          var exporter = makeExporter(Reflect3);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          } else {
            exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter);
          function makeExporter(target, previous) {
            return function(key, value) {
              if (typeof target[key] !== "function") {
                Object.defineProperty(target, key, { configurable: true, writable: true, value });
              }
              if (previous)
                previous(key, value);
            };
          }
        })(function(exporter) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
              return hasOwn.call(map, key);
            } : function(map, key) {
              return key in map;
            },
            get: downLevel ? function(map, key) {
              return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
              return map[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
          var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var Metadata = new _WeakMap();
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject(target))
                throw new TypeError();
              if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(metadataKey))
              return false;
            if (metadataMap.size > 0)
              return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
              return true;
            Metadata.delete(target);
            return true;
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
              var decorator = decorators[i];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
              var decorator = decorators[i];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
          }
          function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
              var key = ownKeys_1[_i];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
              var key = parentKeys_1[_a];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys.length = k;
                return keys;
              }
              var nextValue = IteratorValue(next);
              try {
                keys[k] = nextValue;
              } catch (e) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e;
                }
              }
              k++;
            }
          }
          function Type(x) {
            if (x === null)
              return 1;
            switch (typeof x) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x) {
            return x === void 0;
          }
          function IsNull(x) {
            return x === null;
          }
          function IsSymbol(x) {
            return typeof x === "symbol";
          }
          function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
              var toString_1 = O.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                  return result;
              }
              var valueOf = O.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                  return result;
              }
            } else {
              var valueOf = O.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                  return result;
              }
              var toString_2 = O.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function GetMethod(V, P) {
            var func = V[P];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
              f.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O)
              return proto;
            return constructor;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              function() {
                function MapIterator2(keys, values, selector2) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector2;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index2 = this._index;
                  if (index2 >= 0 && index2 < this._keys.length) {
                    var result = this._selector(this._keys[index2], this._values[index2]);
                    if (index2 + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value, done: true };
                };
                return MapIterator2;
              }()
            );
            return (
              /** @class */
              function() {
                function Map2() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map2.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map2.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map2.prototype.get = function(key) {
                  var index2 = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index2 >= 0 ? this._values[index2] : void 0;
                };
                Map2.prototype.set = function(key, value) {
                  var index2 = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index2] = value;
                  return this;
                };
                Map2.prototype.delete = function(key) {
                  var index2 = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index2 >= 0) {
                    var size = this._keys.length;
                    for (var i = index2 + 1; i < size; i++) {
                      this._keys[i - 1] = this._keys[i];
                      this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map2.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map2.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map2.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map2.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map2.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map2.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map2.prototype._find = function(key, insert) {
                  if (this._cacheKey !== key) {
                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map2;
              }()
            );
            function getKey(key, _) {
              return key;
            }
            function getValue(_, value) {
              return value;
            }
            function getEntry(key, value) {
              return [key, value];
            }
          }
          function CreateSetPolyfill() {
            return (
              /** @class */
              function() {
                function Set2() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set2.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set2.prototype.has = function(value) {
                  return this._map.has(value);
                };
                Set2.prototype.add = function(value) {
                  return this._map.set(value, value), this;
                };
                Set2.prototype.delete = function(value) {
                  return this._map.delete(value);
                };
                Set2.prototype.clear = function() {
                  this._map.clear();
                };
                Set2.prototype.keys = function() {
                  return this._map.keys();
                };
                Set2.prototype.values = function() {
                  return this._map.values();
                };
                Set2.prototype.entries = function() {
                  return this._map.entries();
                };
                Set2.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set2.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set2;
              }()
            );
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              }()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
              for (var i = 0; i < size; ++i)
                buffer[i] = Math.random() * 255 | 0;
              return buffer;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                  return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                  return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-property.js
  var require_json_property = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-property.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonProperty = void 0;
      require_Reflect();
      var object_definition_1 = require_object_definition();
      function JsonProperty(propertyName) {
        return function(target, key) {
          const type = Reflect.getMetadata("design:type", target, key.toString());
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          property.serializedName = propertyName || key.toString();
          property.array = type === Array;
          property.set = type === Set;
          if (!property.array && !property.set && !property.type) {
            property.type = type;
          }
        };
      }
      exports2.JsonProperty = JsonProperty;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-type.js
  var require_json_type = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-type.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonType = void 0;
      var object_definition_1 = require_object_definition();
      function JsonType(type) {
        return function(target, key) {
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          property.type = type;
        };
      }
      exports2.JsonType = JsonType;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-element-type.js
  var require_json_element_type = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-element-type.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonElementType = void 0;
      var object_definition_1 = require_object_definition();
      function JsonElementType(type) {
        return function(target, key) {
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          property.type = type;
        };
      }
      exports2.JsonElementType = JsonElementType;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-converter.js
  var require_json_converter = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonConverter = void 0;
      var object_definition_1 = require_object_definition();
      function JsonConverter(converter) {
        return function(target, key) {
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          if (typeof converter === "function") {
            property.converter = new converter();
          } else {
            property.converter = converter;
          }
        };
      }
      exports2.JsonConverter = JsonConverter;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-readonly.js
  var require_json_readonly = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-readonly.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonReadonly = void 0;
      var object_definition_1 = require_object_definition();
      function JsonReadonly() {
        return function(target, key) {
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          property.readonly = true;
        };
      }
      exports2.JsonReadonly = JsonReadonly;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-writeonly.js
  var require_json_writeonly = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-writeonly.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonWriteonly = void 0;
      var object_definition_1 = require_object_definition();
      function JsonWriteonly() {
        return function(target, key) {
          const property = object_definition_1.getDefinition(target.constructor).getProperty(key.toString());
          property.writeonly = true;
        };
      }
      exports2.JsonWriteonly = JsonWriteonly;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-discriminator-property.js
  var require_json_discriminator_property = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-discriminator-property.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonDiscriminatorProperty = void 0;
      var object_definition_1 = require_object_definition();
      function JsonDiscriminatorProperty(property) {
        return function(constructor) {
          object_definition_1.getDefinition(constructor).discriminatorProperty = property;
        };
      }
      exports2.JsonDiscriminatorProperty = JsonDiscriminatorProperty;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-discriminator-value.js
  var require_json_discriminator_value = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-discriminator-value.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonDiscriminatorValue = void 0;
      var object_definition_1 = require_object_definition();
      function JsonDiscriminatorValue(value) {
        return function(constructor) {
          object_definition_1.getDefinition(constructor).discriminatorValue = value;
        };
      }
      exports2.JsonDiscriminatorValue = JsonDiscriminatorValue;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/json-constructor.js
  var require_json_constructor = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/json-constructor.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonConstructor = void 0;
      var object_definition_1 = require_object_definition();
      function JsonConstructor() {
        return function(target, key) {
          const definition = object_definition_1.getDefinition(target.constructor);
          definition.ctr = target[key.toString()];
        };
      }
      exports2.JsonConstructor = JsonConstructor;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/before-deserialized.js
  var require_before_deserialized = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/before-deserialized.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BeforeDeserialized = void 0;
      var object_definition_1 = require_object_definition();
      function BeforeDeserialized() {
        return function(target, key) {
          const definition = object_definition_1.getDefinition(target.constructor);
          definition.beforeDeserialized = target[key.toString()];
        };
      }
      exports2.BeforeDeserialized = BeforeDeserialized;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/on-deserialized.js
  var require_on_deserialized = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/on-deserialized.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.OnDeserialized = void 0;
      var object_definition_1 = require_object_definition();
      function OnDeserialized() {
        return function(target, key) {
          const definition = object_definition_1.getDefinition(target.constructor);
          definition.onDeserialized = target[key.toString()];
        };
      }
      exports2.OnDeserialized = OnDeserialized;
    }
  });

  // node_modules/ta-json-x/dist/cjs/decorators/index.js
  var require_decorators = __commonJS({
    "node_modules/ta-json-x/dist/cjs/decorators/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding3(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar3(require_json_object(), exports2);
      __exportStar3(require_json_property(), exports2);
      __exportStar3(require_json_type(), exports2);
      __exportStar3(require_json_element_type(), exports2);
      __exportStar3(require_json_converter(), exports2);
      __exportStar3(require_json_readonly(), exports2);
      __exportStar3(require_json_writeonly(), exports2);
      __exportStar3(require_json_discriminator_property(), exports2);
      __exportStar3(require_json_discriminator_value(), exports2);
      __exportStar3(require_json_constructor(), exports2);
      __exportStar3(require_before_deserialized(), exports2);
      __exportStar3(require_on_deserialized(), exports2);
    }
  });

  // node_modules/ta-json-x/dist/cjs/converters/date-converter.js
  var require_date_converter = __commonJS({
    "node_modules/ta-json-x/dist/cjs/converters/date-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DateConverter = void 0;
      var DateConverter = class {
        serialize(property) {
          return property.toString();
        }
        deserialize(value) {
          return new Date(value);
        }
        collapseArrayWithSingleItem() {
          return false;
        }
      };
      exports2.DateConverter = DateConverter;
    }
  });

  // node_modules/ta-json-x/dist/cjs/converters/buffer-converter.js
  var require_buffer_converter = __commonJS({
    "node_modules/ta-json-x/dist/cjs/converters/buffer-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BufferConverter = void 0;
      var BufferConverter = class {
        constructor(encoding = "json") {
          this._encoding = encoding;
        }
        serialize(property) {
          if (this._encoding === "json") {
            return property.toJSON();
          }
          return property.toString(this._encoding);
        }
        deserialize(value) {
          if (this._encoding === "json") {
            return Buffer.from(value.data);
          }
          return Buffer.from(value, this._encoding);
        }
        collapseArrayWithSingleItem() {
          return false;
        }
      };
      exports2.BufferConverter = BufferConverter;
    }
  });

  // node_modules/ta-json-x/dist/cjs/converters/converter.js
  var require_converter = __commonJS({
    "node_modules/ta-json-x/dist/cjs/converters/converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.propertyConverters = void 0;
      var date_converter_1 = require_date_converter();
      var buffer_converter_1 = require_buffer_converter();
      exports2.propertyConverters = /* @__PURE__ */ new Map();
      if (typeof window === "undefined") {
        exports2.propertyConverters.set(Buffer, new buffer_converter_1.BufferConverter());
      }
      exports2.propertyConverters.set(Date, new date_converter_1.DateConverter());
    }
  });

  // node_modules/ta-json-x/dist/cjs/converters/index.js
  var require_converters = __commonJS({
    "node_modules/ta-json-x/dist/cjs/converters/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding3(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar3(require_converter(), exports2);
      __exportStar3(require_buffer_converter(), exports2);
      __exportStar3(require_date_converter(), exports2);
    }
  });

  // node_modules/ta-json-x/dist/cjs/methods/serialize.js
  var require_serialize = __commonJS({
    "node_modules/ta-json-x/dist/cjs/methods/serialize.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.serialize = void 0;
      var util2 = require_util();
      var converter_1 = require_converter();
      var object_definition_1 = require_object_definition();
      function serialize(value, type, options = { keyToPreserveUnknownJSON: void 0 }) {
        if (value.constructor === Array) {
          return value.map((o) => serializeRootObject(o, type, options));
        }
        return serializeRootObject(value, type, options);
      }
      exports2.serialize = serialize;
      function serializeRootObject(object, type = Object.getPrototypeOf(object).constructor, options) {
        const inheritanceChain = object_definition_1.getTypedInheritanceChain(type);
        if (inheritanceChain.length === 0) {
          return object;
        }
        const definitions = inheritanceChain.map((t) => object_definition_1.objectDefinitions.get(t)).filter((t) => !!t);
        const output = {};
        definitions.forEach((d) => {
          d.properties.forEach((p, key) => {
            if (!p.type) {
              throw new Error(`Cannot serialize property '${key}' without type!`);
            }
            const value = object[key];
            if (value == void 0 || p.writeonly) {
              return;
            }
            if (p.set) {
              output[p.serializedName] = serializeArray(Array.from(value || []), p, options);
              return;
            }
            if (p.array) {
              output[p.serializedName] = serializeArray(value, p, options);
              return;
            }
            output[p.serializedName] = serializeObject(value, p, options);
          });
        });
        if (options.keyToPreserveUnknownJSON) {
          const anchor = options.keyToPreserveUnknownJSON;
          if (object[anchor]) {
            const jsonProps = Object.keys(object[anchor]);
            for (const jsonProp of jsonProps) {
              if (object[anchor].hasOwnProperty(jsonProp)) {
                let property;
                definitions.forEach((d) => {
                  d.properties.forEach((p, key) => {
                    if (!property && jsonProp === p.serializedName) {
                      property = p;
                    }
                  });
                });
                if (!property) {
                  if (typeof output[jsonProp] !== "undefined") {
                    console.log(`???!!! TAJSON keyToPreserveUnknownJSON already serialized?! ${anchor}.${jsonProp}`);
                    console.log(util2.inspect(output[jsonProp], { showHidden: false, depth: 1e3, colors: true, customInspect: false }));
                    if (output[jsonProp] !== object[anchor][jsonProp]) {
                      console.log(`???!!! TAJSON keyToPreserveUnknownJSON already serialized DIFF?! ${anchor}.${jsonProp}`);
                      console.log(util2.inspect(object[anchor][jsonProp], { showHidden: false, depth: 1e3, colors: true, customInspect: false }));
                    }
                  }
                  output[jsonProp] = object[anchor][jsonProp];
                }
              }
            }
          }
        }
        return output;
      }
      function serializeArray(array, definition, options) {
        const arr = array.map((v) => serializeObject(v, definition, options));
        if (arr.length === 1) {
          const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
          if (converter && converter.collapseArrayWithSingleItem()) {
            return arr[0];
          }
        }
        return arr;
      }
      function serializeObject(object, definition, options) {
        const primitive = definition.type === String || definition.type === Boolean || definition.type === Number;
        const value = object;
        const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
        if (converter) {
          return converter.serialize(value);
        }
        if (!primitive) {
          const objDefinition = object_definition_1.objectDefinitions.get(definition.type);
          if (objDefinition) {
            if (value instanceof definition.type) {
              return serialize(value, void 0, options);
            }
            return serialize(value, definition.type, options);
          }
        }
        return value;
      }
    }
  });

  // node_modules/ta-json-x/dist/cjs/methods/deserialize.js
  var require_deserialize = __commonJS({
    "node_modules/ta-json-x/dist/cjs/methods/deserialize.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deserialize = void 0;
      var util2 = require_util();
      var object_definition_1 = require_object_definition();
      var converter_1 = require_converter();
      function deserialize(object, type, options = { runConstructor: false, keyToPreserveUnknownJSON: void 0 }) {
        if (object && object.constructor === Array) {
          return object.map((o) => deserializeRootObject(o, type, options));
        }
        return deserializeRootObject(object, type, options);
      }
      exports2.deserialize = deserialize;
      function deserializeRootObject(object, objectType = Object, options) {
        if (!object_definition_1.objectDefinitions.has(objectType)) {
          return object;
        }
        const values = object;
        const [type, ...superTypes] = object_definition_1.getTypedInheritanceChain(objectType, values);
        const output = Object.create(type.prototype);
        const definitions = [...superTypes.reverse(), type].map((t) => object_definition_1.objectDefinitions.get(t)).filter((t) => !!t);
        definitions.forEach((d) => {
          if (options.runConstructor) {
            d.ctr.call(output);
          }
          d.beforeDeserialized.call(output);
          d.properties.forEach((p, key) => {
            if (!p.type) {
              throw new Error(`Cannot deserialize property '${key}' without type!`);
            }
            const value = values[p.serializedName];
            if (value == void 0 || p.readonly) {
              return;
            }
            if (p.array || p.set) {
              output[key] = deserializeArray(value, p, options);
              if (p.set) {
                output[key] = new Set(output[key]);
              }
              return;
            }
            output[key] = deserializeObject(value, p, options);
          });
          d.onDeserialized.call(output);
        });
        if (options.keyToPreserveUnknownJSON) {
          const anchor = options.keyToPreserveUnknownJSON;
          Object.keys(values).forEach((jsonProp) => {
            if (values.hasOwnProperty(jsonProp)) {
              let property;
              definitions.forEach((d) => {
                d.properties.forEach((p, key) => {
                  if (!property && jsonProp === p.serializedName) {
                    property = p;
                  }
                });
                if (!property) {
                  if (!output[anchor]) {
                    output[anchor] = {};
                  }
                  if (typeof output[anchor][jsonProp] !== "undefined") {
                    if (output[anchor][jsonProp] !== values[jsonProp]) {
                      console.log(`???!!! TAJSON keyToPreserveUnknownJSON already deserialized DIFF?! ${anchor}.${jsonProp}`);
                      console.log(util2.inspect(values[jsonProp], { showHidden: false, depth: 1e3, colors: true, customInspect: false }));
                    }
                  }
                  output[anchor][jsonProp] = values[jsonProp];
                } else if (output[anchor] && typeof output[anchor][jsonProp] !== "undefined") {
                  delete output[anchor][jsonProp];
                }
              });
            }
          });
          if (output[anchor] && !Object.keys(output[anchor]).length) {
            delete output[anchor];
          }
        }
        return output;
      }
      function deserializeArray(array, definition, options) {
        const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
        const arr = array instanceof Array ? array : converter && converter.collapseArrayWithSingleItem() ? [array] : array;
        return arr.map((v) => deserializeObject(v, definition, options));
      }
      function deserializeObject(object, definition, options) {
        const primitive = definition.type === String || definition.type === Boolean || definition.type === Number;
        const value = object;
        const converter = definition.converter || converter_1.propertyConverters.get(definition.type);
        if (converter) {
          return converter.deserialize(value);
        }
        if (!primitive) {
          const objDefinition = object_definition_1.objectDefinitions.get(definition.type);
          if (objDefinition) {
            return deserialize(value, definition.type, options);
          }
        }
        return value;
      }
    }
  });

  // node_modules/ta-json-x/dist/cjs/ta-json.js
  var require_ta_json = __commonJS({
    "node_modules/ta-json-x/dist/cjs/ta-json.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TaJson = void 0;
      var serialize_1 = require_serialize();
      var deserialize_1 = require_deserialize();
      var TaJson2 = class {
        static deserialize(object, type, options) {
          return deserialize_1.deserialize(object, type, options);
        }
        static parse(json, type, options) {
          return this.deserialize(JSON.parse(json), type, options);
        }
        static serialize(value, options) {
          return serialize_1.serialize(value, void 0, options);
        }
        static stringify(object, options) {
          return JSON.stringify(this.serialize(object, options));
        }
      };
      exports2.TaJson = TaJson2;
    }
  });

  // node_modules/ta-json-x/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/ta-json-x/dist/cjs/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding3(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TaJson = exports2.JSON = void 0;
      __exportStar3(require_types2(), exports2);
      __exportStar3(require_decorators(), exports2);
      __exportStar3(require_converters(), exports2);
      var ta_json_1 = require_ta_json();
      Object.defineProperty(exports2, "JSON", { enumerable: true, get: function() {
        return ta_json_1.TaJson;
      } });
      Object.defineProperty(exports2, "TaJson", { enumerable: true, get: function() {
        return ta_json_1.TaJson;
      } });
    }
  });

  // node_modules/r2-utils-js/dist/es6-es2015/src/_utils/ta-json-string-converter.js
  var require_ta_json_string_converter = __commonJS({
    "node_modules/r2-utils-js/dist/es6-es2015/src/_utils/ta-json-string-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonStringConverter = void 0;
      var JsonStringConverter = class {
        serialize(property) {
          return property;
        }
        deserialize(value) {
          return value;
        }
        collapseArrayWithSingleItem() {
          return true;
        }
      };
      exports2.JsonStringConverter = JsonStringConverter;
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/_utils/decodeURI.js
  var require_decodeURI = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/_utils/decodeURI.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.tryDecodeURI = void 0;
      function tryDecodeURI(url) {
        if (!url) {
          return null;
        }
        try {
          return decodeURIComponent(url);
        } catch (err) {
          console.log(url);
          console.log(err);
        }
        return url;
      }
      exports2.tryDecodeURI = tryDecodeURI;
    }
  });

  // node_modules/r2-lcp-js/node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports2 = {};
  __export(tslib_es6_exports2, {
    __addDisposableResource: () => __addDisposableResource2,
    __assign: () => __assign2,
    __asyncDelegator: () => __asyncDelegator2,
    __asyncGenerator: () => __asyncGenerator2,
    __asyncValues: () => __asyncValues2,
    __await: () => __await2,
    __awaiter: () => __awaiter2,
    __classPrivateFieldGet: () => __classPrivateFieldGet2,
    __classPrivateFieldIn: () => __classPrivateFieldIn2,
    __classPrivateFieldSet: () => __classPrivateFieldSet2,
    __createBinding: () => __createBinding2,
    __decorate: () => __decorate2,
    __disposeResources: () => __disposeResources2,
    __esDecorate: () => __esDecorate2,
    __exportStar: () => __exportStar2,
    __extends: () => __extends2,
    __generator: () => __generator2,
    __importDefault: () => __importDefault2,
    __importStar: () => __importStar2,
    __makeTemplateObject: () => __makeTemplateObject2,
    __metadata: () => __metadata2,
    __param: () => __param2,
    __propKey: () => __propKey2,
    __read: () => __read2,
    __rest: () => __rest2,
    __runInitializers: () => __runInitializers2,
    __setFunctionName: () => __setFunctionName2,
    __spread: () => __spread2,
    __spreadArray: () => __spreadArray2,
    __spreadArrays: () => __spreadArrays2,
    __values: () => __values2,
    default: () => tslib_es6_default2
  });
  function __extends2(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest2(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate2(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param2(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate2(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function")
        throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn)
        context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access)
        context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_ = accept(result.get))
          descriptor.get = _;
        if (_ = accept(result.set))
          descriptor.set = _;
        if (_ = accept(result.init))
          initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field")
          initializers.unshift(_);
        else
          descriptor[key] = _;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers2(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey2(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName2(f, name, prefix) {
    if (typeof name === "symbol")
      name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata2(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter2(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator2(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar2(m, o) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
        __createBinding2(o, m, p);
  }
  function __values2(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read2(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread2() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read2(arguments[i]));
    return ar;
  }
  function __spreadArrays2() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __spreadArray2(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await2(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  }
  function __asyncGenerator2(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator2(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await2(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues2(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject2(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar2(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  }
  function __importDefault2(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet2(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet2(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn2(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
      throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource2(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources2(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    function next() {
      while (env.stack.length) {
        var rec = env.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } catch (e) {
          fail(e);
        }
      }
      if (env.hasError)
        throw env.error;
    }
    return next();
  }
  var extendStatics2, __assign2, __createBinding2, __setModuleDefault2, _SuppressedError2, tslib_es6_default2;
  var init_tslib_es62 = __esm({
    "node_modules/r2-lcp-js/node_modules/tslib/tslib.es6.mjs"() {
      init_polyfills();
      extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      __assign2 = function() {
        __assign2 = Object.assign || function __assign3(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __setModuleDefault2 = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      _SuppressedError2 = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
      };
      tslib_es6_default2 = {
        __extends: __extends2,
        __assign: __assign2,
        __rest: __rest2,
        __decorate: __decorate2,
        __param: __param2,
        __metadata: __metadata2,
        __awaiter: __awaiter2,
        __generator: __generator2,
        __createBinding: __createBinding2,
        __exportStar: __exportStar2,
        __values: __values2,
        __read: __read2,
        __spread: __spread2,
        __spreadArrays: __spreadArrays2,
        __spreadArray: __spreadArray2,
        __await: __await2,
        __asyncGenerator: __asyncGenerator2,
        __asyncDelegator: __asyncDelegator2,
        __asyncValues: __asyncValues2,
        __makeTemplateObject: __makeTemplateObject2,
        __importStar: __importStar2,
        __importDefault: __importDefault2,
        __classPrivateFieldGet: __classPrivateFieldGet2,
        __classPrivateFieldSet: __classPrivateFieldSet2,
        __classPrivateFieldIn: __classPrivateFieldIn2,
        __addDisposableResource: __addDisposableResource2,
        __disposeResources: __disposeResources2
      };
    }
  });

  // node_modules/r2-lcp-js/dist/es6-es2015/src/models/metadata-encrypted.js
  var require_metadata_encrypted = __commonJS({
    "node_modules/r2-lcp-js/dist/es6-es2015/src/models/metadata-encrypted.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Encrypted = void 0;
      var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
      var ta_json_x_1 = require_cjs();
      var Encrypted = exports2.Encrypted = class Encrypted {
        constructor() {
          this.DecryptedLengthBeforeInflate = -1;
          this.CypherBlockPadding = -1;
        }
        get OriginalLength() {
          return typeof this.OriginalLength2 !== "undefined" ? this.OriginalLength2 : this.OriginalLength1;
        }
        set OriginalLength(length) {
          if (typeof length !== "undefined") {
            this.OriginalLength1 = void 0;
            this.OriginalLength2 = length;
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("scheme"),
        tslib_1.__metadata("design:type", String)
      ], Encrypted.prototype, "Scheme", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("profile"),
        tslib_1.__metadata("design:type", String)
      ], Encrypted.prototype, "Profile", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("algorithm"),
        tslib_1.__metadata("design:type", String)
      ], Encrypted.prototype, "Algorithm", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("compression"),
        tslib_1.__metadata("design:type", String)
      ], Encrypted.prototype, "Compression", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("originalLength"),
        tslib_1.__metadata("design:type", Number)
      ], Encrypted.prototype, "OriginalLength2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("original-length"),
        tslib_1.__metadata("design:type", Object)
      ], Encrypted.prototype, "OriginalLength1", void 0);
      exports2.Encrypted = Encrypted = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Encrypted);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-properties.js
  var require_metadata_properties = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-properties.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Properties = exports2.PropertiesSupportedKeys = exports2.SpreadEnum = exports2.PageEnum = exports2.OverflowEnum = exports2.OrientationEnum = exports2.LayoutEnum = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var metadata_encrypted_1 = require_metadata_encrypted();
      var LayoutEnum;
      (function(LayoutEnum2) {
        LayoutEnum2["Fixed"] = "fixed";
        LayoutEnum2["Reflowable"] = "reflowable";
      })(LayoutEnum || (exports2.LayoutEnum = LayoutEnum = {}));
      var OrientationEnum;
      (function(OrientationEnum2) {
        OrientationEnum2["Auto"] = "auto";
        OrientationEnum2["Landscape"] = "landscape";
        OrientationEnum2["Portrait"] = "portrait";
      })(OrientationEnum || (exports2.OrientationEnum = OrientationEnum = {}));
      var OverflowEnum;
      (function(OverflowEnum2) {
        OverflowEnum2["Auto"] = "auto";
        OverflowEnum2["Paginated"] = "paginated";
        OverflowEnum2["Scrolled"] = "scrolled";
        OverflowEnum2["ScrolledContinuous"] = "scrolled-continuous";
      })(OverflowEnum || (exports2.OverflowEnum = OverflowEnum = {}));
      var PageEnum;
      (function(PageEnum2) {
        PageEnum2["Left"] = "left";
        PageEnum2["Right"] = "right";
        PageEnum2["Center"] = "center";
      })(PageEnum || (exports2.PageEnum = PageEnum = {}));
      var SpreadEnum;
      (function(SpreadEnum2) {
        SpreadEnum2["Auto"] = "auto";
        SpreadEnum2["Both"] = "both";
        SpreadEnum2["None"] = "none";
        SpreadEnum2["Landscape"] = "landscape";
      })(SpreadEnum || (exports2.SpreadEnum = SpreadEnum = {}));
      exports2.PropertiesSupportedKeys = ["contains", "layout", "orientation", "overflow", "page", "spread", "encrypted", "media-overlay"];
      var Properties = exports2.Properties = class Properties {
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("contains"),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Properties.prototype, "Contains", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("layout"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "Layout", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("orientation"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "Orientation", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("overflow"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "Overflow", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("page"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "Page", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("spread"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "Spread", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("encrypted"),
        tslib_1.__metadata("design:type", metadata_encrypted_1.Encrypted)
      ], Properties.prototype, "Encrypted", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("media-overlay"),
        tslib_1.__metadata("design:type", String)
      ], Properties.prototype, "MediaOverlay", void 0);
      exports2.Properties = Properties = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Properties);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/publication-link.js
  var require_publication_link = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/publication-link.js"(exports2) {
      "use strict";
      init_polyfills();
      var Link_1;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Link = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var decodeURI_1 = require_decodeURI();
      var metadata_properties_1 = require_metadata_properties();
      var PROPERTIES_JSON_PROP = "properties";
      var CHILDREN_JSON_PROP = "children";
      var ALTERNATE_JSON_PROP = "alternate";
      var Link2 = exports2.Link = Link_1 = class Link {
        get Href() {
          return this.Href1;
        }
        set Href(href) {
          this.Href1 = href;
          this._urlDecoded = void 0;
        }
        get HrefDecoded() {
          if (this._urlDecoded) {
            return this._urlDecoded;
          }
          if (this._urlDecoded === null) {
            return void 0;
          }
          if (!this.Href) {
            this._urlDecoded = null;
            return void 0;
          }
          this._urlDecoded = (0, decodeURI_1.tryDecodeURI)(this.Href);
          return !this._urlDecoded ? void 0 : this._urlDecoded;
        }
        set HrefDecoded(href) {
          this._urlDecoded = href;
        }
        setHrefDecoded(href) {
          this.Href = href;
          this.HrefDecoded = href;
        }
        AddRels(rels) {
          rels.forEach((rel) => {
            this.AddRel(rel);
          });
        }
        AddRel(rel) {
          if (this.HasRel(rel)) {
            return;
          }
          if (!this.Rel) {
            this.Rel = [rel];
          } else {
            this.Rel.push(rel);
          }
        }
        HasRel(rel) {
          return this.Rel && this.Rel.indexOf(rel) >= 0;
        }
        _OnDeserialized() {
          if (!this.Href && (!this.Children || !this.Children.length)) {
            console.log("Link.Href is not set! (and no child Links)");
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("type"),
        tslib_1.__metadata("design:type", String)
      ], Link2.prototype, "TypeLink", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("height"),
        tslib_1.__metadata("design:type", Number)
      ], Link2.prototype, "Height", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("width"),
        tslib_1.__metadata("design:type", Number)
      ], Link2.prototype, "Width", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("title"),
        tslib_1.__metadata("design:type", String)
      ], Link2.prototype, "Title", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(PROPERTIES_JSON_PROP),
        tslib_1.__metadata("design:type", metadata_properties_1.Properties)
      ], Link2.prototype, "Properties", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("duration"),
        tslib_1.__metadata("design:type", Number)
      ], Link2.prototype, "Duration", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("bitrate"),
        tslib_1.__metadata("design:type", Number)
      ], Link2.prototype, "Bitrate", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("templated"),
        tslib_1.__metadata("design:type", Boolean)
      ], Link2.prototype, "Templated", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(CHILDREN_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(Link_1),
        tslib_1.__metadata("design:type", Array)
      ], Link2.prototype, "Children", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(ALTERNATE_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(Link_1),
        tslib_1.__metadata("design:type", Array)
      ], Link2.prototype, "Alternate", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("rel"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Link2.prototype, "Rel", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("href"),
        tslib_1.__metadata("design:type", String)
      ], Link2.prototype, "Href1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.OnDeserialized)(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", []),
        tslib_1.__metadata("design:returntype", void 0)
      ], Link2.prototype, "_OnDeserialized", null);
      exports2.Link = Link2 = Link_1 = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Link2);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-contributor.js
  var require_metadata_contributor = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-contributor.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Contributor = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var publication_link_1 = require_publication_link();
      var LINKS_JSON_PROP = "links";
      var Contributor = exports2.Contributor = class Contributor {
        get SortAs() {
          return this.SortAs2 ? this.SortAs2 : this.SortAs1;
        }
        set SortAs(sortas) {
          if (sortas) {
            this.SortAs1 = void 0;
            this.SortAs2 = sortas;
          }
        }
        _OnDeserialized() {
          if (!this.Name) {
            console.log("Contributor.Name is not set!");
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("name"),
        tslib_1.__metadata("design:type", Object)
      ], Contributor.prototype, "Name", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sortAs"),
        tslib_1.__metadata("design:type", String)
      ], Contributor.prototype, "SortAs2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sort_as"),
        tslib_1.__metadata("design:type", Object)
      ], Contributor.prototype, "SortAs1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("role"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Contributor.prototype, "Role", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("identifier"),
        tslib_1.__metadata("design:type", String)
      ], Contributor.prototype, "Identifier", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("position"),
        tslib_1.__metadata("design:type", Number)
      ], Contributor.prototype, "Position", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LINKS_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Contributor.prototype, "Links", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.OnDeserialized)(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", []),
        tslib_1.__metadata("design:returntype", void 0)
      ], Contributor.prototype, "_OnDeserialized", null);
      exports2.Contributor = Contributor = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Contributor);
    }
  });

  // node_modules/r2-lcp-js/dist/es6-es2015/src/serializable.js
  var require_serializable = __commonJS({
    "node_modules/r2-lcp-js/dist/es6-es2015/src/serializable.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TaJsonSerialize = exports2.TaJsonDeserialize = exports2.KeyToPreserveUnknownJSON = void 0;
      var ta_json_x_1 = require_cjs();
      exports2.KeyToPreserveUnknownJSON = "AdditionalJSON";
      function TaJsonDeserialize2(json, type) {
        return ta_json_x_1.JSON.deserialize(json, type, { keyToPreserveUnknownJSON: exports2.KeyToPreserveUnknownJSON });
      }
      exports2.TaJsonDeserialize = TaJsonDeserialize2;
      function TaJsonSerialize(obj) {
        return ta_json_x_1.JSON.serialize(obj, { keyToPreserveUnknownJSON: exports2.KeyToPreserveUnknownJSON });
      }
      exports2.TaJsonSerialize = TaJsonSerialize;
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-contributor-json-converter.js
  var require_metadata_contributor_json_converter = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-contributor-json-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonContributorConverter = void 0;
      var serializable_1 = require_serializable();
      var metadata_contributor_1 = require_metadata_contributor();
      var JsonContributorConverter = class {
        serialize(c) {
          if (c.Name && !c.SortAs && (!c.Role || !c.Role.length) && !c.Identifier && typeof c.Position === "undefined" && (!c.Links || !c.Links.length)) {
            if (typeof c.Name === "string") {
              return c.Name;
            }
          }
          return (0, serializable_1.TaJsonSerialize)(c);
        }
        deserialize(value) {
          if (typeof value === "string") {
            const c = new metadata_contributor_1.Contributor();
            c.Name = value;
            return c;
          }
          return (0, serializable_1.TaJsonDeserialize)(value, metadata_contributor_1.Contributor);
        }
        collapseArrayWithSingleItem() {
          return true;
        }
      };
      exports2.JsonContributorConverter = JsonContributorConverter;
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-belongsto.js
  var require_metadata_belongsto = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-belongsto.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BelongsTo = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var metadata_contributor_1 = require_metadata_contributor();
      var metadata_contributor_json_converter_1 = require_metadata_contributor_json_converter();
      var SERIES_JSON_PROP = "series";
      var COLLECTION_JSON_PROP = "collection";
      var BelongsTo = exports2.BelongsTo = class BelongsTo {
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(SERIES_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], BelongsTo.prototype, "Series", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(COLLECTION_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], BelongsTo.prototype, "Collection", void 0);
      exports2.BelongsTo = BelongsTo = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], BelongsTo);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-media-overlay.js
  var require_metadata_media_overlay = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-media-overlay.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MediaOverlay = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var MediaOverlay = exports2.MediaOverlay = class MediaOverlay {
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("active-class"),
        tslib_1.__metadata("design:type", String)
      ], MediaOverlay.prototype, "ActiveClass", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("playback-active-class"),
        tslib_1.__metadata("design:type", String)
      ], MediaOverlay.prototype, "PlaybackActiveClass", void 0);
      exports2.MediaOverlay = MediaOverlay = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], MediaOverlay);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-subject.js
  var require_metadata_subject = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-subject.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Subject = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var publication_link_1 = require_publication_link();
      var LINKS_JSON_PROP = "links";
      var Subject = exports2.Subject = class Subject {
        get SortAs() {
          return this.SortAs2 ? this.SortAs2 : this.SortAs1;
        }
        set SortAs(sortas) {
          if (sortas) {
            this.SortAs1 = void 0;
            this.SortAs2 = sortas;
          }
        }
        _OnDeserialized() {
          if (!this.Name) {
            console.log("Subject.Name is not set!");
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("name"),
        tslib_1.__metadata("design:type", Object)
      ], Subject.prototype, "Name", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sortAs"),
        tslib_1.__metadata("design:type", String)
      ], Subject.prototype, "SortAs2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sort_as"),
        tslib_1.__metadata("design:type", Object)
      ], Subject.prototype, "SortAs1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("scheme"),
        tslib_1.__metadata("design:type", String)
      ], Subject.prototype, "Scheme", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("code"),
        tslib_1.__metadata("design:type", String)
      ], Subject.prototype, "Code", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LINKS_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Subject.prototype, "Links", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.OnDeserialized)(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", []),
        tslib_1.__metadata("design:returntype", void 0)
      ], Subject.prototype, "_OnDeserialized", null);
      exports2.Subject = Subject = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Subject);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-subject-json-converter.js
  var require_metadata_subject_json_converter = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-subject-json-converter.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JsonSubjectConverter = void 0;
      var serializable_1 = require_serializable();
      var metadata_subject_1 = require_metadata_subject();
      var JsonSubjectConverter = class {
        serialize(s) {
          if (s.Name && !s.SortAs && !s.Scheme && !s.Code && (!s.Links || !s.Links.length)) {
            if (typeof s.Name === "string") {
              return s.Name;
            }
          }
          return (0, serializable_1.TaJsonSerialize)(s);
        }
        deserialize(value) {
          if (typeof value === "string") {
            const s = new metadata_subject_1.Subject();
            s.Name = value;
            return s;
          }
          return (0, serializable_1.TaJsonDeserialize)(value, metadata_subject_1.Subject);
        }
        collapseArrayWithSingleItem() {
          return true;
        }
      };
      exports2.JsonSubjectConverter = JsonSubjectConverter;
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-accessibility-certification.js
  var require_metadata_accessibility_certification = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-accessibility-certification.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccessibilityCertification = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var AccessibilityCertification = exports2.AccessibilityCertification = class AccessibilityCertification {
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("certifiedBy"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityCertification.prototype, "CertifiedBy", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("credential"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityCertification.prototype, "Credential", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("report"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityCertification.prototype, "Report", void 0);
      exports2.AccessibilityCertification = AccessibilityCertification = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], AccessibilityCertification);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-accessibility.js
  var require_metadata_accessibility = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata-accessibility.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccessibilityMetadata = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var metadata_accessibility_certification_1 = require_metadata_accessibility_certification();
      var AccessibilityMetadata = exports2.AccessibilityMetadata = class AccessibilityMetadata {
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("certification"),
        tslib_1.__metadata("design:type", metadata_accessibility_certification_1.AccessibilityCertification)
      ], AccessibilityMetadata.prototype, "Certification", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("conformsTo"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityMetadata.prototype, "ConformsTo", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("summary"),
        tslib_1.__metadata("design:type", Object)
      ], AccessibilityMetadata.prototype, "Summary", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessMode"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityMetadata.prototype, "AccessMode", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessModeSufficient"),
        (0, ta_json_x_1.JsonElementType)(Array),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityMetadata.prototype, "AccessModeSufficient", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("feature"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityMetadata.prototype, "Feature", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("hazard"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], AccessibilityMetadata.prototype, "Hazard", void 0);
      exports2.AccessibilityMetadata = AccessibilityMetadata = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], AccessibilityMetadata);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata.js
  var require_metadata = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/metadata.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Metadata = exports2.MetadataSupportedKeys = exports2.DirectionEnum = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var metadata_belongsto_1 = require_metadata_belongsto();
      var metadata_contributor_1 = require_metadata_contributor();
      var metadata_contributor_json_converter_1 = require_metadata_contributor_json_converter();
      var metadata_media_overlay_1 = require_metadata_media_overlay();
      var metadata_properties_1 = require_metadata_properties();
      var metadata_subject_1 = require_metadata_subject();
      var metadata_subject_json_converter_1 = require_metadata_subject_json_converter();
      var metadata_accessibility_1 = require_metadata_accessibility();
      var DirectionEnum;
      (function(DirectionEnum2) {
        DirectionEnum2["Auto"] = "auto";
        DirectionEnum2["RTL"] = "rtl";
        DirectionEnum2["LTR"] = "ltr";
      })(DirectionEnum || (exports2.DirectionEnum = DirectionEnum = {}));
      exports2.MetadataSupportedKeys = [
        "cover",
        "dtb:totalTime",
        "media:duration",
        "media:narrator",
        "media:active-class",
        "media:playback-active-class",
        "dcterms:modified",
        "dcterms:creator",
        "dcterms:contributor",
        "schema:accessMode",
        "schema:accessibilityFeature",
        "schema:accessibilityHazard",
        "schema:accessibilitySummary",
        "schema:accessModeSufficient",
        "schema:accessibilityAPI",
        "schema:accessibilityControl",
        "a11y:certifiedBy",
        "a11y:certifierCredential",
        "a11y:certifierReport",
        "dcterms:conformsTo",
        "title",
        "subtitle",
        "identifier",
        "author",
        "translator",
        "editor",
        "artist",
        "illustrator",
        "letterer",
        "penciler",
        "colorist",
        "inker",
        "narrator",
        "contributor",
        "publisher",
        "imprint",
        "language",
        "modified",
        "published",
        "sortAs",
        "description",
        "readingProgression",
        "direction",
        "belongsTo",
        "duration",
        "numberOfPages",
        "rights",
        "rendition",
        "source",
        "subject"
      ];
      var Metadata = exports2.Metadata = class Metadata {
        get SortAs() {
          return this.SortAs2 ? this.SortAs2 : this.SortAs1;
        }
        set SortAs(sortas) {
          if (sortas) {
            this.SortAs1 = void 0;
            this.SortAs2 = sortas;
          }
        }
        get Direction() {
          return this.Direction2 ? this.Direction2 : this.Direction1;
        }
        set Direction(direction) {
          if (direction) {
            this.Direction1 = void 0;
            this.Direction2 = direction;
          }
        }
        get BelongsTo() {
          return this.BelongsTo2 ? this.BelongsTo2 : this.BelongsTo1;
        }
        set BelongsTo(belongsto) {
          if (belongsto) {
            this.BelongsTo1 = void 0;
            this.BelongsTo2 = belongsto;
          }
        }
        _OnDeserialized() {
          if (!this.Title) {
            console.log("Metadata.Title is not set!");
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibility"),
        tslib_1.__metadata("design:type", metadata_accessibility_1.AccessibilityMetadata)
      ], Metadata.prototype, "Accessibility", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessMode"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessMode", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibilityFeature"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessibilityFeature", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibilityHazard"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessibilityHazard", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibilitySummary"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "AccessibilitySummary", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessModeSufficient"),
        (0, ta_json_x_1.JsonElementType)(Array),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessModeSufficient", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibilityAPI"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessibilityAPI", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("accessibilityControl"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "AccessibilityControl", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("certifiedBy"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "CertifiedBy", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("certifierCredential"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "CertifierCredential", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("certifierReport"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "CertifierReport", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("conformsTo"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "ConformsTo", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("@type"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "RDFType", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("title"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "Title", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("subtitle"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "SubTitle", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("identifier"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "Identifier", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("author"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Author", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("translator"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Translator", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("editor"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Editor", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("artist"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Artist", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("illustrator"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Illustrator", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("letterer"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Letterer", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("penciler"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Penciler", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("colorist"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Colorist", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("inker"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Inker", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("narrator"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Narrator", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("contributor"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Contributor", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("publisher"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Publisher", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("imprint"),
        (0, ta_json_x_1.JsonElementType)(metadata_contributor_1.Contributor),
        (0, ta_json_x_1.JsonConverter)(metadata_contributor_json_converter_1.JsonContributorConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Imprint", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("language"),
        (0, ta_json_x_1.JsonElementType)(String),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Language", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("modified"),
        tslib_1.__metadata("design:type", Date)
      ], Metadata.prototype, "Modified", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("published"),
        tslib_1.__metadata("design:type", Date)
      ], Metadata.prototype, "PublicationDate", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sortAs"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "SortAs2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("sort_as"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "SortAs1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("description"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "Description", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("readingProgression"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "Direction2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("direction"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "Direction1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("belongsTo"),
        tslib_1.__metadata("design:type", metadata_belongsto_1.BelongsTo)
      ], Metadata.prototype, "BelongsTo2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("belongs_to"),
        tslib_1.__metadata("design:type", Object)
      ], Metadata.prototype, "BelongsTo1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("duration"),
        tslib_1.__metadata("design:type", Number)
      ], Metadata.prototype, "Duration", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("numberOfPages"),
        tslib_1.__metadata("design:type", Number)
      ], Metadata.prototype, "NumberOfPages", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("media-overlay"),
        tslib_1.__metadata("design:type", metadata_media_overlay_1.MediaOverlay)
      ], Metadata.prototype, "MediaOverlay", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("rights"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "Rights", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("rendition"),
        tslib_1.__metadata("design:type", metadata_properties_1.Properties)
      ], Metadata.prototype, "Rendition", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("source"),
        tslib_1.__metadata("design:type", String)
      ], Metadata.prototype, "Source", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("subject"),
        (0, ta_json_x_1.JsonConverter)(metadata_subject_json_converter_1.JsonSubjectConverter),
        (0, ta_json_x_1.JsonElementType)(metadata_subject_1.Subject),
        tslib_1.__metadata("design:type", Array)
      ], Metadata.prototype, "Subject", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.OnDeserialized)(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", []),
        tslib_1.__metadata("design:returntype", void 0)
      ], Metadata.prototype, "_OnDeserialized", null);
      exports2.Metadata = Metadata = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Metadata);
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/publication.js
  var require_publication = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/publication.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Publication = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var debug_ = require_browser2();
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      var metadata_1 = require_metadata();
      var publication_link_1 = require_publication_link();
      var debug = debug_("r2:shared#models/publication");
      var METADATA_JSON_PROP = "metadata";
      var LINKS_JSON_PROP = "links";
      var READINGORDER_JSON_PROP = "readingOrder";
      var SPINE_JSON_PROP = "spine";
      var RESOURCES_JSON_PROP = "resources";
      var TOC_JSON_PROP = "toc";
      var PAGELIST_JSON_PROP = "page-list";
      var PAGELIST_CAMEL_JSON_PROP = "pageList";
      var LANDMARKS_JSON_PROP = "landmarks";
      var LOI_JSON_PROP = "loi";
      var LOA_JSON_PROP = "loa";
      var LOV_JSON_PROP = "lov";
      var LOT_JSON_PROP = "lot";
      var Publication2 = exports2.Publication = class Publication {
        get Spine() {
          return this.Spine2 ? this.Spine2 : this.Spine1;
        }
        set Spine(spine) {
          if (spine) {
            this.Spine1 = void 0;
            this.Spine2 = spine;
          }
        }
        get PageList() {
          return this.PageList2 ? this.PageList2 : this.PageList1;
        }
        set PageList(pagelist) {
          if (pagelist) {
            this.PageList1 = void 0;
            this.PageList2 = pagelist;
          }
        }
        freeDestroy() {
          debug("freeDestroy: Publication");
          if (this.Internal) {
            const zipInternal = this.findFromInternal("zip");
            if (zipInternal) {
              const zip = zipInternal.Value;
              zip.freeDestroy();
            }
          }
        }
        findFromInternal(key) {
          if (this.Internal) {
            const found = this.Internal.find((internal) => {
              return internal.Name === key;
            });
            if (found) {
              return found;
            }
          }
          return void 0;
        }
        AddToInternal(key, value) {
          const existing = this.findFromInternal(key);
          if (existing) {
            existing.Value = value;
          } else {
            if (!this.Internal) {
              this.Internal = [];
            }
            const internal = { Name: key, Value: value };
            this.Internal.push(internal);
          }
        }
        GetCover() {
          return this.searchLinkByRel("cover");
        }
        GetNavDoc() {
          return this.searchLinkByRel("contents");
        }
        searchLinkByRel(rel) {
          if (this.Resources) {
            const ll = this.Resources.find((link) => {
              return link.HasRel(rel);
            });
            if (ll) {
              return ll;
            }
          }
          if (this.Spine) {
            const ll = this.Spine.find((link) => {
              return link.HasRel(rel);
            });
            if (ll) {
              return ll;
            }
          }
          if (this.Links) {
            const ll = this.Links.find((link) => {
              return link.HasRel(rel);
            });
            if (ll) {
              return ll;
            }
          }
          return void 0;
        }
        AddLink(typeLink, rel, url, templated) {
          const link = new publication_link_1.Link();
          link.AddRels(rel);
          link.setHrefDecoded(url);
          link.TypeLink = typeLink;
          if (typeof templated !== "undefined") {
            link.Templated = templated;
          }
          if (!this.Links) {
            this.Links = [];
          }
          this.Links.push(link);
        }
        _OnDeserialized() {
          if (!this.Metadata) {
            console.log("Publication.Metadata is not set!");
          }
          if (!this.Spine) {
            console.log("Publication.Spine/ReadingOrder is not set!");
          }
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("@context"),
        (0, ta_json_x_1.JsonElementType)(String),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "Context", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(METADATA_JSON_PROP),
        tslib_1.__metadata("design:type", metadata_1.Metadata)
      ], Publication2.prototype, "Metadata", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LINKS_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "Links", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(READINGORDER_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "Spine2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(SPINE_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Object)
      ], Publication2.prototype, "Spine1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(RESOURCES_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "Resources", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(TOC_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "TOC", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(PAGELIST_CAMEL_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "PageList2", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(PAGELIST_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Object)
      ], Publication2.prototype, "PageList1", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LANDMARKS_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "Landmarks", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LOI_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "LOI", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LOA_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "LOA", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LOV_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "LOV", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)(LOT_JSON_PROP),
        (0, ta_json_x_1.JsonElementType)(publication_link_1.Link),
        tslib_1.__metadata("design:type", Array)
      ], Publication2.prototype, "LOT", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.OnDeserialized)(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", []),
        tslib_1.__metadata("design:returntype", void 0)
      ], Publication2.prototype, "_OnDeserialized", null);
      exports2.Publication = Publication2 = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], Publication2);
    }
  });

  // node_modules/entities/lib/generated/decode-data-html.js
  var require_decode_data_html = __commonJS({
    "node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        // prettier-ignore
        '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
          return c.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/entities/lib/generated/decode-data-xml.js
  var require_decode_data_xml = __commonJS({
    "node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        // prettier-ignore
        "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
          return c.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/entities/lib/decode_codepoint.js
  var require_decode_codepoint = __commonJS({
    "node_modules/entities/lib/decode_codepoint.js"(exports2) {
      "use strict";
      init_polyfills();
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
      var decodeMap = /* @__PURE__ */ new Map([
        [0, 65533],
        // C1 Unicode control character reference replacements
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376]
      ]);
      exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
      (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      };
      function replaceCodePoint(codePoint) {
        var _a2;
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          return 65533;
        }
        return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
      }
      exports2.replaceCodePoint = replaceCodePoint;
      function decodeCodePoint(codePoint) {
        return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
      }
      exports2.default = decodeCodePoint;
    }
  });

  // node_modules/entities/lib/decode.js
  var require_decode = __commonJS({
    "node_modules/entities/lib/decode.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault3 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar3 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault3(result, mod);
        return result;
      };
      var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
      var decode_data_html_js_1 = __importDefault3(require_decode_data_html());
      exports2.htmlDecodeTree = decode_data_html_js_1.default;
      var decode_data_xml_js_1 = __importDefault3(require_decode_data_xml());
      exports2.xmlDecodeTree = decode_data_xml_js_1.default;
      var decode_codepoint_js_1 = __importStar3(require_decode_codepoint());
      exports2.decodeCodePoint = decode_codepoint_js_1.default;
      var decode_codepoint_js_2 = require_decode_codepoint();
      Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.replaceCodePoint;
      } });
      Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.fromCodePoint;
      } });
      var CharCodes;
      (function(CharCodes2) {
        CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
        CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
        CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
        CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
        CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
        CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
        CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
        CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
        CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
        CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
        CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));
      var TO_LOWER_BIT = 32;
      var BinTrieFlags;
      (function(BinTrieFlags2) {
        BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
      })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
      function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
      }
      function isHexadecimalCharacter(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
      }
      function isAsciiAlphaNumeric(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
      }
      function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
      }
      var EntityDecoderState;
      (function(EntityDecoderState2) {
        EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));
      var DecodingMode;
      (function(DecodingMode2) {
        DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
        DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
        DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
      })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
      var EntityDecoder = (
        /** @class */
        function() {
          function EntityDecoder2(decodeTree, emitCodePoint, errors) {
            this.decodeTree = decodeTree;
            this.emitCodePoint = emitCodePoint;
            this.errors = errors;
            this.state = EntityDecoderState.EntityStart;
            this.consumed = 1;
            this.result = 0;
            this.treeIndex = 0;
            this.excess = 1;
            this.decodeMode = DecodingMode.Strict;
          }
          EntityDecoder2.prototype.startEntity = function(decodeMode) {
            this.decodeMode = decodeMode;
            this.state = EntityDecoderState.EntityStart;
            this.result = 0;
            this.treeIndex = 0;
            this.excess = 1;
            this.consumed = 1;
          };
          EntityDecoder2.prototype.write = function(str, offset) {
            switch (this.state) {
              case EntityDecoderState.EntityStart: {
                if (str.charCodeAt(offset) === CharCodes.NUM) {
                  this.state = EntityDecoderState.NumericStart;
                  this.consumed += 1;
                  return this.stateNumericStart(str, offset + 1);
                }
                this.state = EntityDecoderState.NamedEntity;
                return this.stateNamedEntity(str, offset);
              }
              case EntityDecoderState.NumericStart: {
                return this.stateNumericStart(str, offset);
              }
              case EntityDecoderState.NumericDecimal: {
                return this.stateNumericDecimal(str, offset);
              }
              case EntityDecoderState.NumericHex: {
                return this.stateNumericHex(str, offset);
              }
              case EntityDecoderState.NamedEntity: {
                return this.stateNamedEntity(str, offset);
              }
            }
          };
          EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
            if (offset >= str.length) {
              return -1;
            }
            if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
              this.state = EntityDecoderState.NumericHex;
              this.consumed += 1;
              return this.stateNumericHex(str, offset + 1);
            }
            this.state = EntityDecoderState.NumericDecimal;
            return this.stateNumericDecimal(str, offset);
          };
          EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
            if (start !== end) {
              var digitCount = end - start;
              this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
              this.consumed += digitCount;
            }
          };
          EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
            var startIdx = offset;
            while (offset < str.length) {
              var char = str.charCodeAt(offset);
              if (isNumber(char) || isHexadecimalCharacter(char)) {
                offset += 1;
              } else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
              }
            }
            this.addToNumericResult(str, startIdx, offset, 16);
            return -1;
          };
          EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
            var startIdx = offset;
            while (offset < str.length) {
              var char = str.charCodeAt(offset);
              if (isNumber(char)) {
                offset += 1;
              } else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
              }
            }
            this.addToNumericResult(str, startIdx, offset, 10);
            return -1;
          };
          EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
            var _a;
            if (this.consumed <= expectedLength) {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            if (lastCp === CharCodes.SEMI) {
              this.consumed += 1;
            } else if (this.decodeMode === DecodingMode.Strict) {
              return 0;
            }
            this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
            if (this.errors) {
              if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
              }
              this.errors.validateNumericCharacterReference(this.result);
            }
            return this.consumed;
          };
          EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
            var decodeTree = this.decodeTree;
            var current = decodeTree[this.treeIndex];
            var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            for (; offset < str.length; offset++, this.excess++) {
              var char = str.charCodeAt(offset);
              this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
              if (this.treeIndex < 0) {
                return this.result === 0 || // If we are parsing an attribute
                this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
                (valueLength === 0 || // And there should be no invalid characters.
                isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
              }
              current = decodeTree[this.treeIndex];
              valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
              if (valueLength !== 0) {
                if (char === CharCodes.SEMI) {
                  return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                if (this.decodeMode !== DecodingMode.Strict) {
                  this.result = this.treeIndex;
                  this.consumed += this.excess;
                  this.excess = 0;
                }
              }
            }
            return -1;
          };
          EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
            var _a;
            var _b = this, result = _b.result, decodeTree = _b.decodeTree;
            var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
            this.emitNamedEntityData(result, valueLength, this.consumed);
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
            return this.consumed;
          };
          EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
            var decodeTree = this.decodeTree;
            this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
            if (valueLength === 3) {
              this.emitCodePoint(decodeTree[result + 2], consumed);
            }
            return consumed;
          };
          EntityDecoder2.prototype.end = function() {
            var _a;
            switch (this.state) {
              case EntityDecoderState.NamedEntity: {
                return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
              }
              case EntityDecoderState.NumericDecimal: {
                return this.emitNumericEntity(0, 2);
              }
              case EntityDecoderState.NumericHex: {
                return this.emitNumericEntity(0, 3);
              }
              case EntityDecoderState.NumericStart: {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
              }
              case EntityDecoderState.EntityStart: {
                return 0;
              }
            }
          };
          return EntityDecoder2;
        }()
      );
      exports2.EntityDecoder = EntityDecoder;
      function getDecoder(decodeTree) {
        var ret = "";
        var decoder = new EntityDecoder(decodeTree, function(str) {
          return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
        });
        return function decodeWithTrie(str, decodeMode) {
          var lastIndex = 0;
          var offset = 0;
          while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            var len = decoder.write(
              str,
              // Skip the "&"
              offset + 1
            );
            if (len < 0) {
              lastIndex = offset + decoder.end();
              break;
            }
            lastIndex = offset + len;
            offset = len === 0 ? lastIndex + 1 : lastIndex;
          }
          var result = ret + str.slice(lastIndex);
          ret = "";
          return result;
        };
      }
      function determineBranch(decodeTree, current, nodeIdx, char) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        if (jumpOffset) {
          var value = char - jumpOffset;
          return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
        }
        var lo = nodeIdx;
        var hi = lo + branchCount - 1;
        while (lo <= hi) {
          var mid = lo + hi >>> 1;
          var midVal = decodeTree[mid];
          if (midVal < char) {
            lo = mid + 1;
          } else if (midVal > char) {
            hi = mid - 1;
          } else {
            return decodeTree[mid + branchCount];
          }
        }
        return -1;
      }
      exports2.determineBranch = determineBranch;
      var htmlDecoder = getDecoder(decode_data_html_js_1.default);
      var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
      function decodeHTML(str, mode) {
        if (mode === void 0) {
          mode = DecodingMode.Legacy;
        }
        return htmlDecoder(str, mode);
      }
      exports2.decodeHTML = decodeHTML;
      function decodeHTMLAttribute(str) {
        return htmlDecoder(str, DecodingMode.Attribute);
      }
      exports2.decodeHTMLAttribute = decodeHTMLAttribute;
      function decodeHTMLStrict(str) {
        return htmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeHTMLStrict = decodeHTMLStrict;
      function decodeXML(str) {
        return xmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeXML = decodeXML;
    }
  });

  // node_modules/htmlparser2/lib/Tokenizer.js
  var require_Tokenizer = __commonJS({
    "node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.QuoteType = void 0;
      var decode_js_1 = require_decode();
      var CharCodes;
      (function(CharCodes2) {
        CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
        CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
        CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
        CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
        CharCodes2[CharCodes2["Space"] = 32] = "Space";
        CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
        CharCodes2[CharCodes2["Number"] = 35] = "Number";
        CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
        CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
        CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
        CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
        CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
        CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
        CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
        CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
        CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
        CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
        CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
        CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
        CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
        CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
        CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
        CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
        CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
        CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
        CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
        CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
      })(CharCodes || (CharCodes = {}));
      var State;
      (function(State2) {
        State2[State2["Text"] = 1] = "Text";
        State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
        State2[State2["InTagName"] = 3] = "InTagName";
        State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
        State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
        State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
        State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
        State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
        State2[State2["InAttributeName"] = 9] = "InAttributeName";
        State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
        State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
        State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
        State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
        State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
        State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
        State2[State2["InDeclaration"] = 16] = "InDeclaration";
        State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
        State2[State2["BeforeComment"] = 18] = "BeforeComment";
        State2[State2["CDATASequence"] = 19] = "CDATASequence";
        State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
        State2[State2["InCommentLike"] = 21] = "InCommentLike";
        State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
        State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
        State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
        State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
        State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
        State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
        State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
        State2[State2["InHexEntity"] = 29] = "InHexEntity";
      })(State || (State = {}));
      function isWhitespace(c) {
        return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
      }
      function isEndOfTagSection(c) {
        return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
      }
      function isNumber(c) {
        return c >= CharCodes.Zero && c <= CharCodes.Nine;
      }
      function isASCIIAlpha(c) {
        return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
      }
      function isHexDigit(c) {
        return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
      }
      var QuoteType;
      (function(QuoteType2) {
        QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
        QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
        QuoteType2[QuoteType2["Single"] = 2] = "Single";
        QuoteType2[QuoteType2["Double"] = 3] = "Double";
      })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
      var Sequences = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
        // `</title`
      };
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(_a, cbs) {
            var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
            this.cbs = cbs;
            this.state = State.Text;
            this.buffer = "";
            this.sectionStart = 0;
            this.index = 0;
            this.baseState = State.Text;
            this.isSpecial = false;
            this.running = true;
            this.offset = 0;
            this.currentSequence = void 0;
            this.sequenceIndex = 0;
            this.trieIndex = 0;
            this.trieCurrent = 0;
            this.entityResult = 0;
            this.entityExcess = 0;
            this.xmlMode = xmlMode;
            this.decodeEntities = decodeEntities;
            this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
          }
          Tokenizer2.prototype.reset = function() {
            this.state = State.Text;
            this.buffer = "";
            this.sectionStart = 0;
            this.index = 0;
            this.baseState = State.Text;
            this.currentSequence = void 0;
            this.running = true;
            this.offset = 0;
          };
          Tokenizer2.prototype.write = function(chunk) {
            this.offset += this.buffer.length;
            this.buffer = chunk;
            this.parse();
          };
          Tokenizer2.prototype.end = function() {
            if (this.running)
              this.finish();
          };
          Tokenizer2.prototype.pause = function() {
            this.running = false;
          };
          Tokenizer2.prototype.resume = function() {
            this.running = true;
            if (this.index < this.buffer.length + this.offset) {
              this.parse();
            }
          };
          Tokenizer2.prototype.getIndex = function() {
            return this.index;
          };
          Tokenizer2.prototype.getSectionStart = function() {
            return this.sectionStart;
          };
          Tokenizer2.prototype.stateText = function(c) {
            if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
              if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
              }
              this.state = State.BeforeTagName;
              this.sectionStart = this.index;
            } else if (this.decodeEntities && c === CharCodes.Amp) {
              this.state = State.BeforeEntity;
            }
          };
          Tokenizer2.prototype.stateSpecialStartSequence = function(c) {
            var isEnd = this.sequenceIndex === this.currentSequence.length;
            var isMatch = isEnd ? (
              // If we are at the end of the sequence, make sure the tag name has ended
              isEndOfTagSection(c)
            ) : (
              // Otherwise, do a case-insensitive comparison
              (c | 32) === this.currentSequence[this.sequenceIndex]
            );
            if (!isMatch) {
              this.isSpecial = false;
            } else if (!isEnd) {
              this.sequenceIndex++;
              return;
            }
            this.sequenceIndex = 0;
            this.state = State.InTagName;
            this.stateInTagName(c);
          };
          Tokenizer2.prototype.stateInSpecialTag = function(c) {
            if (this.sequenceIndex === this.currentSequence.length) {
              if (c === CharCodes.Gt || isWhitespace(c)) {
                var endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                  var actualIndex = this.index;
                  this.index = endOfText;
                  this.cbs.ontext(this.sectionStart, endOfText);
                  this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2;
                this.stateInClosingTagName(c);
                return;
              }
              this.sequenceIndex = 0;
            }
            if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
              this.sequenceIndex += 1;
            } else if (this.sequenceIndex === 0) {
              if (this.currentSequence === Sequences.TitleEnd) {
                if (this.decodeEntities && c === CharCodes.Amp) {
                  this.state = State.BeforeEntity;
                }
              } else if (this.fastForwardTo(CharCodes.Lt)) {
                this.sequenceIndex = 1;
              }
            } else {
              this.sequenceIndex = Number(c === CharCodes.Lt);
            }
          };
          Tokenizer2.prototype.stateCDATASequence = function(c) {
            if (c === Sequences.Cdata[this.sequenceIndex]) {
              if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
              }
            } else {
              this.sequenceIndex = 0;
              this.state = State.InDeclaration;
              this.stateInDeclaration(c);
            }
          };
          Tokenizer2.prototype.fastForwardTo = function(c) {
            while (++this.index < this.buffer.length + this.offset) {
              if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
              }
            }
            this.index = this.buffer.length + this.offset - 1;
            return false;
          };
          Tokenizer2.prototype.stateInCommentLike = function(c) {
            if (c === this.currentSequence[this.sequenceIndex]) {
              if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                  this.cbs.oncdata(this.sectionStart, this.index, 2);
                } else {
                  this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
              }
            } else if (this.sequenceIndex === 0) {
              if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
              }
            } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
              this.sequenceIndex = 0;
            }
          };
          Tokenizer2.prototype.isTagStartChar = function(c) {
            return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
          };
          Tokenizer2.prototype.startSpecial = function(sequence, offset) {
            this.isSpecial = true;
            this.currentSequence = sequence;
            this.sequenceIndex = offset;
            this.state = State.SpecialStartSequence;
          };
          Tokenizer2.prototype.stateBeforeTagName = function(c) {
            if (c === CharCodes.ExclamationMark) {
              this.state = State.BeforeDeclaration;
              this.sectionStart = this.index + 1;
            } else if (c === CharCodes.Questionmark) {
              this.state = State.InProcessingInstruction;
              this.sectionStart = this.index + 1;
            } else if (this.isTagStartChar(c)) {
              var lower = c | 32;
              this.sectionStart = this.index;
              if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
              } else {
                this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
              }
            } else if (c === CharCodes.Slash) {
              this.state = State.BeforeClosingTagName;
            } else {
              this.state = State.Text;
              this.stateText(c);
            }
          };
          Tokenizer2.prototype.stateInTagName = function(c) {
            if (isEndOfTagSection(c)) {
              this.cbs.onopentagname(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
            }
          };
          Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
            if (isWhitespace(c)) {
            } else if (c === CharCodes.Gt) {
              this.state = State.Text;
            } else {
              this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
              this.sectionStart = this.index;
            }
          };
          Tokenizer2.prototype.stateInClosingTagName = function(c) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
              this.cbs.onclosetag(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.AfterClosingTagName;
              this.stateAfterClosingTagName(c);
            }
          };
          Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.state = State.Text;
              this.baseState = State.Text;
              this.sectionStart = this.index + 1;
            }
          };
          Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
            if (c === CharCodes.Gt) {
              this.cbs.onopentagend(this.index);
              if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
              } else {
                this.state = State.Text;
              }
              this.baseState = this.state;
              this.sectionStart = this.index + 1;
            } else if (c === CharCodes.Slash) {
              this.state = State.InSelfClosingTag;
            } else if (!isWhitespace(c)) {
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
            }
          };
          Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
            if (c === CharCodes.Gt) {
              this.cbs.onselfclosingtag(this.index);
              this.state = State.Text;
              this.baseState = State.Text;
              this.sectionStart = this.index + 1;
              this.isSpecial = false;
            } else if (!isWhitespace(c)) {
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
            }
          };
          Tokenizer2.prototype.stateInAttributeName = function(c) {
            if (c === CharCodes.Eq || isEndOfTagSection(c)) {
              this.cbs.onattribname(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.AfterAttributeName;
              this.stateAfterAttributeName(c);
            }
          };
          Tokenizer2.prototype.stateAfterAttributeName = function(c) {
            if (c === CharCodes.Eq) {
              this.state = State.BeforeAttributeValue;
            } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
              this.cbs.onattribend(QuoteType.NoValue, this.index);
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
            } else if (!isWhitespace(c)) {
              this.cbs.onattribend(QuoteType.NoValue, this.index);
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
            }
          };
          Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
            if (c === CharCodes.DoubleQuote) {
              this.state = State.InAttributeValueDq;
              this.sectionStart = this.index + 1;
            } else if (c === CharCodes.SingleQuote) {
              this.state = State.InAttributeValueSq;
              this.sectionStart = this.index + 1;
            } else if (!isWhitespace(c)) {
              this.sectionStart = this.index;
              this.state = State.InAttributeValueNq;
              this.stateInAttributeValueNoQuotes(c);
            }
          };
          Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
            if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
              this.state = State.BeforeAttributeName;
            } else if (this.decodeEntities && c === CharCodes.Amp) {
              this.baseState = this.state;
              this.state = State.BeforeEntity;
            }
          };
          Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
            this.handleInAttributeValue(c, CharCodes.DoubleQuote);
          };
          Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
            this.handleInAttributeValue(c, CharCodes.SingleQuote);
          };
          Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
            if (isWhitespace(c) || c === CharCodes.Gt) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(QuoteType.Unquoted, this.index);
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
            } else if (this.decodeEntities && c === CharCodes.Amp) {
              this.baseState = this.state;
              this.state = State.BeforeEntity;
            }
          };
          Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
            if (c === CharCodes.OpeningSquareBracket) {
              this.state = State.CDATASequence;
              this.sequenceIndex = 0;
            } else {
              this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
            }
          };
          Tokenizer2.prototype.stateInDeclaration = function(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.ondeclaration(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
            }
          };
          Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.onprocessinginstruction(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
            }
          };
          Tokenizer2.prototype.stateBeforeComment = function(c) {
            if (c === CharCodes.Dash) {
              this.state = State.InCommentLike;
              this.currentSequence = Sequences.CommentEnd;
              this.sequenceIndex = 2;
              this.sectionStart = this.index + 1;
            } else {
              this.state = State.InDeclaration;
            }
          };
          Tokenizer2.prototype.stateInSpecialComment = function(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.oncomment(this.sectionStart, this.index, 0);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
            }
          };
          Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
            var lower = c | 32;
            if (lower === Sequences.ScriptEnd[3]) {
              this.startSpecial(Sequences.ScriptEnd, 4);
            } else if (lower === Sequences.StyleEnd[3]) {
              this.startSpecial(Sequences.StyleEnd, 4);
            } else {
              this.state = State.InTagName;
              this.stateInTagName(c);
            }
          };
          Tokenizer2.prototype.stateBeforeEntity = function(c) {
            this.entityExcess = 1;
            this.entityResult = 0;
            if (c === CharCodes.Number) {
              this.state = State.BeforeNumericEntity;
            } else if (c === CharCodes.Amp) {
            } else {
              this.trieIndex = 0;
              this.trieCurrent = this.entityTrie[0];
              this.state = State.InNamedEntity;
              this.stateInNamedEntity(c);
            }
          };
          Tokenizer2.prototype.stateInNamedEntity = function(c) {
            this.entityExcess += 1;
            this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
            if (this.trieIndex < 0) {
              this.emitNamedEntity();
              this.index--;
              return;
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
            if (masked) {
              var valueLength = (masked >> 14) - 1;
              if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                this.trieIndex += valueLength;
              } else {
                var entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                  this.emitPartial(this.sectionStart, entityStart);
                }
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                  this.emitNamedEntity();
                }
              }
            }
          };
          Tokenizer2.prototype.emitNamedEntity = function() {
            this.state = this.baseState;
            if (this.entityResult === 0) {
              return;
            }
            var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
            switch (valueLength) {
              case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
                break;
              }
              case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
              }
              case 3: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
              }
            }
          };
          Tokenizer2.prototype.stateBeforeNumericEntity = function(c) {
            if ((c | 32) === CharCodes.LowerX) {
              this.entityExcess++;
              this.state = State.InHexEntity;
            } else {
              this.state = State.InNumericEntity;
              this.stateInNumericEntity(c);
            }
          };
          Tokenizer2.prototype.emitNumericEntity = function(strict) {
            var entityStart = this.index - this.entityExcess - 1;
            var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
            if (numberStart !== this.index) {
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.sectionStart = this.index + Number(strict);
              this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
            }
            this.state = this.baseState;
          };
          Tokenizer2.prototype.stateInNumericEntity = function(c) {
            if (c === CharCodes.Semi) {
              this.emitNumericEntity(true);
            } else if (isNumber(c)) {
              this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
              this.entityExcess++;
            } else {
              if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
              } else {
                this.state = this.baseState;
              }
              this.index--;
            }
          };
          Tokenizer2.prototype.stateInHexEntity = function(c) {
            if (c === CharCodes.Semi) {
              this.emitNumericEntity(true);
            } else if (isNumber(c)) {
              this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
              this.entityExcess++;
            } else if (isHexDigit(c)) {
              this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
              this.entityExcess++;
            } else {
              if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
              } else {
                this.state = this.baseState;
              }
              this.index--;
            }
          };
          Tokenizer2.prototype.allowLegacyEntity = function() {
            return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
          };
          Tokenizer2.prototype.cleanup = function() {
            if (this.running && this.sectionStart !== this.index) {
              if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
              } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
              }
            }
          };
          Tokenizer2.prototype.shouldContinue = function() {
            return this.index < this.buffer.length + this.offset && this.running;
          };
          Tokenizer2.prototype.parse = function() {
            while (this.shouldContinue()) {
              var c = this.buffer.charCodeAt(this.index - this.offset);
              switch (this.state) {
                case State.Text: {
                  this.stateText(c);
                  break;
                }
                case State.SpecialStartSequence: {
                  this.stateSpecialStartSequence(c);
                  break;
                }
                case State.InSpecialTag: {
                  this.stateInSpecialTag(c);
                  break;
                }
                case State.CDATASequence: {
                  this.stateCDATASequence(c);
                  break;
                }
                case State.InAttributeValueDq: {
                  this.stateInAttributeValueDoubleQuotes(c);
                  break;
                }
                case State.InAttributeName: {
                  this.stateInAttributeName(c);
                  break;
                }
                case State.InCommentLike: {
                  this.stateInCommentLike(c);
                  break;
                }
                case State.InSpecialComment: {
                  this.stateInSpecialComment(c);
                  break;
                }
                case State.BeforeAttributeName: {
                  this.stateBeforeAttributeName(c);
                  break;
                }
                case State.InTagName: {
                  this.stateInTagName(c);
                  break;
                }
                case State.InClosingTagName: {
                  this.stateInClosingTagName(c);
                  break;
                }
                case State.BeforeTagName: {
                  this.stateBeforeTagName(c);
                  break;
                }
                case State.AfterAttributeName: {
                  this.stateAfterAttributeName(c);
                  break;
                }
                case State.InAttributeValueSq: {
                  this.stateInAttributeValueSingleQuotes(c);
                  break;
                }
                case State.BeforeAttributeValue: {
                  this.stateBeforeAttributeValue(c);
                  break;
                }
                case State.BeforeClosingTagName: {
                  this.stateBeforeClosingTagName(c);
                  break;
                }
                case State.AfterClosingTagName: {
                  this.stateAfterClosingTagName(c);
                  break;
                }
                case State.BeforeSpecialS: {
                  this.stateBeforeSpecialS(c);
                  break;
                }
                case State.InAttributeValueNq: {
                  this.stateInAttributeValueNoQuotes(c);
                  break;
                }
                case State.InSelfClosingTag: {
                  this.stateInSelfClosingTag(c);
                  break;
                }
                case State.InDeclaration: {
                  this.stateInDeclaration(c);
                  break;
                }
                case State.BeforeDeclaration: {
                  this.stateBeforeDeclaration(c);
                  break;
                }
                case State.BeforeComment: {
                  this.stateBeforeComment(c);
                  break;
                }
                case State.InProcessingInstruction: {
                  this.stateInProcessingInstruction(c);
                  break;
                }
                case State.InNamedEntity: {
                  this.stateInNamedEntity(c);
                  break;
                }
                case State.BeforeEntity: {
                  this.stateBeforeEntity(c);
                  break;
                }
                case State.InHexEntity: {
                  this.stateInHexEntity(c);
                  break;
                }
                case State.InNumericEntity: {
                  this.stateInNumericEntity(c);
                  break;
                }
                default: {
                  this.stateBeforeNumericEntity(c);
                }
              }
              this.index++;
            }
            this.cleanup();
          };
          Tokenizer2.prototype.finish = function() {
            if (this.state === State.InNamedEntity) {
              this.emitNamedEntity();
            }
            if (this.sectionStart < this.index) {
              this.handleTrailingData();
            }
            this.cbs.onend();
          };
          Tokenizer2.prototype.handleTrailingData = function() {
            var endIndex = this.buffer.length + this.offset;
            if (this.state === State.InCommentLike) {
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
              } else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
              }
            } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
            } else {
              this.cbs.ontext(this.sectionStart, endIndex);
            }
          };
          Tokenizer2.prototype.emitPartial = function(start, endIndex) {
            if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
              this.cbs.onattribdata(start, endIndex);
            } else {
              this.cbs.ontext(start, endIndex);
            }
          };
          Tokenizer2.prototype.emitCodePoint = function(cp) {
            if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
              this.cbs.onattribentity(cp);
            } else {
              this.cbs.ontextentity(cp);
            }
          };
          return Tokenizer2;
        }()
      );
      exports2.default = Tokenizer;
    }
  });

  // node_modules/htmlparser2/lib/Parser.js
  var require_Parser = __commonJS({
    "node_modules/htmlparser2/lib/Parser.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault3 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar3 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault3(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = void 0;
      var Tokenizer_js_1 = __importStar3(require_Tokenizer());
      var decode_js_1 = require_decode();
      var formTags = /* @__PURE__ */ new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea"
      ]);
      var pTag = /* @__PURE__ */ new Set(["p"]);
      var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
      var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
      var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
      var openImpliesClose = /* @__PURE__ */ new Map([
        ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
        ["th", /* @__PURE__ */ new Set(["th"])],
        ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
        ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
        ["li", /* @__PURE__ */ new Set(["li"])],
        ["p", pTag],
        ["h1", pTag],
        ["h2", pTag],
        ["h3", pTag],
        ["h4", pTag],
        ["h5", pTag],
        ["h6", pTag],
        ["select", formTags],
        ["input", formTags],
        ["output", formTags],
        ["button", formTags],
        ["datalist", formTags],
        ["textarea", formTags],
        ["option", /* @__PURE__ */ new Set(["option"])],
        ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
        ["dd", ddtTags],
        ["dt", ddtTags],
        ["address", pTag],
        ["article", pTag],
        ["aside", pTag],
        ["blockquote", pTag],
        ["details", pTag],
        ["div", pTag],
        ["dl", pTag],
        ["fieldset", pTag],
        ["figcaption", pTag],
        ["figure", pTag],
        ["footer", pTag],
        ["form", pTag],
        ["header", pTag],
        ["hr", pTag],
        ["main", pTag],
        ["nav", pTag],
        ["ol", pTag],
        ["pre", pTag],
        ["section", pTag],
        ["table", pTag],
        ["ul", pTag],
        ["rt", rtpTags],
        ["rp", rtpTags],
        ["tbody", tableSectionTags],
        ["tfoot", tableSectionTags]
      ]);
      var voidElements = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
      var htmlIntegrationElements = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignobject",
        "desc",
        "title"
      ]);
      var reNameEnd = /\s|\//;
      var Parser = (
        /** @class */
        function() {
          function Parser2(cbs, options) {
            if (options === void 0) {
              options = {};
            }
            var _a, _b, _c, _d, _e;
            this.options = options;
            this.startIndex = 0;
            this.endIndex = 0;
            this.openTagStart = 0;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.buffers = [];
            this.bufferOffset = 0;
            this.writeIndex = 0;
            this.ended = false;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
            this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
          }
          Parser2.prototype.ontext = function(start, endIndex) {
            var _a, _b;
            var data = this.getSlice(start, endIndex);
            this.endIndex = endIndex - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
            this.startIndex = endIndex;
          };
          Parser2.prototype.ontextentity = function(cp) {
            var _a, _b;
            var index2 = this.tokenizer.getSectionStart();
            this.endIndex = index2 - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
            this.startIndex = index2;
          };
          Parser2.prototype.isVoidElement = function(name) {
            return !this.options.xmlMode && voidElements.has(name);
          };
          Parser2.prototype.onopentagname = function(start, endIndex) {
            this.endIndex = endIndex;
            var name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            this.emitOpenTag(name);
          };
          Parser2.prototype.emitOpenTag = function(name) {
            var _a, _b, _c, _d;
            this.openTagStart = this.startIndex;
            this.tagname = name;
            var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
            if (impliesClose) {
              while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
                var element = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
              }
            }
            if (!this.isVoidElement(name)) {
              this.stack.push(name);
              if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
              } else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
              }
            }
            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
            if (this.cbs.onopentag)
              this.attribs = {};
          };
          Parser2.prototype.endOpenTag = function(isImplied) {
            var _a, _b;
            this.startIndex = this.openTagStart;
            if (this.attribs) {
              (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
              this.attribs = null;
            }
            if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
              this.cbs.onclosetag(this.tagname, true);
            }
            this.tagname = "";
          };
          Parser2.prototype.onopentagend = function(endIndex) {
            this.endIndex = endIndex;
            this.endOpenTag(false);
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.onclosetag = function(start, endIndex) {
            var _a, _b, _c, _d, _e, _f;
            this.endIndex = endIndex;
            var name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
              this.foreignContext.pop();
            }
            if (!this.isVoidElement(name)) {
              var pos = this.stack.lastIndexOf(name);
              if (pos !== -1) {
                if (this.cbs.onclosetag) {
                  var count = this.stack.length - pos;
                  while (count--) {
                    this.cbs.onclosetag(this.stack.pop(), count !== 0);
                  }
                } else
                  this.stack.length = pos;
              } else if (!this.options.xmlMode && name === "p") {
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
              }
            } else if (!this.options.xmlMode && name === "br") {
              (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
              (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
              (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
            }
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.onselfclosingtag = function(endIndex) {
            this.endIndex = endIndex;
            if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
              this.closeCurrentTag(false);
              this.startIndex = endIndex + 1;
            } else {
              this.onopentagend(endIndex);
            }
          };
          Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
            var _a, _b;
            var name = this.tagname;
            this.endOpenTag(isOpenImplied);
            if (this.stack[this.stack.length - 1] === name) {
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
              this.stack.pop();
            }
          };
          Parser2.prototype.onattribname = function(start, endIndex) {
            this.startIndex = start;
            var name = this.getSlice(start, endIndex);
            this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
          };
          Parser2.prototype.onattribdata = function(start, endIndex) {
            this.attribvalue += this.getSlice(start, endIndex);
          };
          Parser2.prototype.onattribentity = function(cp) {
            this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
          };
          Parser2.prototype.onattribend = function(quote, endIndex) {
            var _a, _b;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
            if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
              this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribvalue = "";
          };
          Parser2.prototype.getInstructionName = function(value) {
            var index2 = value.search(reNameEnd);
            var name = index2 < 0 ? value : value.substr(0, index2);
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            return name;
          };
          Parser2.prototype.ondeclaration = function(start, endIndex) {
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
              var name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
            }
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
              var name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
            }
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.oncomment = function(start, endIndex, offset) {
            var _a, _b, _c, _d;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.oncdata = function(start, endIndex, offset) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            this.endIndex = endIndex;
            var value = this.getSlice(start, endIndex - offset);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
              (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
              (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
              (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            } else {
              (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
              (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
            }
            this.startIndex = endIndex + 1;
          };
          Parser2.prototype.onend = function() {
            var _a, _b;
            if (this.cbs.onclosetag) {
              this.endIndex = this.startIndex;
              for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
                ;
            }
            (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
          };
          Parser2.prototype.reset = function() {
            var _a, _b, _c, _d;
            (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack.length = 0;
            this.startIndex = 0;
            this.endIndex = 0;
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
            this.buffers.length = 0;
            this.bufferOffset = 0;
            this.writeIndex = 0;
            this.ended = false;
          };
          Parser2.prototype.parseComplete = function(data) {
            this.reset();
            this.end(data);
          };
          Parser2.prototype.getSlice = function(start, end) {
            while (start - this.bufferOffset >= this.buffers[0].length) {
              this.shiftBuffer();
            }
            var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
            while (end - this.bufferOffset > this.buffers[0].length) {
              this.shiftBuffer();
              slice += this.buffers[0].slice(0, end - this.bufferOffset);
            }
            return slice;
          };
          Parser2.prototype.shiftBuffer = function() {
            this.bufferOffset += this.buffers[0].length;
            this.writeIndex--;
            this.buffers.shift();
          };
          Parser2.prototype.write = function(chunk) {
            var _a, _b;
            if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
              return;
            }
            this.buffers.push(chunk);
            if (this.tokenizer.running) {
              this.tokenizer.write(chunk);
              this.writeIndex++;
            }
          };
          Parser2.prototype.end = function(chunk) {
            var _a, _b;
            if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
              return;
            }
            if (chunk)
              this.write(chunk);
            this.ended = true;
            this.tokenizer.end();
          };
          Parser2.prototype.pause = function() {
            this.tokenizer.pause();
          };
          Parser2.prototype.resume = function() {
            this.tokenizer.resume();
            while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
              this.tokenizer.write(this.buffers[this.writeIndex++]);
            }
            if (this.ended)
              this.tokenizer.end();
          };
          Parser2.prototype.parseChunk = function(chunk) {
            this.write(chunk);
          };
          Parser2.prototype.done = function(chunk) {
            this.end(chunk);
          };
          return Parser2;
        }()
      );
      exports2.Parser = Parser;
    }
  });

  // node_modules/domelementtype/lib/index.js
  var require_lib = __commonJS({
    "node_modules/domelementtype/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
      var ElementType;
      (function(ElementType2) {
        ElementType2["Root"] = "root";
        ElementType2["Text"] = "text";
        ElementType2["Directive"] = "directive";
        ElementType2["Comment"] = "comment";
        ElementType2["Script"] = "script";
        ElementType2["Style"] = "style";
        ElementType2["Tag"] = "tag";
        ElementType2["CDATA"] = "cdata";
        ElementType2["Doctype"] = "doctype";
      })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
      function isTag(elem) {
        return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
      }
      exports2.isTag = isTag;
      exports2.Root = ElementType.Root;
      exports2.Text = ElementType.Text;
      exports2.Directive = ElementType.Directive;
      exports2.Comment = ElementType.Comment;
      exports2.Script = ElementType.Script;
      exports2.Style = ElementType.Style;
      exports2.Tag = ElementType.Tag;
      exports2.CDATA = ElementType.CDATA;
      exports2.Doctype = ElementType.Doctype;
    }
  });

  // node_modules/domhandler/lib/node.js
  var require_node = __commonJS({
    "node_modules/domhandler/lib/node.js"(exports2) {
      "use strict";
      init_polyfills();
      var __extends3 = exports2 && exports2.__extends || function() {
        var extendStatics3 = function(d, b) {
          extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics3(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics3(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign3 = exports2 && exports2.__assign || function() {
        __assign3 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign3.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
      var domelementtype_1 = require_lib();
      var Node2 = (
        /** @class */
        function() {
          function Node3() {
            this.parent = null;
            this.prev = null;
            this.next = null;
            this.startIndex = null;
            this.endIndex = null;
          }
          Object.defineProperty(Node3.prototype, "parentNode", {
            // Read-write aliases for properties
            /**
             * Same as {@link parent}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.parent;
            },
            set: function(parent) {
              this.parent = parent;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Node3.prototype, "previousSibling", {
            /**
             * Same as {@link prev}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.prev;
            },
            set: function(prev) {
              this.prev = prev;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Node3.prototype, "nextSibling", {
            /**
             * Same as {@link next}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.next;
            },
            set: function(next) {
              this.next = next;
            },
            enumerable: false,
            configurable: true
          });
          Node3.prototype.cloneNode = function(recursive) {
            if (recursive === void 0) {
              recursive = false;
            }
            return cloneNode(this, recursive);
          };
          return Node3;
        }()
      );
      exports2.Node = Node2;
      var DataNode = (
        /** @class */
        function(_super) {
          __extends3(DataNode2, _super);
          function DataNode2(data) {
            var _this = _super.call(this) || this;
            _this.data = data;
            return _this;
          }
          Object.defineProperty(DataNode2.prototype, "nodeValue", {
            /**
             * Same as {@link data}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.data;
            },
            set: function(data) {
              this.data = data;
            },
            enumerable: false,
            configurable: true
          });
          return DataNode2;
        }(Node2)
      );
      exports2.DataNode = DataNode;
      var Text = (
        /** @class */
        function(_super) {
          __extends3(Text2, _super);
          function Text2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = domelementtype_1.ElementType.Text;
            return _this;
          }
          Object.defineProperty(Text2.prototype, "nodeType", {
            get: function() {
              return 3;
            },
            enumerable: false,
            configurable: true
          });
          return Text2;
        }(DataNode)
      );
      exports2.Text = Text;
      var Comment = (
        /** @class */
        function(_super) {
          __extends3(Comment2, _super);
          function Comment2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = domelementtype_1.ElementType.Comment;
            return _this;
          }
          Object.defineProperty(Comment2.prototype, "nodeType", {
            get: function() {
              return 8;
            },
            enumerable: false,
            configurable: true
          });
          return Comment2;
        }(DataNode)
      );
      exports2.Comment = Comment;
      var ProcessingInstruction = (
        /** @class */
        function(_super) {
          __extends3(ProcessingInstruction2, _super);
          function ProcessingInstruction2(name, data) {
            var _this = _super.call(this, data) || this;
            _this.name = name;
            _this.type = domelementtype_1.ElementType.Directive;
            return _this;
          }
          Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
            get: function() {
              return 1;
            },
            enumerable: false,
            configurable: true
          });
          return ProcessingInstruction2;
        }(DataNode)
      );
      exports2.ProcessingInstruction = ProcessingInstruction;
      var NodeWithChildren = (
        /** @class */
        function(_super) {
          __extends3(NodeWithChildren2, _super);
          function NodeWithChildren2(children) {
            var _this = _super.call(this) || this;
            _this.children = children;
            return _this;
          }
          Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
            // Aliases
            /** First child of the node. */
            get: function() {
              var _a;
              return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
            /** Last child of the node. */
            get: function() {
              return this.children.length > 0 ? this.children[this.children.length - 1] : null;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
            /**
             * Same as {@link children}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.children;
            },
            set: function(children) {
              this.children = children;
            },
            enumerable: false,
            configurable: true
          });
          return NodeWithChildren2;
        }(Node2)
      );
      exports2.NodeWithChildren = NodeWithChildren;
      var CDATA = (
        /** @class */
        function(_super) {
          __extends3(CDATA2, _super);
          function CDATA2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = domelementtype_1.ElementType.CDATA;
            return _this;
          }
          Object.defineProperty(CDATA2.prototype, "nodeType", {
            get: function() {
              return 4;
            },
            enumerable: false,
            configurable: true
          });
          return CDATA2;
        }(NodeWithChildren)
      );
      exports2.CDATA = CDATA;
      var Document = (
        /** @class */
        function(_super) {
          __extends3(Document2, _super);
          function Document2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = domelementtype_1.ElementType.Root;
            return _this;
          }
          Object.defineProperty(Document2.prototype, "nodeType", {
            get: function() {
              return 9;
            },
            enumerable: false,
            configurable: true
          });
          return Document2;
        }(NodeWithChildren)
      );
      exports2.Document = Document;
      var Element = (
        /** @class */
        function(_super) {
          __extends3(Element2, _super);
          function Element2(name, attribs, children, type) {
            if (children === void 0) {
              children = [];
            }
            if (type === void 0) {
              type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
            }
            var _this = _super.call(this, children) || this;
            _this.name = name;
            _this.attribs = attribs;
            _this.type = type;
            return _this;
          }
          Object.defineProperty(Element2.prototype, "nodeType", {
            get: function() {
              return 1;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Element2.prototype, "tagName", {
            // DOM Level 1 aliases
            /**
             * Same as {@link name}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.name;
            },
            set: function(name) {
              this.name = name;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Element2.prototype, "attributes", {
            get: function() {
              var _this = this;
              return Object.keys(this.attribs).map(function(name) {
                var _a, _b;
                return {
                  name,
                  value: _this.attribs[name],
                  namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                  prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
                };
              });
            },
            enumerable: false,
            configurable: true
          });
          return Element2;
        }(NodeWithChildren)
      );
      exports2.Element = Element;
      function isTag(node) {
        return (0, domelementtype_1.isTag)(node);
      }
      exports2.isTag = isTag;
      function isCDATA(node) {
        return node.type === domelementtype_1.ElementType.CDATA;
      }
      exports2.isCDATA = isCDATA;
      function isText(node) {
        return node.type === domelementtype_1.ElementType.Text;
      }
      exports2.isText = isText;
      function isComment(node) {
        return node.type === domelementtype_1.ElementType.Comment;
      }
      exports2.isComment = isComment;
      function isDirective(node) {
        return node.type === domelementtype_1.ElementType.Directive;
      }
      exports2.isDirective = isDirective;
      function isDocument(node) {
        return node.type === domelementtype_1.ElementType.Root;
      }
      exports2.isDocument = isDocument;
      function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
      }
      exports2.hasChildren = hasChildren;
      function cloneNode(node, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        var result;
        if (isText(node)) {
          result = new Text(node.data);
        } else if (isComment(node)) {
          result = new Comment(node.data);
        } else if (isTag(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_1 = new Element(node.name, __assign3({}, node.attribs), children);
          children.forEach(function(child) {
            return child.parent = clone_1;
          });
          if (node.namespace != null) {
            clone_1.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign3({}, node["x-attribsNamespace"]);
          }
          if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign3({}, node["x-attribsPrefix"]);
          }
          result = clone_1;
        } else if (isCDATA(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_2 = new CDATA(children);
          children.forEach(function(child) {
            return child.parent = clone_2;
          });
          result = clone_2;
        } else if (isDocument(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_3 = new Document(children);
          children.forEach(function(child) {
            return child.parent = clone_3;
          });
          if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
          }
          result = clone_3;
        } else if (isDirective(node)) {
          var instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
        } else {
          throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
      }
      exports2.cloneNode = cloneNode;
      function cloneChildren(childs) {
        var children = childs.map(function(child) {
          return cloneNode(child, true);
        });
        for (var i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
        }
        return children;
      }
    }
  });

  // node_modules/domhandler/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/domhandler/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding3(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DomHandler = void 0;
      var domelementtype_1 = require_lib();
      var node_js_1 = require_node();
      __exportStar3(require_node(), exports2);
      var defaultOpts = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false
      };
      var DomHandler = (
        /** @class */
        function() {
          function DomHandler2(callback, options, elementCB) {
            this.dom = [];
            this.root = new node_js_1.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
            if (typeof options === "function") {
              elementCB = options;
              options = defaultOpts;
            }
            if (typeof callback === "object") {
              options = callback;
              callback = void 0;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
          }
          DomHandler2.prototype.onparserinit = function(parser) {
            this.parser = parser;
          };
          DomHandler2.prototype.onreset = function() {
            this.dom = [];
            this.root = new node_js_1.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
          };
          DomHandler2.prototype.onend = function() {
            if (this.done)
              return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
          };
          DomHandler2.prototype.onerror = function(error) {
            this.handleCallback(error);
          };
          DomHandler2.prototype.onclosetag = function() {
            this.lastNode = null;
            var elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
              elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
              this.elementCB(elem);
          };
          DomHandler2.prototype.onopentag = function(name, attribs) {
            var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
            var element = new node_js_1.Element(name, attribs, void 0, type);
            this.addNode(element);
            this.tagStack.push(element);
          };
          DomHandler2.prototype.ontext = function(data) {
            var lastNode = this.lastNode;
            if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
              lastNode.data += data;
              if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
              }
            } else {
              var node = new node_js_1.Text(data);
              this.addNode(node);
              this.lastNode = node;
            }
          };
          DomHandler2.prototype.oncomment = function(data) {
            if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
              this.lastNode.data += data;
              return;
            }
            var node = new node_js_1.Comment(data);
            this.addNode(node);
            this.lastNode = node;
          };
          DomHandler2.prototype.oncommentend = function() {
            this.lastNode = null;
          };
          DomHandler2.prototype.oncdatastart = function() {
            var text = new node_js_1.Text("");
            var node = new node_js_1.CDATA([text]);
            this.addNode(node);
            text.parent = node;
            this.lastNode = text;
          };
          DomHandler2.prototype.oncdataend = function() {
            this.lastNode = null;
          };
          DomHandler2.prototype.onprocessinginstruction = function(name, data) {
            var node = new node_js_1.ProcessingInstruction(name, data);
            this.addNode(node);
          };
          DomHandler2.prototype.handleCallback = function(error) {
            if (typeof this.callback === "function") {
              this.callback(error, this.dom);
            } else if (error) {
              throw error;
            }
          };
          DomHandler2.prototype.addNode = function(node) {
            var parent = this.tagStack[this.tagStack.length - 1];
            var previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
              node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
              node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
              node.prev = previousSibling;
              previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
          };
          return DomHandler2;
        }()
      );
      exports2.DomHandler = DomHandler;
      exports2.default = DomHandler;
    }
  });

  // node_modules/entities/lib/generated/encode-html.js
  var require_encode_html = __commonJS({
    "node_modules/entities/lib/generated/encode-html.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function restoreDiff(arr) {
        for (var i = 1; i < arr.length; i++) {
          arr[i][0] += arr[i - 1][0] + 1;
        }
        return arr;
      }
      exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
    }
  });

  // node_modules/entities/lib/escape.js
  var require_escape = __commonJS({
    "node_modules/entities/lib/escape.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
      exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
      var xmlCodeMap = /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"]
      ]);
      exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? function(str, index2) {
        return str.codePointAt(index2);
      } : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(c, index2) {
          return (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
        }
      );
      function encodeXML(str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = exports2.xmlReplacer.exec(str)) !== null) {
          var i = match.index;
          var char = str.charCodeAt(i);
          var next = xmlCodeMap.get(char);
          if (next !== void 0) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
          } else {
            ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
            lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
          }
        }
        return ret + str.substr(lastIdx);
      }
      exports2.encodeXML = encodeXML;
      exports2.escape = encodeXML;
      function getEscaper(regex, map) {
        return function escape2(data) {
          var match;
          var lastIdx = 0;
          var result = "";
          while (match = regex.exec(data)) {
            if (lastIdx !== match.index) {
              result += data.substring(lastIdx, match.index);
            }
            result += map.get(match[0].charCodeAt(0));
            lastIdx = match.index + 1;
          }
          return result + data.substring(lastIdx);
        };
      }
      exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
      exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"]
      ]));
      exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"]
      ]));
    }
  });

  // node_modules/entities/lib/encode.js
  var require_encode = __commonJS({
    "node_modules/entities/lib/encode.js"(exports2) {
      "use strict";
      init_polyfills();
      var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
      var encode_html_js_1 = __importDefault3(require_encode_html());
      var escape_js_1 = require_escape();
      var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
      function encodeHTML(data) {
        return encodeHTMLTrieRe(htmlReplacer, data);
      }
      exports2.encodeHTML = encodeHTML;
      function encodeNonAsciiHTML(data) {
        return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
      }
      exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
      function encodeHTMLTrieRe(regExp, str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = regExp.exec(str)) !== null) {
          var i = match.index;
          ret += str.substring(lastIdx, i);
          var char = str.charCodeAt(i);
          var next = encode_html_js_1.default.get(char);
          if (typeof next === "object") {
            if (i + 1 < str.length) {
              var nextChar = str.charCodeAt(i + 1);
              var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
              if (value !== void 0) {
                ret += value;
                lastIdx = regExp.lastIndex += 1;
                continue;
              }
            }
            next = next.v;
          }
          if (next !== void 0) {
            ret += next;
            lastIdx = i + 1;
          } else {
            var cp = (0, escape_js_1.getCodePoint)(str, i);
            ret += "&#x".concat(cp.toString(16), ";");
            lastIdx = regExp.lastIndex += Number(cp !== char);
          }
        }
        return ret + str.substr(lastIdx);
      }
    }
  });

  // node_modules/entities/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/entities/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
      var decode_js_1 = require_decode();
      var encode_js_1 = require_encode();
      var escape_js_1 = require_escape();
      var EntityLevel;
      (function(EntityLevel2) {
        EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
        EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
      })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
      var EncodingMode;
      (function(EncodingMode2) {
        EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
        EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
        EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
        EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
        EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
      })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
      function decode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var level = typeof options === "number" ? options : options.level;
        if (level === EntityLevel.HTML) {
          var mode = typeof options === "object" ? options.mode : void 0;
          return (0, decode_js_1.decodeHTML)(data, mode);
        }
        return (0, decode_js_1.decodeXML)(data);
      }
      exports2.decode = decode;
      function decodeStrict(data, options) {
        var _a;
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
        return decode(data, opts);
      }
      exports2.decodeStrict = decodeStrict;
      function encode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        if (opts.mode === EncodingMode.UTF8)
          return (0, escape_js_1.escapeUTF8)(data);
        if (opts.mode === EncodingMode.Attribute)
          return (0, escape_js_1.escapeAttribute)(data);
        if (opts.mode === EncodingMode.Text)
          return (0, escape_js_1.escapeText)(data);
        if (opts.level === EntityLevel.HTML) {
          if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
          }
          return (0, encode_js_1.encodeHTML)(data);
        }
        return (0, escape_js_1.encodeXML)(data);
      }
      exports2.encode = encode;
      var escape_js_2 = require_escape();
      Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
        return escape_js_2.encodeXML;
      } });
      Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
        return escape_js_2.escape;
      } });
      Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
        return escape_js_2.escapeUTF8;
      } });
      Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
        return escape_js_2.escapeAttribute;
      } });
      Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
        return escape_js_2.escapeText;
      } });
      var encode_js_2 = require_encode();
      Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
        return encode_js_2.encodeNonAsciiHTML;
      } });
      Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      var decode_js_2 = require_decode();
      Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
        return decode_js_2.EntityDecoder;
      } });
      Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
        return decode_js_2.DecodingMode;
      } });
      Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
        return decode_js_2.decodeXML;
      } });
      Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLAttribute;
      } });
      Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
        return decode_js_2.decodeXML;
      } });
    }
  });

  // node_modules/dom-serializer/lib/foreignNames.js
  var require_foreignNames = __commonJS({
    "node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attributeNames = exports2.elementNames = void 0;
      exports2.elementNames = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath"
      ].map(function(val) {
        return [val.toLowerCase(), val];
      }));
      exports2.attributeNames = new Map([
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan"
      ].map(function(val) {
        return [val.toLowerCase(), val];
      }));
    }
  });

  // node_modules/dom-serializer/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/dom-serializer/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __assign3 = exports2 && exports2.__assign || function() {
        __assign3 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign3.apply(this, arguments);
      };
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault3 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar3 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault3(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.render = void 0;
      var ElementType = __importStar3(require_lib());
      var entities_1 = require_lib3();
      var foreignNames_js_1 = require_foreignNames();
      var unencodedElements = /* @__PURE__ */ new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript"
      ]);
      function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
      }
      function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes)
          return;
        var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
        return Object.keys(attributes).map(function(key) {
          var _a2, _b;
          var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
          if (opts.xmlMode === "foreign") {
            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
          }
          return "".concat(key, '="').concat(encode(value), '"');
        }).join(" ");
      }
      var singleTag = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      function render(node, options) {
        if (options === void 0) {
          options = {};
        }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
        }
        return output;
      }
      exports2.render = render;
      exports2.default = render;
      function renderNode(node, options) {
        switch (node.type) {
          case ElementType.Root:
            return render(node.children, options);
          case ElementType.Doctype:
          case ElementType.Directive:
            return renderDirective(node);
          case ElementType.Comment:
            return renderComment(node);
          case ElementType.CDATA:
            return renderCdata(node);
          case ElementType.Script:
          case ElementType.Style:
          case ElementType.Tag:
            return renderTag(node, options);
          case ElementType.Text:
            return renderText(node, options);
        }
      }
      var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ]);
      var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
      function renderTag(elem, opts) {
        var _a;
        if (opts.xmlMode === "foreign") {
          elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
          if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign3(__assign3({}, opts), { xmlMode: false });
          }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = __assign3(__assign3({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<".concat(elem.name);
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
          tag += " ".concat(attribs);
        }
        if (elem.children.length === 0 && (opts.xmlMode ? (
          // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
          opts.selfClosingTags !== false
        ) : (
          // User explicitly asked for self-closing tags, even in HTML mode
          opts.selfClosingTags && singleTag.has(elem.name)
        ))) {
          if (!opts.xmlMode)
            tag += " ";
          tag += "/>";
        } else {
          tag += ">";
          if (elem.children.length > 0) {
            tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
          }
        }
        return tag;
      }
      function renderDirective(elem) {
        return "<".concat(elem.data, ">");
      }
      function renderText(elem, opts) {
        var _a;
        var data = elem.data || "";
        if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
          data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
        }
        return data;
      }
      function renderCdata(elem) {
        return "<![CDATA[".concat(elem.children[0].data, "]]>");
      }
      function renderComment(elem) {
        return "<!--".concat(elem.data, "-->");
      }
    }
  });

  // node_modules/domutils/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/domutils/lib/stringify.js"(exports2) {
      "use strict";
      init_polyfills();
      var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
      var domhandler_1 = require_lib2();
      var dom_serializer_1 = __importDefault3(require_lib4());
      var domelementtype_1 = require_lib();
      function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
      }
      exports2.getOuterHTML = getOuterHTML;
      function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
          return getOuterHTML(node2, options);
        }).join("") : "";
      }
      exports2.getInnerHTML = getInnerHTML;
      function getText(node) {
        if (Array.isArray(node))
          return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
          return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node))
          return getText(node.children);
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.getText = getText;
      function textContent(node) {
        if (Array.isArray(node))
          return node.map(textContent).join("");
        if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
          return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.textContent = textContent;
      function innerText(node) {
        if (Array.isArray(node))
          return node.map(innerText).join("");
        if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
          return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.innerText = innerText;
    }
  });

  // node_modules/domutils/lib/traversal.js
  var require_traversal = __commonJS({
    "node_modules/domutils/lib/traversal.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
      var domhandler_1 = require_lib2();
      function getChildren(elem) {
        return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
      }
      exports2.getChildren = getChildren;
      function getParent(elem) {
        return elem.parent || null;
      }
      exports2.getParent = getParent;
      function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null)
          return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev, next = elem.next;
        while (prev != null) {
          siblings.unshift(prev);
          _a = prev, prev = _a.prev;
        }
        while (next != null) {
          siblings.push(next);
          _b = next, next = _b.next;
        }
        return siblings;
      }
      exports2.getSiblings = getSiblings;
      function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
      }
      exports2.getAttributeValue = getAttributeValue;
      function hasAttrib(elem, name) {
        return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
      }
      exports2.hasAttrib = hasAttrib;
      function getName(elem) {
        return elem.name;
      }
      exports2.getName = getName;
      function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
          _a = next, next = _a.next;
        return next;
      }
      exports2.nextElementSibling = nextElementSibling;
      function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
          _a = prev, prev = _a.prev;
        return prev;
      }
      exports2.prevElementSibling = prevElementSibling;
    }
  });

  // node_modules/domutils/lib/manipulation.js
  var require_manipulation = __commonJS({
    "node_modules/domutils/lib/manipulation.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
      function removeElement(elem) {
        if (elem.prev)
          elem.prev.next = elem.next;
        if (elem.next)
          elem.next.prev = elem.prev;
        if (elem.parent) {
          var childs = elem.parent.children;
          var childsIndex = childs.lastIndexOf(elem);
          if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
          }
        }
        elem.next = null;
        elem.prev = null;
        elem.parent = null;
      }
      exports2.removeElement = removeElement;
      function replaceElement(elem, replacement) {
        var prev = replacement.prev = elem.prev;
        if (prev) {
          prev.next = replacement;
        }
        var next = replacement.next = elem.next;
        if (next) {
          next.prev = replacement;
        }
        var parent = replacement.parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
          elem.parent = null;
        }
      }
      exports2.replaceElement = replaceElement;
      function appendChild(parent, child) {
        removeElement(child);
        child.next = null;
        child.parent = parent;
        if (parent.children.push(child) > 1) {
          var sibling = parent.children[parent.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
        } else {
          child.prev = null;
        }
      }
      exports2.appendChild = appendChild;
      function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
          currNext.prev = next;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
        } else if (parent) {
          parent.children.push(next);
        }
      }
      exports2.append = append;
      function prependChild(parent, child) {
        removeElement(child);
        child.parent = parent;
        child.prev = null;
        if (parent.children.unshift(child) !== 1) {
          var sibling = parent.children[1];
          sibling.prev = child;
          child.next = sibling;
        } else {
          child.next = null;
        }
      }
      exports2.prependChild = prependChild;
      function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
          elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
      }
      exports2.prepend = prepend;
    }
  });

  // node_modules/domutils/lib/querying.js
  var require_querying = __commonJS({
    "node_modules/domutils/lib/querying.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
      var domhandler_1 = require_lib2();
      function filter(test, node, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return find(test, Array.isArray(node) ? node : [node], recurse, limit);
      }
      exports2.filter = filter;
      function find(test, nodes, recurse, limit) {
        var result = [];
        var nodeStack = [nodes];
        var indexStack = [0];
        for (; ; ) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (indexStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
              return result;
          }
          if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
      exports2.find = find;
      function findOneChild(test, nodes) {
        return nodes.find(test);
      }
      exports2.findOneChild = findOneChild;
      function findOne(test, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        var elem = null;
        for (var i = 0; i < nodes.length && !elem; i++) {
          var node = nodes[i];
          if (!(0, domhandler_1.isTag)(node)) {
            continue;
          } else if (test(node)) {
            elem = node;
          } else if (recurse && node.children.length > 0) {
            elem = findOne(test, node.children, true);
          }
        }
        return elem;
      }
      exports2.findOne = findOne;
      function existsOne(test, nodes) {
        return nodes.some(function(checked) {
          return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
        });
      }
      exports2.existsOne = existsOne;
      function findAll(test, nodes) {
        var result = [];
        var nodeStack = [nodes];
        var indexStack = [0];
        for (; ; ) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if (!(0, domhandler_1.isTag)(elem))
            continue;
          if (test(elem))
            result.push(elem);
          if (elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
      exports2.findAll = findAll;
    }
  });

  // node_modules/domutils/lib/legacy.js
  var require_legacy = __commonJS({
    "node_modules/domutils/lib/legacy.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
      var domhandler_1 = require_lib2();
      var querying_js_1 = require_querying();
      var Checks = {
        tag_name: function(name) {
          if (typeof name === "function") {
            return function(elem) {
              return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return domhandler_1.isTag;
          }
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
          };
        },
        tag_type: function(type) {
          if (typeof type === "function") {
            return function(elem) {
              return type(elem.type);
            };
          }
          return function(elem) {
            return elem.type === type;
          };
        },
        tag_contains: function(data) {
          if (typeof data === "function") {
            return function(elem) {
              return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
          }
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
          };
        }
      };
      function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
        };
      }
      function combineFuncs(a, b) {
        return function(elem) {
          return a(elem) || b(elem);
        };
      }
      function compileTest(options) {
        var funcs = Object.keys(options).map(function(key) {
          var value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
      }
      function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
      }
      exports2.testElement = testElement;
      function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) {
          limit = Infinity;
        }
        var test = compileTest(options);
        return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
      }
      exports2.getElements = getElements;
      function getElementById(id2, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (!Array.isArray(nodes))
          nodes = [nodes];
        return (0, querying_js_1.findOne)(getAttribCheck("id", id2), nodes, recurse);
      }
      exports2.getElementById = getElementById;
      function getElementsByTagName(tagName2, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(Checks["tag_name"](tagName2), nodes, recurse, limit);
      }
      exports2.getElementsByTagName = getElementsByTagName;
      function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
      }
      exports2.getElementsByTagType = getElementsByTagType;
    }
  });

  // node_modules/domutils/lib/helpers.js
  var require_helpers = __commonJS({
    "node_modules/domutils/lib/helpers.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
      var domhandler_1 = require_lib2();
      function removeSubsets(nodes) {
        var idx = nodes.length;
        while (--idx >= 0) {
          var node = nodes[idx];
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
          }
          for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
              nodes.splice(idx, 1);
              break;
            }
          }
        }
        return nodes;
      }
      exports2.removeSubsets = removeSubsets;
      var DocumentPosition;
      (function(DocumentPosition2) {
        DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
        DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
        DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
        DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
        DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
      })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
      function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
          return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
        while (current) {
          aParents.unshift(current);
          current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
          bParents.unshift(current);
          current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
        }
        if (idx === 0) {
          return DocumentPosition.DISCONNECTED;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
          }
          return DocumentPosition.FOLLOWING;
        }
        if (sharedParent === nodeA) {
          return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
        }
        return DocumentPosition.PRECEDING;
      }
      exports2.compareDocumentPosition = compareDocumentPosition;
      function uniqueSort(nodes) {
        nodes = nodes.filter(function(node, i, arr) {
          return !arr.includes(node, i + 1);
        });
        nodes.sort(function(a, b) {
          var relative = compareDocumentPosition(a, b);
          if (relative & DocumentPosition.PRECEDING) {
            return -1;
          } else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
          }
          return 0;
        });
        return nodes;
      }
      exports2.uniqueSort = uniqueSort;
    }
  });

  // node_modules/domutils/lib/feeds.js
  var require_feeds = __commonJS({
    "node_modules/domutils/lib/feeds.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getFeed = void 0;
      var stringify_js_1 = require_stringify();
      var legacy_js_1 = require_legacy();
      function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
      }
      exports2.getFeed = getFeed;
      function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
          type: "atom",
          items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
            var _a2;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
            if (href2) {
              entry.link = href2;
            }
            var description = fetch2("summary", children) || fetch2("content", children);
            if (description) {
              entry.description = description;
            }
            var pubDate = fetch2("updated", children);
            if (pubDate) {
              entry.pubDate = new Date(pubDate);
            }
            return entry;
          })
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
        if (href) {
          feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch2("updated", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
      }
      function getRssFeed(feedRoot) {
        var _a, _b;
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        var feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
            if (pubDate)
              entry.pubDate = new Date(pubDate);
            return entry;
          })
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch2("lastBuildDate", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
      }
      var MEDIA_KEYS_STRING = ["url", "type", "lang"];
      var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width"
      ];
      function getMediaElements(where) {
        return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
          var attribs = elem.attribs;
          var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"]
          };
          for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
              media[attrib] = attribs[attrib];
            }
          }
          for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
              media[attrib] = parseInt(attribs[attrib], 10);
            }
          }
          if (attribs["expression"]) {
            media.expression = attribs["expression"];
          }
          return media;
        });
      }
      function getOneElement(tagName2, node) {
        return (0, legacy_js_1.getElementsByTagName)(tagName2, node, true, 1)[0];
      }
      function fetch2(tagName2, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName2, where, recurse, 1)).trim();
      }
      function addConditionally(obj, prop, tagName2, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var val = fetch2(tagName2, where, recurse);
        if (val)
          obj[prop] = val;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
    }
  });

  // node_modules/domutils/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/domutils/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding3(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
      __exportStar3(require_stringify(), exports2);
      __exportStar3(require_traversal(), exports2);
      __exportStar3(require_manipulation(), exports2);
      __exportStar3(require_querying(), exports2);
      __exportStar3(require_legacy(), exports2);
      __exportStar3(require_helpers(), exports2);
      __exportStar3(require_feeds(), exports2);
      var domhandler_1 = require_lib2();
      Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
        return domhandler_1.isTag;
      } });
      Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
        return domhandler_1.isCDATA;
      } });
      Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
        return domhandler_1.isText;
      } });
      Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
        return domhandler_1.isComment;
      } });
      Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
        return domhandler_1.isDocument;
      } });
      Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
        return domhandler_1.hasChildren;
      } });
    }
  });

  // node_modules/htmlparser2/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/htmlparser2/lib/index.js"(exports2) {
      "use strict";
      init_polyfills();
      var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault3 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar3 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding3(result, mod, k);
        }
        __setModuleDefault3(result, mod);
        return result;
      };
      var __importDefault3 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
      var Parser_js_1 = require_Parser();
      var Parser_js_2 = require_Parser();
      Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
        return Parser_js_2.Parser;
      } });
      var domhandler_1 = require_lib2();
      var domhandler_2 = require_lib2();
      Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
        return domhandler_2.DomHandler;
      } });
      Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
        return domhandler_2.DomHandler;
      } });
      function parseDocument(data, options) {
        var handler = new domhandler_1.DomHandler(void 0, options);
        new Parser_js_1.Parser(handler, options).end(data);
        return handler.root;
      }
      exports2.parseDocument = parseDocument;
      function parseDOM(data, options) {
        return parseDocument(data, options).children;
      }
      exports2.parseDOM = parseDOM;
      function createDomStream(callback, options, elementCallback) {
        var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
        return new Parser_js_1.Parser(handler, options);
      }
      exports2.createDomStream = createDomStream;
      var Tokenizer_js_1 = require_Tokenizer();
      Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
        return __importDefault3(Tokenizer_js_1).default;
      } });
      exports2.ElementType = __importStar3(require_lib());
      var domutils_1 = require_lib5();
      var domutils_2 = require_lib5();
      Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
        return domutils_2.getFeed;
      } });
      var parseFeedDefaultOptions = { xmlMode: true };
      function parseFeed(feed, options) {
        if (options === void 0) {
          options = parseFeedDefaultOptions;
        }
        return (0, domutils_1.getFeed)(parseDOM(feed, options));
      }
      exports2.parseFeed = parseFeed;
      exports2.DomUtils = __importStar3(require_lib5());
    }
  });

  // node_modules/escape-string-regexp/index.js
  var require_escape_string_regexp = __commonJS({
    "node_modules/escape-string-regexp/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = (string) => {
        if (typeof string !== "string") {
          throw new TypeError("Expected a string");
        }
        return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
    }
  });

  // node_modules/is-plain-object/dist/is-plain-object.js
  var require_is_plain_object = __commonJS({
    "node_modules/is-plain-object/dist/is-plain-object.js"(exports2) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports2, "__esModule", { value: true });
      function isObject(o) {
        return Object.prototype.toString.call(o) === "[object Object]";
      }
      function isPlainObject(o) {
        var ctor, prot;
        if (isObject(o) === false)
          return false;
        ctor = o.constructor;
        if (ctor === void 0)
          return true;
        prot = ctor.prototype;
        if (isObject(prot) === false)
          return false;
        if (prot.hasOwnProperty("isPrototypeOf") === false) {
          return false;
        }
        return true;
      }
      exports2.isPlainObject = isPlainObject;
    }
  });

  // node_modules/deepmerge/dist/cjs.js
  var require_cjs2 = __commonJS({
    "node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var isMergeableObject = function isMergeableObject2(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };
      function isNonNullObject(value) {
        return !!value && typeof value === "object";
      }
      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
      }
      var canUseSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }
      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }
      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === "function" ? customMerge : deepmerge;
      }
      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
          return target.propertyIsEnumerable(symbol);
        }) : [];
      }
      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
      }
      function propertyIsOnObject(object, property) {
        try {
          return property in object;
        } catch (_) {
          return false;
        }
      }
      function propertyIsUnsafe(target, key) {
        return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
      }
      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        getKeys(source).forEach(function(key) {
          if (propertyIsUnsafe(target, key)) {
            return;
          }
          if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          }
        });
        return destination;
      }
      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }
      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error("first argument should be an array");
        }
        return array.reduce(function(prev, next) {
          return deepmerge(prev, next, options);
        }, {});
      };
      var deepmerge_1 = deepmerge;
      module2.exports = deepmerge_1;
    }
  });

  // node_modules/parse-srcset/src/parse-srcset.js
  var require_parse_srcset = __commonJS({
    "node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {
      init_polyfills();
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = factory();
        } else {
          root.parseSrcset = factory();
        }
      })(exports2, function() {
        return function(input) {
          function isSpace(c2) {
            return c2 === " " || // space
            c2 === "	" || // horizontal tab
            c2 === "\n" || // new line
            c2 === "\f" || // form feed
            c2 === "\r";
          }
          function collectCharacters(regEx) {
            var chars, match = regEx.exec(input.substring(pos));
            if (match) {
              chars = match[0];
              pos += chars.length;
              return chars;
            }
          }
          var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
          while (true) {
            collectCharacters(regexLeadingCommasOrSpaces);
            if (pos >= inputLength) {
              return candidates;
            }
            url = collectCharacters(regexLeadingNotSpaces);
            descriptors = [];
            if (url.slice(-1) === ",") {
              url = url.replace(regexTrailingCommas, "");
              parseDescriptors();
            } else {
              tokenize();
            }
          }
          function tokenize() {
            collectCharacters(regexLeadingSpaces);
            currentDescriptor = "";
            state = "in descriptor";
            while (true) {
              c = input.charAt(pos);
              if (state === "in descriptor") {
                if (isSpace(c)) {
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                    currentDescriptor = "";
                    state = "after descriptor";
                  }
                } else if (c === ",") {
                  pos += 1;
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                  }
                  parseDescriptors();
                  return;
                } else if (c === "(") {
                  currentDescriptor = currentDescriptor + c;
                  state = "in parens";
                } else if (c === "") {
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                  }
                  parseDescriptors();
                  return;
                } else {
                  currentDescriptor = currentDescriptor + c;
                }
              } else if (state === "in parens") {
                if (c === ")") {
                  currentDescriptor = currentDescriptor + c;
                  state = "in descriptor";
                } else if (c === "") {
                  descriptors.push(currentDescriptor);
                  parseDescriptors();
                  return;
                } else {
                  currentDescriptor = currentDescriptor + c;
                }
              } else if (state === "after descriptor") {
                if (isSpace(c)) {
                } else if (c === "") {
                  parseDescriptors();
                  return;
                } else {
                  state = "in descriptor";
                  pos -= 1;
                }
              }
              pos += 1;
            }
          }
          function parseDescriptors() {
            var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
            for (i = 0; i < descriptors.length; i++) {
              desc = descriptors[i];
              lastChar = desc[desc.length - 1];
              value = desc.substring(0, desc.length - 1);
              intVal = parseInt(value, 10);
              floatVal = parseFloat(value);
              if (regexNonNegativeInteger.test(value) && lastChar === "w") {
                if (w || d) {
                  pError = true;
                }
                if (intVal === 0) {
                  pError = true;
                } else {
                  w = intVal;
                }
              } else if (regexFloatingPoint.test(value) && lastChar === "x") {
                if (w || d || h) {
                  pError = true;
                }
                if (floatVal < 0) {
                  pError = true;
                } else {
                  d = floatVal;
                }
              } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
                if (h || d) {
                  pError = true;
                }
                if (intVal === 0) {
                  pError = true;
                } else {
                  h = intVal;
                }
              } else {
                pError = true;
              }
            }
            if (!pError) {
              candidate.url = url;
              if (w) {
                candidate.w = w;
              }
              if (d) {
                candidate.d = d;
              }
              if (h) {
                candidate.h = h;
              }
              candidates.push(candidate);
            } else if (console && console.log) {
              console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
            }
          }
        };
      });
    }
  });

  // node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
      init_polyfills();
      var x = String;
      var create = function() {
        return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
      };
      module2.exports = create();
      module2.exports.createColors = create;
    }
  });

  // (disabled):node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/postcss/lib/terminal-highlight"() {
      init_polyfills();
    }
  });

  // node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError = class _CssSyntaxError extends Error {
        constructor(message, line, column, source, file, plugin) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin) {
            this.plugin = plugin;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            if (typeof line === "number") {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color) {
          if (!this.source)
            return "";
          let css = this.source;
          if (color == null)
            color = pico.isColorSupported;
          if (terminalHighlight) {
            if (color)
              css = terminalHighlight(css);
          }
          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          let mark, aside;
          if (color) {
            let { bold, gray, red } = pico.createColors(true);
            mark = (text) => bold(red(text));
            aside = (text) => gray(text);
          } else {
            mark = aside = (str) => str;
          }
          return lines.slice(start, end).map((line, index2) => {
            let number = start + 1 + index2;
            let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
            if (number === this.line) {
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + line;
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module2.exports = CssSyntaxError;
      CssSyntaxError.default = CssSyntaxError;
    }
  });

  // node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/postcss/lib/symbols.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports.isClean = Symbol("isClean");
      module2.exports.my = Symbol("my");
    }
  });

  // node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node, semicolon) {
          let name = "@" + node.name;
          let params = node.params ? this.rawValue(node, "params") : "";
          if (typeof node.raws.afterName !== "undefined") {
            name += node.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node);
          }
        }
        beforeAfter(node, detect) {
          let value;
          if (node.type === "decl") {
            value = this.raw(node, null, "beforeDecl");
          } else if (node.type === "comment") {
            value = this.raw(node, null, "beforeComment");
          } else if (detect === "before") {
            value = this.raw(node, null, "beforeRule");
          } else {
            value = this.raw(node, null, "beforeClose");
          }
          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value.includes("\n")) {
            let indent = this.raw(node, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++)
                value += indent;
            }
          }
          return value;
        }
        block(node, start) {
          let between = this.raw(node, "between", "beforeOpen");
          this.builder(start + between + "{", node, "start");
          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, "after");
          } else {
            after = this.raw(node, "after", "emptyBody");
          }
          if (after)
            this.builder(after);
          this.builder("}", node, "end");
        }
        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== "comment")
              break;
            last -= 1;
          }
          let semicolon = this.raw(node, "semicolon");
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            let before = this.raw(child, "before");
            if (before)
              this.builder(before);
            this.stringify(child, last !== i || semicolon);
          }
        }
        comment(node) {
          let left = this.raw(node, "left", "commentLeft");
          let right = this.raw(node, "right", "commentRight");
          this.builder("/*" + left + node.text + right + "*/", node);
        }
        decl(node, semicolon) {
          let between = this.raw(node, "between", "colon");
          let string = node.prop + between + this.rawValue(node, "value");
          if (node.important) {
            string += node.raws.important || " !important";
          }
          if (semicolon)
            string += ";";
          this.builder(string, node);
        }
        document(node) {
          this.body(node);
        }
        raw(node, own, detect) {
          let value;
          if (!detect)
            detect = own;
          if (own) {
            value = node.raws[own];
            if (typeof value !== "undefined")
              return value;
          }
          let parent = node.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent)
            return DEFAULT_RAW[detect];
          let root = node.root();
          if (!root.rawCache)
            root.rawCache = {};
          if (typeof root.rawCache[detect] !== "undefined") {
            return root.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value = this[method](root, node);
            } else {
              root.walk((i) => {
                value = i.raws[own];
                if (typeof value !== "undefined")
                  return false;
              });
            }
          }
          if (typeof value === "undefined")
            value = DEFAULT_RAW[detect];
          root.rawCache[detect] = value;
          return value;
        }
        rawBeforeClose(root) {
          let value;
          root.walk((i) => {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== "undefined") {
                value = i.raws.after;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawBeforeComment(root, node) {
          let value;
          root.walkComments((i) => {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node, null, "beforeDecl");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeDecl(root, node) {
          let value;
          root.walkDecls((i) => {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node, null, "beforeRule");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeOpen(root) {
          let value;
          root.walk((i) => {
            if (i.type !== "decl") {
              value = i.raws.between;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawBeforeRule(root) {
          let value;
          root.walk((i) => {
            if (i.nodes && (i.parent !== root || root.first !== i)) {
              if (typeof i.raws.before !== "undefined") {
                value = i.raws.before;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawColon(root) {
          let value;
          root.walkDecls((i) => {
            if (typeof i.raws.between !== "undefined") {
              value = i.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value;
        }
        rawEmptyBody(root) {
          let value;
          root.walk((i) => {
            if (i.nodes && i.nodes.length === 0) {
              value = i.raws.after;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawIndent(root) {
          if (root.raws.indent)
            return root.raws.indent;
          let value;
          root.walk((i) => {
            let p = i.parent;
            if (p && p !== root && p.parent && p.parent === root) {
              if (typeof i.raws.before !== "undefined") {
                let parts = i.raws.before.split("\n");
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value;
        }
        rawSemicolon(root) {
          let value;
          root.walk((i) => {
            if (i.nodes && i.nodes.length && i.last.type === "decl") {
              value = i.raws.semicolon;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawValue(node, prop) {
          let value = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }
          return value;
        }
        root(node) {
          this.body(node);
          if (node.raws.after)
            this.builder(node.raws.after);
        }
        rule(node) {
          this.block(node, this.rawValue(node, "selector"));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, "end");
          }
        }
        stringify(node, semicolon) {
          if (!this[node.type]) {
            throw new Error(
              "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node.type](node, semicolon);
        }
      };
      module2.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/postcss/lib/stringify.js
  var require_stringify2 = __commonJS({
    "node_modules/postcss/lib/stringify.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Stringifier = require_stringifier();
      function stringify(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }
      module2.exports = stringify;
      stringify.default = stringify;
    }
  });

  // node_modules/postcss/lib/node.js
  var require_node2 = __commonJS({
    "node_modules/postcss/lib/node.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { isClean, my } = require_symbols();
      var CssSyntaxError = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify = require_stringify2();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i)) {
            continue;
          }
          if (i === "proxyCache")
            continue;
          let value = obj[i];
          let type = typeof value;
          if (i === "parent" && type === "object") {
            if (parent)
              cloned[i] = parent;
          } else if (i === "source") {
            cloned[i] = value;
          } else if (Array.isArray(value)) {
            cloned[i] = value.map((j) => cloneNode(j, cloned));
          } else {
            if (type === "object" && value !== null)
              value = cloneNode(value);
            cloned[i] = value;
          }
        }
        return cloned;
      }
      var Node2 = class {
        constructor(defaults = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node of defaults[name]) {
                if (typeof node.clone === "function") {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
            );
          }
          return error;
        }
        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween)
            delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start.column, line: start.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError(message);
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value) {
              if (node[prop] === value)
                return true;
              node[prop] = value;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
              prop === "text") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 + 1];
        }
        positionBy(opts, stringRepresentation) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index, stringRepresentation);
          } else if (opts.word) {
            stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1)
              pos = this.positionInside(index2, stringRepresentation);
          }
          return pos;
        }
        positionInside(index2, stringRepresentation) {
          let string = stringRepresentation || this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;
          for (let i = 0; i < index2; i++) {
            if (string[i] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { column, line };
        }
        prev() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 - 1];
        }
        rangeBy(opts) {
          let start = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start.column + 1,
            line: start.line
          };
          if (opts.word) {
            let stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1) {
              start = this.positionInside(index2, stringRepresentation);
              end = this.positionInside(index2 + opts.word.length, stringRepresentation);
            }
          } else {
            if (opts.start) {
              start = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (opts.endIndex) {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start.line || end.line === start.line && end.column <= start.column) {
            end = { column: start.column + 1, line: start.line };
          }
          return { end, start };
        }
        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache")
              continue;
            let value = this[name];
            if (Array.isArray(value)) {
              fixed[name] = value.map((i) => {
                if (typeof i === "object" && i.toJSON) {
                  return i.toJSON(null, inputs);
                } else {
                  return i;
                }
              });
            } else if (typeof value === "object" && value.toJSON) {
              fixed[name] = value.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value.end,
                inputId,
                start: value.start
              };
            } else {
              fixed[name] = value;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify) {
          if (stringifier.stringify)
            stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i) => {
            result += i;
          });
          return result;
        }
        warn(result, text, opts) {
          let data = { node: this };
          for (let i in opts)
            data[i] = opts[i];
          return result.warn(text, data);
        }
        get proxyOf() {
          return this;
        }
      };
      module2.exports = Node2;
      Node2.default = Node2;
    }
  });

  // node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/postcss/lib/declaration.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Node2 = require_node2();
      var Declaration = class extends Node2 {
        constructor(defaults) {
          if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
            defaults = { ...defaults, value: String(defaults.value) };
          }
          super(defaults);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      module2.exports = Declaration;
      Declaration.default = Declaration;
    }
  });

  // (disabled):node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/source-map-js/source-map.js"() {
      init_polyfills();
    }
  });

  // (disabled):node_modules/path/path.js
  var require_path = __commonJS({
    "(disabled):node_modules/path/path.js"() {
      init_polyfills();
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
      init_polyfills();
    }
  });

  // node_modules/postcss/node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/postcss/node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
      init_polyfills();
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id2 = "";
          let i = size;
          while (i--) {
            id2 += alphabet[Math.random() * alphabet.length | 0];
          }
          return id2;
        };
      };
      var nanoid = (size = 21) => {
        let id2 = "";
        let i = size;
        while (i--) {
          id2 += urlAlphabet[Math.random() * 64 | 0];
        }
        return id2;
      };
      module2.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
      init_polyfills();
    }
  });

  // node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { existsSync, readFileSync } = require_fs();
      var { dirname, join } = require_path();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css, opts) {
          if (opts.map === false)
            return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile)
            this.root = dirname(this.mapFile);
          if (text)
            this.text = text;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          if (charsetUri.test(text) || uri.test(text)) {
            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
          }
          if (baseCharsetUri.test(text) || baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
          }
          let encoding = text.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object")
            return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
          if (!comments)
            return;
          let start = css.lastIndexOf(comments.pop());
          let end = css.indexOf("*/", start);
          if (start > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css.substring(start, end));
          }
        }
        loadFile(path) {
          this.root = dirname(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false)
            return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file)
              map = join(dirname(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string, start) {
          if (!string)
            return false;
          return string.substr(0, start.length) === start;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module2.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/postcss/lib/input.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url();
      var { isAbsolute, resolve } = require_path();
      var { nanoid } = require_non_secure();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve && isAbsolute);
      var Input = class {
        constructor(css, opts = {}) {
          if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }
          this.css = css.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file)
                this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map)
            this.map.file = this.from;
        }
        error(message, line, column, opts = {}) {
          let result, endLine, endColumn;
          if (line && typeof line === "object") {
            let start = line;
            let end = column;
            if (typeof start.offset === "number") {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError(
              message,
              endLine === void 0 ? line : { column, line },
              endLine === void 0 ? column : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column, endColumn, endLine, line, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i = 0, l = lines.length; i < l; i++) {
              lineToIndex[i] = prevIndex;
              prevIndex += lines[i].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max = lineToIndex.length - 2;
            let mid;
            while (min < max) {
              mid = min + (max - min >> 1);
              if (offset < lineToIndex[mid]) {
                max = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            col: offset - lineToIndex[min] + 1,
            line: min + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line, column, endLine, endColumn) {
          if (!this.map)
            return false;
          let consumer = this.map.consumer();
          let from = consumer.originalPositionFor({ column, line });
          if (!from.source)
            return false;
          let to;
          if (typeof endLine === "number") {
            to = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
              from.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from.column,
            endColumn: to && to.column,
            endLine: to && to.line,
            line: from.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source = consumer.sourceContentFor(from.source);
          if (source)
            result.source = source;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
        get from() {
          return this.file || this.id;
        }
      };
      module2.exports = Input;
      Input.default = Input;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input);
      }
    }
  });

  // node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { dirname, relative, resolve, sep } = require_path();
      var { pathToFileURL } = require_url();
      var Input = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname && resolve && relative && sep);
      var MapGenerator = class {
        constructor(stringify, root, opts, cssString) {
          this.stringify = stringify;
          this.mapOpts = opts.map || {};
          this.root = root;
          this.opts = opts;
          this.css = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n"))
            eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root = prev.root || dirname(prev.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = map.sourcesContent.map(() => null);
              }
            } else {
              map = prev.consumer();
            }
            this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false)
            return;
          if (this.root) {
            let node;
            for (let i = this.root.nodes.length - 1; i >= 0; i--) {
              node = this.root.nodes[i];
              if (node.type !== "comment")
                continue;
              if (node.text.indexOf("# sourceMappingURL=") === 0) {
                this.root.removeChild(i);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i) => {
              result += i;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev);
          } else {
            this.map = new SourceMapGenerator({ file: this.outputFile() });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent())
            this.setSourcesContent();
          if (this.root && this.previous().length > 0)
            this.applyPrevMaps();
          if (this.isAnnotation())
            this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          let line = 1;
          let column = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let lines, last;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;
            if (node && type !== "end") {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf("\n");
              column = str.length - last;
            } else {
              column += str.length;
            }
            if (node && type !== "start") {
              let p = node.parent || { raws: {} };
              let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
              if (!childless || node !== p.last || p.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i) => i.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute)
            return file;
          if (file.charCodeAt(0) === 60)
            return file;
          if (/^\w+:\/\//.test(file))
            return file;
          let cached = this.memoizedPaths.get(file);
          if (cached)
            return cached;
          let from = this.opts.to ? dirname(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from = dirname(resolve(from, this.mapOpts.annotation));
          }
          let path = relative(from, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node) => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input(this.css, this.opts);
              if (input.map)
                this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node) => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                  this.map.setSourceContent(fromUrl, node.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from, this.css);
          }
        }
        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node.source.input.from);
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached)
            return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached)
            return cached;
          if (sep === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url);
          return url;
        }
      };
      module2.exports = MapGenerator;
    }
  });

  // node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/postcss/lib/comment.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Node2 = require_node2();
      var Comment = class extends Node2 {
        constructor(defaults) {
          super(defaults);
          this.type = "comment";
        }
      };
      module2.exports = Comment;
      Comment.default = Comment;
    }
  });

  // node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/postcss/lib/container.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { isClean, my } = require_symbols();
      var Declaration = require_declaration();
      var Comment = require_comment();
      var Node2 = require_node2();
      var parse;
      var Rule;
      var AtRule;
      var Root;
      function cleanSource(nodes) {
        return nodes.map((i) => {
          if (i.nodes)
            i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }
      function markDirtyUp(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i of node.proxyOf.nodes) {
            markDirtyUp(i);
          }
        }
      }
      var Container = class _Container extends Node2 {
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes)
              this.proxyOf.nodes.push(node);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes)
              node.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes)
            return void 0;
          let iterator = this.getIterator();
          let index2, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index2 = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index2], index2);
            if (result === false)
              break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach)
            this.lastEach = 0;
          if (!this.indexes)
            this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node[prop](
                    ...args.map((i) => {
                      if (typeof i === "function") {
                        return (child, index2) => i(child.toProxy(), index2);
                      } else {
                        return i;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else if (prop === "nodes") {
                return node.nodes.map((i) => i.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value) {
              if (node[prop] === value)
                return true;
              node[prop] = value;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        index(child) {
          if (typeof child === "number")
            return child;
          if (child.proxyOf)
            child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        insertAfter(exist, add) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex + 1, 0, node);
          let index2;
          for (let id2 in this.indexes) {
            index2 = this.indexes[id2];
            if (existIndex < index2) {
              this.indexes[id2] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex, 0, node);
          let index2;
          for (let id2 in this.indexes) {
            index2 = this.indexes[id2];
            if (existIndex <= index2) {
              this.indexes[id2] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i of nodes) {
              if (i.parent)
                i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i of nodes) {
              if (i.parent)
                i.parent.removeChild(i, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i) => {
            if (!i[my])
              _Container.rebuild(i);
            i = i.proxyOf;
            if (i.parent)
              i.parent.removeChild(i);
            if (i[isClean])
              markDirtyUp(i);
            if (typeof i.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i.parent = this.proxyOf;
            return i;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node of nodes)
              this.proxyOf.nodes.unshift(node);
            for (let id2 in this.indexes) {
              this.indexes[id2] = this.indexes[id2] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        removeAll() {
          for (let node of this.proxyOf.nodes)
            node.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index2;
          for (let id2 in this.indexes) {
            index2 = this.indexes[id2];
            if (index2 >= child) {
              this.indexes[id2] = index2 - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl) => {
            if (opts.props && !opts.props.includes(decl.prop))
              return;
            if (opts.fast && !decl.value.includes(opts.fast))
              return;
            decl.value = decl.value.replace(pattern, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child, i) => {
            let result;
            try {
              result = callback(child, i);
            } catch (e) {
              throw child.addToError(e);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i) => {
              if (child.type === "atrule") {
                return callback(child, i);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "atrule" && name.test(child.name)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "atrule" && child.name === name) {
              return callback(child, i);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i) => {
            if (child.type === "comment") {
              return callback(child, i);
            }
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i) => {
              if (child.type === "decl") {
                return callback(child, i);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i);
            }
          });
        }
        walkRules(selector2, callback) {
          if (!callback) {
            callback = selector2;
            return this.walk((child, i) => {
              if (child.type === "rule") {
                return callback(child, i);
              }
            });
          }
          if (selector2 instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === "rule" && selector2.test(child.selector)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === "rule" && child.selector === selector2) {
              return callback(child, i);
            }
          });
        }
        get first() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      Container.registerParse = (dependant) => {
        parse = dependant;
      };
      Container.registerRule = (dependant) => {
        Rule = dependant;
      };
      Container.registerAtRule = (dependant) => {
        AtRule = dependant;
      };
      Container.registerRoot = (dependant) => {
        Root = dependant;
      };
      module2.exports = Container;
      Container.default = Container;
      Container.rebuild = (node) => {
        if (node.type === "atrule") {
          Object.setPrototypeOf(node, AtRule.prototype);
        } else if (node.type === "rule") {
          Object.setPrototypeOf(node, Rule.prototype);
        } else if (node.type === "decl") {
          Object.setPrototypeOf(node, Declaration.prototype);
        } else if (node.type === "comment") {
          Object.setPrototypeOf(node, Comment.prototype);
        } else if (node.type === "root") {
          Object.setPrototypeOf(node, Root.prototype);
        }
        node[my] = true;
        if (node.nodes) {
          node.nodes.forEach((child) => {
            Container.rebuild(child);
          });
        }
      };
    }
  });

  // node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/postcss/lib/document.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Container = require_container();
      var LazyResult;
      var Processor;
      var Document = class extends Container {
        constructor(defaults) {
          super({ type: "document", ...defaults });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }
      };
      Document.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document.registerProcessor = (dependant) => {
        Processor = dependant;
      };
      module2.exports = Document;
      Document.default = Document;
    }
  });

  // node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var printed = {};
      module2.exports = function warnOnce(message) {
        if (printed[message])
          return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/postcss/lib/warning.js
  var require_warning = __commonJS({
    "node_modules/postcss/lib/warning.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Warning = class {
        constructor(text, opts = {}) {
          this.type = "warning";
          this.text = text;
          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }
          for (let opt in opts)
            this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module2.exports = Warning;
      Warning.default = Warning;
    }
  });

  // node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/postcss/lib/result.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Warning = require_warning();
      var Result = class {
        constructor(processor, root, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning = new Warning(text, opts);
          this.messages.push(warning);
          return warning;
        }
        warnings() {
          return this.messages.filter((i) => i.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      module2.exports = Result;
      Result.default = Result;
    }
  });

  // node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module2.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, next, quote, content, escape2;
        let escaped, escapePos, prev, n, currentToken;
        let length = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }
        function nextToken(opts) {
          if (returned.length)
            return returned.pop();
          if (pos >= length)
            return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED: {
              next = pos;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
              currentToken = ["space", css.slice(pos, next)];
              pos = next - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n = css.charCodeAt(pos + 1);
              if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(")", next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                next = css.indexOf(")", pos + 1);
                content = css.slice(pos, next + 1);
                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next];
                  pos = next;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case BACKSLASH: {
              next = pos;
              escape2 = true;
              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape2 = !escape2;
              }
              code = css.charCodeAt(next + 1);
              if (escape2 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next += 1;
                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                    next += 1;
                  }
                  if (css.charCodeAt(next + 1) === SPACE) {
                    next += 1;
                  }
                }
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            default: {
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next = css.indexOf("*/", pos + 2) + 1;
                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css.slice(pos, next + 1), pos, next];
                buffer.push(currentToken);
                pos = next;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position
        };
      };
    }
  });

  // node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Container = require_container();
      var AtRule = class extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.prepend(...children);
        }
      };
      module2.exports = AtRule;
      AtRule.default = AtRule;
      Container.registerAtRule(AtRule);
    }
  });

  // node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/postcss/lib/root.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Container = require_container();
      var LazyResult;
      var Processor;
      var Root = class extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = "root";
          if (!this.nodes)
            this.nodes = [];
        }
        normalize(child, sample, type) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child, ignore) {
          let index2 = this.index(child);
          if (!ignore && index2 === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index2].raws.before;
          }
          return super.removeChild(child);
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }
      };
      Root.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root.registerProcessor = (dependant) => {
        Processor = dependant;
      };
      module2.exports = Root;
      Root.default = Root;
      Container.registerRoot(Root);
    }
  });

  // node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/postcss/lib/list.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var list = {
        comma(string) {
          return list.split(string, [","], true);
        },
        space(string) {
          let spaces = [" ", "\n", "	"];
          return list.split(string, spaces);
        },
        split(string, separators, last) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape2 = false;
          for (let letter of string) {
            if (escape2) {
              escape2 = false;
            } else if (letter === "\\") {
              escape2 = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0)
                func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter))
                split = true;
            }
            if (split) {
              if (current !== "")
                array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last || current !== "")
            array.push(current.trim());
          return array;
        }
      };
      module2.exports = list;
      list.default = list;
    }
  });

  // node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/postcss/lib/rule.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Container = require_container();
      var list = require_list();
      var Rule = class extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = "rule";
          if (!this.nodes)
            this.nodes = [];
        }
        get selectors() {
          return list.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep);
        }
      };
      module2.exports = Rule;
      Rule.default = Rule;
      Container.registerRule(Rule);
    }
  });

  // node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/postcss/lib/parser.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Declaration = require_declaration();
      var tokenizer = require_tokenize();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Root = require_root();
      var Rule = require_rule();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i = tokens.length - 1; i >= 0; i--) {
          let token = tokens[i];
          let pos = token[3] || token[2];
          if (pos)
            return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.customProperty = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token) {
          let node = new AtRule();
          node.name = token[1].slice(1);
          if (node.name === "") {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);
          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node.source.end = this.getPosition(token[2]);
                node.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                    node.source.end.offset++;
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }
          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, "params", params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              node.source.end.offset++;
              this.spaces = node.raws.between;
              node.raws.between = "";
            }
          } else {
            node.raws.afterName = "";
            node.params = "";
          }
          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false)
            return;
          let founded = 0;
          let token;
          for (let j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2)
                break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token[0] === "word" ? token[3] + 1 : token[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let token, type, prev;
          for (let [i, element] of tokens.entries()) {
            token = element;
            type = token[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i;
              }
            }
            prev = token;
          }
          return false;
        }
        comment(token) {
          let node = new Comment();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          let text = token[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node.text = "";
            node.raws.left = text;
            node.raws.right = "";
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        decl(tokens, customProperty) {
          let node = new Declaration();
          this.init(node, tokens[0][2]);
          let last = tokens[tokens.length - 1];
          if (last[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(
            last[3] || last[2] || findLastWithPosition(tokens)
          );
          node.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1)
              this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);
          node.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node.prop += tokens.shift()[1];
          }
          node.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }
          if (node.prop[0] === "_" || node.prop[0] === "*") {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = [];
          let next;
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === "!important") {
              node.important = true;
              let string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== " !important")
                node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache = tokens.slice(0);
              let str = "";
              for (let j = i; j > 0; j--) {
                let type = cache[j][0];
                if (str.trim().indexOf("!") === 0 && type !== "space") {
                  break;
                }
                str = cache.pop()[1] + str;
              }
              if (str.trim().indexOf("!") === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
          if (hasWord) {
            node.raws.between += firstSpaces.map((i) => i[1]).join("");
            firstSpaces = [];
          }
          this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
          if (node.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token) {
          throw this.input.error(
            "Double colon",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
        emptyRule(token) {
          let node = new Rule();
          this.init(node, token[2]);
          node.selector = "";
          node.raws.between = "";
          this.current = node;
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent)
            this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        // Helpers
        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            column: pos.col,
            line: pos.line,
            offset
          };
        }
        init(node, offset) {
          this.current.push(node);
          node.source = {
            input: this.input,
            start: this.getPosition(offset)
          };
          node.raws.before = this.spaces;
          this.spaces = "";
          if (node.type !== "comment")
            this.semicolon = false;
        }
        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);
            if (type === "(" || type === "[") {
              if (!bracket)
                bracket = token;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket)
                bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0)
                bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile())
            end = true;
          if (brackets.length > 0)
            this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== "space" && token !== "comment")
                  break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node, prop, tokens, customProperty) {
          let token, type;
          let length = tokens.length;
          let value = "";
          let clean = true;
          let next, prev;
          for (let i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === "space" && i === length - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
              next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                if (value.slice(-1) === ",") {
                  clean = false;
                } else {
                  value += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i) => all + i[1], "");
            node.raws[prop] = { raw, value };
          }
          node[prop] = value;
        }
        rule(tokens) {
          tokens.pop();
          let node = new Rule();
          this.init(node, tokens[0][2]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, "selector", tokens);
          this.current = node;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        // Errors
        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = "";
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from) {
          let result = "";
          for (let i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token) {
          throw this.input.error(
            "Unexpected }",
            { offset: token[2] },
            { offset: token[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word",
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node, token) {
          throw this.input.error(
            "At-rule without name",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
      };
      module2.exports = Parser;
    }
  });

  // node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/postcss/lib/parse.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Container = require_container();
      var Parser = require_parser();
      var Input = require_input();
      function parse(css, opts) {
        let input = new Input(css, opts);
        let parser = new Parser(input);
        try {
          parser.parse();
        } catch (e) {
          if (true) {
            if (e.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e;
        }
        return parser.root;
      }
      module2.exports = parse;
      parse.default = parse;
      Container.registerParse(parse);
    }
  });

  // node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var { isClean, my } = require_symbols();
      var MapGenerator = require_map_generator();
      var stringify = require_stringify2();
      var Container = require_container();
      var Document = require_document();
      var warnOnce = require_warn_once();
      var Result = require_result();
      var parse = require_parse();
      var Root = require_root();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === "decl") {
          key = node.prop.toLowerCase();
        } else if (node.type === "atrule") {
          key = node.name.toLowerCase();
        }
        if (key && node.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node) {
        let events;
        if (node.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes)
          node.nodes.forEach((i) => cleanMarks(i));
        return node;
      }
      var postcss = {};
      var LazyResult = class _LazyResult {
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;
          let root;
          if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
            root = cleanMarks(css);
          } else if (css instanceof _LazyResult || css instanceof Result) {
            root = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === "undefined")
                opts.map = {};
              if (!opts.map.inline)
                opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser = parse;
            if (opts.syntax)
              parser = opts.syntax.parse;
            if (opts.parser)
              parser = opts.parser;
            if (parser.parse)
              parser = parser.parse;
            try {
              root = parser(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root && !root[my]) {
              Container.rebuild(root);
            }
          }
          this.result = new Result(processor, root, opts);
          this.helpers = { ...postcss, postcss, result: this.result };
          this.plugins = this.processor.plugins.map((plugin) => {
            if (typeof plugin === "object" && plugin.prepare) {
              return { ...plugin, ...plugin.prepare(this.result) };
            } else {
              return plugin;
            }
          });
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          if (this.processed)
            return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node) {
          let plugin = this.result.lastPlugin;
          try {
            if (node)
              node.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin.postcssPlugin;
              error.setMessage();
            } else if (plugin.postcssVersion) {
              if (true) {
                let pluginName = plugin.postcssPlugin;
                let pluginVer = plugin.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a = pluginVer.split(".");
                let b = runtimeVer.split(".");
                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error)
              console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add = (plugin, type, cb) => {
            if (!this.listeners[type])
              this.listeners[type] = [];
            this.listeners[type].push([plugin, cb]);
          };
          for (let plugin of this.plugins) {
            if (typeof plugin === "object") {
              for (let event in plugin) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                    `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin[event] === "object") {
                    for (let filter in plugin[event]) {
                      if (filter === "*") {
                        add(plugin, event, plugin[event][filter]);
                      } else {
                        add(
                          plugin,
                          event + "-" + filter.toLowerCase(),
                          plugin[event][filter]
                        );
                      }
                    }
                  } else if (typeof plugin[event] === "function") {
                    add(plugin, event, plugin[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i = 0; i < this.plugins.length; i++) {
            let plugin = this.plugins[i];
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              let stack = [toStack(root)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e) {
                    let node = stack[stack.length - 1].node;
                    throw this.handleError(e, node);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin;
                try {
                  if (root.type === "document") {
                    let roots = root.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root, this.helpers);
                  }
                } catch (e) {
                  throw this.handleError(e);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin) {
          this.result.lastPlugin = plugin;
          try {
            if (typeof plugin === "object" && plugin.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root) => plugin.Once(root, this.helpers)
                );
                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin.Once(this.result.root, this.helpers);
            } else if (typeof plugin === "function") {
              return plugin(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error)
            throw this.error;
          if (this.stringified)
            return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify;
          if (opts.syntax)
            str = opts.syntax.stringify;
          if (opts.stringifier)
            str = opts.stringifier;
          if (str.stringify)
            str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error)
            throw this.error;
          if (this.processed)
            return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin of this.plugins) {
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              this.walkSync(root);
            }
            if (this.listeners.OnceExit) {
              if (root.type === "document") {
                for (let subRoot of root.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors2, node) {
          for (let [plugin, visitor] of visitors2) {
            this.result.lastPlugin = plugin;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e) {
              throw this.handleError(e, node.proxyOf);
            }
            if (node.type !== "root" && node.type !== "document" && !node.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack) {
          let visit = stack[stack.length - 1];
          let { node, visitors: visitors2 } = visit;
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            stack.pop();
            return;
          }
          if (visitors2.length > 0 && visit.visitorIndex < visitors2.length) {
            let [plugin, visitor] = visitors2[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors2.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e) {
              throw this.handleError(e, node);
            }
          }
          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child;
            while (child = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit.iterator = 0;
            delete node.indexes[iterator];
          }
          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node.nodes) {
                node.each((child) => {
                  if (!child[isClean])
                    this.walkSync(child);
                });
              }
            } else {
              let visitors2 = this.listeners[event];
              if (visitors2) {
                if (this.visitSync(visitors2, node.toProxy()))
                  return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss = dependant;
      };
      module2.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root.registerLazyResult(LazyResult);
      Document.registerLazyResult(LazyResult);
    }
  });

  // node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var MapGenerator = require_map_generator();
      var stringify = require_stringify2();
      var warnOnce = require_warn_once();
      var parse = require_parse();
      var Result = require_result();
      var NoWorkResult = class {
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = void 0;
          let root;
          let str = stringify;
          this.result = new Result(this._processor, root, this._opts);
          this.result.css = css;
          let self2 = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self2.root;
            }
          });
          let map = new MapGenerator(str, root, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          }
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error)
            throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root;
          let parser = parse;
          try {
            root = parser(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root;
            return root;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      module2.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/postcss/lib/processor.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NoWorkResult = require_no_work_result();
      var LazyResult = require_lazy_result();
      var Document = require_document();
      var Root = require_root();
      var Processor = class {
        constructor(plugins = []) {
          this.version = "8.4.31";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i of plugins) {
            if (i.postcss === true) {
              i = i();
            } else if (i.postcss) {
              i = i.postcss;
            }
            if (typeof i === "object" && Array.isArray(i.plugins)) {
              normalized = normalized.concat(i.plugins);
            } else if (typeof i === "object" && i.postcssPlugin) {
              normalized.push(i);
            } else if (typeof i === "function") {
              normalized.push(i);
            } else if (typeof i === "object" && (i.parse || i.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css, opts = {}) {
          if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }
        use(plugin) {
          this.plugins = this.plugins.concat(this.normalize([plugin]));
          return this;
        }
      };
      module2.exports = Processor;
      Processor.default = Processor;
      Root.registerProcessor(Processor);
      Document.registerProcessor(Processor);
    }
  });

  // node_modules/postcss/lib/fromJSON.js
  var require_fromJSON = __commonJS({
    "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var Declaration = require_declaration();
      var PreviousMap = require_previous_map();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Input = require_input();
      var Root = require_root();
      var Rule = require_rule();
      function fromJSON(json, inputs) {
        if (Array.isArray(json))
          return json.map((n) => fromJSON(n));
        let { inputs: ownInputs, ...defaults } = json;
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = { ...input, __proto__: Input.prototype };
            if (inputHydrated.map) {
              inputHydrated.map = {
                ...inputHydrated.map,
                __proto__: PreviousMap.prototype
              };
            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults.nodes) {
          defaults.nodes = json.nodes.map((n) => fromJSON(n, inputs));
        }
        if (defaults.source) {
          let { inputId, ...source } = defaults.source;
          defaults.source = source;
          if (inputId != null) {
            defaults.source.input = inputs[inputId];
          }
        }
        if (defaults.type === "root") {
          return new Root(defaults);
        } else if (defaults.type === "decl") {
          return new Declaration(defaults);
        } else if (defaults.type === "rule") {
          return new Rule(defaults);
        } else if (defaults.type === "comment") {
          return new Comment(defaults);
        } else if (defaults.type === "atrule") {
          return new AtRule(defaults);
        } else {
          throw new Error("Unknown node type: " + json.type);
        }
      }
      module2.exports = fromJSON;
      fromJSON.default = fromJSON;
    }
  });

  // node_modules/postcss/lib/postcss.js
  var require_postcss = __commonJS({
    "node_modules/postcss/lib/postcss.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var CssSyntaxError = require_css_syntax_error();
      var Declaration = require_declaration();
      var LazyResult = require_lazy_result();
      var Container = require_container();
      var Processor = require_processor();
      var stringify = require_stringify2();
      var fromJSON = require_fromJSON();
      var Document = require_document();
      var Warning = require_warning();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Result = require_result();
      var Input = require_input();
      var parse = require_parse();
      var list = require_list();
      var Rule = require_rule();
      var Root = require_root();
      var Node2 = require_node2();
      function postcss(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor(plugins);
      }
      postcss.plugin = function plugin(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            console.warn(
              name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
            );
            if (process.env.LANG && process.env.LANG.startsWith("cn")) {
              console.warn(
                name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
              );
            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor().version;
          return transformer;
        }
        let cache;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache)
              cache = creator();
            return cache;
          }
        });
        creator.process = function(css, processOpts, pluginOpts) {
          return postcss([creator(pluginOpts)]).process(css, processOpts);
        };
        return creator;
      };
      postcss.stringify = stringify;
      postcss.parse = parse;
      postcss.fromJSON = fromJSON;
      postcss.list = list;
      postcss.comment = (defaults) => new Comment(defaults);
      postcss.atRule = (defaults) => new AtRule(defaults);
      postcss.decl = (defaults) => new Declaration(defaults);
      postcss.rule = (defaults) => new Rule(defaults);
      postcss.root = (defaults) => new Root(defaults);
      postcss.document = (defaults) => new Document(defaults);
      postcss.CssSyntaxError = CssSyntaxError;
      postcss.Declaration = Declaration;
      postcss.Container = Container;
      postcss.Processor = Processor;
      postcss.Document = Document;
      postcss.Comment = Comment;
      postcss.Warning = Warning;
      postcss.AtRule = AtRule;
      postcss.Result = Result;
      postcss.Input = Input;
      postcss.Rule = Rule;
      postcss.Root = Root;
      postcss.Node = Node2;
      LazyResult.registerPostcss(postcss);
      module2.exports = postcss;
      postcss.default = postcss;
    }
  });

  // node_modules/sanitize-html/index.js
  var require_sanitize_html = __commonJS({
    "node_modules/sanitize-html/index.js"(exports2, module2) {
      init_polyfills();
      var htmlparser = require_lib6();
      var escapeStringRegexp = require_escape_string_regexp();
      var { isPlainObject } = require_is_plain_object();
      var deepmerge = require_cjs2();
      var parseSrcset = require_parse_srcset();
      var { parse: postcssParse } = require_postcss();
      var mediaTags = [
        "img",
        "audio",
        "video",
        "picture",
        "svg",
        "object",
        "map",
        "iframe",
        "embed"
      ];
      var vulnerableTags = ["script", "style"];
      function each(obj, cb) {
        if (obj) {
          Object.keys(obj).forEach(function(key) {
            cb(obj[key], key);
          });
        }
      }
      function has(obj, key) {
        return {}.hasOwnProperty.call(obj, key);
      }
      function filter(a, cb) {
        const n = [];
        each(a, function(v) {
          if (cb(v)) {
            n.push(v);
          }
        });
        return n;
      }
      function isEmptyObject(obj) {
        for (const key in obj) {
          if (has(obj, key)) {
            return false;
          }
        }
        return true;
      }
      function stringifySrcset(parsedSrcset) {
        return parsedSrcset.map(function(part) {
          if (!part.url) {
            throw new Error("URL missing");
          }
          return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
        }).join(", ");
      }
      module2.exports = sanitizeHtml;
      var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
      function sanitizeHtml(html, options, _recursing) {
        if (html == null) {
          return "";
        }
        if (typeof html === "number") {
          html = html.toString();
        }
        let result = "";
        let tempResult = "";
        function Frame(tag, attribs) {
          const that = this;
          this.tag = tag;
          this.attribs = attribs || {};
          this.tagPosition = result.length;
          this.text = "";
          this.mediaChildren = [];
          this.updateParentNodeText = function() {
            if (stack.length) {
              const parentFrame = stack[stack.length - 1];
              parentFrame.text += that.text;
            }
          };
          this.updateParentNodeMediaChildren = function() {
            if (stack.length && mediaTags.includes(this.tag)) {
              const parentFrame = stack[stack.length - 1];
              parentFrame.mediaChildren.push(this.tag);
            }
          };
        }
        options = Object.assign({}, sanitizeHtml.defaults, options);
        options.parser = Object.assign({}, htmlParserDefaults, options.parser);
        const tagAllowed = function(name) {
          return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
        };
        vulnerableTags.forEach(function(tag) {
          if (tagAllowed(tag) && !options.allowVulnerableTags) {
            console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
          }
        });
        const nonTextTagsArray = options.nonTextTags || [
          "script",
          "style",
          "textarea",
          "option"
        ];
        let allowedAttributesMap;
        let allowedAttributesGlobMap;
        if (options.allowedAttributes) {
          allowedAttributesMap = {};
          allowedAttributesGlobMap = {};
          each(options.allowedAttributes, function(attributes, tag) {
            allowedAttributesMap[tag] = [];
            const globRegex = [];
            attributes.forEach(function(obj) {
              if (typeof obj === "string" && obj.indexOf("*") >= 0) {
                globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
              } else {
                allowedAttributesMap[tag].push(obj);
              }
            });
            if (globRegex.length) {
              allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
            }
          });
        }
        const allowedClassesMap = {};
        const allowedClassesGlobMap = {};
        const allowedClassesRegexMap = {};
        each(options.allowedClasses, function(classes2, tag) {
          if (allowedAttributesMap) {
            if (!has(allowedAttributesMap, tag)) {
              allowedAttributesMap[tag] = [];
            }
            allowedAttributesMap[tag].push("class");
          }
          allowedClassesMap[tag] = classes2;
          if (Array.isArray(classes2)) {
            const globRegex = [];
            allowedClassesMap[tag] = [];
            allowedClassesRegexMap[tag] = [];
            classes2.forEach(function(obj) {
              if (typeof obj === "string" && obj.indexOf("*") >= 0) {
                globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
              } else if (obj instanceof RegExp) {
                allowedClassesRegexMap[tag].push(obj);
              } else {
                allowedClassesMap[tag].push(obj);
              }
            });
            if (globRegex.length) {
              allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
            }
          }
        });
        const transformTagsMap = {};
        let transformTagsAll;
        each(options.transformTags, function(transform, tag) {
          let transFun;
          if (typeof transform === "function") {
            transFun = transform;
          } else if (typeof transform === "string") {
            transFun = sanitizeHtml.simpleTransform(transform);
          }
          if (tag === "*") {
            transformTagsAll = transFun;
          } else {
            transformTagsMap[tag] = transFun;
          }
        });
        let depth;
        let stack;
        let skipMap;
        let transformMap;
        let skipText;
        let skipTextDepth;
        let addedText = false;
        initializeState();
        const parser = new htmlparser.Parser({
          onopentag: function(name, attribs) {
            if (options.enforceHtmlBoundary && name === "html") {
              initializeState();
            }
            if (skipText) {
              skipTextDepth++;
              return;
            }
            const frame = new Frame(name, attribs);
            stack.push(frame);
            let skip = false;
            const hasText = !!frame.text;
            let transformedTag;
            if (has(transformTagsMap, name)) {
              transformedTag = transformTagsMap[name](name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (transformedTag.text !== void 0) {
                frame.innerText = transformedTag.text;
              }
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (transformTagsAll) {
              transformedTag = transformTagsAll(name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (!tagAllowed(name) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
              skip = true;
              skipMap[depth] = true;
              if (options.disallowedTagsMode === "discard") {
                if (nonTextTagsArray.indexOf(name) !== -1) {
                  skipText = true;
                  skipTextDepth = 1;
                }
              }
              skipMap[depth] = true;
            }
            depth++;
            if (skip) {
              if (options.disallowedTagsMode === "discard") {
                return;
              }
              tempResult = result;
              result = "";
            }
            result += "<" + name;
            if (name === "script") {
              if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                frame.innerText = "";
              }
            }
            if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
              each(attribs, function(value, a) {
                if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
                  delete frame.attribs[a];
                  return;
                }
                if (value === "" && (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes("*"))) {
                  delete frame.attribs[a];
                  return;
                }
                let passedAllowedAttributesMapCheck = false;
                if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
                  passedAllowedAttributesMapCheck = true;
                } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                  for (const o of allowedAttributesMap[name]) {
                    if (isPlainObject(o) && o.name && o.name === a) {
                      passedAllowedAttributesMapCheck = true;
                      let newValue = "";
                      if (o.multiple === true) {
                        const splitStrArray = value.split(" ");
                        for (const s of splitStrArray) {
                          if (o.values.indexOf(s) !== -1) {
                            if (newValue === "") {
                              newValue = s;
                            } else {
                              newValue += " " + s;
                            }
                          }
                        }
                      } else if (o.values.indexOf(value) >= 0) {
                        newValue = value;
                      }
                      value = newValue;
                    }
                  }
                }
                if (passedAllowedAttributesMapCheck) {
                  if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                    if (naughtyHref(name, value)) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (name === "script" && a === "src") {
                    let allowed = true;
                    try {
                      const parsed = parseUrl(value);
                      if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                        const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                          return hostname === parsed.url.hostname;
                        });
                        const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                          return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                        });
                        allowed = allowedHostname || allowedDomain;
                      }
                    } catch (e) {
                      allowed = false;
                    }
                    if (!allowed) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (name === "iframe" && a === "src") {
                    let allowed = true;
                    try {
                      const parsed = parseUrl(value);
                      if (parsed.isRelativeUrl) {
                        allowed = has(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                      } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                        const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                          return hostname === parsed.url.hostname;
                        });
                        const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                          return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                        });
                        allowed = allowedHostname || allowedDomain;
                      }
                    } catch (e) {
                      allowed = false;
                    }
                    if (!allowed) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "srcset") {
                    try {
                      let parsed = parseSrcset(value);
                      parsed.forEach(function(value2) {
                        if (naughtyHref("srcset", value2.url)) {
                          value2.evil = true;
                        }
                      });
                      parsed = filter(parsed, function(v) {
                        return !v.evil;
                      });
                      if (!parsed.length) {
                        delete frame.attribs[a];
                        return;
                      } else {
                        value = stringifySrcset(filter(parsed, function(v) {
                          return !v.evil;
                        }));
                        frame.attribs[a] = value;
                      }
                    } catch (e) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "class") {
                    const allowedSpecificClasses = allowedClassesMap[name];
                    const allowedWildcardClasses = allowedClassesMap["*"];
                    const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                    const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                    const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                    const allowedClassesGlobs = [
                      allowedSpecificClassesGlob,
                      allowedWildcardClassesGlob
                    ].concat(allowedSpecificClassesRegex).filter(function(t) {
                      return t;
                    });
                    if (allowedSpecificClasses && allowedWildcardClasses) {
                      value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                    } else {
                      value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                    }
                    if (!value.length) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "style") {
                    if (options.parseStyleAttributes) {
                      try {
                        const abstractSyntaxTree = postcssParse(name + " {" + value + "}");
                        const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                        value = stringifyStyleAttributes(filteredAST);
                        if (value.length === 0) {
                          delete frame.attribs[a];
                          return;
                        }
                      } catch (e) {
                        if (typeof window !== "undefined") {
                          console.warn('Failed to parse "' + name + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                        }
                        delete frame.attribs[a];
                        return;
                      }
                    } else if (options.allowedStyles) {
                      throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                    }
                  }
                  result += " " + a;
                  if (value && value.length) {
                    result += '="' + escapeHtml(value, true) + '"';
                  }
                } else {
                  delete frame.attribs[a];
                }
              });
            }
            if (options.selfClosing.indexOf(name) !== -1) {
              result += " />";
            } else {
              result += ">";
              if (frame.innerText && !hasText && !options.textFilter) {
                result += escapeHtml(frame.innerText);
                addedText = true;
              }
            }
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
          },
          ontext: function(text) {
            if (skipText) {
              return;
            }
            const lastFrame = stack[stack.length - 1];
            let tag;
            if (lastFrame) {
              tag = lastFrame.tag;
              text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
            }
            if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
              result += text;
            } else {
              const escaped = escapeHtml(text, false);
              if (options.textFilter && !addedText) {
                result += options.textFilter(escaped, tag);
              } else if (!addedText) {
                result += escaped;
              }
            }
            if (stack.length) {
              const frame = stack[stack.length - 1];
              frame.text += text;
            }
          },
          onclosetag: function(name, isImplied) {
            if (skipText) {
              skipTextDepth--;
              if (!skipTextDepth) {
                skipText = false;
              } else {
                return;
              }
            }
            const frame = stack.pop();
            if (!frame) {
              return;
            }
            if (frame.tag !== name) {
              stack.push(frame);
              return;
            }
            skipText = options.enforceHtmlBoundary ? name === "html" : false;
            depth--;
            const skip = skipMap[depth];
            if (skip) {
              delete skipMap[depth];
              if (options.disallowedTagsMode === "discard") {
                frame.updateParentNodeText();
                return;
              }
              tempResult = result;
              result = "";
            }
            if (transformMap[depth]) {
              name = transformMap[depth];
              delete transformMap[depth];
            }
            if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
              result = result.substr(0, frame.tagPosition);
              return;
            }
            frame.updateParentNodeMediaChildren();
            frame.updateParentNodeText();
            if (
              // Already output />
              options.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied
              isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0
            ) {
              if (skip) {
                result = tempResult;
                tempResult = "";
              }
              return;
            }
            result += "</" + name + ">";
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
            addedText = false;
          }
        }, options.parser);
        parser.write(html);
        parser.end();
        return result;
        function initializeState() {
          result = "";
          depth = 0;
          stack = [];
          skipMap = {};
          transformMap = {};
          skipText = false;
          skipTextDepth = 0;
        }
        function escapeHtml(s, quote) {
          if (typeof s !== "string") {
            s = s + "";
          }
          if (options.parser.decodeEntities) {
            s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            if (quote) {
              s = s.replace(/"/g, "&quot;");
            }
          }
          s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s = s.replace(/"/g, "&quot;");
          }
          return s;
        }
        function naughtyHref(name, href) {
          href = href.replace(/[\x00-\x20]+/g, "");
          while (true) {
            const firstIndex = href.indexOf("<!--");
            if (firstIndex === -1) {
              break;
            }
            const lastIndex = href.indexOf("-->", firstIndex + 4);
            if (lastIndex === -1) {
              break;
            }
            href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
          }
          const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
          if (!matches) {
            if (href.match(/^[/\\]{2}/)) {
              return !options.allowProtocolRelative;
            }
            return false;
          }
          const scheme = matches[1].toLowerCase();
          if (has(options.allowedSchemesByTag, name)) {
            return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
          }
          return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
        }
        function parseUrl(value) {
          value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
          if (value.startsWith("relative:")) {
            throw new Error("relative: exploit attempt");
          }
          let base = "relative://relative-site";
          for (let i = 0; i < 100; i++) {
            base += `/${i}`;
          }
          const parsed = new URL(value, base);
          const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
          return {
            isRelativeUrl,
            url: parsed
          };
        }
        function filterCss(abstractSyntaxTree, allowedStyles) {
          if (!allowedStyles) {
            return abstractSyntaxTree;
          }
          const astRules = abstractSyntaxTree.nodes[0];
          let selectedRule;
          if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
            selectedRule = deepmerge(
              allowedStyles[astRules.selector],
              allowedStyles["*"]
            );
          } else {
            selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
          }
          if (selectedRule) {
            abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
          }
          return abstractSyntaxTree;
        }
        function stringifyStyleAttributes(filteredAST) {
          return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
            extractedAttributes.push(
              `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
            );
            return extractedAttributes;
          }, []).join(";");
        }
        function filterDeclarations(selectedRule) {
          return function(allowedDeclarationsList, attributeObject) {
            if (has(selectedRule, attributeObject.prop)) {
              const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
                return regularExpression.test(attributeObject.value);
              });
              if (matchesRegex) {
                allowedDeclarationsList.push(attributeObject);
              }
            }
            return allowedDeclarationsList;
          };
        }
        function filterClasses(classes2, allowed, allowedGlobs) {
          if (!allowed) {
            return classes2;
          }
          classes2 = classes2.split(/\s+/);
          return classes2.filter(function(clss) {
            return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
              return glob.test(clss);
            });
          }).join(" ");
        }
      }
      var htmlParserDefaults = {
        decodeEntities: true
      };
      sanitizeHtml.defaults = {
        allowedTags: [
          // Sections derived from MDN element categories and limited to the more
          // benign categories.
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
          // Content sectioning
          "address",
          "article",
          "aside",
          "footer",
          "header",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hgroup",
          "main",
          "nav",
          "section",
          // Text content
          "blockquote",
          "dd",
          "div",
          "dl",
          "dt",
          "figcaption",
          "figure",
          "hr",
          "li",
          "main",
          "ol",
          "p",
          "pre",
          "ul",
          // Inline text semantics
          "a",
          "abbr",
          "b",
          "bdi",
          "bdo",
          "br",
          "cite",
          "code",
          "data",
          "dfn",
          "em",
          "i",
          "kbd",
          "mark",
          "q",
          "rb",
          "rp",
          "rt",
          "rtc",
          "ruby",
          "s",
          "samp",
          "small",
          "span",
          "strong",
          "sub",
          "sup",
          "time",
          "u",
          "var",
          "wbr",
          // Table content
          "caption",
          "col",
          "colgroup",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr"
        ],
        // Tags that cannot be boolean
        nonBooleanAttributes: [
          "abbr",
          "accept",
          "accept-charset",
          "accesskey",
          "action",
          "allow",
          "alt",
          "as",
          "autocapitalize",
          "autocomplete",
          "blocking",
          "charset",
          "cite",
          "class",
          "color",
          "cols",
          "colspan",
          "content",
          "contenteditable",
          "coords",
          "crossorigin",
          "data",
          "datetime",
          "decoding",
          "dir",
          "dirname",
          "download",
          "draggable",
          "enctype",
          "enterkeyhint",
          "fetchpriority",
          "for",
          "form",
          "formaction",
          "formenctype",
          "formmethod",
          "formtarget",
          "headers",
          "height",
          "hidden",
          "high",
          "href",
          "hreflang",
          "http-equiv",
          "id",
          "imagesizes",
          "imagesrcset",
          "inputmode",
          "integrity",
          "is",
          "itemid",
          "itemprop",
          "itemref",
          "itemtype",
          "kind",
          "label",
          "lang",
          "list",
          "loading",
          "low",
          "max",
          "maxlength",
          "media",
          "method",
          "min",
          "minlength",
          "name",
          "nonce",
          "optimum",
          "pattern",
          "ping",
          "placeholder",
          "popover",
          "popovertarget",
          "popovertargetaction",
          "poster",
          "preload",
          "referrerpolicy",
          "rel",
          "rows",
          "rowspan",
          "sandbox",
          "scope",
          "shape",
          "size",
          "sizes",
          "slot",
          "span",
          "spellcheck",
          "src",
          "srcdoc",
          "srclang",
          "srcset",
          "start",
          "step",
          "style",
          "tabindex",
          "target",
          "title",
          "translate",
          "type",
          "usemap",
          "value",
          "width",
          "wrap",
          // Event handlers
          "onauxclick",
          "onafterprint",
          "onbeforematch",
          "onbeforeprint",
          "onbeforeunload",
          "onbeforetoggle",
          "onblur",
          "oncancel",
          "oncanplay",
          "oncanplaythrough",
          "onchange",
          "onclick",
          "onclose",
          "oncontextlost",
          "oncontextmenu",
          "oncontextrestored",
          "oncopy",
          "oncuechange",
          "oncut",
          "ondblclick",
          "ondrag",
          "ondragend",
          "ondragenter",
          "ondragleave",
          "ondragover",
          "ondragstart",
          "ondrop",
          "ondurationchange",
          "onemptied",
          "onended",
          "onerror",
          "onfocus",
          "onformdata",
          "onhashchange",
          "oninput",
          "oninvalid",
          "onkeydown",
          "onkeypress",
          "onkeyup",
          "onlanguagechange",
          "onload",
          "onloadeddata",
          "onloadedmetadata",
          "onloadstart",
          "onmessage",
          "onmessageerror",
          "onmousedown",
          "onmouseenter",
          "onmouseleave",
          "onmousemove",
          "onmouseout",
          "onmouseover",
          "onmouseup",
          "onoffline",
          "ononline",
          "onpagehide",
          "onpageshow",
          "onpaste",
          "onpause",
          "onplay",
          "onplaying",
          "onpopstate",
          "onprogress",
          "onratechange",
          "onreset",
          "onresize",
          "onrejectionhandled",
          "onscroll",
          "onscrollend",
          "onsecuritypolicyviolation",
          "onseeked",
          "onseeking",
          "onselect",
          "onslotchange",
          "onstalled",
          "onstorage",
          "onsubmit",
          "onsuspend",
          "ontimeupdate",
          "ontoggle",
          "onunhandledrejection",
          "onunload",
          "onvolumechange",
          "onwaiting",
          "onwheel"
        ],
        disallowedTagsMode: "discard",
        allowedAttributes: {
          a: ["href", "name", "target"],
          // We don't currently allow img itself by default, but
          // these attributes would make sense if we did.
          img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
        },
        // Lots of these won't come up by default because we don't allow them
        selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
        // URL schemes we permit
        allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
        allowedSchemesByTag: {},
        allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
        allowProtocolRelative: true,
        enforceHtmlBoundary: false,
        parseStyleAttributes: true
      };
      sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
        merge = merge === void 0 ? true : merge;
        newAttribs = newAttribs || {};
        return function(tagName2, attribs) {
          let attrib;
          if (merge) {
            for (attrib in newAttribs) {
              attribs[attrib] = newAttribs[attrib];
            }
          } else {
            attribs = newAttribs;
          }
          return {
            tagName: newTagName,
            attribs
          };
        };
      };
    }
  });

  // node_modules/loglevel/lib/loglevel.js
  var require_loglevel = __commonJS({
    "node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
      init_polyfills();
      (function(root, definition) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(definition);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = definition();
        } else {
          root.log = definition();
        }
      })(exports2, function() {
        "use strict";
        var noop = function() {
        };
        var undefinedType = "undefined";
        var isIE2 = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
        var logMethods = [
          "trace",
          "debug",
          "info",
          "warn",
          "error"
        ];
        function bindMethod(obj, methodName) {
          var method = obj[methodName];
          if (typeof method.bind === "function") {
            return method.bind(obj);
          } else {
            try {
              return Function.prototype.bind.call(method, obj);
            } catch (e) {
              return function() {
                return Function.prototype.apply.apply(method, [obj, arguments]);
              };
            }
          }
        }
        function traceForIE() {
          if (console.log) {
            if (console.log.apply) {
              console.log.apply(console, arguments);
            } else {
              Function.prototype.apply.apply(console.log, [console, arguments]);
            }
          }
          if (console.trace)
            console.trace();
        }
        function realMethod(methodName) {
          if (methodName === "debug") {
            methodName = "log";
          }
          if (typeof console === undefinedType) {
            return false;
          } else if (methodName === "trace" && isIE2) {
            return traceForIE;
          } else if (console[methodName] !== void 0) {
            return bindMethod(console, methodName);
          } else if (console.log !== void 0) {
            return bindMethod(console, "log");
          } else {
            return noop;
          }
        }
        function replaceLoggingMethods(level, loggerName) {
          for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
          }
          this.log = this.debug;
        }
        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
          return function() {
            if (typeof console !== undefinedType) {
              replaceLoggingMethods.call(this, level, loggerName);
              this[methodName].apply(this, arguments);
            }
          };
        }
        function defaultMethodFactory(methodName, level, loggerName) {
          return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
        }
        function Logger(name, defaultLevel, factory) {
          var self2 = this;
          var currentLevel;
          defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
          var storageKey = "loglevel";
          if (typeof name === "string") {
            storageKey += ":" + name;
          } else if (typeof name === "symbol") {
            storageKey = void 0;
          }
          function persistLevelIfPossible(levelNum) {
            var levelName = (logMethods[levelNum] || "silent").toUpperCase();
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage[storageKey] = levelName;
              return;
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
            } catch (ignore) {
            }
          }
          function getPersistedLevel() {
            var storedLevel;
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              storedLevel = window.localStorage[storageKey];
            } catch (ignore) {
            }
            if (typeof storedLevel === undefinedType) {
              try {
                var cookie = window.document.cookie;
                var location = cookie.indexOf(
                  encodeURIComponent(storageKey) + "="
                );
                if (location !== -1) {
                  storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                }
              } catch (ignore) {
              }
            }
            if (self2.levels[storedLevel] === void 0) {
              storedLevel = void 0;
            }
            return storedLevel;
          }
          function clearPersistedLevel() {
            if (typeof window === undefinedType || !storageKey)
              return;
            try {
              window.localStorage.removeItem(storageKey);
              return;
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (ignore) {
            }
          }
          self2.name = name;
          self2.levels = {
            "TRACE": 0,
            "DEBUG": 1,
            "INFO": 2,
            "WARN": 3,
            "ERROR": 4,
            "SILENT": 5
          };
          self2.methodFactory = factory || defaultMethodFactory;
          self2.getLevel = function() {
            return currentLevel;
          };
          self2.setLevel = function(level, persist) {
            if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
              level = self2.levels[level.toUpperCase()];
            }
            if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {
                persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self2, level, name);
              if (typeof console === undefinedType && level < self2.levels.SILENT) {
                return "No console available for logging";
              }
            } else {
              throw "log.setLevel() called with invalid level: " + level;
            }
          };
          self2.setDefaultLevel = function(level) {
            defaultLevel = level;
            if (!getPersistedLevel()) {
              self2.setLevel(level, false);
            }
          };
          self2.resetLevel = function() {
            self2.setLevel(defaultLevel, false);
            clearPersistedLevel();
          };
          self2.enableAll = function(persist) {
            self2.setLevel(self2.levels.TRACE, persist);
          };
          self2.disableAll = function(persist) {
            self2.setLevel(self2.levels.SILENT, persist);
          };
          var initialLevel = getPersistedLevel();
          if (initialLevel == null) {
            initialLevel = defaultLevel;
          }
          self2.setLevel(initialLevel, false);
        }
        var defaultLogger = new Logger();
        var _loggersByName = {};
        defaultLogger.getLogger = function getLogger(name) {
          if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
          }
          var logger = _loggersByName[name];
          if (!logger) {
            logger = _loggersByName[name] = new Logger(
              name,
              defaultLogger.getLevel(),
              defaultLogger.methodFactory
            );
          }
          return logger;
        };
        var _log = typeof window !== undefinedType ? window.log : void 0;
        defaultLogger.noConflict = function() {
          if (typeof window !== undefinedType && window.log === defaultLogger) {
            window.log = _log;
          }
          return defaultLogger;
        };
        defaultLogger.getLoggers = function getLoggers() {
          return _loggersByName;
        };
        defaultLogger["default"] = defaultLogger;
        return defaultLogger;
      });
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports2, module2) {
      init_polyfills();
      function debounce8(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (null == wait)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        ;
        var debounced = function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      debounce8.debounce = debounce8;
      module2.exports = debounce8;
    }
  });

  // node_modules/cssesc/cssesc.js
  var require_cssesc = __commonJS({
    "node_modules/cssesc/cssesc.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge2(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        for (var key in defaults) {
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
        }
        return result;
      };
      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
      var cssesc2 = function cssesc3(string, options) {
        options = merge(options, cssesc3.options);
        if (options.quotes != "single" && options.quotes != "double") {
          options.quotes = "single";
        }
        var quote = options.quotes == "double" ? '"' : "'";
        var isIdentifier = options.isIdentifier;
        var firstChar = string.charAt(0);
        var output = "";
        var counter2 = 0;
        var length = string.length;
        while (counter2 < length) {
          var character = string.charAt(counter2++);
          var codePoint = character.charCodeAt();
          var value = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter2 < length) {
              var extra = string.charCodeAt(counter2++);
              if ((extra & 64512) == 56320) {
                codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
              } else {
                counter2--;
              }
            }
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value = "\\" + character;
              } else {
                value = "\\" + codePoint.toString(16).toUpperCase() + " ";
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = character;
            }
          }
          output += value;
        }
        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = "\\-" + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = "\\3" + firstChar + " " + output.slice(1);
          }
        }
        output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
          if ($1 && $1.length % 2) {
            return $0;
          }
          return ($1 || "") + $2;
        });
        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };
      cssesc2.options = {
        "escapeEverything": false,
        "isIdentifier": false,
        "quotes": "single",
        "wrap": false
      };
      cssesc2.version = "3.0.0";
      module2.exports = cssesc2;
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports2, module2) {
      init_polyfills();
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar2 = RegExp(reRegExpChar2.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index2 = -1, length = values.length, offset = array.length;
          while (++index2 < length) {
            array[offset + index2] = values[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (comparator(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length = array.length;
          while (++index2 < length) {
            var current = iteratee(array[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index2 = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index2 = -1, length = array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index2 = string.length;
          while (index2-- && reWhitespace.test(string.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash4(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash4.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash4
            }
          };
          lodash4.prototype = baseLodash.prototype;
          lodash4.prototype.constructor = lodash4;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined2 : get(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length = array.length;
            while (++index2 < length) {
              var value = array[index2], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index2 = 0, length = path.length;
            while (object != null && index2 < length) {
              object = object[toKey(path[index2++])];
            }
            return index2 && index2 == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path = paths[index2], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey(path[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index2 = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length = source.length;
            array || (array = Array2(length));
            while (++index2 < length) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash4, "placeholder") ? lodash4 : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash4.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index2 = -1, length = path.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
              return eq(object[index2], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash4[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index2 < length) {
                array[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index2 = indexes[length];
              array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index2 = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex), value = array[rand];
              array[rand] = array[index2];
              array[index2] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat2() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array, value, index2);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value);
              if (index2 < length && eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array, baseProperty(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash4(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce8(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay2 = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce8(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep2(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit3 = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index2 = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index2 < length) {
              var value = object == null ? undefined2 : object[toKey(path[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random2(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString2(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape2(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp2(string) {
            string = toString2(string);
            return string && reHasRegExpChar2.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString2(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString2(string), n);
          }
          function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString2(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash4.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString2(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString2(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString2(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id2 = ++idCounter;
            return toString2(prefix) + id2;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash4.after = after;
          lodash4.ary = ary;
          lodash4.assign = assign;
          lodash4.assignIn = assignIn;
          lodash4.assignInWith = assignInWith;
          lodash4.assignWith = assignWith;
          lodash4.at = at;
          lodash4.before = before;
          lodash4.bind = bind;
          lodash4.bindAll = bindAll;
          lodash4.bindKey = bindKey;
          lodash4.castArray = castArray;
          lodash4.chain = chain;
          lodash4.chunk = chunk;
          lodash4.compact = compact;
          lodash4.concat = concat2;
          lodash4.cond = cond;
          lodash4.conforms = conforms;
          lodash4.constant = constant;
          lodash4.countBy = countBy;
          lodash4.create = create;
          lodash4.curry = curry;
          lodash4.curryRight = curryRight;
          lodash4.debounce = debounce8;
          lodash4.defaults = defaults;
          lodash4.defaultsDeep = defaultsDeep;
          lodash4.defer = defer;
          lodash4.delay = delay2;
          lodash4.difference = difference;
          lodash4.differenceBy = differenceBy;
          lodash4.differenceWith = differenceWith;
          lodash4.drop = drop;
          lodash4.dropRight = dropRight;
          lodash4.dropRightWhile = dropRightWhile;
          lodash4.dropWhile = dropWhile;
          lodash4.fill = fill;
          lodash4.filter = filter;
          lodash4.flatMap = flatMap;
          lodash4.flatMapDeep = flatMapDeep;
          lodash4.flatMapDepth = flatMapDepth;
          lodash4.flatten = flatten;
          lodash4.flattenDeep = flattenDeep;
          lodash4.flattenDepth = flattenDepth;
          lodash4.flip = flip;
          lodash4.flow = flow;
          lodash4.flowRight = flowRight;
          lodash4.fromPairs = fromPairs;
          lodash4.functions = functions;
          lodash4.functionsIn = functionsIn;
          lodash4.groupBy = groupBy;
          lodash4.initial = initial;
          lodash4.intersection = intersection;
          lodash4.intersectionBy = intersectionBy;
          lodash4.intersectionWith = intersectionWith;
          lodash4.invert = invert;
          lodash4.invertBy = invertBy;
          lodash4.invokeMap = invokeMap;
          lodash4.iteratee = iteratee;
          lodash4.keyBy = keyBy;
          lodash4.keys = keys;
          lodash4.keysIn = keysIn;
          lodash4.map = map;
          lodash4.mapKeys = mapKeys;
          lodash4.mapValues = mapValues;
          lodash4.matches = matches;
          lodash4.matchesProperty = matchesProperty;
          lodash4.memoize = memoize;
          lodash4.merge = merge;
          lodash4.mergeWith = mergeWith;
          lodash4.method = method;
          lodash4.methodOf = methodOf;
          lodash4.mixin = mixin;
          lodash4.negate = negate;
          lodash4.nthArg = nthArg;
          lodash4.omit = omit3;
          lodash4.omitBy = omitBy;
          lodash4.once = once;
          lodash4.orderBy = orderBy;
          lodash4.over = over;
          lodash4.overArgs = overArgs;
          lodash4.overEvery = overEvery;
          lodash4.overSome = overSome;
          lodash4.partial = partial;
          lodash4.partialRight = partialRight;
          lodash4.partition = partition;
          lodash4.pick = pick;
          lodash4.pickBy = pickBy;
          lodash4.property = property;
          lodash4.propertyOf = propertyOf;
          lodash4.pull = pull;
          lodash4.pullAll = pullAll;
          lodash4.pullAllBy = pullAllBy;
          lodash4.pullAllWith = pullAllWith;
          lodash4.pullAt = pullAt;
          lodash4.range = range;
          lodash4.rangeRight = rangeRight;
          lodash4.rearg = rearg;
          lodash4.reject = reject;
          lodash4.remove = remove;
          lodash4.rest = rest;
          lodash4.reverse = reverse;
          lodash4.sampleSize = sampleSize;
          lodash4.set = set;
          lodash4.setWith = setWith;
          lodash4.shuffle = shuffle;
          lodash4.slice = slice;
          lodash4.sortBy = sortBy;
          lodash4.sortedUniq = sortedUniq;
          lodash4.sortedUniqBy = sortedUniqBy;
          lodash4.split = split;
          lodash4.spread = spread;
          lodash4.tail = tail;
          lodash4.take = take;
          lodash4.takeRight = takeRight;
          lodash4.takeRightWhile = takeRightWhile;
          lodash4.takeWhile = takeWhile;
          lodash4.tap = tap;
          lodash4.throttle = throttle;
          lodash4.thru = thru;
          lodash4.toArray = toArray;
          lodash4.toPairs = toPairs;
          lodash4.toPairsIn = toPairsIn;
          lodash4.toPath = toPath;
          lodash4.toPlainObject = toPlainObject;
          lodash4.transform = transform;
          lodash4.unary = unary;
          lodash4.union = union;
          lodash4.unionBy = unionBy;
          lodash4.unionWith = unionWith;
          lodash4.uniq = uniq;
          lodash4.uniqBy = uniqBy;
          lodash4.uniqWith = uniqWith;
          lodash4.unset = unset;
          lodash4.unzip = unzip;
          lodash4.unzipWith = unzipWith;
          lodash4.update = update;
          lodash4.updateWith = updateWith;
          lodash4.values = values;
          lodash4.valuesIn = valuesIn;
          lodash4.without = without;
          lodash4.words = words;
          lodash4.wrap = wrap;
          lodash4.xor = xor;
          lodash4.xorBy = xorBy;
          lodash4.xorWith = xorWith;
          lodash4.zip = zip;
          lodash4.zipObject = zipObject;
          lodash4.zipObjectDeep = zipObjectDeep;
          lodash4.zipWith = zipWith;
          lodash4.entries = toPairs;
          lodash4.entriesIn = toPairsIn;
          lodash4.extend = assignIn;
          lodash4.extendWith = assignInWith;
          mixin(lodash4, lodash4);
          lodash4.add = add;
          lodash4.attempt = attempt;
          lodash4.camelCase = camelCase;
          lodash4.capitalize = capitalize;
          lodash4.ceil = ceil;
          lodash4.clamp = clamp;
          lodash4.clone = clone2;
          lodash4.cloneDeep = cloneDeep2;
          lodash4.cloneDeepWith = cloneDeepWith;
          lodash4.cloneWith = cloneWith;
          lodash4.conformsTo = conformsTo;
          lodash4.deburr = deburr;
          lodash4.defaultTo = defaultTo;
          lodash4.divide = divide;
          lodash4.endsWith = endsWith;
          lodash4.eq = eq;
          lodash4.escape = escape2;
          lodash4.escapeRegExp = escapeRegExp2;
          lodash4.every = every;
          lodash4.find = find;
          lodash4.findIndex = findIndex;
          lodash4.findKey = findKey;
          lodash4.findLast = findLast;
          lodash4.findLastIndex = findLastIndex;
          lodash4.findLastKey = findLastKey;
          lodash4.floor = floor;
          lodash4.forEach = forEach;
          lodash4.forEachRight = forEachRight;
          lodash4.forIn = forIn;
          lodash4.forInRight = forInRight;
          lodash4.forOwn = forOwn;
          lodash4.forOwnRight = forOwnRight;
          lodash4.get = get;
          lodash4.gt = gt;
          lodash4.gte = gte;
          lodash4.has = has;
          lodash4.hasIn = hasIn;
          lodash4.head = head;
          lodash4.identity = identity;
          lodash4.includes = includes;
          lodash4.indexOf = indexOf;
          lodash4.inRange = inRange;
          lodash4.invoke = invoke;
          lodash4.isArguments = isArguments;
          lodash4.isArray = isArray;
          lodash4.isArrayBuffer = isArrayBuffer;
          lodash4.isArrayLike = isArrayLike;
          lodash4.isArrayLikeObject = isArrayLikeObject;
          lodash4.isBoolean = isBoolean;
          lodash4.isBuffer = isBuffer;
          lodash4.isDate = isDate;
          lodash4.isElement = isElement;
          lodash4.isEmpty = isEmpty;
          lodash4.isEqual = isEqual;
          lodash4.isEqualWith = isEqualWith;
          lodash4.isError = isError;
          lodash4.isFinite = isFinite2;
          lodash4.isFunction = isFunction;
          lodash4.isInteger = isInteger;
          lodash4.isLength = isLength;
          lodash4.isMap = isMap;
          lodash4.isMatch = isMatch;
          lodash4.isMatchWith = isMatchWith;
          lodash4.isNaN = isNaN2;
          lodash4.isNative = isNative;
          lodash4.isNil = isNil;
          lodash4.isNull = isNull;
          lodash4.isNumber = isNumber;
          lodash4.isObject = isObject;
          lodash4.isObjectLike = isObjectLike;
          lodash4.isPlainObject = isPlainObject;
          lodash4.isRegExp = isRegExp;
          lodash4.isSafeInteger = isSafeInteger;
          lodash4.isSet = isSet;
          lodash4.isString = isString;
          lodash4.isSymbol = isSymbol;
          lodash4.isTypedArray = isTypedArray;
          lodash4.isUndefined = isUndefined;
          lodash4.isWeakMap = isWeakMap;
          lodash4.isWeakSet = isWeakSet;
          lodash4.join = join;
          lodash4.kebabCase = kebabCase;
          lodash4.last = last;
          lodash4.lastIndexOf = lastIndexOf;
          lodash4.lowerCase = lowerCase;
          lodash4.lowerFirst = lowerFirst;
          lodash4.lt = lt;
          lodash4.lte = lte;
          lodash4.max = max;
          lodash4.maxBy = maxBy;
          lodash4.mean = mean;
          lodash4.meanBy = meanBy;
          lodash4.min = min;
          lodash4.minBy = minBy;
          lodash4.stubArray = stubArray;
          lodash4.stubFalse = stubFalse;
          lodash4.stubObject = stubObject;
          lodash4.stubString = stubString;
          lodash4.stubTrue = stubTrue;
          lodash4.multiply = multiply;
          lodash4.nth = nth;
          lodash4.noConflict = noConflict;
          lodash4.noop = noop;
          lodash4.now = now;
          lodash4.pad = pad;
          lodash4.padEnd = padEnd;
          lodash4.padStart = padStart;
          lodash4.parseInt = parseInt2;
          lodash4.random = random2;
          lodash4.reduce = reduce;
          lodash4.reduceRight = reduceRight;
          lodash4.repeat = repeat;
          lodash4.replace = replace;
          lodash4.result = result;
          lodash4.round = round;
          lodash4.runInContext = runInContext2;
          lodash4.sample = sample;
          lodash4.size = size;
          lodash4.snakeCase = snakeCase;
          lodash4.some = some;
          lodash4.sortedIndex = sortedIndex;
          lodash4.sortedIndexBy = sortedIndexBy;
          lodash4.sortedIndexOf = sortedIndexOf;
          lodash4.sortedLastIndex = sortedLastIndex;
          lodash4.sortedLastIndexBy = sortedLastIndexBy;
          lodash4.sortedLastIndexOf = sortedLastIndexOf;
          lodash4.startCase = startCase;
          lodash4.startsWith = startsWith;
          lodash4.subtract = subtract;
          lodash4.sum = sum;
          lodash4.sumBy = sumBy;
          lodash4.template = template;
          lodash4.times = times;
          lodash4.toFinite = toFinite;
          lodash4.toInteger = toInteger;
          lodash4.toLength = toLength;
          lodash4.toLower = toLower;
          lodash4.toNumber = toNumber;
          lodash4.toSafeInteger = toSafeInteger;
          lodash4.toString = toString2;
          lodash4.toUpper = toUpper;
          lodash4.trim = trim;
          lodash4.trimEnd = trimEnd;
          lodash4.trimStart = trimStart;
          lodash4.truncate = truncate;
          lodash4.unescape = unescape2;
          lodash4.uniqueId = uniqueId;
          lodash4.upperCase = upperCase;
          lodash4.upperFirst = upperFirst;
          lodash4.each = forEach;
          lodash4.eachRight = forEachRight;
          lodash4.first = head;
          mixin(lodash4, function() {
            var source = {};
            baseForOwn(lodash4, function(func, methodName) {
              if (!hasOwnProperty.call(lodash4.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash4.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash4[methodName].placeholder = lodash4;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash4[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash4.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash4, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash4.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash4[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash4.prototype.at = wrapperAt;
          lodash4.prototype.chain = wrapperChain;
          lodash4.prototype.commit = wrapperCommit;
          lodash4.prototype.next = wrapperNext;
          lodash4.prototype.plant = wrapperPlant;
          lodash4.prototype.reverse = wrapperReverse;
          lodash4.prototype.toJSON = lodash4.prototype.valueOf = lodash4.prototype.value = wrapperValue;
          lodash4.prototype.first = lodash4.prototype.head;
          if (symIterator) {
            lodash4.prototype[symIterator] = wrapperToIterator;
          }
          return lodash4;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports2);
    }
  });

  // node_modules/uuid/lib/rng-browser.js
  var require_rng_browser = __commonJS({
    "node_modules/uuid/lib/rng-browser.js"(exports2, module2) {
      init_polyfills();
      var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (getRandomValues) {
        rnds8 = new Uint8Array(16);
        module2.exports = function whatwgRNG() {
          getRandomValues(rnds8);
          return rnds8;
        };
      } else {
        rnds = new Array(16);
        module2.exports = function mathRNG() {
          for (var i = 0, r; i < 16; i++) {
            if ((i & 3) === 0)
              r = Math.random() * 4294967296;
            rnds[i] = r >>> ((i & 3) << 3) & 255;
          }
          return rnds;
        };
      }
      var rnds8;
      var rnds;
    }
  });

  // node_modules/uuid/lib/bytesToUuid.js
  var require_bytesToUuid = __commonJS({
    "node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
      init_polyfills();
      var byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex[i] = (i + 256).toString(16).substr(1);
      }
      var i;
      function bytesToUuid(buf, offset) {
        var i2 = offset || 0;
        var bth = byteToHex;
        return [
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]],
          "-",
          bth[buf[i2++]],
          bth[buf[i2++]],
          "-",
          bth[buf[i2++]],
          bth[buf[i2++]],
          "-",
          bth[buf[i2++]],
          bth[buf[i2++]],
          "-",
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]],
          bth[buf[i2++]]
        ].join("");
      }
      module2.exports = bytesToUuid;
    }
  });

  // node_modules/uuid/v1.js
  var require_v1 = __commonJS({
    "node_modules/uuid/v1.js"(exports2, module2) {
      init_polyfills();
      var rng = require_rng_browser();
      var bytesToUuid = require_bytesToUuid();
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = rng();
          if (node == null) {
            node = _nodeId = [
              seedBytes[0] | 1,
              seedBytes[1],
              seedBytes[2],
              seedBytes[3],
              seedBytes[4],
              seedBytes[5]
            ];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = tmh & 255;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = clockseq & 255;
        for (var n = 0; n < 6; ++n) {
          b[i + n] = node[n];
        }
        return buf ? buf : bytesToUuid(b);
      }
      module2.exports = v1;
    }
  });

  // node_modules/uuid/v4.js
  var require_v4 = __commonJS({
    "node_modules/uuid/v4.js"(exports2, module2) {
      init_polyfills();
      var rng = require_rng_browser();
      var bytesToUuid = require_bytesToUuid();
      function v4(options, buf, offset) {
        var i = buf && offset || 0;
        if (typeof options == "string") {
          buf = options === "binary" ? new Array(16) : null;
          options = null;
        }
        options = options || {};
        var rnds = options.random || (options.rng || rng)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          for (var ii = 0; ii < 16; ++ii) {
            buf[i + ii] = rnds[ii];
          }
        }
        return buf || bytesToUuid(rnds);
      }
      module2.exports = v4;
    }
  });

  // node_modules/uuid/index.js
  var require_uuid = __commonJS({
    "node_modules/uuid/index.js"(exports2, module2) {
      init_polyfills();
      var v1 = require_v1();
      var v4 = require_v4();
      var uuid3 = v4;
      uuid3.v1 = v1;
      uuid3.v4 = v4;
      module2.exports = uuid3;
    }
  });

  // node_modules/r2-shared-js/dist/es6-es2015/src/models/media-overlay.js
  var require_media_overlay = __commonJS({
    "node_modules/r2-shared-js/dist/es6-es2015/src/models/media-overlay.js"(exports2) {
      "use strict";
      init_polyfills();
      var MediaOverlayNode_1;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MediaOverlayNode = exports2.timeStrToSeconds = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var ta_json_x_1 = require_cjs();
      var ta_json_string_converter_1 = require_ta_json_string_converter();
      function timeStrToSeconds(timeStr) {
        if (!timeStr) {
          return 0;
        }
        timeStr = timeStr.replace("npt=", "");
        let hours = 0;
        let minutes = 0;
        let seconds = 0;
        try {
          const iMin = timeStr.indexOf("min");
          if (iMin > 0) {
            const minsStr = timeStr.substr(0, iMin);
            minutes = parseFloat(minsStr);
          } else {
            const iMs = timeStr.indexOf("ms");
            if (iMs > 0) {
              const msStr = timeStr.substr(0, iMs);
              const ms = parseFloat(msStr);
              seconds = ms / 1e3;
            } else {
              const iS = timeStr.indexOf("s");
              if (iS > 0) {
                const sStr = timeStr.substr(0, iS);
                seconds = parseFloat(sStr);
              } else {
                const iH = timeStr.indexOf("h");
                if (iH > 0) {
                  const hStr = timeStr.substr(0, iH);
                  hours = parseFloat(hStr);
                } else {
                  const arr = timeStr.split(":");
                  if (arr.length === 1) {
                    seconds = parseFloat(arr[0]);
                  } else if (arr.length === 2) {
                    minutes = parseFloat(arr[0]);
                    seconds = parseFloat(arr[1]);
                  } else if (arr.length === 3) {
                    hours = parseFloat(arr[0]);
                    minutes = parseFloat(arr[1]);
                    seconds = parseFloat(arr[2]);
                  } else {
                    console.log("SMIL TIME CLOCK SYNTAX PARSING ERROR ??");
                    console.log(timeStr);
                  }
                }
              }
            }
          }
        } catch (err) {
          console.log(err);
          console.log("SMIL TIME CLOCK SYNTAX PARSING ERROR!");
          console.log(timeStr);
          return 0;
        }
        return hours * 3600 + minutes * 60 + seconds;
      }
      exports2.timeStrToSeconds = timeStrToSeconds;
      var MediaOverlayNode2 = exports2.MediaOverlayNode = MediaOverlayNode_1 = class MediaOverlayNode {
        constructor() {
          this.initialized = false;
        }
      };
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("text"),
        tslib_1.__metadata("design:type", String)
      ], MediaOverlayNode2.prototype, "Text", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("audio"),
        tslib_1.__metadata("design:type", String)
      ], MediaOverlayNode2.prototype, "Audio", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("role"),
        (0, ta_json_x_1.JsonConverter)(ta_json_string_converter_1.JsonStringConverter),
        (0, ta_json_x_1.JsonElementType)(String),
        tslib_1.__metadata("design:type", Array)
      ], MediaOverlayNode2.prototype, "Role", void 0);
      tslib_1.__decorate([
        (0, ta_json_x_1.JsonProperty)("narration"),
        (0, ta_json_x_1.JsonElementType)(MediaOverlayNode_1),
        tslib_1.__metadata("design:type", Array)
      ], MediaOverlayNode2.prototype, "Children", void 0);
      exports2.MediaOverlayNode = MediaOverlayNode2 = MediaOverlayNode_1 = tslib_1.__decorate([
        (0, ta_json_x_1.JsonObject)()
      ], MediaOverlayNode2);
    }
  });

  // node_modules/devtools-detector/lib/devtools-detector.js
  var require_devtools_detector = __commonJS({
    "node_modules/devtools-detector/lib/devtools-detector.js"(exports2, module2) {
      init_polyfills();
      !function(t, n) {
        "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = n() : "function" == typeof define && define.amd ? define([], n) : "object" == typeof exports2 ? exports2.devtoolsDetector = n() : t.devtoolsDetector = n();
      }("undefined" != typeof self ? self : exports2, function() {
        return function(t) {
          var n = {};
          function e(r) {
            if (n[r])
              return n[r].exports;
            var i = n[r] = { i: r, l: false, exports: {} };
            return t[r].call(i.exports, i, i.exports, e), i.l = true, i.exports;
          }
          return e.m = t, e.c = n, e.d = function(t2, n2, r) {
            e.o(t2, n2) || Object.defineProperty(t2, n2, { configurable: false, enumerable: true, get: r });
          }, e.n = function(t2) {
            var n2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return e.d(n2, "a", n2), n2;
          }, e.o = function(t2, n2) {
            return Object.prototype.hasOwnProperty.call(t2, n2);
          }, e.p = "", e(e.s = 3);
        }([function(t, n, e) {
          "use strict";
          e.d(n, "j", function() {
            return s;
          }), e.d(n, "e", function() {
            return l;
          }), e.d(n, "f", function() {
            return d;
          }), e.d(n, "d", function() {
            return h;
          }), e.d(n, "i", function() {
            return p;
          }), e.d(n, "g", function() {
            return v;
          }), e.d(n, "c", function() {
            return b;
          }), e.d(n, "h", function() {
            return y;
          }), n.a = function() {
            for (var t2, n2 = [], e2 = 0; e2 < arguments.length; e2++)
              n2[e2] = arguments[e2];
            if (null === f || void 0 === f ? void 0 : f.document)
              return (t2 = f.document).createElement.apply(t2, n2);
            return {};
          }, e.d(n, "b", function() {
            return w;
          });
          var r, i, o, u, c, a = e(1), f = Object(a.a)(), s = (null === (r = null === f || void 0 === f ? void 0 : f.navigator) || void 0 === r ? void 0 : r.userAgent) || "unknown", l = "InstallTrigger" in ((null === f || void 0 === f ? void 0 : f.window) || {}) || /firefox/i.test(s), d = /trident/i.test(s) || /msie/i.test(s), h = /edge/i.test(s), p = /webkit/i.test(s) && !h, v = /IqiyiApp/.test(s), b = void 0 !== (null === (i = null === f || void 0 === f ? void 0 : f.window) || void 0 === i ? void 0 : i.chrome) || /chrome/i.test(s) || /CriOS/i.test(s), y = "[object SafariRemoteNotification]" === ((null === (u = null === (o = null === f || void 0 === f ? void 0 : f.window) || void 0 === o ? void 0 : o.safari) || void 0 === u ? void 0 : u.pushNotification) || false).toString() || /safari/i.test(s) && !b;
          var w = "function" == typeof (null === (c = f.document) || void 0 === c ? void 0 : c.createElement);
        }, function(t, n, e) {
          "use strict";
          (function(t2) {
            n.c = function() {
              return "undefined" != typeof performance ? performance.now() : Date.now();
            }, n.b = function(t3) {
              void 0 === t3 && (t3 = {});
              for (var n2 = t3.includes, e2 = void 0 === n2 ? [] : n2, r2 = t3.excludes, i2 = void 0 === r2 ? [] : r2, o = false, u = false, c = 0, a = e2; c < a.length; c++) {
                var f = a[c];
                if (true === f) {
                  o = true;
                  break;
                }
              }
              for (var s = 0, l = i2; s < l.length; s++) {
                var f = l[s];
                if (true === f) {
                  u = true;
                  break;
                }
              }
              return o && !u;
            }, n.d = function(t3, n2, e2) {
              var o = i.a[t3];
              if (void 0 === o)
                return false;
              return Object(r.compare)(o, n2, e2);
            }, n.a = function() {
              if ("undefined" != typeof self)
                return self;
              if ("undefined" != typeof window)
                return window;
              if (void 0 !== t2)
                return t2;
              return this;
            };
            var r = e(8), i = (e.n(r), e(4));
          }).call(n, e(7));
        }, function(t, n, e) {
          "use strict";
          e.d(n, "b", function() {
            return o;
          }), e.d(n, "c", function() {
            return u;
          }), e.d(n, "a", function() {
            return c;
          });
          var r = e(0);
          function i(t2) {
            if (console) {
              if (!r.f && !r.d)
                return console[t2];
              if ("log" === t2 || "clear" === t2)
                return function() {
                  for (var n2 = [], e2 = 0; e2 < arguments.length; e2++)
                    n2[e2] = arguments[e2];
                  console[t2].apply(console, n2);
                };
            }
            return function() {
              for (var t3 = [], n2 = 0; n2 < arguments.length; n2++)
                t3[n2] = arguments[n2];
            };
          }
          var o = i("log"), u = i("table"), c = i("clear");
        }, function(t, n, e) {
          "use strict";
          Object.defineProperty(n, "__esModule", { value: true }), n.addListener = function(t2) {
            s.addListener(t2);
          }, n.removeListener = function(t2) {
            s.removeListener(t2);
          }, n.isLaunch = function() {
            return s.isLaunch();
          }, n.launch = function() {
            s.launch();
          }, n.stop = function() {
            s.stop();
          }, n.setDetectDelay = function(t2) {
            s.setDetectDelay(t2);
          };
          var r = e(6), i = e(9);
          e.d(n, "DevtoolsDetector", function() {
            return r.a;
          }), e.d(n, "checkers", function() {
            return i;
          });
          var o = e(1);
          e.d(n, "match", function() {
            return o.b;
          }), e.d(n, "specificVersionMatch", function() {
            return o.d;
          });
          var u = e(0);
          e.d(n, "userAgent", function() {
            return u.j;
          }), e.d(n, "isFirefox", function() {
            return u.e;
          }), e.d(n, "isIE", function() {
            return u.f;
          }), e.d(n, "isEdge", function() {
            return u.d;
          }), e.d(n, "isWebkit", function() {
            return u.i;
          }), e.d(n, "isIqiyiApp", function() {
            return u.g;
          }), e.d(n, "isChrome", function() {
            return u.c;
          }), e.d(n, "isSafari", function() {
            return u.h;
          }), e.d(n, "createElement", function() {
            return u.a;
          }), e.d(n, "inBrowser", function() {
            return u.b;
          });
          var c = e(2);
          e.d(n, "log", function() {
            return c.b;
          }), e.d(n, "table", function() {
            return c.c;
          }), e.d(n, "clear", function() {
            return c.a;
          });
          var a = e(4);
          e.d(n, "versionMap", function() {
            return a.a;
          });
          var f = e(5);
          e.d(n, "isMac", function() {
            return f.d;
          }), e.d(n, "isIpad", function() {
            return f.b;
          }), e.d(n, "isIphone", function() {
            return f.c;
          }), e.d(n, "isAndroid", function() {
            return f.a;
          }), e.d(n, "isWindows", function() {
            return f.e;
          });
          var s = new r.a({ checkers: [i.erudaChecker, i.elementIdChecker, i.regToStringChecker, i.functionToStringChecker, i.depRegToStringChecker, i.dateToStringChecker, i.performanceChecker, i.debuggerChecker] });
          n.default = s;
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return r;
          });
          for (var r = {}, i = 0, o = (e(0).j || "").match(/\w+\/(\d|\.)+(\s|$)/gi) || []; i < o.length; i++) {
            var u = o[i].split("/"), c = u[0], a = u[1];
            r[c] = a;
          }
        }, function(t, n, e) {
          "use strict";
          e.d(n, "d", function() {
            return i;
          }), e.d(n, "b", function() {
            return o;
          }), e.d(n, "c", function() {
            return u;
          }), e.d(n, "a", function() {
            return c;
          }), e.d(n, "e", function() {
            return a;
          });
          var r = e(0), i = /macintosh/i.test(r.j), o = /ipad/i.test(r.j) || i && navigator.maxTouchPoints > 1, u = /iphone/i.test(r.j), c = /android/i.test(r.j), a = /windows/i.test(r.j);
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return u;
          });
          var r = e(0), i = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c(t3) {
                try {
                  a(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c);
              }
              a((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, o = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c(0), throw: c(1), return: c(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c(o3) {
              return function(c2) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c2]);
              };
            }
          }, u = function() {
            function t2(t3) {
              var n2 = t3.checkers;
              this._listeners = [], this._isOpen = false, this._detectLoopStopped = true, this._detectLoopDelay = 500, this._checkers = n2.slice();
            }
            return t2.prototype.launch = function() {
              r.b && (this._detectLoopDelay <= 0 && this.setDetectDelay(500), this._detectLoopStopped && (this._detectLoopStopped = false, this._detectLoop()));
            }, t2.prototype.stop = function() {
              this._detectLoopStopped || (this._detectLoopStopped = true, clearTimeout(this._timer));
            }, t2.prototype.isLaunch = function() {
              return !this._detectLoopStopped;
            }, t2.prototype.setDetectDelay = function(t3) {
              this._detectLoopDelay = t3;
            }, t2.prototype.addListener = function(t3) {
              this._listeners.push(t3);
            }, t2.prototype.removeListener = function(t3) {
              this._listeners = this._listeners.filter(function(n2) {
                return n2 !== t3;
              });
            }, t2.prototype._broadcast = function(t3) {
              for (var n2 = 0, e2 = this._listeners; n2 < e2.length; n2++) {
                var r2 = e2[n2];
                try {
                  r2(t3.isOpen, t3);
                } catch (t4) {
                }
              }
            }, t2.prototype._detectLoop = function() {
              return i(this, void 0, void 0, function() {
                var t3, n2, e2, r2, i2, u2 = this;
                return o(this, function(o2) {
                  switch (o2.label) {
                    case 0:
                      t3 = false, n2 = "", e2 = 0, r2 = this._checkers, o2.label = 1;
                    case 1:
                      return e2 < r2.length ? [4, (i2 = r2[e2]).isEnable()] : [3, 6];
                    case 2:
                      return o2.sent() ? (n2 = i2.name, [4, i2.isOpen()]) : [3, 4];
                    case 3:
                      t3 = o2.sent(), o2.label = 4;
                    case 4:
                      if (t3)
                        return [3, 6];
                      o2.label = 5;
                    case 5:
                      return e2++, [3, 1];
                    case 6:
                      return t3 != this._isOpen && (this._isOpen = t3, this._broadcast({ isOpen: t3, checkerName: n2 })), this._detectLoopDelay > 0 && !this._detectLoopStopped ? this._timer = setTimeout(function() {
                        return u2._detectLoop();
                      }, this._detectLoopDelay) : this.stop(), [2];
                  }
                });
              });
            }, t2;
          }();
        }, function(t, n) {
          var e;
          e = function() {
            return this;
          }();
          try {
            e = e || Function("return this")() || (0, eval)("this");
          } catch (t2) {
            "object" == typeof window && (e = window);
          }
          t.exports = e;
        }, function(t, n, e) {
          var r, i, o;
          !function(e2, u) {
            i = [], void 0 === (o = "function" == typeof (r = u) ? r.apply(n, i) : r) || (t.exports = o);
          }(0, function() {
            var t2 = /^v?(?:\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+))?(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
            function n2(t3) {
              var n3 = t3.replace(/^v/, "").replace(/\+.*$/, ""), e3 = function(t4, n4) {
                return -1 === t4.indexOf(n4) ? t4.length : t4.indexOf(n4);
              }(n3, "-"), r3 = n3.substring(0, e3).split(".");
              return r3.push(n3.substring(e3 + 1)), r3;
            }
            function e2(t3) {
              return isNaN(Number(t3)) ? t3 : Number(t3);
            }
            function r2(n3) {
              if ("string" != typeof n3)
                throw new TypeError("Invalid argument expected string");
              if (!t2.test(n3))
                throw new Error("Invalid argument not valid semver ('" + n3 + "' received)");
            }
            function i2(t3, i3) {
              [t3, i3].forEach(r2);
              for (var o3 = n2(t3), u2 = n2(i3), c = 0; c < Math.max(o3.length - 1, u2.length - 1); c++) {
                var a = parseInt(o3[c] || 0, 10), f = parseInt(u2[c] || 0, 10);
                if (a > f)
                  return 1;
                if (f > a)
                  return -1;
              }
              var s = o3[o3.length - 1], l = u2[u2.length - 1];
              if (s && l) {
                var d = s.split(".").map(e2), h = l.split(".").map(e2);
                for (c = 0; c < Math.max(d.length, h.length); c++) {
                  if (void 0 === d[c] || "string" == typeof h[c] && "number" == typeof d[c])
                    return -1;
                  if (void 0 === h[c] || "string" == typeof d[c] && "number" == typeof h[c])
                    return 1;
                  if (d[c] > h[c])
                    return 1;
                  if (h[c] > d[c])
                    return -1;
                }
              } else if (s || l)
                return s ? -1 : 1;
              return 0;
            }
            var o2 = [">", ">=", "=", "<", "<="], u = { ">": [1], ">=": [0, 1], "=": [0], "<=": [-1, 0], "<": [-1] };
            return i2.validate = function(n3) {
              return "string" == typeof n3 && t2.test(n3);
            }, i2.compare = function(t3, n3, e3) {
              !function(t4) {
                if ("string" != typeof t4)
                  throw new TypeError("Invalid operator type, expected string but got " + typeof t4);
                if (-1 === o2.indexOf(t4))
                  throw new TypeError("Invalid operator, expected one of " + o2.join("|"));
              }(e3);
              var r3 = i2(t3, n3);
              return u[e3].indexOf(r3) > -1;
            }, i2;
          });
        }, function(t, n, e) {
          "use strict";
          Object.defineProperty(n, "__esModule", { value: true });
          var r = e(10);
          e.d(n, "depRegToStringChecker", function() {
            return r.a;
          });
          var i = e(11);
          e.d(n, "elementIdChecker", function() {
            return i.a;
          });
          var o = e(12);
          e.d(n, "functionToStringChecker", function() {
            return o.a;
          });
          var u = e(13);
          e.d(n, "regToStringChecker", function() {
            return u.a;
          });
          var c = e(14);
          e.d(n, "debuggerChecker", function() {
            return c.a;
          });
          var a = e(15);
          e.d(n, "dateToStringChecker", function() {
            return a.a;
          });
          var f = e(16);
          e.d(n, "performanceChecker", function() {
            return f.a;
          });
          var s = e(17);
          e.d(n, "erudaChecker", function() {
            return s.a;
          });
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return s;
          });
          var r = e(0), i = e(2), o = e(1), u = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, c = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          }, a = / /, f = false;
          a.toString = function() {
            return f = true, s.name;
          };
          var s = { name: "dep-reg-to-string", isOpen: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return f = false, Object(i.c)({ dep: a }), Object(i.a)(), [2, f];
              });
            });
          }, isEnable: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return [2, Object(o.b)({ includes: [true], excludes: [r.e, r.f] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return s;
          });
          var r = e(0), i = e(2), o = e(1), u = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, c = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          }, a = Object(r.a)("div"), f = false;
          Object.defineProperty(a, "id", { get: function() {
            return f = true, s.name;
          }, configurable: true });
          var s = { name: "element-id", isOpen: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return f = false, Object(i.b)(a), Object(i.a)(), [2, f];
              });
            });
          }, isEnable: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return [2, Object(o.b)({ includes: [true], excludes: [r.f, r.d, r.e] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return l;
          });
          var r = e(0), i = e(2), o = e(5), u = e(1), c = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, a = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          };
          function f() {
          }
          var s = 0;
          f.toString = function() {
            return s++, "";
          };
          var l = { name: "function-to-string", isOpen: function() {
            return c(this, void 0, void 0, function() {
              return a(this, function(t2) {
                return s = 0, Object(i.b)(f), Object(i.a)(), [2, 2 === s];
              });
            });
          }, isEnable: function() {
            return c(this, void 0, void 0, function() {
              return a(this, function(t2) {
                return [2, Object(u.b)({ includes: [true], excludes: [r.g, r.e, (o.b || o.c) && r.c] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return s;
          });
          var r = e(2), i = e(0), o = e(1), u = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, c = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          }, a = / /, f = false;
          a.toString = function() {
            return f = true, s.name;
          };
          var s = { name: "reg-to-string", isOpen: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return f = false, Object(r.b)(a), Object(r.a)(), [2, f];
              });
            });
          }, isEnable: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return [2, Object(o.b)({ includes: [true], excludes: [i.i] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return u;
          });
          var r = e(1), i = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c(t3) {
                try {
                  a(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c);
              }
              a((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, o = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c(0), throw: c(1), return: c(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c(o3) {
              return function(c2) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c2]);
              };
            }
          }, u = { name: "debugger-checker", isOpen: function() {
            return i(this, void 0, void 0, function() {
              var t2;
              return o(this, function(n2) {
                return t2 = Object(r.c)(), (function() {
                }).constructor("debugger")(), [2, Object(r.c)() - t2 > 100];
              });
            });
          }, isEnable: function() {
            return i(this, void 0, void 0, function() {
              return o(this, function(t2) {
                return [2, true];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return l;
          });
          var r = e(0), i = e(2), o = e(1), u = e(3), c = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, a = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          }, f = /* @__PURE__ */ new Date(), s = 0;
          f.toString = function() {
            return s++, "";
          };
          var l = { name: "date-to-string", isOpen: function() {
            return c(this, void 0, void 0, function() {
              return a(this, function(t2) {
                return s = 0, Object(i.b)(f), Object(i.a)(), [2, 2 === s];
              });
            });
          }, isEnable: function() {
            return c(this, void 0, void 0, function() {
              return a(this, function(t2) {
                return [2, Object(o.b)({ includes: [r.c], excludes: [(u.isIpad || u.isIphone) && r.c] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return s;
          });
          var r = e(0), i = e(2), o = e(1), u = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u2(t3) {
                try {
                  a2(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u2, c2);
              }
              a2((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, c = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u2 = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c2(0), throw: c2(1), return: c2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c2(o3) {
              return function(c3) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u2; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u2.label++, { value: o4[1], done: false };
                        case 5:
                          u2.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u2.ops.pop(), u2.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u2.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u2 = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u2.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u2.label < i2[1]) {
                            u2.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u2.label < i2[2]) {
                            u2.label = i2[2], u2.ops.push(o4);
                            break;
                          }
                          i2[2] && u2.ops.pop(), u2.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u2);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c3]);
              };
            }
          }, a = null, f = 0, s = { name: "performance", isOpen: function() {
            return u(this, void 0, void 0, function() {
              var t2, n2;
              return c(this, function(e2) {
                return null === a && (a = function() {
                  for (var t3 = function() {
                    for (var t4 = {}, n4 = 0; n4 < 500; n4++)
                      t4["".concat(n4)] = "".concat(n4);
                    return t4;
                  }(), n3 = [], e3 = 0; e3 < 50; e3++)
                    n3.push(t3);
                  return n3;
                }()), t2 = function() {
                  var t3 = Object(o.c)();
                  return Object(i.c)(a), Object(o.c)() - t3;
                }(), n2 = function() {
                  var t3 = Object(o.c)();
                  return Object(i.b)(a), Object(o.c)() - t3;
                }(), f = Math.max(f, n2), Object(i.a)(), 0 === t2 ? [2, false] : 0 === f ? [2, false] : [2, t2 > 10 * f];
              });
            });
          }, isEnable: function() {
            return u(this, void 0, void 0, function() {
              return c(this, function(t2) {
                return [2, Object(o.b)({ includes: [r.c], excludes: [] })];
              });
            });
          } };
        }, function(t, n, e) {
          "use strict";
          e.d(n, "a", function() {
            return o;
          });
          var r = this && this.__awaiter || function(t2, n2, e2, r2) {
            return new (e2 || (e2 = Promise))(function(i2, o2) {
              function u(t3) {
                try {
                  a(r2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c(t3) {
                try {
                  a(r2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a(t3) {
                t3.done ? i2(t3.value) : function(t4) {
                  return t4 instanceof e2 ? t4 : new e2(function(n3) {
                    n3(t4);
                  });
                }(t3.value).then(u, c);
              }
              a((r2 = r2.apply(t2, n2 || [])).next());
            });
          }, i = this && this.__generator || function(t2, n2) {
            var e2, r2, i2, o2, u = { label: 0, sent: function() {
              if (1 & i2[0])
                throw i2[1];
              return i2[1];
            }, trys: [], ops: [] };
            return o2 = { next: c(0), throw: c(1), return: c(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
              return this;
            }), o2;
            function c(o3) {
              return function(c2) {
                return function(o4) {
                  if (e2)
                    throw new TypeError("Generator is already executing.");
                  for (; u; )
                    try {
                      if (e2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
                        return i2;
                      switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                        case 0:
                        case 1:
                          i2 = o4;
                          break;
                        case 4:
                          return u.label++, { value: o4[1], done: false };
                        case 5:
                          u.label++, r2 = o4[1], o4 = [0];
                          continue;
                        case 7:
                          o4 = u.ops.pop(), u.trys.pop();
                          continue;
                        default:
                          if (!(i2 = (i2 = u.trys).length > 0 && i2[i2.length - 1]) && (6 === o4[0] || 2 === o4[0])) {
                            u = 0;
                            continue;
                          }
                          if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                            u.label = o4[1];
                            break;
                          }
                          if (6 === o4[0] && u.label < i2[1]) {
                            u.label = i2[1], i2 = o4;
                            break;
                          }
                          if (i2 && u.label < i2[2]) {
                            u.label = i2[2], u.ops.push(o4);
                            break;
                          }
                          i2[2] && u.ops.pop(), u.trys.pop();
                          continue;
                      }
                      o4 = n2.call(t2, u);
                    } catch (t3) {
                      o4 = [6, t3], r2 = 0;
                    } finally {
                      e2 = i2 = 0;
                    }
                  if (5 & o4[0])
                    throw o4[1];
                  return { value: o4[0] ? o4[1] : void 0, done: true };
                }([o3, c2]);
              };
            }
          }, o = { name: "eruda", isOpen: function() {
            var t2;
            return r(this, void 0, void 0, function() {
              return i(this, function(n2) {
                return "undefined" != typeof eruda ? [2, true === (null === (t2 = null === eruda || void 0 === eruda ? void 0 : eruda._devTools) || void 0 === t2 ? void 0 : t2._isShow)] : [2, false];
              });
            });
          }, isEnable: function() {
            return r(this, void 0, void 0, function() {
              return i(this, function(t2) {
                return [2, true];
              });
            });
          } };
        }]);
      });
    }
  });

  // node_modules/node-releases/data/processed/envs.json
  var require_envs = __commonJS({
    "node_modules/node-releases/data/processed/envs.json"(exports2, module2) {
      module2.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: false, security: false, v8: "2.3.8.0" }, { name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: false, security: false, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.8.25" }, { name: "nodejs", version: "0.6.0", date: "2011-11-04", lts: false, security: false, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: false, security: false, v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: false, security: false, v8: "3.11.10.10" }, { name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: false, security: false, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: false, security: false, v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: false, security: false, v8: "3.17.13.0" }, { name: "nodejs", version: "0.12.0", date: "2015-02-06", lts: false, security: false, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: false, security: false, v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: false, security: false, v8: "4.5.103.33" }, { name: "nodejs", version: "4.2.0", date: "2015-10-12", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: false, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0", date: "2016-09-27", lts: "Argon", security: true, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: false, v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: false, v8: "4.5.103.45" }, { name: "nodejs", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: true, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: false, security: false, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "2015-12-15", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.9.0", date: "2016-03-16", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: false, security: false, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.2.0", date: "2016-05-17", lts: false, security: false, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: false, security: false, v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: false, security: false, v8: "5.0.71.60" }, { name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: false, security: false, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: false, security: false, v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: false, security: true, v8: "5.1.281.83" }, { name: "nodejs", version: "6.8.0", date: "2016-10-12", lts: false, security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron", security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: false, v8: "5.1.281.93" }, { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: false, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12.0", date: "2017-11-06", lts: "Boron", security: false, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.16.0", date: "2018-12-26", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: false, security: false, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.5.0", date: "2017-01-31", lts: false, security: false, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: false, security: false, v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: false, security: false, v8: "5.5.372.41" }, { name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.3.0", date: "2017-08-08", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.9.0", date: "2017-10-31", lts: "Carbon", security: false, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "Carbon", security: false, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: true, v8: "6.2.414.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: false, v8: "6.2.414.66" }, { name: "nodejs", version: "8.13.0", date: "2018-11-20", lts: "Carbon", security: false, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "Carbon", security: true, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: false, v8: "6.2.414.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: false, v8: "6.2.414.77" }, { name: "nodejs", version: "8.17.0", date: "2019-12-17", lts: "Carbon", security: true, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: false, security: false, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12-12", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.9.0", date: "2018-03-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: false, security: true, v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "10.0.0", date: "2018-04-24", lts: false, security: false, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: false, security: false, v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.3.0", date: "2018-05-29", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: false, security: false, v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.6.0", date: "2018-07-04", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.9.0", date: "2018-08-15", lts: false, security: false, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: false, security: false, v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.12.0", date: "2018-10-10", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "2019-10-22", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "2020-06-02", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "2018-10-23", lts: false, security: false, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: false, security: false, v8: "7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.3.0", date: "2018-11-27", lts: false, security: true, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.6.0", date: "2018-12-26", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.9.0", date: "2019-01-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.12.0", date: "2019-03-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.0", date: "2019-04-23", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.3.0", date: "2019-05-21", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.6.0", date: "2019-07-03", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.9.0", date: "2019-08-20", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: false, security: false, v8: "7.7.299.11" }, { name: "nodejs", version: "12.12.0", date: "2019-10-11", lts: false, security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21", lts: "Erbium", security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.16.0", date: "2020-02-11", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.20.0", date: "2020-11-24", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.1.0", date: "2019-11-05", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: false, security: false, v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.4.0", date: "2019-12-17", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.7.0", date: "2020-01-21", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.10.0", date: "2020-03-04", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.13.0", date: "2020-04-14", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: false, security: false, v8: "8.1.307.30" }, { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "2020-05-05", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: false, security: true, v8: "8.1.307.31" }, { name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: false, security: false, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.8.0", date: "2020-08-11", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.11.0", date: "2020-09-15", lts: false, security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15.0", date: "2020-10-27", lts: "Fermium", security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "Fermium", security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.19.0", date: "2022-02-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "Fermium", security: true, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: false, security: false, v8: "8.6.395.16" }, { name: "nodejs", version: "15.1.0", date: "2020-11-04", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.4.0", date: "2020-12-09", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.7.0", date: "2021-01-25", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.10.0", date: "2021-02-23", lts: false, security: true, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.13.0", date: "2021-03-31", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: false, security: false, v8: "9.0.257.17" }, { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: false, security: false, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "2021-05-19", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: false, security: false, v8: "9.1.269.36" }, { name: "nodejs", version: "16.5.0", date: "2021-07-14", lts: false, security: false, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: false, security: true, v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.8.0", date: "2021-08-25", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: false, security: false, v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: false, security: false, v8: "9.3.345.19" }, { name: "nodejs", version: "16.11.0", date: "2021-10-08", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.15.0", date: "2022-04-26", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "Gallium", security: true, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.19.0", date: "2022-12-13", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: false, security: false, v8: "9.5.172.21" }, { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: false, security: false, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "2021-11-30", lts: false, security: false, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.5.0", date: "2022-02-10", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.8.0", date: "2022-03-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.1.0", date: "2022-05-03", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.4.0", date: "2022-06-16", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: false, security: true, v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.7.0", date: "2022-07-26", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.11.0", date: "2022-10-13", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydrogen", security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.15.0", date: "2023-03-05", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: false, security: false, v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: false, security: false, v8: "10.7.193.20" }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: false, security: false, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14", lts: false, security: false, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6.0", date: "2023-02-01", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.9.0", date: "2023-04-10", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17", lts: false, security: false, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "2023-06-08", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: false, security: false, v8: "11.3.244.8" }];
    }
  });

  // node_modules/caniuse-lite/data/browsers.js
  var require_browsers = __commonJS({
    "node_modules/caniuse-lite/data/browsers.js"(exports2, module2) {
      init_polyfills();
      module2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
    }
  });

  // node_modules/caniuse-lite/dist/unpacker/browsers.js
  var require_browsers2 = __commonJS({
    "node_modules/caniuse-lite/dist/unpacker/browsers.js"(exports2, module2) {
      init_polyfills();
      module2.exports.browsers = require_browsers();
    }
  });

  // node_modules/caniuse-lite/data/browserVersions.js
  var require_browserVersions = __commonJS({
    "node_modules/caniuse-lite/data/browserVersions.js"(exports2, module2) {
      init_polyfills();
      module2.exports = { "0": "113", "1": "114", "2": "115", "3": "116", "4": "5", "5": "19", "6": "23", "7": "24", "8": "25", "9": "26", A: "10", B: "11", C: "12", D: "117", E: "7", F: "8", G: "9", H: "15", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "20", n: "21", o: "22", p: "73", q: "103", r: "104", s: "105", t: "106", u: "107", v: "108", w: "109", x: "110", y: "111", z: "112", AB: "27", BB: "28", CB: "29", DB: "30", EB: "31", FB: "32", GB: "33", HB: "34", IB: "35", JB: "36", KB: "37", LB: "38", MB: "39", NB: "40", OB: "41", PB: "42", QB: "43", RB: "44", SB: "45", TB: "46", UB: "47", VB: "48", WB: "49", XB: "50", YB: "51", ZB: "52", aB: "53", bB: "54", cB: "55", dB: "56", eB: "57", fB: "58", gB: "60", hB: "62", iB: "63", jB: "64", kB: "65", lB: "66", mB: "67", nB: "68", oB: "69", pB: "70", qB: "71", rB: "72", sB: "74", tB: "75", uB: "76", vB: "77", wB: "78", xB: "11.1", yB: "12.1", zB: "15.5", "0B": "16.0", "1B": "17.0", "2B": "3", "3B": "59", "4B": "61", "5B": "82", "6B": "118", "7B": "119", "8B": "120", "9B": "3.2", AC: "10.1", BC: "13.1", CC: "15.2-15.3", DC: "15.4", EC: "16.1", FC: "16.2", GC: "16.3", HC: "16.4", IC: "16.5", JC: "16.6", KC: "17.1", LC: "11.5", MC: "4.2-4.3", NC: "5.5", OC: "2", PC: "3.5", QC: "3.6", RC: "3.1", SC: "5.1", TC: "6.1", UC: "7.1", VC: "9.1", WC: "14.1", XC: "15.1", YC: "15.6", ZC: "TP", aC: "9.5-9.6", bC: "10.0-10.1", cC: "10.5", dC: "10.6", eC: "11.6", fC: "4.0-4.1", gC: "5.0-5.1", hC: "6.0-6.1", iC: "7.0-7.1", jC: "8.1-8.4", kC: "9.0-9.2", lC: "9.3", mC: "10.0-10.2", nC: "10.3", oC: "11.0-11.2", pC: "11.3-11.4", qC: "12.0-12.1", rC: "12.2-12.5", sC: "13.0-13.1", tC: "13.2", uC: "13.3", vC: "13.4-13.7", wC: "14.0-14.4", xC: "14.5-14.8", yC: "15.0-15.1", zC: "15.6-15.7", "0C": "all", "1C": "2.1", "2C": "2.2", "3C": "2.3", "4C": "4.1", "5C": "4.4", "6C": "4.4.3-4.4.4", "7C": "5.0-5.4", "8C": "6.2-6.4", "9C": "7.2-7.4", AD: "8.2", BD: "9.2", CD: "11.1-11.2", DD: "12.0", ED: "13.0", FD: "14.0", GD: "15.0", HD: "18.0", ID: "19.0", JD: "13.18", KD: "2.5", LD: "3.0-3.1" };
    }
  });

  // node_modules/caniuse-lite/dist/unpacker/browserVersions.js
  var require_browserVersions2 = __commonJS({
    "node_modules/caniuse-lite/dist/unpacker/browserVersions.js"(exports2, module2) {
      init_polyfills();
      module2.exports.browserVersions = require_browserVersions();
    }
  });

  // node_modules/caniuse-lite/data/agents.js
  var require_agents = __commonJS({
    "node_modules/caniuse-lite/data/agents.js"(exports2, module2) {
      init_polyfills();
      module2.exports = { A: { A: { J: 0, E: 0, F: 0.0268696, G: 0.0537391, A: 0, B: 0.416478, NC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "NC", "J", "E", "F", "G", "A", "B", "", "", ""], E: "IE", F: { NC: 962323200, J: 998870400, E: 1161129600, F: 1237420800, G: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { "0": 0.035192, "1": 0.607062, "2": 3.20687, "3": 1.03376, C: 4399e-6, K: 4399e-6, L: 4399e-6, H: 4399e-6, M: 0, N: 4399e-6, O: 8798e-6, P: 0, Q: 4399e-6, R: 4399e-6, S: 4399e-6, T: 8798e-6, U: 4399e-6, V: 8798e-6, W: 4399e-6, X: 4399e-6, Y: 4399e-6, Z: 8798e-6, a: 0, b: 0.013197, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0.017596, j: 0, k: 0, l: 0, q: 0, r: 0, s: 0, t: 0, u: 8798e-6, v: 0.013197, w: 0.083581, x: 0.013197, y: 0.092379, z: 0.096778, D: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "H", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "D", "", "", ""], E: "Edge", F: { "0": 1683158400, "1": 1685664e3, "2": 1689897600, "3": 1692576e3, C: 1438128e3, K: 1447286400, L: 1470096e3, H: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, q: 1655942400, r: 1659657600, s: 1661990400, t: 1664755200, u: 1666915200, v: 1670198400, w: 1673481600, x: 1675900800, y: 1678665600, z: 1680825600, D: 1694649600 }, D: { C: "ms", K: "ms", L: "ms", H: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { "0": 0.026394, "1": 0.030793, "2": 0.580668, "3": 1.39008, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, OC: 0, "2B": 0, I: 0, J: 0, E: 0, F: 0, G: 0, A: 0, B: 8798e-6, C: 0, K: 0, L: 0, H: 0, M: 0, N: 0, O: 0, m: 0, n: 0, o: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 8798e-6, RB: 4399e-6, SB: 0, TB: 0, UB: 0, VB: 4399e-6, WB: 0, XB: 8798e-6, YB: 0, ZB: 0.052788, aB: 4399e-6, bB: 4399e-6, cB: 0, dB: 8798e-6, eB: 0, fB: 0, "3B": 4399e-6, gB: 0, "4B": 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0.030793, p: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0.039591, P: 0, Q: 0, R: 0, "5B": 0, S: 8798e-6, T: 0, U: 0, V: 0, W: 0, X: 4399e-6, Y: 0, Z: 4399e-6, a: 8798e-6, b: 0, c: 0, d: 0.013197, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.118773, q: 0.017596, r: 0, s: 4399e-6, t: 4399e-6, u: 4399e-6, v: 8798e-6, w: 8798e-6, x: 8798e-6, y: 0.013197, z: 0.065985, D: 0.052788, "6B": 0, "7B": 0, "8B": 0, PC: 0, QC: 0 }, B: "moz", C: ["OC", "2B", "PC", "QC", "I", "4", "J", "E", "F", "G", "A", "B", "C", "K", "L", "H", "M", "N", "O", "5", "m", "n", "o", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "3B", "gB", "4B", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "p", "sB", "tB", "uB", "vB", "wB", "P", "Q", "R", "5B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "D", "6B", "7B", "8B"], E: "Firefox", F: { "0": 1683590400, "1": 1686009600, "2": 1688428800, "3": 1690848e3, "4": 1308614400, "5": 1357603200, "6": 1372118400, "7": 1375747200, "8": 1379376e3, "9": 1386633600, OC: 1161648e3, "2B": 1213660800, PC: 124632e4, QC: 1264032e3, I: 1300752e3, J: 1313452800, E: 1317081600, F: 1317081600, G: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, H: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, m: 1361232e3, n: 1364860800, o: 1368489600, AB: 1391472e3, BB: 1395100800, CB: 1398729600, DB: 1402358400, EB: 1405987200, FB: 1409616e3, GB: 1413244800, HB: 1417392e3, IB: 1421107200, JB: 1424736e3, KB: 1428278400, LB: 1431475200, MB: 1435881600, NB: 1439251200, OB: 144288e4, PB: 1446508800, QB: 1450137600, RB: 1453852800, SB: 1457395200, TB: 1461628800, UB: 1465257600, VB: 1470096e3, WB: 1474329600, XB: 1479168e3, YB: 1485216e3, ZB: 1488844800, aB: 149256e4, bB: 1497312e3, cB: 1502150400, dB: 1506556800, eB: 1510617600, fB: 1516665600, "3B": 1520985600, gB: 1525824e3, "4B": 1529971200, hB: 1536105600, iB: 1540252800, jB: 1544486400, kB: 154872e4, lB: 1552953600, mB: 1558396800, nB: 1562630400, oB: 1567468800, pB: 1571788800, qB: 1575331200, rB: 1578355200, p: 1581379200, sB: 1583798400, tB: 1586304e3, uB: 1588636800, vB: 1591056e3, wB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, "5B": 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, q: 1658793600, r: 1661212800, s: 1663632e3, t: 1666051200, u: 1668470400, v: 1670889600, w: 1673913600, x: 1676332800, y: 1678752e3, z: 1681171200, D: 1693267200, "6B": null, "7B": null, "8B": null } }, D: { A: { "0": 0.255142, "1": 2.10712, "2": 12.8099, "3": 5.7231, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, I: 0, J: 0, E: 0, F: 0, G: 0, A: 0, B: 0, C: 0, K: 0, L: 0, H: 0, M: 0, N: 0, O: 0, m: 0, n: 0, o: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 4399e-6, IB: 0, JB: 0, KB: 0, LB: 0.013197, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 4399e-6, VB: 0.017596, WB: 0.030793, XB: 0.013197, YB: 0, ZB: 0, aB: 8798e-6, bB: 0, cB: 4399e-6, dB: 0.048389, eB: 4399e-6, fB: 0, "3B": 0, gB: 0.021995, "4B": 4399e-6, hB: 4399e-6, iB: 8798e-6, jB: 0, kB: 8798e-6, lB: 0.026394, mB: 4399e-6, nB: 0.039591, oB: 0.065985, pB: 0.039591, qB: 0.021995, rB: 0.026394, p: 0.030793, sB: 0.048389, tB: 0.048389, uB: 0.096778, vB: 0.026394, wB: 0.039591, P: 0.202354, Q: 0.079182, R: 0.057187, S: 0.114374, T: 0.030793, U: 0.083581, V: 0.092379, W: 0.08798, X: 0.048389, Y: 0.039591, Z: 0.048389, a: 0.061586, b: 0.035192, c: 0.127571, d: 0.030793, e: 0.017596, f: 0.026394, g: 0.026394, h: 0.061586, i: 0.04399, j: 0.035192, k: 0.035192, l: 0.039591, q: 0.211152, r: 0.052788, s: 0.048389, t: 0.052788, u: 0.123172, v: 0.180359, w: 1.83878, x: 0.149566, y: 0.285935, z: 0.228748, D: 0.017596, "6B": 4399e-6, "7B": 0, "8B": 0 }, B: "webkit", C: ["", "", "", "", "", "I", "4", "J", "E", "F", "G", "A", "B", "C", "K", "L", "H", "M", "N", "O", "5", "m", "n", "o", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "3B", "gB", "4B", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "p", "sB", "tB", "uB", "vB", "wB", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "D", "6B", "7B", "8B"], E: "Chrome", F: { "0": 1682985600, "1": 1685404800, "2": 1689724800, "3": 1692057600, "4": 1274745600, "5": 1332892800, "6": 1348531200, "7": 1352246400, "8": 1357862400, "9": 1361404800, I: 1264377600, J: 1283385600, E: 1287619200, F: 1291248e3, G: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, H: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, m: 133704e4, n: 1340668800, o: 1343692800, AB: 1364428800, BB: 1369094400, CB: 1374105600, DB: 1376956800, EB: 1384214400, FB: 1389657600, GB: 1392940800, HB: 1397001600, IB: 1400544e3, JB: 1405468800, KB: 1409011200, LB: 141264e4, MB: 1416268800, NB: 1421798400, OB: 1425513600, PB: 1429401600, QB: 143208e4, RB: 1437523200, SB: 1441152e3, TB: 1444780800, UB: 1449014400, VB: 1453248e3, WB: 1456963200, XB: 1460592e3, YB: 1464134400, ZB: 1469059200, aB: 1472601600, bB: 1476230400, cB: 1480550400, dB: 1485302400, eB: 1489017600, fB: 149256e4, "3B": 1496707200, gB: 1500940800, "4B": 1504569600, hB: 1508198400, iB: 1512518400, jB: 1516752e3, kB: 1520294400, lB: 1523923200, mB: 1527552e3, nB: 1532390400, oB: 1536019200, pB: 1539648e3, qB: 1543968e3, rB: 154872e4, p: 1552348800, sB: 1555977600, tB: 1559606400, uB: 1564444800, vB: 1568073600, wB: 1571702400, P: 1575936e3, Q: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, q: 1655769600, r: 1659398400, s: 1661817600, t: 1664236800, u: 1666656e3, v: 166968e4, w: 1673308800, x: 1675728e3, y: 1678147200, z: 1680566400, D: 1694476800, "6B": null, "7B": null, "8B": null } }, E: { A: { "4": 0, I: 0, J: 0, E: 0, F: 0, G: 0, A: 0, B: 0, C: 0, K: 0.017596, L: 0.105576, H: 0.017596, RC: 0, "9B": 0, SC: 8798e-6, TC: 0, UC: 0, VC: 0.140768, AC: 0, xB: 4399e-6, yB: 0.030793, BC: 0.136369, WC: 0.255142, XC: 0.039591, CC: 0.035192, DC: 0.070384, zB: 0.123172, YC: 0.576269, "0B": 0.171561, EC: 0.180359, FC: 0.184758, GC: 0.422304, HC: 0.189157, IC: 1.15254, JC: 1.65402, "1B": 0.026394, KC: 0, ZC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "9B", "I", "4", "SC", "J", "TC", "E", "UC", "F", "G", "VC", "A", "AC", "B", "xB", "C", "yB", "K", "BC", "L", "WC", "H", "XC", "CC", "DC", "zB", "YC", "0B", "EC", "FC", "GC", "HC", "IC", "JC", "1B", "KC", "ZC"], E: "Safari", F: { "4": 1275868800, RC: 1205798400, "9B": 1226534400, I: 1244419200, SC: 131112e4, J: 1343174400, TC: 13824e5, E: 13824e5, UC: 1410998400, F: 1413417600, G: 1443657600, VC: 1458518400, A: 1474329600, AC: 1490572800, B: 1505779200, xB: 1522281600, C: 1537142400, yB: 1553472e3, K: 1568851200, BC: 1585008e3, L: 1600214400, WC: 1619395200, H: 1632096e3, XC: 1635292800, CC: 1639353600, DC: 1647216e3, zB: 1652745600, YC: 1658275200, "0B": 1662940800, EC: 1666569600, FC: 1670889600, GC: 1674432e3, HC: 1679875200, IC: 1684368e3, JC: 1690156800, "1B": null, KC: null, ZC: null } }, F: { A: { "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, G: 0, B: 0, C: 0, H: 0, M: 0, N: 0, O: 0, m: 0, n: 0, o: 0, AB: 0, BB: 4399e-6, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0.013197, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, p: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, P: 0, Q: 0, R: 0, "5B": 0, S: 0, T: 0, U: 4399e-6, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0.057187, f: 0, g: 0.079182, h: 0, i: 0.030793, j: 0.83581, k: 0.466294, l: 8798e-6, aC: 0, bC: 0, cC: 0, dC: 0, xB: 0, LC: 0, eC: 0, yB: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "aC", "bC", "cC", "dC", "B", "xB", "LC", "eC", "C", "yB", "H", "M", "N", "O", "5", "m", "n", "o", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "p", "sB", "tB", "uB", "vB", "wB", "P", "Q", "R", "5B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "", "", ""], E: "Opera", F: { "5": 1390867200, "6": 1405987200, "7": 1409616e3, "8": 1413331200, "9": 1417132800, G: 1150761600, aC: 1223424e3, bC: 1251763200, cC: 1267488e3, dC: 1277942400, B: 1292457600, xB: 1302566400, LC: 1309219200, eC: 1323129600, C: 1323129600, yB: 1352073600, H: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, m: 1393891200, n: 1399334400, o: 1401753600, AB: 1422316800, BB: 1425945600, CB: 1430179200, DB: 1433808e3, EB: 1438646400, FB: 1442448e3, GB: 1445904e3, HB: 1449100800, IB: 1454371200, JB: 1457308800, KB: 146232e4, LB: 1465344e3, MB: 1470096e3, NB: 1474329600, OB: 1477267200, PB: 1481587200, QB: 1486425600, RB: 1490054400, SB: 1494374400, TB: 1498003200, UB: 1502236800, VB: 1506470400, WB: 1510099200, XB: 1515024e3, YB: 1517961600, ZB: 1521676800, aB: 1525910400, bB: 1530144e3, cB: 1534982400, dB: 1537833600, eB: 1543363200, fB: 1548201600, gB: 1554768e3, hB: 1561593600, iB: 1566259200, jB: 1570406400, kB: 1573689600, lB: 1578441600, mB: 1583971200, nB: 1587513600, oB: 1592956800, pB: 1595894400, qB: 1600128e3, rB: 1603238400, p: 161352e4, sB: 1612224e3, tB: 1616544e3, uB: 1619568e3, vB: 1623715200, wB: 1627948800, P: 1631577600, Q: 1633392e3, R: 1635984e3, "5B": 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800 }, D: { G: "o", B: "o", C: "o", aC: "o", bC: "o", cC: "o", dC: "o", xB: "o", LC: "o", eC: "o", yB: "o" } }, G: { A: { F: 0, "9B": 0, fC: 0, MC: 279764e-8, gC: 419646e-8, hC: 279764e-8, iC: 0.0125894, jC: 419646e-8, kC: 839291e-8, lC: 0.0391669, mC: 279764e-8, nC: 0.0545539, oC: 0.0223811, pC: 0.0195835, qC: 0.015387, rC: 0.257383, sC: 699409e-8, tC: 0.0111905, uC: 0.0181846, vC: 0.0573516, wC: 0.149674, xC: 0.257383, yC: 0.0965185, CC: 0.10631, DC: 0.120298, zB: 0.170656, zC: 1.13864, "0B": 0.43783, EC: 0.863071, FC: 0.440628, GC: 0.879857, HC: 0.211222, IC: 2.6032, JC: 5.87084, "1B": 0.0965185, KC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "9B", "fC", "MC", "gC", "hC", "iC", "F", "jC", "kC", "lC", "mC", "nC", "oC", "pC", "qC", "rC", "sC", "tC", "uC", "vC", "wC", "xC", "yC", "CC", "DC", "zB", "zC", "0B", "EC", "FC", "GC", "HC", "IC", "JC", "1B", "KC", "", ""], E: "Safari on iOS", F: { "9B": 1270252800, fC: 1283904e3, MC: 1299628800, gC: 1331078400, hC: 1359331200, iC: 1394409600, F: 1410912e3, jC: 1413763200, kC: 1442361600, lC: 1458518400, mC: 1473724800, nC: 1490572800, oC: 1505779200, pC: 1522281600, qC: 1537142400, rC: 1553472e3, sC: 1568851200, tC: 1572220800, uC: 1580169600, vC: 1585008e3, wC: 1600214400, xC: 1619395200, yC: 1632096e3, CC: 1639353600, DC: 1647216e3, zB: 1652659200, zC: 1658275200, "0B": 1662940800, EC: 1666569600, FC: 1670889600, GC: 1674432e3, HC: 1679875200, IC: 1684368e3, JC: 1690156800, "1B": 1694995200, KC: null } }, H: { A: { "0C": 1.08194 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0C", "", "", ""], E: "Opera Mini", F: { "0C": 1426464e3 } }, I: { A: { "2B": 0, I: 0.0136938, D: 0, "1C": 0, "2C": 684689e-8, "3C": 0, "4C": 0.0273876, MC: 0.0479282, "5C": 0, "6C": 0.212254 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "1C", "2C", "3C", "2B", "I", "4C", "MC", "5C", "6C", "D", "", "", ""], E: "Android Browser", F: { "1C": 1256515200, "2C": 1274313600, "3C": 1291593600, "2B": 1298332800, I: 1318896e3, "4C": 1341792e3, MC: 1374624e3, "5C": 1386547200, "6C": 1401667200, D: 1694476800 } }, J: { A: { E: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "A", "", "", ""], E: "Blackberry Browser", F: { E: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, p: 0, xB: 0, LC: 0, yB: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "xB", "LC", "C", "yB", "p", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, xB: 1314835200, LC: 1318291200, C: 1330300800, yB: 1349740800, p: 1673827200 }, D: { p: "webkit" } }, L: { A: { D: 37.5486 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "", ""], E: "Chrome for Android", F: { D: 1694476800 } }, M: { A: { D: 0.263294 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "", ""], E: "Firefox for Android", F: { D: 1693267200 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { zB: 1.00276 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "zB", "", "", ""], E: "UC Browser for Android", F: { zB: 1687132800 }, D: { zB: "webkit" } }, P: { A: { I: 0.115947, m: 0.0843248, n: 0.210812, o: 0, "7C": 0, "8C": 0, "9C": 0.0421624, AD: 0, BD: 0, AC: 0, CD: 0.0105406, DD: 0, ED: 0.0210812, FD: 0.0210812, GD: 0, "0B": 0.0316218, "1B": 0.0316218, HD: 0.0316218, ID: 0.052703 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "7C", "8C", "9C", "AD", "BD", "AC", "CD", "DD", "ED", "FD", "GD", "0B", "1B", "HD", "ID", "m", "n", "o", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, "7C": 1481846400, "8C": 1509408e3, "9C": 1528329600, AD: 1546128e3, BD: 1554163200, AC: 1567900800, CD: 1582588800, DD: 1593475200, ED: 1605657600, FD: 1618531200, GD: 1629072e3, "0B": 1640736e3, "1B": 1651708800, HD: 1659657600, ID: 1667260800, m: 1677369600, n: 1684454400, o: 1689292800 } }, Q: { A: { BC: 0.173662 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BC", "", "", ""], E: "QQ Browser", F: { BC: 1663718400 } }, R: { A: { JD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "JD", "", "", ""], E: "Baidu Browser", F: { JD: 1663027200 } }, S: { A: { KD: 0.05602, LD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KD", "LD", "", "", ""], E: "KaiOS Browser", F: { KD: 1527811200, LD: 1631664e3 } } };
    }
  });

  // node_modules/caniuse-lite/dist/unpacker/agents.js
  var require_agents2 = __commonJS({
    "node_modules/caniuse-lite/dist/unpacker/agents.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var browsers = require_browsers2().browsers;
      var versions = require_browserVersions2().browserVersions;
      var agentsData = require_agents();
      function unpackBrowserVersions(versionsData) {
        return Object.keys(versionsData).reduce((usage, version2) => {
          usage[versions[version2]] = versionsData[version2];
          return usage;
        }, {});
      }
      module2.exports.agents = Object.keys(agentsData).reduce((map, key) => {
        let versionsData = agentsData[key];
        map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
          if (entry === "A") {
            data.usage_global = unpackBrowserVersions(versionsData[entry]);
          } else if (entry === "C") {
            data.versions = versionsData[entry].reduce((list, version2) => {
              if (version2 === "") {
                list.push(null);
              } else {
                list.push(versions[version2]);
              }
              return list;
            }, []);
          } else if (entry === "D") {
            data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
          } else if (entry === "E") {
            data.browser = versionsData[entry];
          } else if (entry === "F") {
            data.release_date = Object.keys(versionsData[entry]).reduce(
              (map2, key2) => {
                map2[versions[key2]] = versionsData[entry][key2];
                return map2;
              },
              {}
            );
          } else {
            data.prefix = versionsData[entry];
          }
          return data;
        }, {});
        return map;
      }, {});
    }
  });

  // node_modules/node-releases/data/release-schedule/release-schedule.json
  var require_release_schedule = __commonJS({
    "node_modules/node-releases/data/release-schedule/release-schedule.json"(exports2, module2) {
      module2.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Dubnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Gallium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "" } };
    }
  });

  // node_modules/electron-to-chromium/versions.js
  var require_versions = __commonJS({
    "node_modules/electron-to-chromium/versions.js"(exports2, module2) {
      init_polyfills();
      module2.exports = {
        "0.20": "39",
        "0.21": "41",
        "0.22": "41",
        "0.23": "41",
        "0.24": "41",
        "0.25": "42",
        "0.26": "42",
        "0.27": "43",
        "0.28": "43",
        "0.29": "43",
        "0.30": "44",
        "0.31": "45",
        "0.32": "45",
        "0.33": "45",
        "0.34": "45",
        "0.35": "45",
        "0.36": "47",
        "0.37": "49",
        "1.0": "49",
        "1.1": "50",
        "1.2": "51",
        "1.3": "52",
        "1.4": "53",
        "1.5": "54",
        "1.6": "56",
        "1.7": "58",
        "1.8": "59",
        "2.0": "61",
        "2.1": "61",
        "3.0": "66",
        "3.1": "66",
        "4.0": "69",
        "4.1": "69",
        "4.2": "69",
        "5.0": "73",
        "6.0": "76",
        "6.1": "76",
        "7.0": "78",
        "7.1": "78",
        "7.2": "78",
        "7.3": "78",
        "8.0": "80",
        "8.1": "80",
        "8.2": "80",
        "8.3": "80",
        "8.4": "80",
        "8.5": "80",
        "9.0": "83",
        "9.1": "83",
        "9.2": "83",
        "9.3": "83",
        "9.4": "83",
        "10.0": "85",
        "10.1": "85",
        "10.2": "85",
        "10.3": "85",
        "10.4": "85",
        "11.0": "87",
        "11.1": "87",
        "11.2": "87",
        "11.3": "87",
        "11.4": "87",
        "11.5": "87",
        "12.0": "89",
        "12.1": "89",
        "12.2": "89",
        "13.0": "91",
        "13.1": "91",
        "13.2": "91",
        "13.3": "91",
        "13.4": "91",
        "13.5": "91",
        "13.6": "91",
        "14.0": "93",
        "14.1": "93",
        "14.2": "93",
        "15.0": "94",
        "15.1": "94",
        "15.2": "94",
        "15.3": "94",
        "15.4": "94",
        "15.5": "94",
        "16.0": "96",
        "16.1": "96",
        "16.2": "96",
        "17.0": "98",
        "17.1": "98",
        "17.2": "98",
        "17.3": "98",
        "17.4": "98",
        "18.0": "100",
        "18.1": "100",
        "18.2": "100",
        "18.3": "100",
        "19.0": "102",
        "19.1": "102",
        "20.0": "104",
        "20.1": "104",
        "20.2": "104",
        "20.3": "104",
        "21.0": "106",
        "21.1": "106",
        "21.2": "106",
        "21.3": "106",
        "21.4": "106",
        "22.0": "108",
        "22.1": "108",
        "22.2": "108",
        "22.3": "108",
        "23.0": "110",
        "23.1": "110",
        "23.2": "110",
        "23.3": "110",
        "24.0": "112",
        "24.1": "112",
        "24.2": "112",
        "24.3": "112",
        "24.4": "112",
        "24.5": "112",
        "24.6": "112",
        "24.7": "112",
        "24.8": "112",
        "25.0": "114",
        "25.1": "114",
        "25.2": "114",
        "25.3": "114",
        "25.4": "114",
        "25.5": "114",
        "25.6": "114",
        "25.7": "114",
        "25.8": "114",
        "26.0": "116",
        "26.1": "116",
        "26.2": "116",
        "27.0": "118"
      };
    }
  });

  // node_modules/browserslist/error.js
  var require_error = __commonJS({
    "node_modules/browserslist/error.js"(exports2, module2) {
      init_polyfills();
      function BrowserslistError(message) {
        this.name = "BrowserslistError";
        this.message = message;
        this.browserslist = true;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, BrowserslistError);
        }
      }
      BrowserslistError.prototype = Error.prototype;
      module2.exports = BrowserslistError;
    }
  });

  // node_modules/browserslist/parse.js
  var require_parse2 = __commonJS({
    "node_modules/browserslist/parse.js"(exports2, module2) {
      init_polyfills();
      var AND_REGEXP = /^\s+and\s+(.*)/i;
      var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
      function flatten(array) {
        if (!Array.isArray(array))
          return [array];
        return array.reduce(function(a, b) {
          return a.concat(flatten(b));
        }, []);
      }
      function find(string, predicate) {
        for (var n = 1, max = string.length; n <= max; n++) {
          var parsed = string.substr(-n, n);
          if (predicate(parsed, n, max)) {
            return string.slice(0, -n);
          }
        }
        return "";
      }
      function matchQuery(all, query) {
        var node = { query };
        if (query.indexOf("not ") === 0) {
          node.not = true;
          query = query.slice(4);
        }
        for (var name in all) {
          var type = all[name];
          var match = query.match(type.regexp);
          if (match) {
            node.type = name;
            for (var i = 0; i < type.matches.length; i++) {
              node[type.matches[i]] = match[i + 1];
            }
            return node;
          }
        }
        node.type = "unknown";
        return node;
      }
      function matchBlock(all, string, qs) {
        var node;
        return find(string, function(parsed, n, max) {
          if (AND_REGEXP.test(parsed)) {
            node = matchQuery(all, parsed.match(AND_REGEXP)[1]);
            node.compose = "and";
            qs.unshift(node);
            return true;
          } else if (OR_REGEXP.test(parsed)) {
            node = matchQuery(all, parsed.match(OR_REGEXP)[1]);
            node.compose = "or";
            qs.unshift(node);
            return true;
          } else if (n === max) {
            node = matchQuery(all, parsed.trim());
            node.compose = "or";
            qs.unshift(node);
            return true;
          }
          return false;
        });
      }
      module2.exports = function parse(all, queries) {
        if (!Array.isArray(queries))
          queries = [queries];
        return flatten(
          queries.map(function(block) {
            var qs = [];
            do {
              block = matchBlock(all, block, qs);
            } while (block);
            return qs;
          })
        );
      };
    }
  });

  // node_modules/browserslist/browser.js
  var require_browser3 = __commonJS({
    "node_modules/browserslist/browser.js"(exports2, module2) {
      init_polyfills();
      var BrowserslistError = require_error();
      function noop() {
      }
      module2.exports = {
        loadQueries: function loadQueries() {
          throw new BrowserslistError(
            "Sharable configs are not supported in client-side build of Browserslist"
          );
        },
        getStat: function getStat(opts) {
          return opts.stats;
        },
        loadConfig: function loadConfig(opts) {
          if (opts.config) {
            throw new BrowserslistError(
              "Browserslist config are not supported in client-side build"
            );
          }
        },
        loadCountry: function loadCountry() {
          throw new BrowserslistError(
            "Country statistics are not supported in client-side build of Browserslist"
          );
        },
        loadFeature: function loadFeature() {
          throw new BrowserslistError(
            "Supports queries are not available in client-side build of Browserslist"
          );
        },
        currentNode: function currentNode(resolve, context) {
          return resolve(["maintained node versions"], context)[0];
        },
        parseConfig: noop,
        readConfig: noop,
        findConfig: noop,
        clearCaches: noop,
        oldDataWarning: noop,
        env: {}
      };
    }
  });

  // node_modules/browserslist/index.js
  var require_browserslist = __commonJS({
    "node_modules/browserslist/index.js"(exports2, module2) {
      init_polyfills();
      var jsReleases = require_envs();
      var agents = require_agents2().agents;
      var jsEOL = require_release_schedule();
      var path = require_path();
      var e2c = require_versions();
      var BrowserslistError = require_error();
      var parse = require_parse2();
      var env = require_browser3();
      var YEAR = 365.259641 * 24 * 60 * 60 * 1e3;
      var ANDROID_EVERGREEN_FIRST = "37";
      var OP_MOB_BLINK_FIRST = 14;
      function isVersionsMatch(versionA, versionB) {
        return (versionA + ".").indexOf(versionB + ".") === 0;
      }
      function isEolReleased(name) {
        var version2 = name.slice(1);
        return browserslist2.nodeVersions.some(function(i) {
          return isVersionsMatch(i, version2);
        });
      }
      function normalize(versions) {
        return versions.filter(function(version2) {
          return typeof version2 === "string";
        });
      }
      function normalizeElectron(version2) {
        var versionToUse = version2;
        if (version2.split(".").length === 3) {
          versionToUse = version2.split(".").slice(0, -1).join(".");
        }
        return versionToUse;
      }
      function nameMapper(name) {
        return function mapName(version2) {
          return name + " " + version2;
        };
      }
      function getMajor(version2) {
        return parseInt(version2.split(".")[0]);
      }
      function getMajorVersions(released, number) {
        if (released.length === 0)
          return [];
        var majorVersions = uniq(released.map(getMajor));
        var minimum = majorVersions[majorVersions.length - number];
        if (!minimum) {
          return released;
        }
        var selected = [];
        for (var i = released.length - 1; i >= 0; i--) {
          if (minimum > getMajor(released[i]))
            break;
          selected.unshift(released[i]);
        }
        return selected;
      }
      function uniq(array) {
        var filtered = [];
        for (var i = 0; i < array.length; i++) {
          if (filtered.indexOf(array[i]) === -1)
            filtered.push(array[i]);
        }
        return filtered;
      }
      function fillUsage(result, name, data) {
        for (var i in data) {
          result[name + " " + i] = data[i];
        }
      }
      function generateFilter(sign, version2) {
        version2 = parseFloat(version2);
        if (sign === ">") {
          return function(v) {
            return parseFloat(v) > version2;
          };
        } else if (sign === ">=") {
          return function(v) {
            return parseFloat(v) >= version2;
          };
        } else if (sign === "<") {
          return function(v) {
            return parseFloat(v) < version2;
          };
        } else {
          return function(v) {
            return parseFloat(v) <= version2;
          };
        }
      }
      function generateSemverFilter(sign, version2) {
        version2 = version2.split(".").map(parseSimpleInt);
        version2[1] = version2[1] || 0;
        version2[2] = version2[2] || 0;
        if (sign === ">") {
          return function(v) {
            v = v.split(".").map(parseSimpleInt);
            return compareSemver(v, version2) > 0;
          };
        } else if (sign === ">=") {
          return function(v) {
            v = v.split(".").map(parseSimpleInt);
            return compareSemver(v, version2) >= 0;
          };
        } else if (sign === "<") {
          return function(v) {
            v = v.split(".").map(parseSimpleInt);
            return compareSemver(version2, v) > 0;
          };
        } else {
          return function(v) {
            v = v.split(".").map(parseSimpleInt);
            return compareSemver(version2, v) >= 0;
          };
        }
      }
      function parseSimpleInt(x) {
        return parseInt(x);
      }
      function compare(a, b) {
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      }
      function compareSemver(a, b) {
        return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || "0"), parseInt(b[1] || "0")) || compare(parseInt(a[2] || "0"), parseInt(b[2] || "0"));
      }
      function semverFilterLoose(operator, range) {
        range = range.split(".").map(parseSimpleInt);
        if (typeof range[1] === "undefined") {
          range[1] = "x";
        }
        switch (operator) {
          case "<=":
            return function(version2) {
              version2 = version2.split(".").map(parseSimpleInt);
              return compareSemverLoose(version2, range) <= 0;
            };
          case ">=":
          default:
            return function(version2) {
              version2 = version2.split(".").map(parseSimpleInt);
              return compareSemverLoose(version2, range) >= 0;
            };
        }
      }
      function compareSemverLoose(version2, range) {
        if (version2[0] !== range[0]) {
          return version2[0] < range[0] ? -1 : 1;
        }
        if (range[1] === "x") {
          return 0;
        }
        if (version2[1] !== range[1]) {
          return version2[1] < range[1] ? -1 : 1;
        }
        return 0;
      }
      function resolveVersion(data, version2) {
        if (data.versions.indexOf(version2) !== -1) {
          return version2;
        } else if (browserslist2.versionAliases[data.name][version2]) {
          return browserslist2.versionAliases[data.name][version2];
        } else {
          return false;
        }
      }
      function normalizeVersion(data, version2) {
        var resolved = resolveVersion(data, version2);
        if (resolved) {
          return resolved;
        } else if (data.versions.length === 1) {
          return data.versions[0];
        } else {
          return false;
        }
      }
      function filterByYear(since, context) {
        since = since / 1e3;
        return Object.keys(agents).reduce(function(selected, name) {
          var data = byName(name, context);
          if (!data)
            return selected;
          var versions = Object.keys(data.releaseDate).filter(function(v) {
            var date = data.releaseDate[v];
            return date !== null && date >= since;
          });
          return selected.concat(versions.map(nameMapper(data.name)));
        }, []);
      }
      function cloneData(data) {
        return {
          name: data.name,
          versions: data.versions,
          released: data.released,
          releaseDate: data.releaseDate
        };
      }
      function byName(name, context) {
        name = name.toLowerCase();
        name = browserslist2.aliases[name] || name;
        if (context.mobileToDesktop && browserslist2.desktopNames[name]) {
          var desktop = browserslist2.data[browserslist2.desktopNames[name]];
          if (name === "android") {
            return normalizeAndroidData(cloneData(browserslist2.data[name]), desktop);
          } else {
            var cloned = cloneData(desktop);
            cloned.name = name;
            return cloned;
          }
        }
        return browserslist2.data[name];
      }
      function normalizeAndroidVersions(androidVersions, chromeVersions) {
        var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
        return androidVersions.filter(function(version2) {
          return /^(?:[2-4]\.|[34]$)/.test(version2);
        }).concat(chromeVersions.slice(iFirstEvergreen));
      }
      function normalizeAndroidData(android, chrome) {
        android.released = normalizeAndroidVersions(android.released, chrome.released);
        android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
        android.released.forEach(function(v) {
          if (android.releaseDate[v] === void 0) {
            android.releaseDate[v] = chrome.releaseDate[v];
          }
        });
        return android;
      }
      function checkName(name, context) {
        var data = byName(name, context);
        if (!data)
          throw new BrowserslistError("Unknown browser " + name);
        return data;
      }
      function unknownQuery(query) {
        return new BrowserslistError(
          "Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query."
        );
      }
      function filterJumps(list, name, nVersions, context) {
        var jump = 1;
        switch (name) {
          case "android":
            if (context.mobileToDesktop)
              return list;
            var released = browserslist2.data.chrome.released;
            jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
            break;
          case "op_mob":
            var latest = browserslist2.data.op_mob.released.slice(-1)[0];
            jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
            break;
          default:
            return list;
        }
        if (nVersions <= jump) {
          return list.slice(-1);
        }
        return list.slice(jump - 1 - nVersions);
      }
      function isSupported(flags) {
        return typeof flags === "string" && (flags.indexOf("y") >= 0 || flags.indexOf("a") >= 0);
      }
      function resolve(queries, context) {
        return parse(QUERIES, queries).reduce(function(result, node, index2) {
          if (node.not && index2 === 0) {
            throw new BrowserslistError(
              "Write any browsers query (for instance, `defaults`) before `" + node.query + "`"
            );
          }
          var type = QUERIES[node.type];
          var array = type.select.call(browserslist2, context, node).map(function(j) {
            var parts = j.split(" ");
            if (parts[1] === "0") {
              return parts[0] + " " + byName(parts[0], context).versions[0];
            } else {
              return j;
            }
          });
          if (node.compose === "and") {
            if (node.not) {
              return result.filter(function(j) {
                return array.indexOf(j) === -1;
              });
            } else {
              return result.filter(function(j) {
                return array.indexOf(j) !== -1;
              });
            }
          } else {
            if (node.not) {
              var filter = {};
              array.forEach(function(j) {
                filter[j] = true;
              });
              return result.filter(function(j) {
                return !filter[j];
              });
            }
            return result.concat(array);
          }
        }, []);
      }
      function prepareOpts(opts) {
        if (typeof opts === "undefined")
          opts = {};
        if (typeof opts.path === "undefined") {
          opts.path = path.resolve ? path.resolve(".") : ".";
        }
        return opts;
      }
      function prepareQueries(queries, opts) {
        if (typeof queries === "undefined" || queries === null) {
          var config2 = browserslist2.loadConfig(opts);
          if (config2) {
            queries = config2;
          } else {
            queries = browserslist2.defaults;
          }
        }
        return queries;
      }
      function checkQueries(queries) {
        if (!(typeof queries === "string" || Array.isArray(queries))) {
          throw new BrowserslistError(
            "Browser queries must be an array or string. Got " + typeof queries + "."
          );
        }
      }
      var cache = {};
      function browserslist2(queries, opts) {
        opts = prepareOpts(opts);
        queries = prepareQueries(queries, opts);
        checkQueries(queries);
        var context = {
          ignoreUnknownVersions: opts.ignoreUnknownVersions,
          dangerousExtend: opts.dangerousExtend,
          mobileToDesktop: opts.mobileToDesktop,
          path: opts.path,
          env: opts.env
        };
        env.oldDataWarning(browserslist2.data);
        var stats = env.getStat(opts, browserslist2.data);
        if (stats) {
          context.customUsage = {};
          for (var browser in stats) {
            fillUsage(context.customUsage, browser, stats[browser]);
          }
        }
        var cacheKey = JSON.stringify([queries, context]);
        if (cache[cacheKey])
          return cache[cacheKey];
        var result = uniq(resolve(queries, context)).sort(function(name1, name2) {
          name1 = name1.split(" ");
          name2 = name2.split(" ");
          if (name1[0] === name2[0]) {
            var version1 = name1[1].split("-")[0];
            var version2 = name2[1].split("-")[0];
            return compareSemver(version2.split("."), version1.split("."));
          } else {
            return compare(name1[0], name2[0]);
          }
        });
        if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
          cache[cacheKey] = result;
        }
        return result;
      }
      browserslist2.parse = function(queries, opts) {
        opts = prepareOpts(opts);
        queries = prepareQueries(queries, opts);
        checkQueries(queries);
        return parse(QUERIES, queries);
      };
      browserslist2.cache = {};
      browserslist2.data = {};
      browserslist2.usage = {
        global: {},
        custom: null
      };
      browserslist2.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
      browserslist2.aliases = {
        fx: "firefox",
        ff: "firefox",
        ios: "ios_saf",
        explorer: "ie",
        blackberry: "bb",
        explorermobile: "ie_mob",
        operamini: "op_mini",
        operamobile: "op_mob",
        chromeandroid: "and_chr",
        firefoxandroid: "and_ff",
        ucandroid: "and_uc",
        qqandroid: "and_qq"
      };
      browserslist2.desktopNames = {
        and_chr: "chrome",
        and_ff: "firefox",
        ie_mob: "ie",
        android: "chrome"
        // has extra processing logic
      };
      browserslist2.versionAliases = {};
      browserslist2.clearCaches = env.clearCaches;
      browserslist2.parseConfig = env.parseConfig;
      browserslist2.readConfig = env.readConfig;
      browserslist2.findConfig = env.findConfig;
      browserslist2.loadConfig = env.loadConfig;
      browserslist2.coverage = function(browsers, stats) {
        var data;
        if (typeof stats === "undefined") {
          data = browserslist2.usage.global;
        } else if (stats === "my stats") {
          var opts = {};
          opts.path = path.resolve ? path.resolve(".") : ".";
          var customStats = env.getStat(opts);
          if (!customStats) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          data = {};
          for (var browser in customStats) {
            fillUsage(data, browser, customStats[browser]);
          }
        } else if (typeof stats === "string") {
          if (stats.length > 2) {
            stats = stats.toLowerCase();
          } else {
            stats = stats.toUpperCase();
          }
          env.loadCountry(browserslist2.usage, stats, browserslist2.data);
          data = browserslist2.usage[stats];
        } else {
          if ("dataByBrowser" in stats) {
            stats = stats.dataByBrowser;
          }
          data = {};
          for (var name in stats) {
            for (var version2 in stats[name]) {
              data[name + " " + version2] = stats[name][version2];
            }
          }
        }
        return browsers.reduce(function(all, i) {
          var usage = data[i];
          if (usage === void 0) {
            usage = data[i.replace(/ \S+$/, " 0")];
          }
          return all + (usage || 0);
        }, 0);
      };
      function nodeQuery(context, node) {
        var matched = browserslist2.nodeVersions.filter(function(i) {
          return isVersionsMatch(i, node.version);
        });
        if (matched.length === 0) {
          if (context.ignoreUnknownVersions) {
            return [];
          } else {
            throw new BrowserslistError(
              "Unknown version " + node.version + " of Node.js"
            );
          }
        }
        return ["node " + matched[matched.length - 1]];
      }
      function sinceQuery(context, node) {
        var year = parseInt(node.year);
        var month = parseInt(node.month || "01") - 1;
        var day = parseInt(node.day || "01");
        return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
      }
      function coverQuery(context, node) {
        var coverage = parseFloat(node.coverage);
        var usage = browserslist2.usage.global;
        if (node.place) {
          if (node.place.match(/^my\s+stats$/i)) {
            if (!context.customUsage) {
              throw new BrowserslistError("Custom usage statistics was not provided");
            }
            usage = context.customUsage;
          } else {
            var place;
            if (node.place.length === 2) {
              place = node.place.toUpperCase();
            } else {
              place = node.place.toLowerCase();
            }
            env.loadCountry(browserslist2.usage, place, browserslist2.data);
            usage = browserslist2.usage[place];
          }
        }
        var versions = Object.keys(usage).sort(function(a, b) {
          return usage[b] - usage[a];
        });
        var coveraged = 0;
        var result = [];
        var version2;
        for (var i = 0; i < versions.length; i++) {
          version2 = versions[i];
          if (usage[version2] === 0)
            break;
          coveraged += usage[version2];
          result.push(version2);
          if (coveraged >= coverage)
            break;
        }
        return result;
      }
      var QUERIES = {
        last_major_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
          select: function(context, node) {
            return Object.keys(agents).reduce(function(selected, name) {
              var data = byName(name, context);
              if (!data)
                return selected;
              var list = getMajorVersions(data.released, node.versions);
              list = list.map(nameMapper(data.name));
              list = filterJumps(list, data.name, node.versions, context);
              return selected.concat(list);
            }, []);
          }
        },
        last_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+versions?$/i,
          select: function(context, node) {
            return Object.keys(agents).reduce(function(selected, name) {
              var data = byName(name, context);
              if (!data)
                return selected;
              var list = data.released.slice(-node.versions);
              list = list.map(nameMapper(data.name));
              list = filterJumps(list, data.name, node.versions, context);
              return selected.concat(list);
            }, []);
          }
        },
        last_electron_major_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
          select: function(context, node) {
            var validVersions = getMajorVersions(Object.keys(e2c), node.versions);
            return validVersions.map(function(i) {
              return "chrome " + e2c[i];
            });
          }
        },
        last_node_major_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
          select: function(context, node) {
            return getMajorVersions(browserslist2.nodeVersions, node.versions).map(
              function(version2) {
                return "node " + version2;
              }
            );
          }
        },
        last_browser_major_versions: {
          matches: ["versions", "browser"],
          regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
          select: function(context, node) {
            var data = checkName(node.browser, context);
            var validVersions = getMajorVersions(data.released, node.versions);
            var list = validVersions.map(nameMapper(data.name));
            list = filterJumps(list, data.name, node.versions, context);
            return list;
          }
        },
        last_electron_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
          select: function(context, node) {
            return Object.keys(e2c).slice(-node.versions).map(function(i) {
              return "chrome " + e2c[i];
            });
          }
        },
        last_node_versions: {
          matches: ["versions"],
          regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
          select: function(context, node) {
            return browserslist2.nodeVersions.slice(-node.versions).map(function(version2) {
              return "node " + version2;
            });
          }
        },
        last_browser_versions: {
          matches: ["versions", "browser"],
          regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
          select: function(context, node) {
            var data = checkName(node.browser, context);
            var list = data.released.slice(-node.versions).map(nameMapper(data.name));
            list = filterJumps(list, data.name, node.versions, context);
            return list;
          }
        },
        unreleased_versions: {
          matches: [],
          regexp: /^unreleased\s+versions$/i,
          select: function(context) {
            return Object.keys(agents).reduce(function(selected, name) {
              var data = byName(name, context);
              if (!data)
                return selected;
              var list = data.versions.filter(function(v) {
                return data.released.indexOf(v) === -1;
              });
              list = list.map(nameMapper(data.name));
              return selected.concat(list);
            }, []);
          }
        },
        unreleased_electron_versions: {
          matches: [],
          regexp: /^unreleased\s+electron\s+versions?$/i,
          select: function() {
            return [];
          }
        },
        unreleased_browser_versions: {
          matches: ["browser"],
          regexp: /^unreleased\s+(\w+)\s+versions?$/i,
          select: function(context, node) {
            var data = checkName(node.browser, context);
            return data.versions.filter(function(v) {
              return data.released.indexOf(v) === -1;
            }).map(nameMapper(data.name));
          }
        },
        last_years: {
          matches: ["years"],
          regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
          select: function(context, node) {
            return filterByYear(Date.now() - YEAR * node.years, context);
          }
        },
        since_y: {
          matches: ["year"],
          regexp: /^since (\d+)$/i,
          select: sinceQuery
        },
        since_y_m: {
          matches: ["year", "month"],
          regexp: /^since (\d+)-(\d+)$/i,
          select: sinceQuery
        },
        since_y_m_d: {
          matches: ["year", "month", "day"],
          regexp: /^since (\d+)-(\d+)-(\d+)$/i,
          select: sinceQuery
        },
        popularity: {
          matches: ["sign", "popularity"],
          regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
          select: function(context, node) {
            var popularity = parseFloat(node.popularity);
            var usage = browserslist2.usage.global;
            return Object.keys(usage).reduce(function(result, version2) {
              if (node.sign === ">") {
                if (usage[version2] > popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<") {
                if (usage[version2] < popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<=") {
                if (usage[version2] <= popularity) {
                  result.push(version2);
                }
              } else if (usage[version2] >= popularity) {
                result.push(version2);
              }
              return result;
            }, []);
          }
        },
        popularity_in_my_stats: {
          matches: ["sign", "popularity"],
          regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
          select: function(context, node) {
            var popularity = parseFloat(node.popularity);
            if (!context.customUsage) {
              throw new BrowserslistError("Custom usage statistics was not provided");
            }
            var usage = context.customUsage;
            return Object.keys(usage).reduce(function(result, version2) {
              var percentage = usage[version2];
              if (percentage == null) {
                return result;
              }
              if (node.sign === ">") {
                if (percentage > popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<") {
                if (percentage < popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<=") {
                if (percentage <= popularity) {
                  result.push(version2);
                }
              } else if (percentage >= popularity) {
                result.push(version2);
              }
              return result;
            }, []);
          }
        },
        popularity_in_config_stats: {
          matches: ["sign", "popularity", "config"],
          regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
          select: function(context, node) {
            var popularity = parseFloat(node.popularity);
            var stats = env.loadStat(context, node.config, browserslist2.data);
            if (stats) {
              context.customUsage = {};
              for (var browser in stats) {
                fillUsage(context.customUsage, browser, stats[browser]);
              }
            }
            if (!context.customUsage) {
              throw new BrowserslistError("Custom usage statistics was not provided");
            }
            var usage = context.customUsage;
            return Object.keys(usage).reduce(function(result, version2) {
              var percentage = usage[version2];
              if (percentage == null) {
                return result;
              }
              if (node.sign === ">") {
                if (percentage > popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<") {
                if (percentage < popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<=") {
                if (percentage <= popularity) {
                  result.push(version2);
                }
              } else if (percentage >= popularity) {
                result.push(version2);
              }
              return result;
            }, []);
          }
        },
        popularity_in_place: {
          matches: ["sign", "popularity", "place"],
          regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
          select: function(context, node) {
            var popularity = parseFloat(node.popularity);
            var place = node.place;
            if (place.length === 2) {
              place = place.toUpperCase();
            } else {
              place = place.toLowerCase();
            }
            env.loadCountry(browserslist2.usage, place, browserslist2.data);
            var usage = browserslist2.usage[place];
            return Object.keys(usage).reduce(function(result, version2) {
              var percentage = usage[version2];
              if (percentage == null) {
                return result;
              }
              if (node.sign === ">") {
                if (percentage > popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<") {
                if (percentage < popularity) {
                  result.push(version2);
                }
              } else if (node.sign === "<=") {
                if (percentage <= popularity) {
                  result.push(version2);
                }
              } else if (percentage >= popularity) {
                result.push(version2);
              }
              return result;
            }, []);
          }
        },
        cover: {
          matches: ["coverage"],
          regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
          select: coverQuery
        },
        cover_in: {
          matches: ["coverage", "place"],
          regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
          select: coverQuery
        },
        supports: {
          matches: ["feature"],
          regexp: /^supports\s+([\w-]+)$/,
          select: function(context, node) {
            env.loadFeature(browserslist2.cache, node.feature);
            var features = browserslist2.cache[node.feature];
            var result = [];
            for (var name in features) {
              var data = byName(name, context);
              var checkDesktop = context.mobileToDesktop && name in browserslist2.desktopNames && isSupported(features[name][data.released.slice(-1)[0]]);
              data.versions.forEach(function(version2) {
                var flags = features[name][version2];
                if (flags === void 0 && checkDesktop) {
                  flags = features[browserslist2.desktopNames[name]][version2];
                }
                if (isSupported(flags)) {
                  result.push(name + " " + version2);
                }
              });
            }
            return result;
          }
        },
        electron_range: {
          matches: ["from", "to"],
          regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
          select: function(context, node) {
            var fromToUse = normalizeElectron(node.from);
            var toToUse = normalizeElectron(node.to);
            var from = parseFloat(node.from);
            var to = parseFloat(node.to);
            if (!e2c[fromToUse]) {
              throw new BrowserslistError("Unknown version " + from + " of electron");
            }
            if (!e2c[toToUse]) {
              throw new BrowserslistError("Unknown version " + to + " of electron");
            }
            return Object.keys(e2c).filter(function(i) {
              var parsed = parseFloat(i);
              return parsed >= from && parsed <= to;
            }).map(function(i) {
              return "chrome " + e2c[i];
            });
          }
        },
        node_range: {
          matches: ["from", "to"],
          regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
          select: function(context, node) {
            return browserslist2.nodeVersions.filter(semverFilterLoose(">=", node.from)).filter(semverFilterLoose("<=", node.to)).map(function(v) {
              return "node " + v;
            });
          }
        },
        browser_range: {
          matches: ["browser", "from", "to"],
          regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
          select: function(context, node) {
            var data = checkName(node.browser, context);
            var from = parseFloat(normalizeVersion(data, node.from) || node.from);
            var to = parseFloat(normalizeVersion(data, node.to) || node.to);
            function filter(v) {
              var parsed = parseFloat(v);
              return parsed >= from && parsed <= to;
            }
            return data.released.filter(filter).map(nameMapper(data.name));
          }
        },
        electron_ray: {
          matches: ["sign", "version"],
          regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
          select: function(context, node) {
            var versionToUse = normalizeElectron(node.version);
            return Object.keys(e2c).filter(generateFilter(node.sign, versionToUse)).map(function(i) {
              return "chrome " + e2c[i];
            });
          }
        },
        node_ray: {
          matches: ["sign", "version"],
          regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
          select: function(context, node) {
            return browserslist2.nodeVersions.filter(generateSemverFilter(node.sign, node.version)).map(function(v) {
              return "node " + v;
            });
          }
        },
        browser_ray: {
          matches: ["browser", "sign", "version"],
          regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
          select: function(context, node) {
            var version2 = node.version;
            var data = checkName(node.browser, context);
            var alias = browserslist2.versionAliases[data.name][version2];
            if (alias)
              version2 = alias;
            return data.released.filter(generateFilter(node.sign, version2)).map(function(v) {
              return data.name + " " + v;
            });
          }
        },
        firefox_esr: {
          matches: [],
          regexp: /^(firefox|ff|fx)\s+esr$/i,
          select: function() {
            return ["firefox 102", "firefox 115"];
          }
        },
        opera_mini_all: {
          matches: [],
          regexp: /(operamini|op_mini)\s+all/i,
          select: function() {
            return ["op_mini all"];
          }
        },
        electron_version: {
          matches: ["version"],
          regexp: /^electron\s+([\d.]+)$/i,
          select: function(context, node) {
            var versionToUse = normalizeElectron(node.version);
            var chrome = e2c[versionToUse];
            if (!chrome) {
              throw new BrowserslistError(
                "Unknown version " + node.version + " of electron"
              );
            }
            return ["chrome " + chrome];
          }
        },
        node_major_version: {
          matches: ["version"],
          regexp: /^node\s+(\d+)$/i,
          select: nodeQuery
        },
        node_minor_version: {
          matches: ["version"],
          regexp: /^node\s+(\d+\.\d+)$/i,
          select: nodeQuery
        },
        node_patch_version: {
          matches: ["version"],
          regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
          select: nodeQuery
        },
        current_node: {
          matches: [],
          regexp: /^current\s+node$/i,
          select: function(context) {
            return [env.currentNode(resolve, context)];
          }
        },
        maintained_node: {
          matches: [],
          regexp: /^maintained\s+node\s+versions$/i,
          select: function(context) {
            var now = Date.now();
            var queries = Object.keys(jsEOL).filter(function(key) {
              return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
            }).map(function(key) {
              return "node " + key.slice(1);
            });
            return resolve(queries, context);
          }
        },
        phantomjs_1_9: {
          matches: [],
          regexp: /^phantomjs\s+1.9$/i,
          select: function() {
            return ["safari 5"];
          }
        },
        phantomjs_2_1: {
          matches: [],
          regexp: /^phantomjs\s+2.1$/i,
          select: function() {
            return ["safari 6"];
          }
        },
        browser_version: {
          matches: ["browser", "version"],
          regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
          select: function(context, node) {
            var version2 = node.version;
            if (/^tp$/i.test(version2))
              version2 = "TP";
            var data = checkName(node.browser, context);
            var alias = normalizeVersion(data, version2);
            if (alias) {
              version2 = alias;
            } else {
              if (version2.indexOf(".") === -1) {
                alias = version2 + ".0";
              } else {
                alias = version2.replace(/\.0$/, "");
              }
              alias = normalizeVersion(data, alias);
              if (alias) {
                version2 = alias;
              } else if (context.ignoreUnknownVersions) {
                return [];
              } else {
                throw new BrowserslistError(
                  "Unknown version " + version2 + " of " + node.browser
                );
              }
            }
            return [data.name + " " + version2];
          }
        },
        browserslist_config: {
          matches: [],
          regexp: /^browserslist config$/i,
          select: function(context) {
            return browserslist2(void 0, context);
          }
        },
        extends: {
          matches: ["config"],
          regexp: /^extends (.+)$/i,
          select: function(context, node) {
            return resolve(env.loadQueries(context, node.config), context);
          }
        },
        defaults: {
          matches: [],
          regexp: /^defaults$/i,
          select: function(context) {
            return resolve(browserslist2.defaults, context);
          }
        },
        dead: {
          matches: [],
          regexp: /^dead$/i,
          select: function(context) {
            var dead = [
              "Baidu >= 0",
              "ie <= 11",
              "ie_mob <= 11",
              "bb <= 10",
              "op_mob <= 12.1",
              "samsung 4"
            ];
            return resolve(dead, context);
          }
        },
        unknown: {
          matches: [],
          regexp: /^(\w+)$/i,
          select: function(context, node) {
            if (byName(node.query, context)) {
              throw new BrowserslistError(
                "Specify versions in Browserslist query for browser " + node.query
              );
            } else {
              throw unknownQuery(node.query);
            }
          }
        }
      };
      (function() {
        for (var name in agents) {
          var browser = agents[name];
          browserslist2.data[name] = {
            name,
            versions: normalize(agents[name].versions),
            released: normalize(agents[name].versions.slice(0, -3)),
            releaseDate: agents[name].release_date
          };
          fillUsage(browserslist2.usage.global, name, browser.usage_global);
          browserslist2.versionAliases[name] = {};
          for (var i = 0; i < browser.versions.length; i++) {
            var full = browser.versions[i];
            if (!full)
              continue;
            if (full.indexOf("-") !== -1) {
              var interval = full.split("-");
              for (var j = 0; j < interval.length; j++) {
                browserslist2.versionAliases[name][interval[j]] = full;
              }
            }
          }
        }
        browserslist2.nodeVersions = jsReleases.map(function(release) {
          return release.version;
        });
      })();
      module2.exports = browserslist2;
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js
  var require_compat_dotall_s_transform = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        // Whether `u` flag present. In which case we transform to
        // \u{10FFFF} instead of \uFFFF.
        _hasUFlag: false,
        // Only run this plugin if we have `s` flag.
        shouldRun: function shouldRun(ast) {
          var shouldRun2 = ast.flags.includes("s");
          if (!shouldRun2) {
            return false;
          }
          ast.flags = ast.flags.replace("s", "");
          this._hasUFlag = ast.flags.includes("u");
          return true;
        },
        Char: function Char(path) {
          var node = path.node;
          if (node.kind !== "meta" || node.value !== ".") {
            return;
          }
          var toValue = "\\uFFFF";
          var toSymbol = "\uFFFF";
          if (this._hasUFlag) {
            toValue = "\\u{10FFFF}";
            toSymbol = "\u{10FFFF}";
          }
          path.replace({
            type: "CharacterClass",
            expressions: [{
              type: "ClassRange",
              from: {
                type: "Char",
                value: "\\0",
                kind: "decimal",
                symbol: "\0"
              },
              to: {
                type: "Char",
                value: toValue,
                kind: "unicode",
                symbol: toSymbol
              }
            }]
          });
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js
  var require_compat_named_capturing_groups_transform = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        // To track the names of the groups, and return them
        // in the transform result state.
        //
        // A map from name to number: {foo: 2, bar: 4}
        _groupNames: {},
        /**
         * Initialises the trasnform.
         */
        init: function init() {
          this._groupNames = {};
        },
        /**
         * Returns extra state, which eventually is returned to
         */
        getExtra: function getExtra() {
          return this._groupNames;
        },
        Group: function Group(path) {
          var node = path.node;
          if (!node.name) {
            return;
          }
          this._groupNames[node.name] = node.number;
          delete node.name;
          delete node.nameRaw;
        },
        Backreference: function Backreference(path) {
          var node = path.node;
          if (node.kind !== "name") {
            return;
          }
          node.kind = "number";
          node.reference = node.number;
          delete node.referenceRaw;
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js
  var require_compat_x_flag_transform = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        RegExp: function RegExp2(_ref) {
          var node = _ref.node;
          if (node.flags.includes("x")) {
            node.flags = node.flags.replace("x", "");
          }
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js
  var require_transforms = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        // "dotAll" `s` flag
        dotAll: require_compat_dotall_s_transform(),
        // Named capturing groups.
        namedCapturingGroups: require_compat_named_capturing_groups_transform(),
        // `x` flag
        xFlag: require_compat_x_flag_transform()
      };
    }
  });

  // node_modules/regexp-tree/dist/generator/index.js
  var require_generator = __commonJS({
    "node_modules/regexp-tree/dist/generator/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function gen(node) {
        return node ? generator[node.type](node) : "";
      }
      var generator = {
        RegExp: function RegExp2(node) {
          return "/" + gen(node.body) + "/" + node.flags;
        },
        Alternative: function Alternative(node) {
          return (node.expressions || []).map(gen).join("");
        },
        Disjunction: function Disjunction(node) {
          return gen(node.left) + "|" + gen(node.right);
        },
        Group: function Group(node) {
          var expression = gen(node.expression);
          if (node.capturing) {
            if (node.name) {
              return "(?<" + (node.nameRaw || node.name) + ">" + expression + ")";
            }
            return "(" + expression + ")";
          }
          return "(?:" + expression + ")";
        },
        Backreference: function Backreference(node) {
          switch (node.kind) {
            case "number":
              return "\\" + node.reference;
            case "name":
              return "\\k<" + (node.referenceRaw || node.reference) + ">";
            default:
              throw new TypeError("Unknown Backreference kind: " + node.kind);
          }
        },
        Assertion: function Assertion(node) {
          switch (node.kind) {
            case "^":
            case "$":
            case "\\b":
            case "\\B":
              return node.kind;
            case "Lookahead": {
              var assertion = gen(node.assertion);
              if (node.negative) {
                return "(?!" + assertion + ")";
              }
              return "(?=" + assertion + ")";
            }
            case "Lookbehind": {
              var _assertion = gen(node.assertion);
              if (node.negative) {
                return "(?<!" + _assertion + ")";
              }
              return "(?<=" + _assertion + ")";
            }
            default:
              throw new TypeError("Unknown Assertion kind: " + node.kind);
          }
        },
        CharacterClass: function CharacterClass(node) {
          var expressions = node.expressions.map(gen).join("");
          if (node.negative) {
            return "[^" + expressions + "]";
          }
          return "[" + expressions + "]";
        },
        ClassRange: function ClassRange(node) {
          return gen(node.from) + "-" + gen(node.to);
        },
        Repetition: function Repetition(node) {
          return "" + gen(node.expression) + gen(node.quantifier);
        },
        Quantifier: function Quantifier(node) {
          var quantifier = void 0;
          var greedy = node.greedy ? "" : "?";
          switch (node.kind) {
            case "+":
            case "?":
            case "*":
              quantifier = node.kind;
              break;
            case "Range":
              if (node.from === node.to) {
                quantifier = "{" + node.from + "}";
              } else if (!node.to) {
                quantifier = "{" + node.from + ",}";
              } else {
                quantifier = "{" + node.from + "," + node.to + "}";
              }
              break;
            default:
              throw new TypeError("Unknown Quantifier kind: " + node.kind);
          }
          return "" + quantifier + greedy;
        },
        Char: function Char(node) {
          var value = node.value;
          switch (node.kind) {
            case "simple": {
              if (node.escaped) {
                return "\\" + value;
              }
              return value;
            }
            case "hex":
            case "unicode":
            case "oct":
            case "decimal":
            case "control":
            case "meta":
              return value;
            default:
              throw new TypeError("Unknown Char kind: " + node.kind);
          }
        },
        UnicodeProperty: function UnicodeProperty(node) {
          var escapeChar = node.negative ? "P" : "p";
          var namePart = void 0;
          if (!node.shorthand && !node.binary) {
            namePart = node.name + "=";
          } else {
            namePart = "";
          }
          return "\\" + escapeChar + "{" + namePart + node.value + "}";
        }
      };
      module2.exports = {
        /**
         * Generates a regexp string from an AST.
         *
         * @param Object ast - an AST node
         */
        generate: gen
      };
    }
  });

  // node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js
  var require_parser_unicode_properties = __commonJS({
    "node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NON_BINARY_PROP_NAMES_TO_ALIASES = {
        General_Category: "gc",
        Script: "sc",
        Script_Extensions: "scx"
      };
      var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);
      var BINARY_PROP_NAMES_TO_ALIASES = {
        ASCII: "ASCII",
        ASCII_Hex_Digit: "AHex",
        Alphabetic: "Alpha",
        Any: "Any",
        Assigned: "Assigned",
        Bidi_Control: "Bidi_C",
        Bidi_Mirrored: "Bidi_M",
        Case_Ignorable: "CI",
        Cased: "Cased",
        Changes_When_Casefolded: "CWCF",
        Changes_When_Casemapped: "CWCM",
        Changes_When_Lowercased: "CWL",
        Changes_When_NFKC_Casefolded: "CWKCF",
        Changes_When_Titlecased: "CWT",
        Changes_When_Uppercased: "CWU",
        Dash: "Dash",
        Default_Ignorable_Code_Point: "DI",
        Deprecated: "Dep",
        Diacritic: "Dia",
        Emoji: "Emoji",
        Emoji_Component: "Emoji_Component",
        Emoji_Modifier: "Emoji_Modifier",
        Emoji_Modifier_Base: "Emoji_Modifier_Base",
        Emoji_Presentation: "Emoji_Presentation",
        Extended_Pictographic: "Extended_Pictographic",
        Extender: "Ext",
        Grapheme_Base: "Gr_Base",
        Grapheme_Extend: "Gr_Ext",
        Hex_Digit: "Hex",
        IDS_Binary_Operator: "IDSB",
        IDS_Trinary_Operator: "IDST",
        ID_Continue: "IDC",
        ID_Start: "IDS",
        Ideographic: "Ideo",
        Join_Control: "Join_C",
        Logical_Order_Exception: "LOE",
        Lowercase: "Lower",
        Math: "Math",
        Noncharacter_Code_Point: "NChar",
        Pattern_Syntax: "Pat_Syn",
        Pattern_White_Space: "Pat_WS",
        Quotation_Mark: "QMark",
        Radical: "Radical",
        Regional_Indicator: "RI",
        Sentence_Terminal: "STerm",
        Soft_Dotted: "SD",
        Terminal_Punctuation: "Term",
        Unified_Ideograph: "UIdeo",
        Uppercase: "Upper",
        Variation_Selector: "VS",
        White_Space: "space",
        XID_Continue: "XIDC",
        XID_Start: "XIDS"
      };
      var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);
      var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
        Cased_Letter: "LC",
        Close_Punctuation: "Pe",
        Connector_Punctuation: "Pc",
        Control: ["Cc", "cntrl"],
        Currency_Symbol: "Sc",
        Dash_Punctuation: "Pd",
        Decimal_Number: ["Nd", "digit"],
        Enclosing_Mark: "Me",
        Final_Punctuation: "Pf",
        Format: "Cf",
        Initial_Punctuation: "Pi",
        Letter: "L",
        Letter_Number: "Nl",
        Line_Separator: "Zl",
        Lowercase_Letter: "Ll",
        Mark: ["M", "Combining_Mark"],
        Math_Symbol: "Sm",
        Modifier_Letter: "Lm",
        Modifier_Symbol: "Sk",
        Nonspacing_Mark: "Mn",
        Number: "N",
        Open_Punctuation: "Ps",
        Other: "C",
        Other_Letter: "Lo",
        Other_Number: "No",
        Other_Punctuation: "Po",
        Other_Symbol: "So",
        Paragraph_Separator: "Zp",
        Private_Use: "Co",
        Punctuation: ["P", "punct"],
        Separator: "Z",
        Space_Separator: "Zs",
        Spacing_Mark: "Mc",
        Surrogate: "Cs",
        Symbol: "S",
        Titlecase_Letter: "Lt",
        Unassigned: "Cn",
        Uppercase_Letter: "Lu"
      };
      var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);
      var SCRIPT_VALUE_TO_ALIASES = {
        Adlam: "Adlm",
        Ahom: "Ahom",
        Anatolian_Hieroglyphs: "Hluw",
        Arabic: "Arab",
        Armenian: "Armn",
        Avestan: "Avst",
        Balinese: "Bali",
        Bamum: "Bamu",
        Bassa_Vah: "Bass",
        Batak: "Batk",
        Bengali: "Beng",
        Bhaiksuki: "Bhks",
        Bopomofo: "Bopo",
        Brahmi: "Brah",
        Braille: "Brai",
        Buginese: "Bugi",
        Buhid: "Buhd",
        Canadian_Aboriginal: "Cans",
        Carian: "Cari",
        Caucasian_Albanian: "Aghb",
        Chakma: "Cakm",
        Cham: "Cham",
        Cherokee: "Cher",
        Common: "Zyyy",
        Coptic: ["Copt", "Qaac"],
        Cuneiform: "Xsux",
        Cypriot: "Cprt",
        Cyrillic: "Cyrl",
        Deseret: "Dsrt",
        Devanagari: "Deva",
        Dogra: "Dogr",
        Duployan: "Dupl",
        Egyptian_Hieroglyphs: "Egyp",
        Elbasan: "Elba",
        Ethiopic: "Ethi",
        Georgian: "Geor",
        Glagolitic: "Glag",
        Gothic: "Goth",
        Grantha: "Gran",
        Greek: "Grek",
        Gujarati: "Gujr",
        Gunjala_Gondi: "Gong",
        Gurmukhi: "Guru",
        Han: "Hani",
        Hangul: "Hang",
        Hanifi_Rohingya: "Rohg",
        Hanunoo: "Hano",
        Hatran: "Hatr",
        Hebrew: "Hebr",
        Hiragana: "Hira",
        Imperial_Aramaic: "Armi",
        Inherited: ["Zinh", "Qaai"],
        Inscriptional_Pahlavi: "Phli",
        Inscriptional_Parthian: "Prti",
        Javanese: "Java",
        Kaithi: "Kthi",
        Kannada: "Knda",
        Katakana: "Kana",
        Kayah_Li: "Kali",
        Kharoshthi: "Khar",
        Khmer: "Khmr",
        Khojki: "Khoj",
        Khudawadi: "Sind",
        Lao: "Laoo",
        Latin: "Latn",
        Lepcha: "Lepc",
        Limbu: "Limb",
        Linear_A: "Lina",
        Linear_B: "Linb",
        Lisu: "Lisu",
        Lycian: "Lyci",
        Lydian: "Lydi",
        Mahajani: "Mahj",
        Makasar: "Maka",
        Malayalam: "Mlym",
        Mandaic: "Mand",
        Manichaean: "Mani",
        Marchen: "Marc",
        Medefaidrin: "Medf",
        Masaram_Gondi: "Gonm",
        Meetei_Mayek: "Mtei",
        Mende_Kikakui: "Mend",
        Meroitic_Cursive: "Merc",
        Meroitic_Hieroglyphs: "Mero",
        Miao: "Plrd",
        Modi: "Modi",
        Mongolian: "Mong",
        Mro: "Mroo",
        Multani: "Mult",
        Myanmar: "Mymr",
        Nabataean: "Nbat",
        New_Tai_Lue: "Talu",
        Newa: "Newa",
        Nko: "Nkoo",
        Nushu: "Nshu",
        Ogham: "Ogam",
        Ol_Chiki: "Olck",
        Old_Hungarian: "Hung",
        Old_Italic: "Ital",
        Old_North_Arabian: "Narb",
        Old_Permic: "Perm",
        Old_Persian: "Xpeo",
        Old_Sogdian: "Sogo",
        Old_South_Arabian: "Sarb",
        Old_Turkic: "Orkh",
        Oriya: "Orya",
        Osage: "Osge",
        Osmanya: "Osma",
        Pahawh_Hmong: "Hmng",
        Palmyrene: "Palm",
        Pau_Cin_Hau: "Pauc",
        Phags_Pa: "Phag",
        Phoenician: "Phnx",
        Psalter_Pahlavi: "Phlp",
        Rejang: "Rjng",
        Runic: "Runr",
        Samaritan: "Samr",
        Saurashtra: "Saur",
        Sharada: "Shrd",
        Shavian: "Shaw",
        Siddham: "Sidd",
        SignWriting: "Sgnw",
        Sinhala: "Sinh",
        Sogdian: "Sogd",
        Sora_Sompeng: "Sora",
        Soyombo: "Soyo",
        Sundanese: "Sund",
        Syloti_Nagri: "Sylo",
        Syriac: "Syrc",
        Tagalog: "Tglg",
        Tagbanwa: "Tagb",
        Tai_Le: "Tale",
        Tai_Tham: "Lana",
        Tai_Viet: "Tavt",
        Takri: "Takr",
        Tamil: "Taml",
        Tangut: "Tang",
        Telugu: "Telu",
        Thaana: "Thaa",
        Thai: "Thai",
        Tibetan: "Tibt",
        Tifinagh: "Tfng",
        Tirhuta: "Tirh",
        Ugaritic: "Ugar",
        Vai: "Vaii",
        Warang_Citi: "Wara",
        Yi: "Yiii",
        Zanabazar_Square: "Zanb"
      };
      var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);
      function inverseMap(data) {
        var inverse = {};
        for (var name in data) {
          if (!data.hasOwnProperty(name)) {
            continue;
          }
          var value = data[name];
          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              inverse[value[i]] = name;
            }
          } else {
            inverse[value] = name;
          }
        }
        return inverse;
      }
      function isValidName(name) {
        return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
      }
      function isValidValue(name, value) {
        if (isGeneralCategoryName(name)) {
          return isGeneralCategoryValue(value);
        }
        if (isScriptCategoryName(name)) {
          return isScriptCategoryValue(value);
        }
        return false;
      }
      function isAlias(name) {
        return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
      }
      function isGeneralCategoryName(name) {
        return name === "General_Category" || name == "gc";
      }
      function isScriptCategoryName(name) {
        return name === "Script" || name === "Script_Extensions" || name === "sc" || name === "scx";
      }
      function isGeneralCategoryValue(value) {
        return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
      }
      function isScriptCategoryValue(value) {
        return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
      }
      function isBinaryPropertyName(name) {
        return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
      }
      function getCanonicalName(name) {
        if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
          return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
        }
        if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
          return BINARY_ALIASES_TO_PROP_NAMES[name];
        }
        return null;
      }
      function getCanonicalValue(value) {
        if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
          return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
        }
        if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
          return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
        }
        if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
          return BINARY_ALIASES_TO_PROP_NAMES[value];
        }
        return null;
      }
      module2.exports = {
        isAlias,
        isValidName,
        isValidValue,
        isGeneralCategoryValue,
        isScriptCategoryValue,
        isBinaryPropertyName,
        getCanonicalName,
        getCanonicalValue,
        NON_BINARY_PROP_NAMES_TO_ALIASES,
        NON_BINARY_ALIASES_TO_PROP_NAMES,
        BINARY_PROP_NAMES_TO_ALIASES,
        BINARY_ALIASES_TO_PROP_NAMES,
        GENERAL_CATEGORY_VALUE_TO_ALIASES,
        GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,
        SCRIPT_VALUE_TO_ALIASES,
        SCRIPT_VALUE_ALIASES_TO_VALUE
      };
    }
  });

  // node_modules/regexp-tree/dist/parser/generated/regexp-tree.js
  var require_regexp_tree = __commonJS({
    "node_modules/regexp-tree/dist/parser/generated/regexp-tree.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var yytext = void 0;
      var yyleng = void 0;
      var yy = {};
      var __ = void 0;
      var __loc = void 0;
      function yyloc(start, end) {
        if (!yy.options.captureLocations) {
          return null;
        }
        if (!start || !end) {
          return start || end;
        }
        return {
          startOffset: start.startOffset,
          endOffset: end.endOffset,
          startLine: start.startLine,
          endLine: end.endLine,
          startColumn: start.startColumn,
          endColumn: end.endColumn
        };
      }
      var EOF = "$";
      var productions = [[-1, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [0, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
        __loc = yyloc(_1loc, _4loc);
        __ = Node2({
          type: "RegExp",
          body: _2,
          flags: checkFlags(_4)
        }, loc(_1loc, _4loc || _3loc));
      }], [1, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [1, 0, function() {
        __loc = null;
        __ = "";
      }], [2, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [2, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        __ = _1 + _2;
      }], [3, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [4, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [4, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        var _loc = null;
        if (_2loc) {
          _loc = loc(_1loc || _2loc, _3loc || _2loc);
        }
        ;
        __ = Node2({
          type: "Disjunction",
          left: _1,
          right: _3
        }, _loc);
      }], [5, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        if (_1.length === 0) {
          __ = null;
          return;
        }
        if (_1.length === 1) {
          __ = Node2(_1[0], __loc);
        } else {
          __ = Node2({
            type: "Alternative",
            expressions: _1
          }, __loc);
        }
      }], [6, 0, function() {
        __loc = null;
        __ = [];
      }], [6, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        __ = _1.concat(_2);
      }], [7, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Node2(Object.assign({ type: "Assertion" }, _1), __loc);
      }], [7, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        __ = _1;
        if (_2) {
          __ = Node2({
            type: "Repetition",
            expression: _1,
            quantifier: _2
          }, __loc);
        }
      }], [8, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = { kind: "^" };
      }], [8, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = { kind: "$" };
      }], [8, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = { kind: "\\b" };
      }], [8, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = { kind: "\\B" };
      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = {
          kind: "Lookahead",
          assertion: _2
        };
      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = {
          kind: "Lookahead",
          negative: true,
          assertion: _2
        };
      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = {
          kind: "Lookbehind",
          assertion: _2
        };
      }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = {
          kind: "Lookbehind",
          negative: true,
          assertion: _2
        };
      }], [9, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [9, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [9, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "simple", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1.slice(1), "simple", __loc);
        __.escaped = true;
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "unicode", __loc);
        __.isSurrogatePair = true;
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "unicode", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = UnicodeProperty(_1, __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "control", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "hex", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "oct", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = GroupRefOrDecChar(_1, __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "meta", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "meta", __loc);
      }], [10, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = NamedGroupRefOrChars(_1, _1loc);
      }], [11, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [11, 0], [12, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [12, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        _1.greedy = false;
        __ = _1;
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Node2({
          type: "Quantifier",
          kind: _1,
          greedy: true
        }, __loc);
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Node2({
          type: "Quantifier",
          kind: _1,
          greedy: true
        }, __loc);
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Node2({
          type: "Quantifier",
          kind: _1,
          greedy: true
        }, __loc);
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        var range = getRange(_1);
        __ = Node2({
          type: "Quantifier",
          kind: "Range",
          from: range[0],
          to: range[0],
          greedy: true
        }, __loc);
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Node2({
          type: "Quantifier",
          kind: "Range",
          from: getRange(_1)[0],
          greedy: true
        }, __loc);
      }], [13, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        var range = getRange(_1);
        __ = Node2({
          type: "Quantifier",
          kind: "Range",
          from: range[0],
          to: range[1],
          greedy: true
        }, __loc);
      }], [14, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [14, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        var nameRaw = String(_1);
        var name = decodeUnicodeGroupName(nameRaw);
        if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
          throw new SyntaxError('Duplicate of the named group "' + name + '".');
        }
        namedGroups[name] = _1.groupNumber;
        __ = Node2({
          type: "Group",
          capturing: true,
          name,
          nameRaw,
          number: _1.groupNumber,
          expression: _2
        }, __loc);
      }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = Node2({
          type: "Group",
          capturing: true,
          number: _1.groupNumber,
          expression: _2
        }, __loc);
      }], [16, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = Node2({
          type: "Group",
          capturing: false,
          expression: _2
        }, __loc);
      }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = Node2({
          type: "CharacterClass",
          negative: true,
          expressions: _2
        }, __loc);
      }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
        __loc = yyloc(_1loc, _3loc);
        __ = Node2({
          type: "CharacterClass",
          expressions: _2
        }, __loc);
      }], [18, 0, function() {
        __loc = null;
        __ = [];
      }], [18, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [19, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = [_1];
      }], [19, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        __ = [_1].concat(_2);
      }], [19, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
        __loc = yyloc(_1loc, _4loc);
        checkClassRange(_1, _3);
        __ = [Node2({
          type: "ClassRange",
          from: _1,
          to: _3
        }, loc(_1loc, _3loc))];
        if (_4) {
          __ = __.concat(_4);
        }
      }], [20, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [20, 2, function(_1, _2, _1loc, _2loc) {
        __loc = yyloc(_1loc, _2loc);
        __ = [_1].concat(_2);
      }], [20, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
        __loc = yyloc(_1loc, _4loc);
        checkClassRange(_1, _3);
        __ = [Node2({
          type: "ClassRange",
          from: _1,
          to: _3
        }, loc(_1loc, _3loc))];
        if (_4) {
          __ = __.concat(_4);
        }
      }], [21, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "simple", __loc);
      }], [21, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [22, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = _1;
      }], [22, 1, function(_1, _1loc) {
        __loc = yyloc(_1loc, _1loc);
        __ = Char(_1, "meta", __loc);
      }]];
      var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };
      var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];
      var stack = [];
      var tokenizer = void 0;
      var lexRules = [[/^#[^\n]+/, function() {
      }], [/^\s+/, function() {
      }], [/^-/, function() {
        return "DASH";
      }], [/^\//, function() {
        return "CHAR";
      }], [/^#/, function() {
        return "CHAR";
      }], [/^\|/, function() {
        return "CHAR";
      }], [/^\./, function() {
        return "CHAR";
      }], [/^\{/, function() {
        return "CHAR";
      }], [/^\{\d+\}/, function() {
        return "RANGE_EXACT";
      }], [/^\{\d+,\}/, function() {
        return "RANGE_OPEN";
      }], [/^\{\d+,\d+\}/, function() {
        return "RANGE_CLOSED";
      }], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
        var groupName = yytext.slice(3, -1);
        validateUnicodeGroupName(groupName, this.getCurrentState());
        return "NAMED_GROUP_REF";
      }], [/^\\b/, function() {
        return "ESC_b";
      }], [/^\\B/, function() {
        return "ESC_B";
      }], [/^\\c[a-zA-Z]/, function() {
        return "CTRL_CH";
      }], [/^\\0\d{1,2}/, function() {
        return "OCT_CODE";
      }], [/^\\0/, function() {
        return "DEC_CODE";
      }], [/^\\\d{1,3}/, function() {
        return "DEC_CODE";
      }], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function() {
        return "U_CODE_SURROGATE";
      }], [/^\\u\{[0-9a-fA-F]{1,}\}/, function() {
        return "U_CODE";
      }], [/^\\u[0-9a-fA-F]{4}/, function() {
        return "U_CODE";
      }], [/^\\[pP]\{\w+(?:=\w+)?\}/, function() {
        return "U_PROP_VALUE_EXP";
      }], [/^\\x[0-9a-fA-F]{2}/, function() {
        return "HEX_CODE";
      }], [/^\\[tnrdDsSwWvf]/, function() {
        return "META_CHAR";
      }], [/^\\\//, function() {
        return "ESC_CHAR";
      }], [/^\\[ #]/, function() {
        return "ESC_CHAR";
      }], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function() {
        return "ESC_CHAR";
      }], [/^\\[^*?+\[()\\|]/, function() {
        var s = this.getCurrentState();
        if (s === "u_class" && yytext === "\\-") {
          return "ESC_CHAR";
        } else if (s === "u" || s === "xu" || s === "u_class") {
          throw new SyntaxError("invalid Unicode escape " + yytext);
        }
        return "ESC_CHAR";
      }], [/^\(/, function() {
        return "CHAR";
      }], [/^\)/, function() {
        return "CHAR";
      }], [/^\(\?=/, function() {
        return "POS_LA_ASSERT";
      }], [/^\(\?!/, function() {
        return "NEG_LA_ASSERT";
      }], [/^\(\?<=/, function() {
        return "POS_LB_ASSERT";
      }], [/^\(\?<!/, function() {
        return "NEG_LB_ASSERT";
      }], [/^\(\?:/, function() {
        return "NON_CAPTURE_GROUP";
      }], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
        yytext = yytext.slice(3, -1);
        validateUnicodeGroupName(yytext, this.getCurrentState());
        return "NAMED_CAPTURE_GROUP";
      }], [/^\(/, function() {
        return "L_PAREN";
      }], [/^\)/, function() {
        return "R_PAREN";
      }], [/^[*?+[^$]/, function() {
        return "CHAR";
      }], [/^\\\]/, function() {
        return "ESC_CHAR";
      }], [/^\]/, function() {
        this.popState();
        return "R_BRACKET";
      }], [/^\^/, function() {
        return "BOS";
      }], [/^\$/, function() {
        return "EOS";
      }], [/^\*/, function() {
        return "STAR";
      }], [/^\?/, function() {
        return "Q_MARK";
      }], [/^\+/, function() {
        return "PLUS";
      }], [/^\|/, function() {
        return "BAR";
      }], [/^\./, function() {
        return "ANY";
      }], [/^\//, function() {
        return "SLASH";
      }], [/^[^*?+\[()\\|]/, function() {
        return "CHAR";
      }], [/^\[\^/, function() {
        var s = this.getCurrentState();
        this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
        return "NEG_CLASS";
      }], [/^\[/, function() {
        var s = this.getCurrentState();
        this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
        return "L_BRACKET";
      }]];
      var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };
      var EOF_TOKEN = {
        type: EOF,
        value: ""
      };
      tokenizer = {
        initString: function initString(string) {
          this._string = string;
          this._cursor = 0;
          this._states = ["INITIAL"];
          this._tokensQueue = [];
          this._currentLine = 1;
          this._currentColumn = 0;
          this._currentLineBeginOffset = 0;
          this._tokenStartOffset = 0;
          this._tokenEndOffset = 0;
          this._tokenStartLine = 1;
          this._tokenEndLine = 1;
          this._tokenStartColumn = 0;
          this._tokenEndColumn = 0;
          return this;
        },
        /**
         * Returns tokenizer states.
         */
        getStates: function getStates() {
          return this._states;
        },
        getCurrentState: function getCurrentState() {
          return this._states[this._states.length - 1];
        },
        pushState: function pushState(state) {
          this._states.push(state);
        },
        begin: function begin(state) {
          this.pushState(state);
        },
        popState: function popState() {
          if (this._states.length > 1) {
            return this._states.pop();
          }
          return this._states[0];
        },
        getNextToken: function getNextToken() {
          if (this._tokensQueue.length > 0) {
            return this.onToken(this._toToken(this._tokensQueue.shift()));
          }
          if (!this.hasMoreTokens()) {
            return this.onToken(EOF_TOKEN);
          }
          var string = this._string.slice(this._cursor);
          var lexRulesForState = lexRulesByConditions[this.getCurrentState()];
          for (var i = 0; i < lexRulesForState.length; i++) {
            var lexRuleIndex = lexRulesForState[i];
            var lexRule = lexRules[lexRuleIndex];
            var matched = this._match(string, lexRule[0]);
            if (string === "" && matched === "") {
              this._cursor++;
            }
            if (matched !== null) {
              yytext = matched;
              yyleng = yytext.length;
              var token = lexRule[1].call(this);
              if (!token) {
                return this.getNextToken();
              }
              if (Array.isArray(token)) {
                var tokensToQueue = token.slice(1);
                token = token[0];
                if (tokensToQueue.length > 0) {
                  var _tokensQueue;
                  (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray(tokensToQueue));
                }
              }
              return this.onToken(this._toToken(token, yytext));
            }
          }
          if (this.isEOF()) {
            this._cursor++;
            return EOF_TOKEN;
          }
          this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
        },
        /**
         * Throws default "Unexpected token" exception, showing the actual
         * line from the source, pointing with the ^ marker to the bad token.
         * In addition, shows `line:column` location.
         */
        throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
          var lineSource = this._string.split("\n")[line - 1];
          var lineData = "";
          if (lineSource) {
            var pad = " ".repeat(column);
            lineData = "\n\n" + lineSource + "\n" + pad + "^\n";
          }
          throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ("at " + line + ":" + column + "."));
        },
        getCursor: function getCursor() {
          return this._cursor;
        },
        getCurrentLine: function getCurrentLine() {
          return this._currentLine;
        },
        getCurrentColumn: function getCurrentColumn() {
          return this._currentColumn;
        },
        _captureLocation: function _captureLocation(matched) {
          var nlRe = /\n/g;
          this._tokenStartOffset = this._cursor;
          this._tokenStartLine = this._currentLine;
          this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;
          var nlMatch = void 0;
          while ((nlMatch = nlRe.exec(matched)) !== null) {
            this._currentLine++;
            this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
          }
          this._tokenEndOffset = this._cursor + matched.length;
          this._tokenEndLine = this._currentLine;
          this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
        },
        _toToken: function _toToken(tokenType) {
          var yytext2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return {
            // Basic data.
            type: tokenType,
            value: yytext2,
            // Location data.
            startOffset: this._tokenStartOffset,
            endOffset: this._tokenEndOffset,
            startLine: this._tokenStartLine,
            endLine: this._tokenEndLine,
            startColumn: this._tokenStartColumn,
            endColumn: this._tokenEndColumn
          };
        },
        isEOF: function isEOF() {
          return this._cursor === this._string.length;
        },
        hasMoreTokens: function hasMoreTokens() {
          return this._cursor <= this._string.length;
        },
        _match: function _match(string, regexp) {
          var matched = string.match(regexp);
          if (matched) {
            this._captureLocation(matched[0]);
            this._cursor += matched[0].length;
            return matched[0];
          }
          return null;
        },
        /**
         * Allows analyzing, and transforming token. Default implementation
         * just passes the token through.
         */
        onToken: function onToken(token) {
          return token;
        }
      };
      yy.lexer = tokenizer;
      yy.tokenizer = tokenizer;
      yy.options = {
        captureLocations: true
      };
      var yyparse = {
        /**
         * Sets global parsing options.
         */
        setOptions: function setOptions(options) {
          yy.options = options;
          return this;
        },
        /**
         * Returns parsing options.
         */
        getOptions: function getOptions() {
          return yy.options;
        },
        /**
         * Parses a string.
         */
        parse: function parse(string, parseOptions) {
          if (!tokenizer) {
            throw new Error("Tokenizer instance wasn't specified.");
          }
          tokenizer.initString(string);
          var globalOptions = yy.options;
          if (parseOptions) {
            yy.options = Object.assign({}, yy.options, parseOptions);
          }
          yyparse.onParseBegin(string, tokenizer, yy.options);
          stack.length = 0;
          stack.push(0);
          var token = tokenizer.getNextToken();
          var shiftedToken = null;
          do {
            if (!token) {
              yy.options = globalOptions;
              unexpectedEndOfInput();
            }
            var state = stack[stack.length - 1];
            var column = tokens[token.type];
            if (!table[state].hasOwnProperty(column)) {
              yy.options = globalOptions;
              unexpectedToken(token);
            }
            var entry = table[state][column];
            if (entry[0] === "s") {
              var _loc2 = null;
              if (yy.options.captureLocations) {
                _loc2 = {
                  startOffset: token.startOffset,
                  endOffset: token.endOffset,
                  startLine: token.startLine,
                  endLine: token.endLine,
                  startColumn: token.startColumn,
                  endColumn: token.endColumn
                };
              }
              shiftedToken = this.onShift(token);
              stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));
              token = tokenizer.getNextToken();
            } else if (entry[0] === "r") {
              var productionNumber = entry.slice(1);
              var production = productions[productionNumber];
              var hasSemanticAction = typeof production[2] === "function";
              var semanticValueArgs = hasSemanticAction ? [] : null;
              var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;
              if (production[1] !== 0) {
                var rhsLength = production[1];
                while (rhsLength-- > 0) {
                  stack.pop();
                  var stackEntry = stack.pop();
                  if (hasSemanticAction) {
                    semanticValueArgs.unshift(stackEntry.semanticValue);
                    if (locationArgs) {
                      locationArgs.unshift(stackEntry.loc);
                    }
                  }
                }
              }
              var reduceStackEntry = { symbol: production[0] };
              if (hasSemanticAction) {
                yytext = shiftedToken ? shiftedToken.value : null;
                yyleng = shiftedToken ? shiftedToken.value.length : null;
                var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;
                production[2].apply(production, _toConsumableArray(semanticActionArgs));
                reduceStackEntry.semanticValue = __;
                if (locationArgs) {
                  reduceStackEntry.loc = __loc;
                }
              }
              var nextState = stack[stack.length - 1];
              var symbolToReduceWith = production[0];
              stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
            } else if (entry === "acc") {
              stack.pop();
              var parsed = stack.pop();
              if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
                yy.options = globalOptions;
                unexpectedToken(token);
              }
              if (parsed.hasOwnProperty("semanticValue")) {
                yy.options = globalOptions;
                yyparse.onParseEnd(parsed.semanticValue);
                return parsed.semanticValue;
              }
              yyparse.onParseEnd();
              yy.options = globalOptions;
              return true;
            }
          } while (tokenizer.hasMoreTokens() || stack.length > 1);
        },
        setTokenizer: function setTokenizer(customTokenizer) {
          tokenizer = customTokenizer;
          return yyparse;
        },
        getTokenizer: function getTokenizer() {
          return tokenizer;
        },
        onParseBegin: function onParseBegin(string, tokenizer2, options) {
        },
        onParseEnd: function onParseEnd(parsed) {
        },
        /**
         * Allows analyzing, and transforming shifted token. Default implementation
         * just passes the token through.
         */
        onShift: function onShift(token) {
          return token;
        }
      };
      var capturingGroupsCount = 0;
      var namedGroups = {};
      var parsingString = "";
      yyparse.onParseBegin = function(string, lexer) {
        parsingString = string;
        capturingGroupsCount = 0;
        namedGroups = {};
        var lastSlash = string.lastIndexOf("/");
        var flags = string.slice(lastSlash);
        if (flags.includes("x") && flags.includes("u")) {
          lexer.pushState("xu");
        } else {
          if (flags.includes("x")) {
            lexer.pushState("x");
          }
          if (flags.includes("u")) {
            lexer.pushState("u");
          }
        }
      };
      yyparse.onShift = function(token) {
        if (token.type === "L_PAREN" || token.type === "NAMED_CAPTURE_GROUP") {
          token.value = new String(token.value);
          token.value.groupNumber = ++capturingGroupsCount;
        }
        return token;
      };
      function getRange(text) {
        var range = text.match(/\d+/g).map(Number);
        if (Number.isFinite(range[1]) && range[1] < range[0]) {
          throw new SyntaxError("Numbers out of order in " + text + " quantifier");
        }
        return range;
      }
      function checkClassRange(from, to) {
        if (from.kind === "control" || to.kind === "control" || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
          throw new SyntaxError("Range " + from.value + "-" + to.value + " out of order in character class");
        }
      }
      var unicodeProperties = require_parser_unicode_properties();
      function UnicodeProperty(matched, loc2) {
        var negative = matched[1] === "P";
        var separatorIdx = matched.indexOf("=");
        var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
        var value = void 0;
        var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);
        var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);
        if (isShorthand) {
          value = name;
          name = "General_Category";
        } else if (isBinaryProperty) {
          value = name;
        } else {
          if (!unicodeProperties.isValidName(name)) {
            throw new SyntaxError("Invalid unicode property name: " + name + ".");
          }
          value = matched.slice(separatorIdx + 1, -1);
          if (!unicodeProperties.isValidValue(name, value)) {
            throw new SyntaxError("Invalid " + name + " unicode property value: " + value + ".");
          }
        }
        return Node2({
          type: "UnicodeProperty",
          name,
          value,
          negative,
          shorthand: isShorthand,
          binary: isBinaryProperty,
          canonicalName: unicodeProperties.getCanonicalName(name) || name,
          canonicalValue: unicodeProperties.getCanonicalValue(value) || value
        }, loc2);
      }
      function Char(value, kind, loc2) {
        var symbol = void 0;
        var codePoint = void 0;
        switch (kind) {
          case "decimal": {
            codePoint = Number(value.slice(1));
            symbol = String.fromCodePoint(codePoint);
            break;
          }
          case "oct": {
            codePoint = parseInt(value.slice(1), 8);
            symbol = String.fromCodePoint(codePoint);
            break;
          }
          case "hex":
          case "unicode": {
            if (value.lastIndexOf("\\u") > 0) {
              var _value$split$slice = value.split("\\u").slice(1), _value$split$slice2 = _slicedToArray(_value$split$slice, 2), lead = _value$split$slice2[0], trail = _value$split$slice2[1];
              lead = parseInt(lead, 16);
              trail = parseInt(trail, 16);
              codePoint = (lead - 55296) * 1024 + (trail - 56320) + 65536;
              symbol = String.fromCodePoint(codePoint);
            } else {
              var hex = value.slice(2).replace("{", "");
              codePoint = parseInt(hex, 16);
              if (codePoint > 1114111) {
                throw new SyntaxError("Bad character escape sequence: " + value);
              }
              symbol = String.fromCodePoint(codePoint);
            }
            break;
          }
          case "meta": {
            switch (value) {
              case "\\t":
                symbol = "	";
                codePoint = symbol.codePointAt(0);
                break;
              case "\\n":
                symbol = "\n";
                codePoint = symbol.codePointAt(0);
                break;
              case "\\r":
                symbol = "\r";
                codePoint = symbol.codePointAt(0);
                break;
              case "\\v":
                symbol = "\v";
                codePoint = symbol.codePointAt(0);
                break;
              case "\\f":
                symbol = "\f";
                codePoint = symbol.codePointAt(0);
                break;
              case "\\b":
                symbol = "\b";
                codePoint = symbol.codePointAt(0);
              case "\\0":
                symbol = "\0";
                codePoint = 0;
              case ".":
                symbol = ".";
                codePoint = NaN;
                break;
              default:
                codePoint = NaN;
            }
            break;
          }
          case "simple": {
            symbol = value;
            codePoint = symbol.codePointAt(0);
            break;
          }
        }
        return Node2({
          type: "Char",
          value,
          kind,
          symbol,
          codePoint
        }, loc2);
      }
      var validFlags = "gimsuxy";
      function checkFlags(flags) {
        var seen = /* @__PURE__ */ new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var flag = _step.value;
            if (seen.has(flag) || !validFlags.includes(flag)) {
              throw new SyntaxError("Invalid flags: " + flags);
            }
            seen.add(flag);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return flags.split("").sort().join("");
      }
      function GroupRefOrDecChar(text, textLoc) {
        var reference = Number(text.slice(1));
        if (reference > 0 && reference <= capturingGroupsCount) {
          return Node2({
            type: "Backreference",
            kind: "number",
            number: reference,
            reference
          }, textLoc);
        }
        return Char(text, "decimal", textLoc);
      }
      var uReStart = /^\\u[0-9a-fA-F]{4}/;
      var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/;
      var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/;
      function validateUnicodeGroupName(name, state) {
        var isUnicodeName = ucpReAnywhere.test(name);
        var isUnicodeState = state === "u" || state === "xu" || state === "u_class";
        if (isUnicodeName && !isUnicodeState) {
          throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
        }
        return name;
      }
      var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;
      function decodeUnicodeGroupName(name) {
        return name.replace(new RegExp(uidRe, "g"), function(_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
          if (leadSurrogate) {
            return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
          }
          if (leadSurrogateOnly) {
            return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
          }
          if (trailSurrogateOnly) {
            return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
          }
          if (nonSurrogate) {
            return String.fromCodePoint(parseInt(nonSurrogate, 16));
          }
          if (codePoint) {
            return String.fromCodePoint(parseInt(codePoint, 16));
          }
          return _;
        });
      }
      function NamedGroupRefOrChars(text, textLoc) {
        var referenceRaw = text.slice(3, -1);
        var reference = decodeUnicodeGroupName(referenceRaw);
        if (namedGroups.hasOwnProperty(reference)) {
          return Node2({
            type: "Backreference",
            kind: "name",
            number: namedGroups[reference],
            reference,
            referenceRaw
          }, textLoc);
        }
        var startOffset = null;
        var startLine = null;
        var endLine = null;
        var startColumn = null;
        if (textLoc) {
          startOffset = textLoc.startOffset;
          startLine = textLoc.startLine;
          endLine = textLoc.endLine;
          startColumn = textLoc.startColumn;
        }
        var charRe = /^[\w$<>]/;
        var loc2 = void 0;
        var chars = [
          // Init to first \k, taking 2 symbols.
          Char(text.slice(1, 2), "simple", startOffset ? {
            startLine,
            endLine,
            startColumn,
            startOffset,
            endOffset: startOffset += 2,
            endColumn: startColumn += 2
          } : null)
        ];
        chars[0].escaped = true;
        text = text.slice(2);
        while (text.length > 0) {
          var matched = null;
          if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
            if (startOffset) {
              loc2 = {
                startLine,
                endLine,
                startColumn,
                startOffset,
                endOffset: startOffset += matched[0].length,
                endColumn: startColumn += matched[0].length
              };
            }
            chars.push(Char(matched[0], "unicode", loc2));
            text = text.slice(matched[0].length);
          } else if (matched = text.match(charRe)) {
            if (startOffset) {
              loc2 = {
                startLine,
                endLine,
                startColumn,
                startOffset,
                endOffset: ++startOffset,
                endColumn: ++startColumn
              };
            }
            chars.push(Char(matched[0], "simple", loc2));
            text = text.slice(1);
          }
        }
        return chars;
      }
      function Node2(node, loc2) {
        if (yy.options.captureLocations) {
          node.loc = {
            source: parsingString.slice(loc2.startOffset, loc2.endOffset),
            start: {
              line: loc2.startLine,
              column: loc2.startColumn,
              offset: loc2.startOffset
            },
            end: {
              line: loc2.endLine,
              column: loc2.endColumn,
              offset: loc2.endOffset
            }
          };
        }
        return node;
      }
      function loc(start, end) {
        if (!yy.options.captureLocations) {
          return null;
        }
        return {
          startOffset: start.startOffset,
          endOffset: end.endOffset,
          startLine: start.startLine,
          endLine: end.endLine,
          startColumn: start.startColumn,
          endColumn: end.endColumn
        };
      }
      function unexpectedToken(token) {
        if (token.type === EOF) {
          unexpectedEndOfInput();
        }
        tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
      }
      function unexpectedEndOfInput() {
        parseError("Unexpected end of input.");
      }
      function parseError(message) {
        throw new SyntaxError(message);
      }
      module2.exports = yyparse;
    }
  });

  // node_modules/regexp-tree/dist/parser/index.js
  var require_parser2 = __commonJS({
    "node_modules/regexp-tree/dist/parser/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var regexpTreeParser = require_regexp_tree();
      var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);
      regexpTreeParser.parse = function(regexp, options) {
        return generatedParseFn("" + regexp, options);
      };
      regexpTreeParser.setOptions({ captureLocations: false });
      module2.exports = regexpTreeParser;
    }
  });

  // node_modules/regexp-tree/dist/traverse/node-path.js
  var require_node_path = __commonJS({
    "node_modules/regexp-tree/dist/traverse/node-path.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var DEFAULT_COLLECTION_PROP = "expressions";
      var DEFAULT_SINGLE_PROP = "expression";
      var NodePath = function() {
        function NodePath2(node) {
          var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          _classCallCheck(this, NodePath2);
          this.node = node;
          this.parentPath = parentPath;
          this.parent = parentPath ? parentPath.node : null;
          this.property = property;
          this.index = index2;
        }
        _createClass(NodePath2, [{
          key: "_enforceProp",
          value: function _enforceProp(property) {
            if (!this.node.hasOwnProperty(property)) {
              throw new Error("Node of type " + this.node.type + ` doesn't have "` + property + '" collection.');
            }
          }
          /**
           * Sets a node into a children collection or the single child.
           * By default child nodes are supposed to be under `expressions` property.
           * An explicit property can be passed.
           *
           * @param Object node - a node to set into a collection or as single child
           * @param number index - index at which to set
           * @param string property - name of the collection or single property
           */
        }, {
          key: "setChild",
          value: function setChild(node) {
            var index2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var childPath = void 0;
            if (index2 != null) {
              if (!property) {
                property = DEFAULT_COLLECTION_PROP;
              }
              this._enforceProp(property);
              this.node[property][index2] = node;
              childPath = NodePath2.getForNode(node, this, property, index2);
            } else {
              if (!property) {
                property = DEFAULT_SINGLE_PROP;
              }
              this._enforceProp(property);
              this.node[property] = node;
              childPath = NodePath2.getForNode(node, this, property, null);
            }
            return childPath;
          }
          /**
           * Appends a node to a children collection.
           * By default child nodes are supposed to be under `expressions` property.
           * An explicit property can be passed.
           *
           * @param Object node - a node to set into a collection or as single child
           * @param string property - name of the collection or single property
           */
        }, {
          key: "appendChild",
          value: function appendChild(node) {
            var property = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (!property) {
              property = DEFAULT_COLLECTION_PROP;
            }
            this._enforceProp(property);
            var end = this.node[property].length;
            return this.setChild(node, end, property);
          }
          /**
           * Inserts a node into a collection.
           * By default child nodes are supposed to be under `expressions` property.
           * An explicit property can be passed.
           *
           * @param Object node - a node to insert into a collection
           * @param number index - index at which to insert
           * @param string property - name of the collection property
           */
        }, {
          key: "insertChildAt",
          value: function insertChildAt(node, index2) {
            var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COLLECTION_PROP;
            this._enforceProp(property);
            this.node[property].splice(index2, 0, node);
            if (index2 <= NodePath2.getTraversingIndex()) {
              NodePath2.updateTraversingIndex(1);
            }
            this._rebuildIndex(this.node, property);
          }
          /**
           * Removes a node.
           */
        }, {
          key: "remove",
          value: function remove() {
            if (this.isRemoved()) {
              return;
            }
            NodePath2.registry.delete(this.node);
            this.node = null;
            if (!this.parent) {
              return;
            }
            if (this.index !== null) {
              this.parent[this.property].splice(this.index, 1);
              if (this.index <= NodePath2.getTraversingIndex()) {
                NodePath2.updateTraversingIndex(-1);
              }
              this._rebuildIndex(this.parent, this.property);
              this.index = null;
              this.property = null;
              return;
            }
            delete this.parent[this.property];
            this.property = null;
          }
          /**
           * Rebuilds child nodes index (used on remove/insert).
           */
        }, {
          key: "_rebuildIndex",
          value: function _rebuildIndex(parent, property) {
            var parentPath = NodePath2.getForNode(parent);
            for (var i = 0; i < parent[property].length; i++) {
              var path = NodePath2.getForNode(parent[property][i], parentPath, property, i);
              path.index = i;
            }
          }
          /**
           * Whether the path was removed.
           */
        }, {
          key: "isRemoved",
          value: function isRemoved() {
            return this.node === null;
          }
          /**
           * Replaces a node with the passed one.
           */
        }, {
          key: "replace",
          value: function replace(newNode) {
            NodePath2.registry.delete(this.node);
            this.node = newNode;
            if (!this.parent) {
              return null;
            }
            if (this.index !== null) {
              this.parent[this.property][this.index] = newNode;
            } else {
              this.parent[this.property] = newNode;
            }
            return NodePath2.getForNode(newNode, this.parentPath, this.property, this.index);
          }
          /**
           * Updates a node inline.
           */
        }, {
          key: "update",
          value: function update(nodeProps) {
            Object.assign(this.node, nodeProps);
          }
          /**
           * Returns parent.
           */
        }, {
          key: "getParent",
          value: function getParent() {
            return this.parentPath;
          }
          /**
           * Returns nth child.
           */
        }, {
          key: "getChild",
          value: function getChild() {
            var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            if (this.node.expressions) {
              return NodePath2.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
            } else if (this.node.expression && n == 0) {
              return NodePath2.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
            }
            return null;
          }
          /**
           * Whether a path node is syntactically equal to the passed one.
           *
           * NOTE: we don't rely on `source` property from the `loc` data
           * (which would be the fastest comparison), since it might be unsync
           * after several modifications. We use here simple `JSON.stringify`
           * excluding the `loc` data.
           *
           * @param NodePath other - path to compare to.
           * @return boolean
           */
        }, {
          key: "hasEqualSource",
          value: function hasEqualSource(path) {
            return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
          }
          /**
           * JSON-encodes a node skipping location.
           */
        }, {
          key: "jsonEncode",
          value: function jsonEncode() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, format = _ref.format, useLoc = _ref.useLoc;
            return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format);
          }
          /**
           * Returns previous sibling.
           */
        }, {
          key: "getPreviousSibling",
          value: function getPreviousSibling() {
            if (!this.parent || this.index == null) {
              return null;
            }
            return NodePath2.getForNode(this.parent[this.property][this.index - 1], NodePath2.getForNode(this.parent), this.property, this.index - 1);
          }
          /**
           * Returns next sibling.
           */
        }, {
          key: "getNextSibling",
          value: function getNextSibling() {
            if (!this.parent || this.index == null) {
              return null;
            }
            return NodePath2.getForNode(this.parent[this.property][this.index + 1], NodePath2.getForNode(this.parent), this.property, this.index + 1);
          }
          /**
           * Returns a NodePath instance for a node.
           *
           * The same NodePath can be reused in several places, e.g.
           * a parent node passed for all its children.
           */
        }], [{
          key: "getForNode",
          value: function getForNode(node) {
            var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
            if (!node) {
              return null;
            }
            if (!NodePath2.registry.has(node)) {
              NodePath2.registry.set(node, new NodePath2(node, parentPath, prop, index2 == -1 ? null : index2));
            }
            var path = NodePath2.registry.get(node);
            if (parentPath !== null) {
              path.parentPath = parentPath;
              path.parent = path.parentPath.node;
            }
            if (prop !== null) {
              path.property = prop;
            }
            if (index2 >= 0) {
              path.index = index2;
            }
            return path;
          }
          /**
           * Initializes the NodePath registry. The registry is a map from
           * a node to its NodePath instance.
           */
        }, {
          key: "initRegistry",
          value: function initRegistry() {
            if (!NodePath2.registry) {
              NodePath2.registry = /* @__PURE__ */ new Map();
            }
            NodePath2.registry.clear();
          }
          /**
           * Updates index of a currently traversing collection.
           */
        }, {
          key: "updateTraversingIndex",
          value: function updateTraversingIndex(dx) {
            return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1] += dx;
          }
          /**
           * Returns current traversing index.
           */
        }, {
          key: "getTraversingIndex",
          value: function getTraversingIndex() {
            return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1];
          }
        }]);
        return NodePath2;
      }();
      NodePath.initRegistry();
      NodePath.traversingIndexStack = [];
      function jsonSkipLoc(prop, value) {
        if (prop === "loc") {
          return void 0;
        }
        return value;
      }
      module2.exports = NodePath;
    }
  });

  // node_modules/regexp-tree/dist/traverse/index.js
  var require_traverse = __commonJS({
    "node_modules/regexp-tree/dist/traverse/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NodePath = require_node_path();
      function astTraverse(root) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var pre = options.pre;
        var post = options.post;
        var skipProperty = options.skipProperty;
        function visit(node, parent, prop, idx) {
          if (!node || typeof node.type !== "string") {
            return;
          }
          var res = void 0;
          if (pre) {
            res = pre(node, parent, prop, idx);
          }
          if (res !== false) {
            if (parent && parent[prop]) {
              if (!isNaN(idx)) {
                node = parent[prop][idx];
              } else {
                node = parent[prop];
              }
            }
            for (var _prop in node) {
              if (node.hasOwnProperty(_prop)) {
                if (skipProperty ? skipProperty(_prop, node) : _prop[0] === "$") {
                  continue;
                }
                var child = node[_prop];
                if (Array.isArray(child)) {
                  var index2 = 0;
                  NodePath.traversingIndexStack.push(index2);
                  while (index2 < child.length) {
                    visit(child[index2], node, _prop, index2);
                    index2 = NodePath.updateTraversingIndex(1);
                  }
                  NodePath.traversingIndexStack.pop();
                } else {
                  visit(child, node, _prop);
                }
              }
            }
          }
          if (post) {
            post(node, parent, prop, idx);
          }
        }
        visit(root, null);
      }
      module2.exports = {
        /**
         * Traverses an AST.
         *
         * @param Object ast - an AST node
         *
         * @param Object | Array<Object> handlers:
         *
         *   an object (or an array of objects)
         *
         *   Each such object contains a handler function per node.
         *   In case of an array of handlers, they are applied in order.
         *   A handler may return a transformed node (or a different type).
         *
         *   The per-node function may instead be an object with functions pre and post.
         *   pre is called before visiting the node, post after.
         *   If a handler is a function, it is treated as the pre function, with an empty post.
         *
         * @param Object options:
         *
         *   a config object, specifying traversal options:
         *
         *   `asNodes`: boolean - whether handlers should receives raw AST nodes
         *   (false by default), instead of a `NodePath` wrapper. Note, by default
         *   `NodePath` wrapper provides a set of convenient method to manipulate
         *   a traversing AST, and also has access to all parents list. A raw
         *   nodes traversal should be used in rare cases, when no `NodePath`
         *   features are needed.
         *
         * Special hooks:
         *
         *   - `shouldRun(ast)` - a predicate determining whether the handler
         *                        should be applied.
         *
         * NOTE: Multiple handlers are used as an optimization of applying all of
         * them in one AST traversal pass.
         */
        traverse: function traverse(ast, handlers) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { asNodes: false };
          if (!Array.isArray(handlers)) {
            handlers = [handlers];
          }
          handlers = handlers.filter(function(handler) {
            if (typeof handler.shouldRun !== "function") {
              return true;
            }
            return handler.shouldRun(ast);
          });
          NodePath.initRegistry();
          handlers.forEach(function(handler) {
            if (typeof handler.init === "function") {
              handler.init(ast);
            }
          });
          function getPathFor(node, parent, prop, index2) {
            var parentPath = NodePath.getForNode(parent);
            var nodePath = NodePath.getForNode(node, parentPath, prop, index2);
            return nodePath;
          }
          astTraverse(ast, {
            /**
             * Handler on node enter.
             */
            pre: function pre(node, parent, prop, index2) {
              var nodePath = void 0;
              if (!options.asNodes) {
                nodePath = getPathFor(node, parent, prop, index2);
              }
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var handler = _step.value;
                  if (typeof handler["*"] === "function") {
                    if (nodePath) {
                      if (!nodePath.isRemoved()) {
                        var handlerResult = handler["*"](nodePath);
                        if (handlerResult === false) {
                          return false;
                        }
                      }
                    } else {
                      handler["*"](node, parent, prop, index2);
                    }
                  }
                  var handlerFuncPre = void 0;
                  if (typeof handler[node.type] === "function") {
                    handlerFuncPre = handler[node.type];
                  } else if (typeof handler[node.type] === "object" && typeof handler[node.type].pre === "function") {
                    handlerFuncPre = handler[node.type].pre;
                  }
                  if (handlerFuncPre) {
                    if (nodePath) {
                      if (!nodePath.isRemoved()) {
                        var _handlerResult = handlerFuncPre.call(handler, nodePath);
                        if (_handlerResult === false) {
                          return false;
                        }
                      }
                    } else {
                      handlerFuncPre.call(handler, node, parent, prop, index2);
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            },
            // pre func
            /**
             * Handler on node exit.
             */
            post: function post(node, parent, prop, index2) {
              if (!node) {
                return;
              }
              var nodePath = void 0;
              if (!options.asNodes) {
                nodePath = getPathFor(node, parent, prop, index2);
              }
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var handler = _step2.value;
                  var handlerFuncPost = void 0;
                  if (typeof handler[node.type] === "object" && typeof handler[node.type].post === "function") {
                    handlerFuncPost = handler[node.type].post;
                  }
                  if (handlerFuncPost) {
                    if (nodePath) {
                      if (!nodePath.isRemoved()) {
                        var handlerResult = handlerFuncPost.call(handler, nodePath);
                        if (handlerResult === false) {
                          return false;
                        }
                      }
                    } else {
                      handlerFuncPost.call(handler, node, parent, prop, index2);
                    }
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            },
            // post func
            /**
             * Skip locations by default.
             */
            skipProperty: function skipProperty(prop) {
              return prop === "loc";
            }
          });
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/transform/index.js
  var require_transform = __commonJS({
    "node_modules/regexp-tree/dist/transform/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var generator = require_generator();
      var parser = require_parser2();
      var traverse = require_traverse();
      var TransformResult = function() {
        function TransformResult2(ast) {
          var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          _classCallCheck(this, TransformResult2);
          this._ast = ast;
          this._source = null;
          this._string = null;
          this._regexp = null;
          this._extra = extra;
        }
        _createClass(TransformResult2, [{
          key: "getAST",
          value: function getAST() {
            return this._ast;
          }
        }, {
          key: "setExtra",
          value: function setExtra(extra) {
            this._extra = extra;
          }
        }, {
          key: "getExtra",
          value: function getExtra() {
            return this._extra;
          }
        }, {
          key: "toRegExp",
          value: function toRegExp() {
            if (!this._regexp) {
              this._regexp = new RegExp(this.getSource(), this._ast.flags);
            }
            return this._regexp;
          }
        }, {
          key: "getSource",
          value: function getSource() {
            if (!this._source) {
              this._source = generator.generate(this._ast.body);
            }
            return this._source;
          }
        }, {
          key: "getFlags",
          value: function getFlags() {
            return this._ast.flags;
          }
        }, {
          key: "toString",
          value: function toString2() {
            if (!this._string) {
              this._string = generator.generate(this._ast);
            }
            return this._string;
          }
        }]);
        return TransformResult2;
      }();
      module2.exports = {
        /**
         * Expose `TransformResult`.
         */
        TransformResult,
        /**
         * Transforms a regular expression applying a set of
         * transformation handlers.
         *
         * @param string | AST | RegExp:
         *
         *   a regular expression in different representations: a string,
         *   a RegExp object, or an AST.
         *
         * @param Object | Array<Object>:
         *
         *   a handler (or a list of handlers) from `traverse` API.
         *
         * @return TransformResult instance.
         *
         * Example:
         *
         *   transform(/[a-z]/i, {
         *     onChar(path) {
         *       const {node} = path;
         *
         *       if (...) {
         *         path.remove();
         *       }
         *     }
         *   });
         */
        transform: function transform(regexp, handlers) {
          var ast = regexp;
          if (regexp instanceof RegExp) {
            regexp = "" + regexp;
          }
          if (typeof regexp === "string") {
            ast = parser.parse(regexp, {
              captureLocations: true
            });
          }
          traverse.traverse(ast, handlers);
          return new TransformResult(ast);
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/index.js
  var require_compat_transpiler = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var compatTransforms = require_transforms();
      var _transform = require_transform();
      module2.exports = {
        /**
         * Translates a regexp in new syntax to equivalent regexp in old syntax.
         *
         * @param string|RegExp|AST - regexp
         * @param Array transformsWhitelist - names of the transforms to apply
         */
        transform: function transform(regexp) {
          var transformsWhitelist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);
          var result = void 0;
          var extra = {};
          transformToApply.forEach(function(transformName) {
            if (!compatTransforms.hasOwnProperty(transformName)) {
              throw new Error("Unknown compat-transform: " + transformName + ". Available transforms are: " + Object.keys(compatTransforms).join(", "));
            }
            var handler = compatTransforms[transformName];
            result = _transform.transform(regexp, handler);
            regexp = result.getAST();
            if (typeof handler.getExtra === "function") {
              extra[transformName] = handler.getExtra();
            }
          });
          result.setExtra(extra);
          return result;
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/utils/clone.js
  var require_clone = __commonJS({
    "node_modules/regexp-tree/dist/utils/clone.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = function clone2(obj) {
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        var res = void 0;
        if (Array.isArray(obj)) {
          res = [];
        } else {
          res = {};
        }
        for (var i in obj) {
          res[i] = clone2(obj[i]);
        }
        return res;
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js
  var require_char_surrogate_pair_to_single_unicode_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        shouldRun: function shouldRun(ast) {
          return ast.flags.includes("u");
        },
        Char: function Char(path) {
          var node = path.node;
          if (node.kind !== "unicode" || !node.isSurrogatePair || isNaN(node.codePoint)) {
            return;
          }
          node.value = "\\u{" + node.codePoint.toString(16) + "}";
          delete node.isSurrogatePair;
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js
  var require_char_code_to_simple_char_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var UPPER_A_CP = "A".codePointAt(0);
      var UPPER_Z_CP = "Z".codePointAt(0);
      var LOWER_A_CP = "a".codePointAt(0);
      var LOWER_Z_CP = "z".codePointAt(0);
      var DIGIT_0_CP = "0".codePointAt(0);
      var DIGIT_9_CP = "9".codePointAt(0);
      module2.exports = {
        Char: function Char(path) {
          var node = path.node, parent = path.parent;
          if (isNaN(node.codePoint) || node.kind === "simple") {
            return;
          }
          if (parent.type === "ClassRange") {
            if (!isSimpleRange(parent)) {
              return;
            }
          }
          if (!isPrintableASCIIChar(node.codePoint)) {
            return;
          }
          var symbol = String.fromCodePoint(node.codePoint);
          var newChar = {
            type: "Char",
            kind: "simple",
            value: symbol,
            symbol,
            codePoint: node.codePoint
          };
          if (needsEscape(symbol, parent.type)) {
            newChar.escaped = true;
          }
          path.replace(newChar);
        }
      };
      function isSimpleRange(classRange) {
        var from = classRange.from, to = classRange.to;
        return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
      }
      function isPrintableASCIIChar(codePoint) {
        return codePoint >= 32 && codePoint <= 126;
      }
      function needsEscape(symbol, parentType) {
        if (parentType === "ClassRange" || parentType === "CharacterClass") {
          return /[\]\\^-]/.test(symbol);
        }
        return /[*[()+?^$./\\|{}]/.test(symbol);
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js
  var require_char_case_insensitive_lowercase_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var UPPER_A_CP = "A".codePointAt(0);
      var UPPER_Z_CP = "Z".codePointAt(0);
      module2.exports = {
        _AZClassRanges: null,
        _hasUFlag: false,
        init: function init(ast) {
          this._AZClassRanges = /* @__PURE__ */ new Set();
          this._hasUFlag = ast.flags.includes("u");
        },
        shouldRun: function shouldRun(ast) {
          return ast.flags.includes("i");
        },
        Char: function Char(path) {
          var node = path.node, parent = path.parent;
          if (isNaN(node.codePoint)) {
            return;
          }
          if (!this._hasUFlag && node.codePoint >= 4096) {
            return;
          }
          if (parent.type === "ClassRange") {
            if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
              return;
            }
            this._AZClassRanges.add(parent);
          }
          var lower = node.symbol.toLowerCase();
          if (lower !== node.symbol) {
            node.value = displaySymbolAsValue(lower, node);
            node.symbol = lower;
            node.codePoint = lower.codePointAt(0);
          }
        }
      };
      function isAZClassRange(classRange) {
        var from = classRange.from, to = classRange.to;
        return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
      }
      function displaySymbolAsValue(symbol, node) {
        var codePoint = symbol.codePointAt(0);
        if (node.kind === "decimal") {
          return "\\" + codePoint;
        }
        if (node.kind === "oct") {
          return "\\0" + codePoint.toString(8);
        }
        if (node.kind === "hex") {
          return "\\x" + codePoint.toString(16);
        }
        if (node.kind === "unicode") {
          if (node.isSurrogatePair) {
            var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint), lead = _getSurrogatePairFrom.lead, trail = _getSurrogatePairFrom.trail;
            return "\\u" + "0".repeat(4 - lead.length) + lead + "\\u" + "0".repeat(4 - trail.length) + trail;
          } else if (node.value.includes("{")) {
            return "\\u{" + codePoint.toString(16) + "}";
          } else {
            var code = codePoint.toString(16);
            return "\\u" + "0".repeat(4 - code.length) + code;
          }
        }
        return symbol;
      }
      function getSurrogatePairFromCodePoint(codePoint) {
        var lead = Math.floor((codePoint - 65536) / 1024) + 55296;
        var trail = (codePoint - 65536) % 1024 + 56320;
        return {
          lead: lead.toString(16),
          trail: trail.toString(16)
        };
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js
  var require_char_class_remove_duplicates_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        CharacterClass: function CharacterClass(path) {
          var node = path.node;
          var sources = {};
          for (var i = 0; i < node.expressions.length; i++) {
            var childPath = path.getChild(i);
            var source = childPath.jsonEncode();
            if (sources.hasOwnProperty(source)) {
              childPath.remove();
              i--;
            }
            sources[source] = true;
          }
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/transform/utils.js
  var require_utils = __commonJS({
    "node_modules/regexp-tree/dist/transform/utils.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function disjunctionToList(node) {
        if (node.type !== "Disjunction") {
          throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
        }
        var list = [];
        if (node.left && node.left.type === "Disjunction") {
          list.push.apply(list, _toConsumableArray(disjunctionToList(node.left)).concat([node.right]));
        } else {
          list.push(node.left, node.right);
        }
        return list;
      }
      function listToDisjunction(list) {
        return list.reduce(function(left, right) {
          return {
            type: "Disjunction",
            left,
            right
          };
        });
      }
      function increaseQuantifierByOne(quantifier) {
        if (quantifier.kind === "*") {
          quantifier.kind = "+";
        } else if (quantifier.kind === "+") {
          quantifier.kind = "Range";
          quantifier.from = 2;
          delete quantifier.to;
        } else if (quantifier.kind === "?") {
          quantifier.kind = "Range";
          quantifier.from = 1;
          quantifier.to = 2;
        } else if (quantifier.kind === "Range") {
          quantifier.from += 1;
          if (quantifier.to) {
            quantifier.to += 1;
          }
        }
      }
      module2.exports = {
        disjunctionToList,
        listToDisjunction,
        increaseQuantifierByOne
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js
  var require_quantifiers_merge_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _require = require_utils();
      var increaseQuantifierByOne = _require.increaseQuantifierByOne;
      module2.exports = {
        Repetition: function Repetition(path) {
          var node = path.node, parent = path.parent;
          if (parent.type !== "Alternative" || !path.index) {
            return;
          }
          var previousSibling = path.getPreviousSibling();
          if (!previousSibling) {
            return;
          }
          if (previousSibling.node.type === "Repetition") {
            if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
              return;
            }
            var _extractFromTo = extractFromTo(previousSibling.node.quantifier), previousSiblingFrom = _extractFromTo.from, previousSiblingTo = _extractFromTo.to;
            var _extractFromTo2 = extractFromTo(node.quantifier), nodeFrom = _extractFromTo2.from, nodeTo = _extractFromTo2.to;
            if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
              return;
            }
            node.quantifier.kind = "Range";
            node.quantifier.from = previousSiblingFrom + nodeFrom;
            if (previousSiblingTo && nodeTo) {
              node.quantifier.to = previousSiblingTo + nodeTo;
            } else {
              delete node.quantifier.to;
            }
            if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
              node.quantifier.greedy = true;
            }
            previousSibling.remove();
          } else {
            if (!previousSibling.hasEqualSource(path.getChild())) {
              return;
            }
            increaseQuantifierByOne(node.quantifier);
            previousSibling.remove();
          }
        }
      };
      function isGreedyOpenRange(quantifier) {
        return quantifier.greedy && (quantifier.kind === "+" || quantifier.kind === "*" || quantifier.kind === "Range" && !quantifier.to);
      }
      function extractFromTo(quantifier) {
        var from = void 0, to = void 0;
        if (quantifier.kind === "*") {
          from = 0;
        } else if (quantifier.kind === "+") {
          from = 1;
        } else if (quantifier.kind === "?") {
          from = 0;
          to = 1;
        } else {
          from = quantifier.from;
          if (quantifier.to) {
            to = quantifier.to;
          }
        }
        return { from, to };
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js
  var require_quantifier_range_to_symbol_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        Quantifier: function Quantifier(path) {
          var node = path.node;
          if (node.kind !== "Range") {
            return;
          }
          rewriteOpenZero(path);
          rewriteOpenOne(path);
          rewriteExactOne(path);
        }
      };
      function rewriteOpenZero(path) {
        var node = path.node;
        if (node.from !== 0 || node.to) {
          return;
        }
        node.kind = "*";
        delete node.from;
      }
      function rewriteOpenOne(path) {
        var node = path.node;
        if (node.from !== 1 || node.to) {
          return;
        }
        node.kind = "+";
        delete node.from;
      }
      function rewriteExactOne(path) {
        var node = path.node;
        if (node.from !== 1 || node.to !== 1) {
          return;
        }
        path.parentPath.replace(path.parentPath.node.expression);
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js
  var require_char_class_classranges_to_chars_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        ClassRange: function ClassRange(path) {
          var node = path.node;
          if (node.from.codePoint === node.to.codePoint) {
            path.replace(node.from);
          } else if (node.from.codePoint === node.to.codePoint - 1) {
            path.getParent().insertChildAt(node.to, path.index + 1);
            path.replace(node.from);
          }
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js
  var require_char_class_to_meta_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      module2.exports = {
        _hasIFlag: false,
        _hasUFlag: false,
        init: function init(ast) {
          this._hasIFlag = ast.flags.includes("i");
          this._hasUFlag = ast.flags.includes("u");
        },
        CharacterClass: function CharacterClass(path) {
          rewriteNumberRanges(path);
          rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);
          rewriteWhitespaceRanges(path);
        }
      };
      function rewriteNumberRanges(path) {
        var node = path.node;
        node.expressions.forEach(function(expression, i) {
          if (isFullNumberRange(expression)) {
            path.getChild(i).replace({
              type: "Char",
              value: "\\d",
              kind: "meta"
            });
          }
        });
      }
      function rewriteWordRanges(path, hasIFlag, hasUFlag) {
        var node = path.node;
        var numberPath = null;
        var lowerCasePath = null;
        var upperCasePath = null;
        var underscorePath = null;
        var u017fPath = null;
        var u212aPath = null;
        node.expressions.forEach(function(expression, i) {
          if (isMetaChar(expression, "\\d")) {
            numberPath = path.getChild(i);
          } else if (isLowerCaseRange(expression)) {
            lowerCasePath = path.getChild(i);
          } else if (isUpperCaseRange(expression)) {
            upperCasePath = path.getChild(i);
          } else if (isUnderscore(expression)) {
            underscorePath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 383)) {
            u017fPath = path.getChild(i);
          } else if (hasIFlag && hasUFlag && isCodePoint(expression, 8490)) {
            u212aPath = path.getChild(i);
          }
        });
        if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
          numberPath.replace({
            type: "Char",
            value: "\\w",
            kind: "meta"
          });
          if (lowerCasePath) {
            lowerCasePath.remove();
          }
          if (upperCasePath) {
            upperCasePath.remove();
          }
          underscorePath.remove();
          if (u017fPath) {
            u017fPath.remove();
          }
          if (u212aPath) {
            u212aPath.remove();
          }
        }
      }
      var whitespaceRangeTests = [function(node) {
        return isChar(node, " ");
      }].concat(_toConsumableArray(["\\f", "\\n", "\\r", "\\t", "\\v"].map(function(char) {
        return function(node) {
          return isMetaChar(node, char);
        };
      })), _toConsumableArray([160, 5760, 8232, 8233, 8239, 8287, 12288, 65279].map(function(codePoint) {
        return function(node) {
          return isCodePoint(node, codePoint);
        };
      })), [function(node) {
        return node.type === "ClassRange" && isCodePoint(node.from, 8192) && isCodePoint(node.to, 8202);
      }]);
      function rewriteWhitespaceRanges(path) {
        var node = path.node;
        if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function(test) {
          return node.expressions.some(function(expression) {
            return test(expression);
          });
        })) {
          return;
        }
        var nNode = node.expressions.find(function(expression) {
          return isMetaChar(expression, "\\n");
        });
        nNode.value = "\\s";
        nNode.symbol = void 0;
        nNode.codePoint = NaN;
        node.expressions.map(function(expression, i) {
          return whitespaceRangeTests.some(function(test) {
            return test(expression);
          }) ? path.getChild(i) : void 0;
        }).filter(Boolean).forEach(function(path2) {
          return path2.remove();
        });
      }
      function isFullNumberRange(node) {
        return node.type === "ClassRange" && node.from.value === "0" && node.to.value === "9";
      }
      function isChar(node, value) {
        var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "simple";
        return node.type === "Char" && node.value === value && node.kind === kind;
      }
      function isMetaChar(node, value) {
        return isChar(node, value, "meta");
      }
      function isLowerCaseRange(node) {
        return node.type === "ClassRange" && node.from.value === "a" && node.to.value === "z";
      }
      function isUpperCaseRange(node) {
        return node.type === "ClassRange" && node.from.value === "A" && node.to.value === "Z";
      }
      function isUnderscore(node) {
        return node.type === "Char" && node.value === "_" && node.kind === "simple";
      }
      function isCodePoint(node, codePoint) {
        return node.type === "Char" && node.kind === "unicode" && node.codePoint === codePoint;
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js
  var require_char_class_to_single_char_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        CharacterClass: function CharacterClass(path) {
          var node = path.node;
          if (node.expressions.length !== 1 || !hasAppropriateSiblings(path) || !isAppropriateChar(node.expressions[0])) {
            return;
          }
          var _node$expressions$ = node.expressions[0], value = _node$expressions$.value, kind = _node$expressions$.kind, escaped = _node$expressions$.escaped;
          if (node.negative) {
            if (!isMeta(value)) {
              return;
            }
            value = getInverseMeta(value);
          }
          path.replace({
            type: "Char",
            value,
            kind,
            escaped: escaped || shouldEscape(value)
          });
        }
      };
      function isAppropriateChar(node) {
        return node.type === "Char" && // We don't extract [\b] (backspace) since \b has different
        // semantics (word boundary).
        node.value !== "\\b";
      }
      function isMeta(value) {
        return /^\\[dwsDWS]$/.test(value);
      }
      function getInverseMeta(value) {
        return /[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase();
      }
      function hasAppropriateSiblings(path) {
        var parent = path.parent, index2 = path.index;
        if (parent.type !== "Alternative") {
          return true;
        }
        var previousNode = parent.expressions[index2 - 1];
        if (previousNode == null) {
          return true;
        }
        if (previousNode.type === "Backreference" && previousNode.kind === "number") {
          return false;
        }
        if (previousNode.type === "Char" && previousNode.kind === "decimal") {
          return false;
        }
        return true;
      }
      function shouldEscape(value) {
        return /[*[()+?$./{}|]/.test(value);
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js
  var require_char_escape_unescape_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        _hasXFlag: false,
        init: function init(ast) {
          this._hasXFlag = ast.flags.includes("x");
        },
        Char: function Char(path) {
          var node = path.node;
          if (!node.escaped) {
            return;
          }
          if (shouldUnescape(path, this._hasXFlag)) {
            delete node.escaped;
          }
        }
      };
      function shouldUnescape(path, hasXFlag) {
        var value = path.node.value, index2 = path.index, parent = path.parent;
        if (parent.type !== "CharacterClass" && parent.type !== "ClassRange") {
          return !preservesEscape(value, index2, parent, hasXFlag);
        }
        return !preservesInCharClass(value, index2, parent);
      }
      function preservesInCharClass(value, index2, parent) {
        if (value === "^") {
          return index2 === 0 && !parent.negative;
        }
        if (value === "-") {
          return true;
        }
        return /[\]\\]/.test(value);
      }
      function preservesEscape(value, index2, parent, hasXFlag) {
        if (value === "{") {
          return preservesOpeningCurlyBraceEscape(index2, parent);
        }
        if (value === "}") {
          return preservesClosingCurlyBraceEscape(index2, parent);
        }
        if (hasXFlag && /[ #]/.test(value)) {
          return true;
        }
        return /[*[()+?^$./\\|]/.test(value);
      }
      function consumeNumbers(startIndex, parent, rtl) {
        var i = startIndex;
        var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
        while (siblingNode && siblingNode.type === "Char" && siblingNode.kind === "simple" && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
          rtl ? i-- : i++;
          siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
        }
        return Math.abs(startIndex - i);
      }
      function isSimpleChar(node, value) {
        return node && node.type === "Char" && node.kind === "simple" && !node.escaped && node.value === value;
      }
      function preservesOpeningCurlyBraceEscape(index2, parent) {
        if (index2 == null) {
          return false;
        }
        var nbFollowingNumbers = consumeNumbers(index2 + 1, parent);
        var i = index2 + nbFollowingNumbers + 1;
        var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
        if (nbFollowingNumbers) {
          if (isSimpleChar(nextSiblingNode, "}")) {
            return true;
          }
          if (isSimpleChar(nextSiblingNode, ",")) {
            nbFollowingNumbers = consumeNumbers(i + 1, parent);
            i = i + nbFollowingNumbers + 1;
            nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
            return isSimpleChar(nextSiblingNode, "}");
          }
        }
        return false;
      }
      function preservesClosingCurlyBraceEscape(index2, parent) {
        if (index2 == null) {
          return false;
        }
        var nbPrecedingNumbers = consumeNumbers(index2 - 1, parent, true);
        var i = index2 - nbPrecedingNumbers - 1;
        var previousSiblingNode = i >= 0 && parent.expressions[i];
        if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{")) {
          return true;
        }
        if (isSimpleChar(previousSiblingNode, ",")) {
          nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
          i = i - nbPrecedingNumbers - 1;
          previousSiblingNode = i < parent.expressions.length && parent.expressions[i];
          return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{");
        }
        return false;
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js
  var require_char_class_classranges_merge_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        _hasIUFlags: false,
        init: function init(ast) {
          this._hasIUFlags = ast.flags.includes("i") && ast.flags.includes("u");
        },
        CharacterClass: function CharacterClass(path) {
          var node = path.node;
          var expressions = node.expressions;
          var metas = [];
          expressions.forEach(function(expression2) {
            if (isMeta(expression2)) {
              metas.push(expression2.value);
            }
          });
          expressions.sort(sortCharClass);
          for (var i = 0; i < expressions.length; i++) {
            var expression = expressions[i];
            if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
              expressions.splice(i, 1);
              i--;
            } else {
              var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
              expressions.splice(i - nbMergedChars + 1, nbMergedChars);
              i -= nbMergedChars;
            }
          }
        }
      };
      function sortCharClass(a, b) {
        var aValue = getSortValue(a);
        var bValue = getSortValue(b);
        if (aValue === bValue) {
          if (a.type === "ClassRange" && b.type !== "ClassRange") {
            return -1;
          }
          if (b.type === "ClassRange" && a.type !== "ClassRange") {
            return 1;
          }
          if (a.type === "ClassRange" && b.type === "ClassRange") {
            return getSortValue(a.to) - getSortValue(b.to);
          }
          if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
            return a.value < b.value ? -1 : 1;
          }
        }
        return aValue - bValue;
      }
      function getSortValue(expression) {
        if (expression.type === "Char") {
          if (expression.value === "-") {
            return Infinity;
          }
          if (expression.kind === "control") {
            return Infinity;
          }
          if (expression.kind === "meta" && isNaN(expression.codePoint)) {
            return -1;
          }
          return expression.codePoint;
        }
        return expression.from.codePoint;
      }
      function isMeta(expression) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        return expression.type === "Char" && expression.kind === "meta" && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
      }
      function isControl(expression) {
        return expression.type === "Char" && expression.kind === "control";
      }
      function fitsInMetas(expression, metas, hasIUFlags) {
        for (var i = 0; i < metas.length; i++) {
          if (fitsInMeta(expression, metas[i], hasIUFlags)) {
            return true;
          }
        }
        return false;
      }
      function fitsInMeta(expression, meta, hasIUFlags) {
        if (expression.type === "ClassRange") {
          return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
        }
        if (meta === "\\S" && (isMeta(expression, "\\w") || isMeta(expression, "\\d"))) {
          return true;
        }
        if (meta === "\\D" && (isMeta(expression, "\\W") || isMeta(expression, "\\s"))) {
          return true;
        }
        if (meta === "\\w" && isMeta(expression, "\\d")) {
          return true;
        }
        if (meta === "\\W" && isMeta(expression, "\\s")) {
          return true;
        }
        if (expression.type !== "Char" || isNaN(expression.codePoint)) {
          return false;
        }
        if (meta === "\\s") {
          return fitsInMetaS(expression);
        }
        if (meta === "\\S") {
          return !fitsInMetaS(expression);
        }
        if (meta === "\\d") {
          return fitsInMetaD(expression);
        }
        if (meta === "\\D") {
          return !fitsInMetaD(expression);
        }
        if (meta === "\\w") {
          return fitsInMetaW(expression, hasIUFlags);
        }
        if (meta === "\\W") {
          return !fitsInMetaW(expression, hasIUFlags);
        }
        return false;
      }
      function fitsInMetaS(expression) {
        return expression.codePoint === 9 || // \t
        expression.codePoint === 10 || // \n
        expression.codePoint === 11 || // \v
        expression.codePoint === 12 || // \f
        expression.codePoint === 13 || // \r
        expression.codePoint === 32 || // space
        expression.codePoint === 160 || // nbsp
        expression.codePoint === 5760 || // part of Zs
        expression.codePoint >= 8192 && expression.codePoint <= 8202 || // part of Zs
        expression.codePoint === 8232 || // line separator
        expression.codePoint === 8233 || // paragraph separator
        expression.codePoint === 8239 || // part of Zs
        expression.codePoint === 8287 || // part of Zs
        expression.codePoint === 12288 || // part of Zs
        expression.codePoint === 65279;
      }
      function fitsInMetaD(expression) {
        return expression.codePoint >= 48 && expression.codePoint <= 57;
      }
      function fitsInMetaW(expression, hasIUFlags) {
        return fitsInMetaD(expression) || expression.codePoint >= 65 && expression.codePoint <= 90 || // A-Z
        expression.codePoint >= 97 && expression.codePoint <= 122 || // a-z
        expression.value === "_" || hasIUFlags && (expression.codePoint === 383 || expression.codePoint === 8490);
      }
      function combinesWithPrecedingClassRange(expression, classRange) {
        if (classRange && classRange.type === "ClassRange") {
          if (fitsInClassRange(expression, classRange)) {
            return true;
          } else if (
            // We only want \w chars or char codes to keep readability
            isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1
          ) {
            classRange.to = expression;
            return true;
          } else if (expression.type === "ClassRange" && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
            if (expression.from.codePoint < classRange.from.codePoint) {
              classRange.from = expression.from;
            }
            if (expression.to.codePoint > classRange.to.codePoint) {
              classRange.to = expression.to;
            }
            return true;
          }
        }
        return false;
      }
      function combinesWithFollowingClassRange(expression, classRange) {
        if (classRange && classRange.type === "ClassRange") {
          if (
            // We only want \w chars or char codes to keep readability
            isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1
          ) {
            classRange.from = expression;
            return true;
          }
        }
        return false;
      }
      function fitsInClassRange(expression, classRange) {
        if (expression.type === "Char" && isNaN(expression.codePoint)) {
          return false;
        }
        if (expression.type === "ClassRange") {
          return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
        }
        return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
      }
      function charCombinesWithPrecedingChars(expression, index2, expressions) {
        if (!isMetaWCharOrCode(expression)) {
          return 0;
        }
        var nbMergedChars = 0;
        while (index2 > 0) {
          var currentExpression = expressions[index2];
          var precedingExpresion = expressions[index2 - 1];
          if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
            nbMergedChars++;
            index2--;
          } else {
            break;
          }
        }
        if (nbMergedChars > 1) {
          expressions[index2] = {
            type: "ClassRange",
            from: expressions[index2],
            to: expression
          };
          return nbMergedChars;
        }
        return 0;
      }
      function isMetaWCharOrCode(expression) {
        return expression && expression.type === "Char" && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === "unicode" || expression.kind === "hex" || expression.kind === "oct" || expression.kind === "decimal");
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js
  var require_disjunction_remove_duplicates_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NodePath = require_node_path();
      var _require = require_utils();
      var disjunctionToList = _require.disjunctionToList;
      var listToDisjunction = _require.listToDisjunction;
      module2.exports = {
        Disjunction: function Disjunction(path) {
          var node = path.node;
          var uniqueNodesMap = {};
          var parts = disjunctionToList(node).filter(function(part) {
            var encoded = part ? NodePath.getForNode(part).jsonEncode() : "null";
            if (uniqueNodesMap.hasOwnProperty(encoded)) {
              return false;
            }
            uniqueNodesMap[encoded] = part;
            return true;
          });
          path.replace(listToDisjunction(parts));
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js
  var require_group_single_chars_to_char_class = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        Disjunction: function Disjunction(path) {
          var node = path.node, parent = path.parent;
          if (!handlers[parent.type]) {
            return;
          }
          var charset = /* @__PURE__ */ new Map();
          if (!shouldProcess(node, charset) || !charset.size) {
            return;
          }
          var characterClass = {
            type: "CharacterClass",
            expressions: Array.from(charset.keys()).sort().map(function(key) {
              return charset.get(key);
            })
          };
          handlers[parent.type](path.getParent(), characterClass);
        }
      };
      var handlers = {
        RegExp: function RegExp2(path, characterClass) {
          var node = path.node;
          node.body = characterClass;
        },
        Group: function Group(path, characterClass) {
          var node = path.node;
          if (node.capturing) {
            node.expression = characterClass;
          } else {
            path.replace(characterClass);
          }
        }
      };
      function shouldProcess(expression, charset) {
        if (!expression) {
          return false;
        }
        var type = expression.type;
        if (type === "Disjunction") {
          var left = expression.left, right = expression.right;
          return shouldProcess(left, charset) && shouldProcess(right, charset);
        } else if (type === "Char") {
          if (expression.kind === "meta" && expression.symbol === ".") {
            return false;
          }
          var value = expression.value;
          charset.set(value, expression);
          return true;
        } else if (type === "CharacterClass" && !expression.negative) {
          return expression.expressions.every(function(expression2) {
            return shouldProcess(expression2, charset);
          });
        }
        return false;
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js
  var require_remove_empty_group_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = {
        Group: function Group(path) {
          var node = path.node, parent = path.parent;
          var childPath = path.getChild();
          if (node.capturing || childPath) {
            return;
          }
          if (parent.type === "Repetition") {
            path.getParent().replace(node);
          } else if (parent.type !== "RegExp") {
            path.remove();
          }
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js
  var require_ungroup_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      module2.exports = {
        Group: function Group(path) {
          var node = path.node, parent = path.parent;
          var childPath = path.getChild();
          if (node.capturing || !childPath) {
            return;
          }
          if (!hasAppropriateSiblings(path)) {
            return;
          }
          if (childPath.node.type === "Disjunction" && parent.type !== "RegExp") {
            return;
          }
          if (parent.type === "Repetition" && childPath.node.type !== "Char" && childPath.node.type !== "CharacterClass") {
            return;
          }
          if (childPath.node.type === "Alternative") {
            var parentPath = path.getParent();
            if (parentPath.node.type === "Alternative") {
              parentPath.replace({
                type: "Alternative",
                expressions: [].concat(_toConsumableArray(parent.expressions.slice(0, path.index)), _toConsumableArray(childPath.node.expressions), _toConsumableArray(parent.expressions.slice(path.index + 1)))
              });
            }
          } else {
            path.replace(childPath.node);
          }
        }
      };
      function hasAppropriateSiblings(path) {
        var parent = path.parent, index2 = path.index;
        if (parent.type !== "Alternative") {
          return true;
        }
        var previousNode = parent.expressions[index2 - 1];
        if (previousNode == null) {
          return true;
        }
        if (previousNode.type === "Backreference" && previousNode.kind === "number") {
          return false;
        }
        if (previousNode.type === "Char" && previousNode.kind === "decimal") {
          return false;
        }
        return true;
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js
  var require_combine_repeating_patterns_transform = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var NodePath = require_node_path();
      var _require = require_utils();
      var increaseQuantifierByOne = _require.increaseQuantifierByOne;
      module2.exports = {
        Alternative: function Alternative(path) {
          var node = path.node;
          var index2 = 1;
          while (index2 < node.expressions.length) {
            var child = path.getChild(index2);
            index2 = Math.max(1, combineRepeatingPatternLeft(path, child, index2));
            if (index2 >= node.expressions.length) {
              break;
            }
            child = path.getChild(index2);
            index2 = Math.max(1, combineWithPreviousRepetition(path, child, index2));
            if (index2 >= node.expressions.length) {
              break;
            }
            child = path.getChild(index2);
            index2 = Math.max(1, combineRepetitionWithPrevious(path, child, index2));
            index2++;
          }
        }
      };
      function combineRepeatingPatternLeft(alternative, child, index2) {
        var node = alternative.node;
        var nbPossibleLengths = Math.ceil(index2 / 2);
        var i = 0;
        while (i < nbPossibleLengths) {
          var startIndex = index2 - 2 * i - 1;
          var right = void 0, left = void 0;
          if (i === 0) {
            right = child;
            left = alternative.getChild(startIndex);
          } else {
            right = NodePath.getForNode({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(node.expressions.slice(index2 - i, index2)), [child.node])
            });
            left = NodePath.getForNode({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(node.expressions.slice(startIndex, index2 - i)))
            });
          }
          if (right.hasEqualSource(left)) {
            for (var j = 0; j < 2 * i + 1; j++) {
              alternative.getChild(startIndex).remove();
            }
            child.replace({
              type: "Repetition",
              expression: i === 0 && right.node.type !== "Repetition" ? right.node : {
                type: "Group",
                capturing: false,
                expression: right.node
              },
              quantifier: {
                type: "Quantifier",
                kind: "Range",
                from: 2,
                to: 2,
                greedy: true
              }
            });
            return startIndex;
          }
          i++;
        }
        return index2;
      }
      function combineWithPreviousRepetition(alternative, child, index2) {
        var node = alternative.node;
        var i = 0;
        while (i < index2) {
          var previousChild = alternative.getChild(i);
          if (previousChild.node.type === "Repetition" && previousChild.node.quantifier.greedy) {
            var left = previousChild.getChild();
            var right = void 0;
            if (left.node.type === "Group" && !left.node.capturing) {
              left = left.getChild();
            }
            if (i + 1 === index2) {
              right = child;
              if (right.node.type === "Group" && !right.node.capturing) {
                right = right.getChild();
              }
            } else {
              right = NodePath.getForNode({
                type: "Alternative",
                expressions: [].concat(_toConsumableArray(node.expressions.slice(i + 1, index2 + 1)))
              });
            }
            if (left.hasEqualSource(right)) {
              for (var j = i; j < index2; j++) {
                alternative.getChild(i + 1).remove();
              }
              increaseQuantifierByOne(previousChild.node.quantifier);
              return i;
            }
          }
          i++;
        }
        return index2;
      }
      function combineRepetitionWithPrevious(alternative, child, index2) {
        var node = alternative.node;
        if (child.node.type === "Repetition" && child.node.quantifier.greedy) {
          var right = child.getChild();
          var left = void 0;
          if (right.node.type === "Group" && !right.node.capturing) {
            right = right.getChild();
          }
          var rightLength = void 0;
          if (right.node.type === "Alternative") {
            rightLength = right.node.expressions.length;
            left = NodePath.getForNode({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(node.expressions.slice(index2 - rightLength, index2)))
            });
          } else {
            rightLength = 1;
            left = alternative.getChild(index2 - 1);
            if (left.node.type === "Group" && !left.node.capturing) {
              left = left.getChild();
            }
          }
          if (left.hasEqualSource(right)) {
            for (var j = index2 - rightLength; j < index2; j++) {
              alternative.getChild(index2 - rightLength).remove();
            }
            increaseQuantifierByOne(child.node.quantifier);
            return index2 - rightLength;
          }
        }
        return index2;
      }
    }
  });

  // node_modules/regexp-tree/dist/optimizer/transforms/index.js
  var require_transforms2 = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/transforms/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = /* @__PURE__ */ new Map([
        // \ud83d\ude80 -> \u{1f680}
        ["charSurrogatePairToSingleUnicode", require_char_surrogate_pair_to_single_unicode_transform()],
        // \u0061 -> a
        ["charCodeToSimpleChar", require_char_code_to_simple_char_transform()],
        // /Aa/i -> /aa/i
        ["charCaseInsensitiveLowerCaseTransform", require_char_case_insensitive_lowercase_transform()],
        // [\d\d] -> [\d]
        ["charClassRemoveDuplicates", require_char_class_remove_duplicates_transform()],
        // a{1,2}a{2,3} -> a{3,5}
        ["quantifiersMerge", require_quantifiers_merge_transform()],
        // a{1,} -> a+, a{3,3} -> a{3}, a{1} -> a
        ["quantifierRangeToSymbol", require_quantifier_range_to_symbol_transform()],
        // [a-a] -> [a], [a-b] -> [ab]
        ["charClassClassrangesToChars", require_char_class_classranges_to_chars_transform()],
        // [0-9] -> [\d]
        ["charClassToMeta", require_char_class_to_meta_transform()],
        // [\d] -> \d, [^\w] -> \W
        ["charClassToSingleChar", require_char_class_to_single_char_transform()],
        // \e -> e
        ["charEscapeUnescape", require_char_escape_unescape_transform()],
        // [a-de-f] -> [a-f]
        ["charClassClassrangesMerge", require_char_class_classranges_merge_transform()],
        // (ab|ab) -> (ab)
        ["disjunctionRemoveDuplicates", require_disjunction_remove_duplicates_transform()],
        // (a|b|c) -> [abc]
        ["groupSingleCharsToCharClass", require_group_single_chars_to_char_class()],
        // (?:)a -> a
        ["removeEmptyGroup", require_remove_empty_group_transform()],
        // (?:a) -> a
        ["ungroup", require_ungroup_transform()],
        // abcabcabc -> (?:abc){3}
        ["combineRepeatingPatterns", require_combine_repeating_patterns_transform()]
      ]);
    }
  });

  // node_modules/regexp-tree/dist/optimizer/index.js
  var require_optimizer = __commonJS({
    "node_modules/regexp-tree/dist/optimizer/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var clone2 = require_clone();
      var parser = require_parser2();
      var transform = require_transform();
      var optimizationTransforms = require_transforms2();
      module2.exports = {
        /**
         * Optimizer transforms a regular expression into an optimized version,
         * replacing some sub-expressions with their idiomatic patterns.
         *
         * @param string | RegExp | AST - a regexp to optimize.
         *
         * @return TransformResult - an optimized regexp.
         *
         * Example:
         *
         *   /[a-zA-Z_0-9][a-zA-Z_0-9]*\e{1,}/
         *
         * Optimized to:
         *
         *   /\w+e+/
         */
        optimize: function optimize2(regexp) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === void 0 ? [] : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === void 0 ? [] : _ref$blacklist;
          var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());
          var transformToApply = transformsRaw.filter(function(transform2) {
            return !blacklist.includes(transform2);
          });
          var ast = regexp;
          if (regexp instanceof RegExp) {
            regexp = "" + regexp;
          }
          if (typeof regexp === "string") {
            ast = parser.parse(regexp);
          }
          var result = new transform.TransformResult(ast);
          var prevResultString = void 0;
          do {
            prevResultString = result.toString();
            ast = clone2(result.getAST());
            transformToApply.forEach(function(transformName) {
              if (!optimizationTransforms.has(transformName)) {
                throw new Error("Unknown optimization-transform: " + transformName + ". Available transforms are: " + Array.from(optimizationTransforms.keys()).join(", "));
              }
              var transformer = optimizationTransforms.get(transformName);
              var newResult = transform.transform(ast, transformer);
              if (newResult.toString() !== result.toString()) {
                if (newResult.toString().length <= result.toString().length) {
                  result = newResult;
                } else {
                  ast = clone2(result.getAST());
                }
              }
            });
          } while (result.toString() !== prevResultString);
          return result;
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js
  var require_special_symbols = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var EPSILON = "\u03B5";
      var EPSILON_CLOSURE = EPSILON + "*";
      module2.exports = {
        EPSILON,
        EPSILON_CLOSURE
      };
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js
  var require_nfa = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_special_symbols();
      var EPSILON = _require.EPSILON;
      var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
      var NFA = function() {
        function NFA2(inState, outState) {
          _classCallCheck(this, NFA2);
          this.in = inState;
          this.out = outState;
        }
        _createClass(NFA2, [{
          key: "matches",
          value: function matches(string) {
            return this.in.matches(string);
          }
          /**
           * Returns an alphabet for this NFA.
           */
        }, {
          key: "getAlphabet",
          value: function getAlphabet() {
            if (!this._alphabet) {
              this._alphabet = /* @__PURE__ */ new Set();
              var table = this.getTransitionTable();
              for (var state in table) {
                var transitions = table[state];
                for (var symbol in transitions) {
                  if (symbol !== EPSILON_CLOSURE) {
                    this._alphabet.add(symbol);
                  }
                }
              }
            }
            return this._alphabet;
          }
          /**
           * Returns set of accepting states.
           */
        }, {
          key: "getAcceptingStates",
          value: function getAcceptingStates() {
            if (!this._acceptingStates) {
              this.getTransitionTable();
            }
            return this._acceptingStates;
          }
          /**
           * Returns accepting state numbers.
           */
        }, {
          key: "getAcceptingStateNumbers",
          value: function getAcceptingStateNumbers() {
            if (!this._acceptingStateNumbers) {
              this._acceptingStateNumbers = /* @__PURE__ */ new Set();
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var acceptingState = _step.value;
                  this._acceptingStateNumbers.add(acceptingState.number);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            }
            return this._acceptingStateNumbers;
          }
          /**
           * Builds and returns transition table.
           */
        }, {
          key: "getTransitionTable",
          value: function getTransitionTable() {
            var _this = this;
            if (!this._transitionTable) {
              this._transitionTable = {};
              this._acceptingStates = /* @__PURE__ */ new Set();
              var visited = /* @__PURE__ */ new Set();
              var symbols = /* @__PURE__ */ new Set();
              var visitState = function visitState2(state) {
                if (visited.has(state)) {
                  return;
                }
                visited.add(state);
                state.number = visited.size;
                _this._transitionTable[state.number] = {};
                if (state.accepting) {
                  _this._acceptingStates.add(state);
                }
                var transitions = state.getTransitions();
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = void 0;
                try {
                  for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _ref = _step2.value;
                    var _ref2 = _slicedToArray(_ref, 2);
                    var symbol = _ref2[0];
                    var symbolTransitions = _ref2[1];
                    var combinedState = [];
                    symbols.add(symbol);
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = void 0;
                    try {
                      for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var nextState = _step3.value;
                        visitState2(nextState);
                        combinedState.push(nextState.number);
                      }
                    } catch (err) {
                      _didIteratorError3 = true;
                      _iteratorError3 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                          _iterator3.return();
                        }
                      } finally {
                        if (_didIteratorError3) {
                          throw _iteratorError3;
                        }
                      }
                    }
                    _this._transitionTable[state.number][symbol] = combinedState;
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                      _iterator2.return();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              };
              visitState(this.in);
              visited.forEach(function(state) {
                delete _this._transitionTable[state.number][EPSILON];
                _this._transitionTable[state.number][EPSILON_CLOSURE] = [].concat(_toConsumableArray(state.getEpsilonClosure())).map(function(s) {
                  return s.number;
                });
              });
            }
            return this._transitionTable;
          }
        }]);
        return NFA2;
      }();
      module2.exports = NFA;
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js
  var require_dfa_minimizer = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      function _toArray(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      }
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var currentTransitionMap = null;
      function minimize(dfa) {
        var table = dfa.getTransitionTable();
        var allStates = Object.keys(table);
        var alphabet = dfa.getAlphabet();
        var accepting = dfa.getAcceptingStateNumbers();
        currentTransitionMap = {};
        var nonAccepting = /* @__PURE__ */ new Set();
        allStates.forEach(function(state) {
          state = Number(state);
          var isAccepting = accepting.has(state);
          if (isAccepting) {
            currentTransitionMap[state] = accepting;
          } else {
            nonAccepting.add(state);
            currentTransitionMap[state] = nonAccepting;
          }
        });
        var all = [
          // 0-equivalent sets.
          [nonAccepting, accepting].filter(function(set2) {
            return set2.size > 0;
          })
        ];
        var current = void 0;
        var previous = void 0;
        current = all[all.length - 1];
        previous = all[all.length - 2];
        var _loop = function _loop2() {
          var newTransitionMap = {};
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _set = _step3.value;
              var handledStates = {};
              var _set2 = _toArray(_set), first = _set2[0], rest = _set2.slice(1);
              handledStates[first] = /* @__PURE__ */ new Set([first]);
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = void 0;
              try {
                restSets:
                  for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var state = _step4.value;
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = void 0;
                    try {
                      for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var handledState = _step5.value;
                        if (areEquivalent(state, handledState, table, alphabet)) {
                          handledStates[handledState].add(state);
                          handledStates[state] = handledStates[handledState];
                          continue restSets;
                        }
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                          _iterator5.return();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                    handledStates[state] = /* @__PURE__ */ new Set([state]);
                  }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
              Object.assign(newTransitionMap, handledStates);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          currentTransitionMap = newTransitionMap;
          var newSets = new Set(Object.keys(newTransitionMap).map(function(state2) {
            return newTransitionMap[state2];
          }));
          all.push([].concat(_toConsumableArray(newSets)));
          current = all[all.length - 1];
          previous = all[all.length - 2];
        };
        while (!sameRow(current, previous)) {
          _loop();
        }
        var remaped = /* @__PURE__ */ new Map();
        var idx = 1;
        current.forEach(function(set2) {
          return remaped.set(set2, idx++);
        });
        var minimizedTable = {};
        var minimizedAcceptingStates = /* @__PURE__ */ new Set();
        var updateAcceptingStates = function updateAcceptingStates2(set2, idx2) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = set2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var state = _step.value;
              if (accepting.has(state)) {
                minimizedAcceptingStates.add(idx2);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        };
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _ref = _step2.value;
            var _ref2 = _slicedToArray(_ref, 2);
            var set = _ref2[0];
            var _idx = _ref2[1];
            minimizedTable[_idx] = {};
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = void 0;
            try {
              for (var _iterator6 = alphabet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var symbol = _step6.value;
                updateAcceptingStates(set, _idx);
                var originalTransition = void 0;
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = void 0;
                try {
                  for (var _iterator7 = set[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var originalState = _step7.value;
                    originalTransition = table[originalState][symbol];
                    if (originalTransition) {
                      break;
                    }
                  }
                } catch (err) {
                  _didIteratorError7 = true;
                  _iteratorError7 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                      _iterator7.return();
                    }
                  } finally {
                    if (_didIteratorError7) {
                      throw _iteratorError7;
                    }
                  }
                }
                if (originalTransition) {
                  minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
                }
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        dfa.setTransitionTable(minimizedTable);
        dfa.setAcceptingStateNumbers(minimizedAcceptingStates);
        return dfa;
      }
      function sameRow(r1, r2) {
        if (!r2) {
          return false;
        }
        if (r1.length !== r2.length) {
          return false;
        }
        for (var i = 0; i < r1.length; i++) {
          var s1 = r1[i];
          var s2 = r2[i];
          if (s1.size !== s2.size) {
            return false;
          }
          if ([].concat(_toConsumableArray(s1)).sort().join(",") !== [].concat(_toConsumableArray(s2)).sort().join(",")) {
            return false;
          }
        }
        return true;
      }
      function areEquivalent(s1, s2, table, alphabet) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = void 0;
        try {
          for (var _iterator8 = alphabet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var symbol = _step8.value;
            if (!goToSameSet(s1, s2, table, symbol)) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
        return true;
      }
      function goToSameSet(s1, s2, table, symbol) {
        if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
          return false;
        }
        var originalTransitionS1 = table[s1][symbol];
        var originalTransitionS2 = table[s2][symbol];
        if (!originalTransitionS1 && !originalTransitionS2) {
          return true;
        }
        return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
      }
      module2.exports = {
        minimize
      };
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js
  var require_dfa = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var DFAMinimizer = require_dfa_minimizer();
      var _require = require_special_symbols();
      var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
      var DFA = function() {
        function DFA2(nfa) {
          _classCallCheck(this, DFA2);
          this._nfa = nfa;
        }
        _createClass(DFA2, [{
          key: "minimize",
          value: function minimize() {
            this.getTransitionTable();
            this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
            this._originalTransitionTable = this._transitionTable;
            DFAMinimizer.minimize(this);
          }
          /**
           * Returns alphabet for this DFA.
           */
        }, {
          key: "getAlphabet",
          value: function getAlphabet() {
            return this._nfa.getAlphabet();
          }
          /**
           * Returns accepting states.
           */
        }, {
          key: "getAcceptingStateNumbers",
          value: function getAcceptingStateNumbers() {
            if (!this._acceptingStateNumbers) {
              this.getTransitionTable();
            }
            return this._acceptingStateNumbers;
          }
          /**
           * Returns original accepting states.
           */
        }, {
          key: "getOriginaAcceptingStateNumbers",
          value: function getOriginaAcceptingStateNumbers() {
            if (!this._originalAcceptingStateNumbers) {
              this.getTransitionTable();
            }
            return this._originalAcceptingStateNumbers;
          }
          /**
           * Sets transition table.
           */
        }, {
          key: "setTransitionTable",
          value: function setTransitionTable(table) {
            this._transitionTable = table;
          }
          /**
           * Sets accepting states.
           */
        }, {
          key: "setAcceptingStateNumbers",
          value: function setAcceptingStateNumbers(stateNumbers) {
            this._acceptingStateNumbers = stateNumbers;
          }
          /**
           * DFA transition table is built from NFA table.
           */
        }, {
          key: "getTransitionTable",
          value: function getTransitionTable() {
            var _this = this;
            if (this._transitionTable) {
              return this._transitionTable;
            }
            var nfaTable = this._nfa.getTransitionTable();
            var nfaStates = Object.keys(nfaTable);
            this._acceptingStateNumbers = /* @__PURE__ */ new Set();
            var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];
            var worklist = [startState];
            var alphabet = this.getAlphabet();
            var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();
            var dfaTable = {};
            var updateAcceptingStates = function updateAcceptingStates2(states2) {
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var nfaAcceptingState = _step.value;
                  if (states2.indexOf(nfaAcceptingState) !== -1) {
                    _this._acceptingStateNumbers.add(states2.join(","));
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            };
            while (worklist.length > 0) {
              var states = worklist.shift();
              var dfaStateLabel = states.join(",");
              dfaTable[dfaStateLabel] = {};
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = alphabet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var symbol = _step2.value;
                  var onSymbol = [];
                  updateAcceptingStates(states);
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = void 0;
                  try {
                    for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var state = _step3.value;
                      var nfaStatesOnSymbol = nfaTable[state][symbol];
                      if (!nfaStatesOnSymbol) {
                        continue;
                      }
                      var _iteratorNormalCompletion4 = true;
                      var _didIteratorError4 = false;
                      var _iteratorError4 = void 0;
                      try {
                        for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                          var nfaStateOnSymbol = _step4.value;
                          if (!nfaTable[nfaStateOnSymbol]) {
                            continue;
                          }
                          onSymbol.push.apply(onSymbol, _toConsumableArray(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                        }
                      } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                          }
                        } finally {
                          if (_didIteratorError4) {
                            throw _iteratorError4;
                          }
                        }
                      }
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                  var dfaStatesOnSymbolSet = new Set(onSymbol);
                  var dfaStatesOnSymbol = [].concat(_toConsumableArray(dfaStatesOnSymbolSet));
                  if (dfaStatesOnSymbol.length > 0) {
                    var dfaOnSymbolStr = dfaStatesOnSymbol.join(",");
                    dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;
                    if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                      worklist.unshift(dfaStatesOnSymbol);
                    }
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
            return this._transitionTable = this._remapStateNumbers(dfaTable);
          }
          /**
           * Remaps state numbers in the resulting table:
           * combined states '1,2,3' -> 1, '3,4' -> 2, etc.
           */
        }, {
          key: "_remapStateNumbers",
          value: function _remapStateNumbers(calculatedDFATable) {
            var newStatesMap = {};
            this._originalTransitionTable = calculatedDFATable;
            var transitionTable = {};
            Object.keys(calculatedDFATable).forEach(function(originalNumber2, newNumber) {
              newStatesMap[originalNumber2] = newNumber + 1;
            });
            for (var originalNumber in calculatedDFATable) {
              var originalRow = calculatedDFATable[originalNumber];
              var row = {};
              for (var symbol in originalRow) {
                row[symbol] = newStatesMap[originalRow[symbol]];
              }
              transitionTable[newStatesMap[originalNumber]] = row;
            }
            this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
            this._acceptingStateNumbers = /* @__PURE__ */ new Set();
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = void 0;
            try {
              for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _originalNumber = _step5.value;
                this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
            return transitionTable;
          }
          /**
           * Returns original DFA table, where state numbers
           * are combined numbers from NFA.
           */
        }, {
          key: "getOriginalTransitionTable",
          value: function getOriginalTransitionTable() {
            if (!this._originalTransitionTable) {
              this.getTransitionTable();
            }
            return this._originalTransitionTable;
          }
          /**
           * Checks whether this DFA accepts a string.
           */
        }, {
          key: "matches",
          value: function matches(string) {
            var state = 1;
            var i = 0;
            var table = this.getTransitionTable();
            while (string[i]) {
              state = table[state][string[i++]];
              if (!state) {
                return false;
              }
            }
            if (!this.getAcceptingStateNumbers().has(state)) {
              return false;
            }
            return true;
          }
        }]);
        return DFA2;
      }();
      module2.exports = DFA;
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js
  var require_state = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var State = function() {
        function State2() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$accepting = _ref.accepting, accepting = _ref$accepting === void 0 ? false : _ref$accepting;
          _classCallCheck(this, State2);
          this._transitions = /* @__PURE__ */ new Map();
          this.accepting = accepting;
        }
        _createClass(State2, [{
          key: "getTransitions",
          value: function getTransitions() {
            return this._transitions;
          }
          /**
           * Creates a transition on symbol.
           */
        }, {
          key: "addTransition",
          value: function addTransition(symbol, toState) {
            this.getTransitionsOnSymbol(symbol).add(toState);
            return this;
          }
          /**
           * Returns transitions set on symbol.
           */
        }, {
          key: "getTransitionsOnSymbol",
          value: function getTransitionsOnSymbol(symbol) {
            var transitions = this._transitions.get(symbol);
            if (!transitions) {
              transitions = /* @__PURE__ */ new Set();
              this._transitions.set(symbol, transitions);
            }
            return transitions;
          }
        }]);
        return State2;
      }();
      module2.exports = State;
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js
  var require_nfa_state = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass)
          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var State = require_state();
      var _require = require_special_symbols();
      var EPSILON = _require.EPSILON;
      var NFAState = function(_State) {
        _inherits(NFAState2, _State);
        function NFAState2() {
          _classCallCheck(this, NFAState2);
          return _possibleConstructorReturn(this, (NFAState2.__proto__ || Object.getPrototypeOf(NFAState2)).apply(this, arguments));
        }
        _createClass(NFAState2, [{
          key: "matches",
          /**
           * Whether this state matches a string.
           *
           * We maintain set of visited epsilon-states to avoid infinite loops
           * when an epsilon-transition goes eventually to itself.
           *
           * NOTE: this function is rather "educational", since we use DFA for strings
           * matching. DFA is built on top of NFA, and uses fast transition table.
           */
          value: function matches(string) {
            var visited = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
            if (visited.has(this)) {
              return false;
            }
            visited.add(this);
            if (string.length === 0) {
              if (this.accepting) {
                return true;
              }
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var nextState = _step.value;
                  if (nextState.matches("", visited)) {
                    return true;
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
              return false;
            }
            var symbol = string[0];
            var rest = string.slice(1);
            var symbolTransitions = this.getTransitionsOnSymbol(symbol);
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _nextState = _step2.value;
                if (_nextState.matches(rest)) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _nextState2 = _step3.value;
                if (_nextState2.matches(string, visited)) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            return false;
          }
          /**
           * Returns an -closure for this state:
           * self + all states following -transitions.
           */
        }, {
          key: "getEpsilonClosure",
          value: function getEpsilonClosure() {
            var _this2 = this;
            if (!this._epsilonClosure) {
              (function() {
                var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON);
                var closure = _this2._epsilonClosure = /* @__PURE__ */ new Set();
                closure.add(_this2);
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = void 0;
                try {
                  for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var nextState = _step4.value;
                    if (!closure.has(nextState)) {
                      closure.add(nextState);
                      var nextClosure = nextState.getEpsilonClosure();
                      nextClosure.forEach(function(state) {
                        return closure.add(state);
                      });
                    }
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              })();
            }
            return this._epsilonClosure;
          }
        }]);
        return NFAState2;
      }(State);
      module2.exports = NFAState;
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js
  var require_builders = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NFA = require_nfa();
      var NFAState = require_nfa_state();
      var _require = require_special_symbols();
      var EPSILON = _require.EPSILON;
      function char(c) {
        var inState = new NFAState();
        var outState = new NFAState({
          accepting: true
        });
        return new NFA(inState.addTransition(c, outState), outState);
      }
      function e() {
        return char(EPSILON);
      }
      function altPair(first, second) {
        first.out.accepting = false;
        second.out.accepting = true;
        first.out.addTransition(EPSILON, second.in);
        return new NFA(first.in, second.out);
      }
      function alt(first) {
        for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          fragments[_key - 1] = arguments[_key];
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var fragment = _step.value;
            first = altPair(first, fragment);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return first;
      }
      function orPair(first, second) {
        var inState = new NFAState();
        var outState = new NFAState();
        inState.addTransition(EPSILON, first.in);
        inState.addTransition(EPSILON, second.in);
        outState.accepting = true;
        first.out.accepting = false;
        second.out.accepting = false;
        first.out.addTransition(EPSILON, outState);
        second.out.addTransition(EPSILON, outState);
        return new NFA(inState, outState);
      }
      function or(first) {
        for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          fragments[_key2 - 1] = arguments[_key2];
        }
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var fragment = _step2.value;
            first = orPair(first, fragment);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        return first;
      }
      function repExplicit(fragment) {
        var inState = new NFAState();
        var outState = new NFAState({
          accepting: true
        });
        inState.addTransition(EPSILON, fragment.in);
        inState.addTransition(EPSILON, outState);
        fragment.out.accepting = false;
        fragment.out.addTransition(EPSILON, outState);
        outState.addTransition(EPSILON, fragment.in);
        return new NFA(inState, outState);
      }
      function rep(fragment) {
        fragment.in.addTransition(EPSILON, fragment.out);
        fragment.out.addTransition(EPSILON, fragment.in);
        return fragment;
      }
      function plusRep(fragment) {
        fragment.out.addTransition(EPSILON, fragment.in);
        return fragment;
      }
      function questionRep(fragment) {
        fragment.in.addTransition(EPSILON, fragment.out);
        return fragment;
      }
      module2.exports = {
        alt,
        char,
        e,
        or,
        rep,
        repExplicit,
        plusRep,
        questionRep
      };
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js
  var require_nfa_from_regexp = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var parser = require_parser2();
      var _require = require_builders();
      var alt = _require.alt;
      var char = _require.char;
      var or = _require.or;
      var rep = _require.rep;
      var plusRep = _require.plusRep;
      var questionRep = _require.questionRep;
      function gen(node) {
        if (node && !generator[node.type]) {
          throw new Error(node.type + " is not supported in NFA/DFA interpreter.");
        }
        return node ? generator[node.type](node) : "";
      }
      var generator = {
        RegExp: function RegExp2(node) {
          if (node.flags !== "") {
            throw new Error("NFA/DFA: Flags are not supported yet.");
          }
          return gen(node.body);
        },
        Alternative: function Alternative(node) {
          var fragments = (node.expressions || []).map(gen);
          return alt.apply(void 0, _toConsumableArray(fragments));
        },
        Disjunction: function Disjunction(node) {
          return or(gen(node.left), gen(node.right));
        },
        Repetition: function Repetition(node) {
          switch (node.quantifier.kind) {
            case "*":
              return rep(gen(node.expression));
            case "+":
              return plusRep(gen(node.expression));
            case "?":
              return questionRep(gen(node.expression));
            default:
              throw new Error("Unknown repeatition: " + node.quantifier.kind + ".");
          }
        },
        Char: function Char(node) {
          if (node.kind !== "simple") {
            throw new Error("NFA/DFA: Only simple chars are supported yet.");
          }
          return char(node.value);
        },
        Group: function Group(node) {
          return gen(node.expression);
        }
      };
      module2.exports = {
        /**
         * Builds an NFA from the passed regexp.
         */
        build: function build2(regexp) {
          var ast = regexp;
          if (regexp instanceof RegExp) {
            regexp = "" + regexp;
          }
          if (typeof regexp === "string") {
            ast = parser.parse(regexp, {
              captureLocations: true
            });
          }
          return gen(ast);
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js
  var require_finite_automaton = __commonJS({
    "node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var NFA = require_nfa();
      var DFA = require_dfa();
      var nfaFromRegExp = require_nfa_from_regexp();
      var builders = require_builders();
      module2.exports = {
        /**
         * Export NFA and DFA classes.
         */
        NFA,
        DFA,
        /**
         * Expose builders.
         */
        builders,
        /**
         * Builds an NFA for the passed regexp.
         *
         * @param string | AST | RegExp:
         *
         *   a regular expression in different representations: a string,
         *   a RegExp object, or an AST.
         */
        toNFA: function toNFA(regexp) {
          return nfaFromRegExp.build(regexp);
        },
        /**
         * Builds DFA for the passed regexp.
         *
         * @param string | AST | RegExp:
         *
         *   a regular expression in different representations: a string,
         *   a RegExp object, or an AST.
         */
        toDFA: function toDFA(regexp) {
          return new DFA(this.toNFA(regexp));
        },
        /**
         * Returns true if regexp accepts the string.
         */
        test: function test(regexp, string) {
          return this.toDFA(regexp).matches(string);
        }
      };
    }
  });

  // node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js
  var require_runtime = __commonJS({
    "node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var RegExpTree = function() {
        function RegExpTree2(re, _ref) {
          var flags = _ref.flags, groups = _ref.groups, source = _ref.source;
          _classCallCheck(this, RegExpTree2);
          this._re = re;
          this._groups = groups;
          this.flags = flags;
          this.source = source || re.source;
          this.dotAll = flags.includes("s");
          this.global = re.global;
          this.ignoreCase = re.ignoreCase;
          this.multiline = re.multiline;
          this.sticky = re.sticky;
          this.unicode = re.unicode;
        }
        _createClass(RegExpTree2, [{
          key: "test",
          value: function test(string) {
            return this._re.test(string);
          }
          /**
           * Facade wrapper for RegExp `compile` method.
           */
        }, {
          key: "compile",
          value: function compile(string) {
            return this._re.compile(string);
          }
          /**
           * Facade wrapper for RegExp `toString` method.
           */
        }, {
          key: "toString",
          value: function toString2() {
            if (!this._toStringResult) {
              this._toStringResult = "/" + this.source + "/" + this.flags;
            }
            return this._toStringResult;
          }
          /**
           * Facade wrapper for RegExp `exec` method.
           */
        }, {
          key: "exec",
          value: function exec(string) {
            var result = this._re.exec(string);
            if (!this._groups || !result) {
              return result;
            }
            result.groups = {};
            for (var group in this._groups) {
              var groupNumber = this._groups[group];
              result.groups[group] = result[groupNumber];
            }
            return result;
          }
        }]);
        return RegExpTree2;
      }();
      module2.exports = {
        RegExpTree
      };
    }
  });

  // node_modules/regexp-tree/dist/regexp-tree.js
  var require_regexp_tree2 = __commonJS({
    "node_modules/regexp-tree/dist/regexp-tree.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var compatTranspiler = require_compat_transpiler();
      var generator = require_generator();
      var optimizer = require_optimizer();
      var parser = require_parser2();
      var _transform = require_transform();
      var _traverse = require_traverse();
      var fa = require_finite_automaton();
      var _require = require_runtime();
      var RegExpTree = _require.RegExpTree;
      var regexpTree = {
        /**
         * Parser module exposed.
         */
        parser,
        /**
         * Expose finite-automaton module.
         */
        fa,
        /**
         * `TransformResult` exposed.
         */
        TransformResult: _transform.TransformResult,
        /**
         * Parses a regexp string, producing an AST.
         *
         * @param string regexp
         *
         *   a regular expression in different formats: string, AST, RegExp.
         *
         * @param Object options
         *
         *   parsing options for this parse call. Default are:
         *
         *     - captureLocations: boolean
         *     - any other custom options
         *
         * @return Object AST
         */
        parse: function parse(regexp, options) {
          return parser.parse("" + regexp, options);
        },
        /**
         * Traverses a RegExp AST.
         *
         * @param Object ast
         * @param Object | Array<Object> handlers
         *
         * Each `handler` is an object containing handler function for needed
         * node types. Example:
         *
         *   regexpTree.traverse(ast, {
         *     onChar(node) {
         *       ...
         *     },
         *   });
         *
         * The value for a node type may also be an object with functions pre and post.
         * This enables more context-aware analyses, e.g. measuring star height.
         */
        traverse: function traverse(ast, handlers, options) {
          return _traverse.traverse(ast, handlers, options);
        },
        /**
         * Transforms a regular expression.
         *
         * A regexp can be passed in different formats (string, regexp or AST),
         * applying a set of transformations. It is a convenient wrapper
         * on top of "parse-traverse-generate" tool chain.
         *
         * @param string | AST | RegExp regexp - a regular expression;
         * @param Object | Array<Object> handlers - a list of handlers.
         *
         * @return TransformResult - a transformation result.
         */
        transform: function transform(regexp, handlers) {
          return _transform.transform(regexp, handlers);
        },
        /**
         * Generates a RegExp string from an AST.
         *
         * @param Object ast
         *
         * Invariant:
         *
         *   regexpTree.generate(regexpTree.parse('/[a-z]+/i')); // '/[a-z]+/i'
         */
        generate: function generate(ast) {
          return generator.generate(ast);
        },
        /**
         * Creates a RegExp object from a regexp string.
         *
         * @param string regexp
         */
        toRegExp: function toRegExp(regexp) {
          var compat = this.compatTranspile(regexp);
          return new RegExp(compat.getSource(), compat.getFlags());
        },
        /**
         * Optimizes a regular expression by replacing some
         * sub-expressions with their idiomatic patterns.
         *
         * @param string regexp
         *
         * @return TransformResult object
         */
        optimize: function optimize2(regexp, whitelist) {
          var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, blacklist = _ref.blacklist;
          return optimizer.optimize(regexp, { whitelist, blacklist });
        },
        /**
         * Translates a regular expression in new syntax or in new format
         * into equivalent expressions in old syntax.
         *
         * @param string regexp
         *
         * @return TransformResult object
         */
        compatTranspile: function compatTranspile(regexp, whitelist) {
          return compatTranspiler.transform(regexp, whitelist);
        },
        /**
         * Executes a regular expression on a string.
         *
         * @param RegExp|string re - a regular expression.
         * @param string string - a testing string.
         */
        exec: function exec(re, string) {
          if (typeof re === "string") {
            var compat = this.compatTranspile(re);
            var extra = compat.getExtra();
            if (extra.namedCapturingGroups) {
              re = new RegExpTree(compat.toRegExp(), {
                flags: compat.getFlags(),
                source: compat.getSource(),
                groups: extra.namedCapturingGroups
              });
            } else {
              re = compat.toRegExp();
            }
          }
          return re.exec(string);
        }
      };
      module2.exports = regexpTree;
    }
  });

  // node_modules/regexp-tree/index.js
  var require_regexp_tree3 = __commonJS({
    "node_modules/regexp-tree/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      module2.exports = require_regexp_tree2();
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
      init_polyfills();
    }
  });

  // node_modules/jscrypto/index.js
  var require_jscrypto = __commonJS({
    "node_modules/jscrypto/index.js"(exports2, module2) {
      init_polyfills();
      !function(n, t) {
        if ("object" == typeof exports2 && "object" == typeof module2)
          module2.exports = t();
        else if ("function" == typeof define && define.amd)
          define([], t);
        else if ("object" == typeof exports2)
          exports2.JsCrypto = t();
        else {
          var r = t();
          for (var i in n.JsCrypto = n.JsCrypto || {}, r)
            n.JsCrypto[i] = r[i];
        }
      }(exports2, function() {
        return function() {
          "use strict";
          var n = { 9691: function(n2, t2, r2) {
            r2.d(t2, { AES: function() {
              return _;
            } });
            var i2, e = r2(9456), o = r2(787), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), s = function() {
              return (s = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, a = [], h = [], v = [], w = [], l = [], b = [], d = [], y = [], p = [], O = [];
            !function() {
              for (var n3 = [], t3 = 0; t3 < 256; t3++)
                n3[t3] = t3 < 128 ? t3 << 1 : t3 << 1 ^ 283;
              var r3 = 0, i3 = 0;
              for (t3 = 0; t3 < 256; t3++) {
                var e2 = i3 ^ i3 << 1 ^ i3 << 2 ^ i3 << 3 ^ i3 << 4;
                e2 = e2 >>> 8 ^ 255 & e2 ^ 99, a[r3] = e2, h[e2] = r3;
                var o2 = n3[r3], u2 = n3[o2], f2 = n3[u2], c2 = 257 * n3[e2] ^ 16843008 * e2;
                v[r3] = c2 << 24 | c2 >>> 8, w[r3] = c2 << 16 | c2 >>> 16, l[r3] = c2 << 8 | c2 >>> 24, b[r3] = c2, c2 = 16843009 * f2 ^ 65537 * u2 ^ 257 * o2 ^ 16843008 * r3, d[e2] = c2 << 24 | c2 >>> 8, y[e2] = c2 << 16 | c2 >>> 16, p[e2] = c2 << 8 | c2 >>> 24, O[e2] = c2, r3 ? (r3 = o2 ^ n3[n3[n3[f2 ^ o2]]], i3 ^= n3[n3[i3]]) : r3 = i3 = 1;
              }
            }();
            var j = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], _ = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.u = 0, r3.h = [], r3.v = [], r3.O = t4, r3.A(), r3;
              }
              return c(t3, n3), t3.prototype.A = function() {
                var n4;
                if (!this.u || this.k !== this.H) {
                  for (var t4 = this.k = this.H, r3 = t4.words, i3 = t4.nSigBytes / 4, e2 = 4 * ((this.u = i3 + 6) + 1), o2 = this.h = [], u2 = 0; u2 < e2; u2++)
                    u2 < i3 ? o2[u2] = r3[u2] : (n4 = o2[u2 - 1], u2 % i3 ? i3 > 6 && u2 % i3 == 4 && (n4 = a[n4 >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4]) : (n4 = a[(n4 = n4 << 8 | n4 >>> 24) >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4], n4 ^= j[u2 / i3 | 0] << 24), o2[u2] = o2[u2 - i3] ^ n4);
                  this.v = [];
                  for (var f2 = 0; f2 < e2; f2++) {
                    u2 = e2 - f2;
                    n4 = f2 % 4 ? o2[u2] : o2[u2 - 4], this.v[f2] = f2 < 4 || u2 <= 4 ? n4 : d[a[n4 >>> 24]] ^ y[a[n4 >>> 16 & 255]] ^ p[a[n4 >>> 8 & 255]] ^ O[a[255 & n4]];
                  }
                }
              }, t3.prototype.encryptBlock = function(n4, t4) {
                this.B(n4, t4, this.h, v, w, l, b, a);
              }, t3.prototype.decryptBlock = function(n4, t4) {
                var r3 = n4[t4 + 1];
                n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3, this.B(n4, t4, this.v, d, y, p, O, h), r3 = n4[t4 + 1], n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3;
              }, t3.prototype.B = function(n4, t4, r3, i3, e2, o2, u2, f2) {
                for (var c2 = this.u, s2 = n4[t4] ^ r3[0], a2 = n4[t4 + 1] ^ r3[1], h2 = n4[t4 + 2] ^ r3[2], v2 = n4[t4 + 3] ^ r3[3], w2 = 4, l2 = 1; l2 < c2; l2++) {
                  var b2 = i3[s2 >>> 24] ^ e2[a2 >>> 16 & 255] ^ o2[h2 >>> 8 & 255] ^ u2[255 & v2] ^ r3[w2++], d2 = i3[a2 >>> 24] ^ e2[h2 >>> 16 & 255] ^ o2[v2 >>> 8 & 255] ^ u2[255 & s2] ^ r3[w2++], y2 = i3[h2 >>> 24] ^ e2[v2 >>> 16 & 255] ^ o2[s2 >>> 8 & 255] ^ u2[255 & a2] ^ r3[w2++], p2 = i3[v2 >>> 24] ^ e2[s2 >>> 16 & 255] ^ o2[a2 >>> 8 & 255] ^ u2[255 & h2] ^ r3[w2++];
                  s2 = b2, a2 = d2, h2 = y2, v2 = p2;
                }
                var O2 = (f2[s2 >>> 24] << 24 | f2[a2 >>> 16 & 255] << 16 | f2[h2 >>> 8 & 255] << 8 | f2[255 & v2]) ^ r3[w2++], j2 = (f2[a2 >>> 24] << 24 | f2[h2 >>> 16 & 255] << 16 | f2[v2 >>> 8 & 255] << 8 | f2[255 & s2]) ^ r3[w2++], _2 = (f2[h2 >>> 24] << 24 | f2[v2 >>> 16 & 255] << 16 | f2[s2 >>> 8 & 255] << 8 | f2[255 & a2]) ^ r3[w2++], m = (f2[v2 >>> 24] << 24 | f2[s2 >>> 16 & 255] << 16 | f2[a2 >>> 8 & 255] << 8 | f2[255 & h2]) ^ r3[w2++];
                n4[t4] = O2, n4[t4 + 1] = j2, n4[t4 + 2] = _2, n4[t4 + 3] = m;
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
              }, t3.encrypt = function(n4, r3, i3) {
                if ("string" == typeof r3)
                  return u.E.encrypt(t3, n4, r3, i3);
                if (r3.nSigBytes % 4 != 0)
                  throw new Error("Key size must be multiple of 32bit/4byte/1word");
                return f.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                if ("string" == typeof r3)
                  return u.E.decrypt(t3, n4, r3, i3);
                if (r3.nSigBytes % 4 != 0)
                  throw new Error("Key size must be multiple of 32bit/4byte/1word");
                return f.D.decrypt(t3, n4, r3, i3);
              }, t3.keySize = 8, t3;
            }(o.G);
          }, 3967: function(n2, t2, r2) {
            r2.d(t2, { CBCMAC: function() {
              return f;
            } });
            var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(3664);
            function f(n3, t3, r3, f2, c, s) {
              var a = s && s.Cipher ? s.Cipher : o.AES, h = "string" == typeof r3 ? i2.d.parse(r3) : r3, v = f2 || new e.e([0, 0]), w = "string" == typeof t3 ? i2.d.parse(t3) : t3, l = "string" == typeof n3 ? i2.d.parse(n3) : n3, b = c || 16;
              return u.K.mac(a, h, v, w, l, b);
            }
          }, 9910: function(n2, t2, r2) {
            r2.d(t2, { DES: function() {
              return b;
            } });
            var i2, e = r2(787), o = r2(9456), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), s = function() {
              return (s = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], h = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], v = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], w = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], b = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 2, r3.I = [], r3.U = [], r3.L = 0, r3.F = 0, r3.O = t4, r3.A(), r3;
              }
              return c(t3, n3), t3.prototype.A = function() {
                for (var n4 = this.H.words, t4 = [], r3 = 0; r3 < 56; r3++) {
                  var i3 = a[r3] - 1;
                  t4[r3] = n4[i3 >>> 5] >>> 31 - i3 % 32 & 1;
                }
                for (var e2 = this.I = [], o2 = 0; o2 < 16; o2++) {
                  var u2 = e2[o2] = [], f2 = v[o2];
                  for (r3 = 0; r3 < 24; r3++)
                    u2[r3 / 6 | 0] |= t4[(h[r3] - 1 + f2) % 28] << 31 - r3 % 6, u2[4 + (r3 / 6 | 0)] |= t4[28 + (h[r3 + 24] - 1 + f2) % 28] << 31 - r3 % 6;
                  u2[0] = u2[0] << 1 | u2[0] >>> 31;
                  for (r3 = 1; r3 < 7; r3++)
                    u2[r3] = u2[r3] >>> 4 * (r3 - 1) + 3;
                  u2[7] = u2[7] << 5 | u2[7] >>> 27;
                }
                this.U = [];
                for (r3 = 0; r3 < 16; r3++)
                  this.U[r3] = e2[15 - r3];
              }, t3.prototype.encryptBlock = function(n4, t4) {
                this.R(n4, t4, this.I);
              }, t3.prototype.decryptBlock = function(n4, t4) {
                this.R(n4, t4, this.U);
              }, t3.prototype.R = function(n4, t4, r3) {
                this.L = n4[t4], this.F = n4[t4 + 1], this.X(4, 252645135), this.X(16, 65535), this.Z(2, 858993459), this.Z(8, 16711935), this.X(1, 1431655765);
                for (var i3 = 0; i3 < 16; i3++) {
                  for (var e2 = r3[i3], o2 = this.L, u2 = this.F, f2 = 0, c2 = 0; c2 < 8; c2++) {
                    var s2 = (u2 ^ e2[c2]) & l[c2];
                    f2 |= w[c2][s2 >>> 0];
                  }
                  this.L = u2, this.F = o2 ^ f2;
                }
                var a2 = this.L;
                this.L = this.F, this.F = a2, this.X(1, 1431655765), this.Z(8, 16711935), this.Z(2, 858993459), this.X(16, 65535), this.X(4, 252645135), n4[t4] = this.L, n4[t4 + 1] = this.F;
              }, t3.prototype.X = function(n4, t4) {
                var r3 = (this.L >>> n4 ^ this.F) & t4;
                this.F ^= r3, this.L ^= r3 << n4;
              }, t3.prototype.Z = function(n4, t4) {
                var r3 = (this.F >>> n4 ^ this.L) & t4;
                this.L ^= r3, this.F ^= r3 << n4;
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.ENC_TRANSFORM_MODE }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.DEC_TRANSFORM_MODE }));
              }, t3.encrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? u.E.encrypt(t3, n4, r3, i3) : f.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? u.E.decrypt(t3, n4, r3, i3) : f.D.decrypt(t3, n4, r3, i3);
              }, t3.keySize = 2, t3.ivSize = 2, t3;
            }(e.G);
          }, 6739: function(n2, t2, r2) {
            r2.d(t2, { DES3: function() {
              return v;
            } });
            var i2, e = r2(9109), o = r2(787), u = r2(9456), f = r2(9910), c = r2(3354), s = r2(5693), a = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), h = function() {
              return (h = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, v = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                r3.N = 2, r3.O = t4;
                var i3 = r3.J();
                return r3.Y = i3[0], r3.$ = i3[1], r3.nn = i3[2], r3;
              }
              return a(t3, n3), t3.prototype.J = function() {
                var n4 = this.H.words;
                if (2 !== n4.length && 4 !== n4.length && n4.length < 6)
                  throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                var t4 = n4.slice(0, 2), r3 = n4.length < 4 ? n4.slice(0, 2) : n4.slice(2, 4), i3 = n4.length < 6 ? n4.slice(0, 2) : n4.slice(4, 6);
                return [f.DES.createEncryptor(new c.e(t4)), f.DES.createEncryptor(new c.e(r3)), f.DES.createEncryptor(new c.e(i3))];
              }, t3.prototype.A = function() {
                var n4 = this.J();
                this.Y = n4[0], this.$ = n4[1], this.nn = n4[2];
              }, t3.prototype.encryptBlock = function(n4, t4) {
                this.Y.encryptBlock(n4, t4), this.$.decryptBlock(n4, t4), this.nn.encryptBlock(n4, t4);
              }, t3.prototype.decryptBlock = function(n4, t4) {
                this.nn.decryptBlock(n4, t4), this.$.encryptBlock(n4, t4), this.Y.decryptBlock(n4, t4);
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.ENC_TRANSFORM_MODE }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.DEC_TRANSFORM_MODE }));
              }, t3.encrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? s.E.encrypt(t3, n4, r3, i3) : e.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? s.E.decrypt(t3, n4, r3, i3) : e.D.decrypt(t3, n4, r3, i3);
              }, t3.keySize = 6, t3.ivSize = 2, t3;
            }(o.G);
          }, 7753: function(n2, t2, r2) {
            r2.d(t2, { GMAC: function() {
              return f;
            } });
            var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(5607);
            function f(n3, t3, r3, f2, c) {
              var s = "string" == typeof n3 ? i2.d.parse(n3) : n3, a = r3 || new e.e([0, 0, 0, 0]), h = c && c.Cipher ? c.Cipher : o.AES, v = "string" == typeof t3 ? i2.d.parse(t3) : t3, w = f2 || 16;
              return u.V.mac(h, v, a, s, void 0, w);
            }
          }, 6367: function(n2, t2, r2) {
            r2.d(t2, { Hmac: function() {
              return e;
            } });
            var i2 = r2(4768), e = function() {
              function n3(n4, t3) {
                this.tn = n4, "string" == typeof t3 && (t3 = i2.d.parse(t3));
                var r3 = n4.blockSize, e2 = 4 * r3;
                t3.nSigBytes > e2 && (t3 = n4.finalize(t3)), t3.clamp();
                for (var o = this.rn = t3.clone(), u = this.en = t3.clone(), f = o.words, c = u.words, s = 0; s < r3; s++)
                  f[s] ^= 1549556828, c[s] ^= 909522486;
                u.nSigBytes = e2, o.nSigBytes = e2, this.reset();
              }
              return n3.prototype.reset = function() {
                this.tn.reset(), this.tn.update(this.en);
              }, n3.prototype.update = function(n4) {
                return this.tn.update(n4), this;
              }, n3.prototype.finalize = function(n4) {
                var t3 = this.tn.finalize(n4);
                return this.tn.reset(), this.tn.finalize(this.rn.clone().concat(t3));
              }, n3;
            }();
          }, 3027: function(n2, t2, r2) {
            r2.d(t2, { HmacMD5: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(670);
            function o(n3, t3) {
              return new i2.Hmac(new e.MD5(), t3).finalize(n3);
            }
          }, 149: function(n2, t2, r2) {
            r2.d(t2, { HmacSHA1: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(3173);
            function o(n3, t3) {
              return new i2.Hmac(new e.SHA1(), t3).finalize(n3);
            }
          }, 4105: function(n2, t2, r2) {
            r2.d(t2, { HmacSHA224: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(766);
            function o(n3, t3) {
              return new i2.Hmac(new e.SHA224(), t3).finalize(n3);
            }
          }, 980: function(n2, t2, r2) {
            r2.d(t2, { HmacSHA256: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(5561);
            function o(n3, t3) {
              return new i2.Hmac(new e.SHA256(), t3).finalize(n3);
            }
          }, 5838: function(n2, t2, r2) {
            r2.d(t2, { HmacSHA384: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(6324);
            function o(n3, t3) {
              return new i2.Hmac(new e.SHA384(), t3).finalize(n3);
            }
          }, 9902: function(n2, t2, r2) {
            r2.d(t2, { HmacSHA512: function() {
              return o;
            } });
            var i2 = r2(6367), e = r2(7491);
            function o(n3, t3) {
              return new i2.Hmac(new e.SHA512(), t3).finalize(n3);
            }
          }, 670: function(n2, t2, r2) {
            r2.d(t2, { MD5: function() {
              return v;
            } });
            var i2, e = r2(3354), o = r2(1868), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = [];
            function c(n3, t3, r3, i3, e2, o2, u2) {
              var f2 = n3 + (t3 & r3 | ~t3 & i3) + e2 + u2;
              return (f2 << o2 | f2 >>> 32 - o2) + t3;
            }
            function s(n3, t3, r3, i3, e2, o2, u2) {
              var f2 = n3 + (t3 & i3 | r3 & ~i3) + e2 + u2;
              return (f2 << o2 | f2 >>> 32 - o2) + t3;
            }
            function a(n3, t3, r3, i3, e2, o2, u2) {
              var f2 = n3 + (t3 ^ r3 ^ i3) + e2 + u2;
              return (f2 << o2 | f2 >>> 32 - o2) + t3;
            }
            function h(n3, t3, r3, i3, e2, o2, u2) {
              var f2 = n3 + (r3 ^ (t3 | ~i3)) + e2 + u2;
              return (f2 << o2 | f2 >>> 32 - o2) + t3;
            }
            !function() {
              for (var n3 = 0; n3 < 64; n3++)
                f[n3] = 4294967296 * Math.abs(Math.sin(n3 + 1)) | 0;
            }();
            var v = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]), t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]);
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = 0; r3 < 16; r3++) {
                  var i3 = t4 + r3, e2 = n4[i3];
                  n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
                }
                var o2 = this.on.words, u2 = n4[t4], v2 = n4[t4 + 1], w = n4[t4 + 2], l = n4[t4 + 3], b = n4[t4 + 4], d = n4[t4 + 5], y = n4[t4 + 6], p = n4[t4 + 7], O = n4[t4 + 8], j = n4[t4 + 9], _ = n4[t4 + 10], m = n4[t4 + 11], A = n4[t4 + 12], g = n4[t4 + 13], E = n4[t4 + 14], S = n4[t4 + 15], M = o2[0], k = o2[1], H2 = o2[2], C = o2[3];
                M = c(M, k, H2, C, u2, 7, f[0]), C = c(C, M, k, H2, v2, 12, f[1]), H2 = c(H2, C, M, k, w, 17, f[2]), k = c(k, H2, C, M, l, 22, f[3]), M = c(M, k, H2, C, b, 7, f[4]), C = c(C, M, k, H2, d, 12, f[5]), H2 = c(H2, C, M, k, y, 17, f[6]), k = c(k, H2, C, M, p, 22, f[7]), M = c(M, k, H2, C, O, 7, f[8]), C = c(C, M, k, H2, j, 12, f[9]), H2 = c(H2, C, M, k, _, 17, f[10]), k = c(k, H2, C, M, m, 22, f[11]), M = c(M, k, H2, C, A, 7, f[12]), C = c(C, M, k, H2, g, 12, f[13]), H2 = c(H2, C, M, k, E, 17, f[14]), M = s(M, k = c(k, H2, C, M, S, 22, f[15]), H2, C, v2, 5, f[16]), C = s(C, M, k, H2, y, 9, f[17]), H2 = s(H2, C, M, k, m, 14, f[18]), k = s(k, H2, C, M, u2, 20, f[19]), M = s(M, k, H2, C, d, 5, f[20]), C = s(C, M, k, H2, _, 9, f[21]), H2 = s(H2, C, M, k, S, 14, f[22]), k = s(k, H2, C, M, b, 20, f[23]), M = s(M, k, H2, C, j, 5, f[24]), C = s(C, M, k, H2, E, 9, f[25]), H2 = s(H2, C, M, k, l, 14, f[26]), k = s(k, H2, C, M, O, 20, f[27]), M = s(M, k, H2, C, g, 5, f[28]), C = s(C, M, k, H2, w, 9, f[29]), H2 = s(H2, C, M, k, p, 14, f[30]), M = a(M, k = s(k, H2, C, M, A, 20, f[31]), H2, C, d, 4, f[32]), C = a(C, M, k, H2, O, 11, f[33]), H2 = a(H2, C, M, k, m, 16, f[34]), k = a(k, H2, C, M, E, 23, f[35]), M = a(M, k, H2, C, v2, 4, f[36]), C = a(C, M, k, H2, b, 11, f[37]), H2 = a(H2, C, M, k, p, 16, f[38]), k = a(k, H2, C, M, _, 23, f[39]), M = a(M, k, H2, C, g, 4, f[40]), C = a(C, M, k, H2, u2, 11, f[41]), H2 = a(H2, C, M, k, l, 16, f[42]), k = a(k, H2, C, M, y, 23, f[43]), M = a(M, k, H2, C, j, 4, f[44]), C = a(C, M, k, H2, A, 11, f[45]), H2 = a(H2, C, M, k, S, 16, f[46]), M = h(M, k = a(k, H2, C, M, w, 23, f[47]), H2, C, u2, 6, f[48]), C = h(C, M, k, H2, p, 10, f[49]), H2 = h(H2, C, M, k, E, 15, f[50]), k = h(k, H2, C, M, d, 21, f[51]), M = h(M, k, H2, C, A, 6, f[52]), C = h(C, M, k, H2, l, 10, f[53]), H2 = h(H2, C, M, k, _, 15, f[54]), k = h(k, H2, C, M, v2, 21, f[55]), M = h(M, k, H2, C, O, 6, f[56]), C = h(C, M, k, H2, S, 10, f[57]), H2 = h(H2, C, M, k, y, 15, f[58]), k = h(k, H2, C, M, g, 21, f[59]), M = h(M, k, H2, C, b, 6, f[60]), C = h(C, M, k, H2, m, 10, f[61]), H2 = h(H2, C, M, k, w, 15, f[62]), k = h(k, H2, C, M, j, 21, f[63]), o2[0] = o2[0] + M | 0, o2[1] = o2[1] + k | 0, o2[2] = o2[2] + H2 | 0, o2[3] = o2[3] + C | 0;
              }, t3.prototype.fn = function() {
                var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                t4[i3 >>> 5] |= 128 << 24 - i3 % 32;
                var e2 = Math.floor(r3 / 4294967296), o2 = r3;
                t4[15 + (i3 + 64 >>> 9 << 4)] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8), t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
                for (var u2 = this.on, f2 = u2.words, c2 = 0; c2 < 4; c2++) {
                  var s2 = f2[c2];
                  f2[c2] = 16711935 & (s2 << 8 | s2 >>> 24) | 4278255360 & (s2 << 24 | s2 >>> 8);
                }
                return u2;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4) {
                return new t3().finalize(n4);
              }, t3;
            }(o.P);
          }, 4615: function(n2, t2, r2) {
            r2.d(t2, { RC4: function() {
              return s;
            } });
            var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function() {
              return (c = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.S = [], r3.i = 0, r3.j = 0, r3.O = t4, r3.A(), r3;
              }
              return f(t3, n3), t3.prototype.A = function() {
                var n4 = this.H, t4 = n4.words, r3 = n4.nSigBytes;
                this.S = [];
                for (var i3 = 0; i3 < 256; i3++)
                  this.S[i3] = i3;
                i3 = 0;
                for (var e2 = 0; i3 < 256; i3++) {
                  var o2 = i3 % r3, u2 = t4[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
                  e2 = (e2 + this.S[i3] + u2) % 256;
                  var f2 = this.S[i3];
                  this.S[i3] = this.S[e2], this.S[e2] = f2;
                }
                this.i = this.j = 0;
              }, t3.prototype.un = function(n4, t4) {
                n4[t4] ^= this.generateKeyStreamWord();
              }, t3.prototype.generateKeyStreamWord = function() {
                for (var n4 = this.S, t4 = this.i, r3 = this.j, i3 = 0, e2 = 0; e2 < 4; e2++) {
                  r3 = (r3 + n4[t4 = (t4 + 1) % 256]) % 256;
                  var o2 = n4[t4];
                  n4[t4] = n4[r3], n4[r3] = o2, i3 |= n4[(n4[t4] + n4[r3]) % 256] << 24 - 8 * e2;
                }
                return this.i = t4, this.j = r3, i3;
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.encrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
              }, t3.ivSize = 0, t3.keySize = 8, t3;
            }(e.q);
          }, 9639: function(n2, t2, r2) {
            r2.d(t2, { RC4Drop: function() {
              return s;
            } });
            var i2, e = r2(5693), o = r2(9109), u = r2(4615), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function() {
              return (c = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.drop = 192, r3.O = t4, t4 && "number" == typeof t4.drop && (r3.drop = t4.drop), r3.A(), r3;
              }
              return f(t3, n3), t3.prototype.A = function() {
                n3.prototype.A.call(this);
                for (var t4 = this.drop; t4 > 0; t4--)
                  this.generateKeyStreamWord();
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.encrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? e.E.encrypt(t3, n4, r3, i3) : o.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? e.E.decrypt(t3, n4, r3, i3) : o.D.decrypt(t3, n4, r3, i3);
              }, t3;
            }(u.RC4);
          }, 7104: function(n2, t2, r2) {
            r2.d(t2, { RIPEMD160: function() {
              return O;
            } });
            var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = new o.e([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), c = new o.e([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), s = new o.e([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), a = new o.e([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), h = new o.e([0, 1518500249, 1859775393, 2400959708, 2840853838]), v = new o.e([1352829926, 1548603684, 1836072691, 2053994217, 0]);
            function w(n3, t3, r3) {
              return n3 ^ t3 ^ r3;
            }
            function l(n3, t3, r3) {
              return n3 & t3 | ~n3 & r3;
            }
            function b(n3, t3, r3) {
              return (n3 | ~t3) ^ r3;
            }
            function d(n3, t3, r3) {
              return n3 & r3 | t3 & ~r3;
            }
            function y(n3, t3, r3) {
              return n3 ^ (t3 | ~r3);
            }
            function p(n3, t3) {
              return n3 << t3 | n3 >>> 32 - t3;
            }
            var O = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = 0; r3 < 16; r3++) {
                  var i3 = t4 + r3, e2 = n4[i3];
                  n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
                }
                var o2, u2, O2, j, _, m, A, g, E, S, M, k = this.on.words, H2 = h.words, C = v.words, B = f.words, N = c.words, I = s.words, z = a.words;
                m = o2 = k[0], A = u2 = k[1], g = O2 = k[2], E = j = k[3], S = _ = k[4];
                for (r3 = 0; r3 < 80; r3 += 1)
                  M = o2 + n4[t4 + B[r3]] | 0, M += r3 < 16 ? w(u2, O2, j) + H2[0] : r3 < 32 ? l(u2, O2, j) + H2[1] : r3 < 48 ? b(u2, O2, j) + H2[2] : r3 < 64 ? d(u2, O2, j) + H2[3] : y(u2, O2, j) + H2[4], M = (M = p(M |= 0, I[r3])) + _ | 0, o2 = _, _ = j, j = p(O2, 10), O2 = u2, u2 = M, M = m + n4[t4 + N[r3]] | 0, M += r3 < 16 ? y(A, g, E) + C[0] : r3 < 32 ? d(A, g, E) + C[1] : r3 < 48 ? b(A, g, E) + C[2] : r3 < 64 ? l(A, g, E) + C[3] : w(A, g, E) + C[4], M = (M = p(M |= 0, z[r3])) + S | 0, m = S, S = E, E = p(g, 10), g = A, A = M;
                M = k[1] + O2 + E | 0, k[1] = k[2] + j + S | 0, k[2] = k[3] + _ + m | 0, k[3] = k[4] + o2 + A | 0, k[4] = k[0] + u2 + g | 0, k[0] = M;
              }, t3.prototype.fn = function() {
                var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
                for (var e2 = this.on, o2 = e2.words, u2 = 0; u2 < 5; u2++) {
                  var f2 = o2[u2];
                  o2[u2] = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8);
                }
                return e2;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(e.P);
          }, 5187: function(n2, t2, r2) {
            r2.d(t2, { Rabbit: function() {
              return s;
            } });
            var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function() {
              return (c = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 4, r3.S = [], r3.C = [], r3.G = [], r3.hn = [], r3.vn = [], r3.wn = 0, r3.O = t4, r3.A(), r3;
              }
              return f(t3, n3), t3.prototype.A = function() {
                for (var n4 = this.H.words, t4 = this.ln, r3 = 0; r3 < 4; r3++)
                  n4[r3] = 16711935 & (n4[r3] << 8 | n4[r3] >>> 24) | 4278255360 & (n4[r3] << 24 | n4[r3] >>> 8);
                var i3 = this.hn = [n4[0], n4[3] << 16 | n4[2] >>> 16, n4[1], n4[0] << 16 | n4[3] >>> 16, n4[2], n4[1] << 16 | n4[0] >>> 16, n4[3], n4[2] << 16 | n4[1] >>> 16], e2 = this.vn = [n4[2] << 16 | n4[2] >>> 16, 4294901760 & n4[0] | 65535 & n4[1], n4[3] << 16 | n4[3] >>> 16, 4294901760 & n4[1] | 65535 & n4[2], n4[0] << 16 | n4[0] >>> 16, 4294901760 & n4[2] | 65535 & n4[3], n4[1] << 16 | n4[1] >>> 16, 4294901760 & n4[3] | 65535 & n4[0]];
                this.wn = 0;
                for (r3 = 0; r3 < 4; r3++)
                  this.nextState();
                for (r3 = 0; r3 < 8; r3++)
                  e2[r3] ^= i3[r3 + 4 & 7];
                if (t4) {
                  var o2 = t4.words, u2 = o2[0], f2 = o2[1], c2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), s2 = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8), a = c2 >>> 16 | 4294901760 & s2, h = s2 << 16 | 65535 & c2;
                  e2[0] ^= c2, e2[1] ^= a, e2[2] ^= s2, e2[3] ^= h, e2[4] ^= c2, e2[5] ^= a, e2[6] ^= s2, e2[7] ^= h;
                  for (r3 = 0; r3 < 4; r3++)
                    this.nextState();
                }
              }, t3.prototype.un = function(n4, t4) {
                var r3 = this.hn;
                this.nextState(), this.S[0] = r3[0] ^ r3[5] >>> 16 ^ r3[3] << 16, this.S[1] = r3[2] ^ r3[7] >>> 16 ^ r3[5] << 16, this.S[2] = r3[4] ^ r3[1] >>> 16 ^ r3[7] << 16, this.S[3] = r3[6] ^ r3[3] >>> 16 ^ r3[1] << 16;
                for (var i3 = 0; i3 < 4; i3++)
                  this.S[i3] = 16711935 & (this.S[i3] << 8 | this.S[i3] >>> 24) | 4278255360 & (this.S[i3] << 24 | this.S[i3] >>> 8), n4[t4 + i3] ^= this.S[i3];
              }, t3.prototype.nextState = function() {
                for (var n4 = this.hn, t4 = this.vn, r3 = 0; r3 < 8; r3++)
                  this.C[r3] = t4[r3];
                t4[0] = t4[0] + 1295307597 + this.wn | 0, t4[1] = t4[1] + 3545052371 + (t4[0] >>> 0 < this.C[0] >>> 0 ? 1 : 0) | 0, t4[2] = t4[2] + 886263092 + (t4[1] >>> 0 < this.C[1] >>> 0 ? 1 : 0) | 0, t4[3] = t4[3] + 1295307597 + (t4[2] >>> 0 < this.C[2] >>> 0 ? 1 : 0) | 0, t4[4] = t4[4] + 3545052371 + (t4[3] >>> 0 < this.C[3] >>> 0 ? 1 : 0) | 0, t4[5] = t4[5] + 886263092 + (t4[4] >>> 0 < this.C[4] >>> 0 ? 1 : 0) | 0, t4[6] = t4[6] + 1295307597 + (t4[5] >>> 0 < this.C[5] >>> 0 ? 1 : 0) | 0, t4[7] = t4[7] + 3545052371 + (t4[6] >>> 0 < this.C[6] >>> 0 ? 1 : 0) | 0, this.wn = t4[7] >>> 0 < this.C[7] >>> 0 ? 1 : 0;
                for (r3 = 0; r3 < 8; r3++) {
                  var i3 = n4[r3] + t4[r3], e2 = 65535 & i3, o2 = i3 >>> 16, u2 = ((e2 * e2 >>> 17) + e2 * o2 >>> 15) + o2 * o2, f2 = ((4294901760 & i3) * i3 | 0) + ((65535 & i3) * i3 | 0);
                  this.G[r3] = u2 ^ f2;
                }
                var c2 = this.G;
                n4[0] = c2[0] + (c2[7] << 16 | c2[7] >>> 16) + (c2[6] << 16 | c2[6] >>> 16) | 0, n4[1] = c2[1] + (c2[0] << 8 | c2[0] >>> 24) + c2[7] | 0, n4[2] = c2[2] + (c2[1] << 16 | c2[1] >>> 16) + (c2[0] << 16 | c2[0] >>> 16) | 0, n4[3] = c2[3] + (c2[2] << 8 | c2[2] >>> 24) + c2[1] | 0, n4[4] = c2[4] + (c2[3] << 16 | c2[3] >>> 16) + (c2[2] << 16 | c2[2] >>> 16) | 0, n4[5] = c2[5] + (c2[4] << 8 | c2[4] >>> 24) + c2[3] | 0, n4[6] = c2[6] + (c2[5] << 16 | c2[5] >>> 16) + (c2[4] << 16 | c2[4] >>> 16) | 0, n4[7] = c2[7] + (c2[6] << 8 | c2[6] >>> 24) + c2[5] | 0;
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
              }, t3.encrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
              }, t3.decrypt = function(n4, r3, i3) {
                return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
              }, t3.ivSize = 4, t3;
            }(e.q);
          }, 3173: function(n2, t2, r2) {
            r2.d(t2, { SHA1: function() {
              return c;
            } });
            var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = [], c = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], c2 = r3[4], s = 0; s < 80; s++) {
                  if (s < 16)
                    f[s] = 0 | n4[t4 + s];
                  else {
                    var a = f[s - 3] ^ f[s - 8] ^ f[s - 14] ^ f[s - 16];
                    f[s] = a << 1 | a >>> 31;
                  }
                  var h = (i3 << 5 | i3 >>> 27) + c2 + f[s];
                  h += s < 20 ? 1518500249 + (e2 & o2 | ~e2 & u2) : s < 40 ? 1859775393 + (e2 ^ o2 ^ u2) : s < 60 ? (e2 & o2 | e2 & u2 | o2 & u2) - 1894007588 : (e2 ^ o2 ^ u2) - 899497514, c2 = u2, u2 = o2, o2 = e2 << 30 | e2 >>> 2, e2 = i3, i3 = h;
                }
                r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + c2 | 0;
              }, t3.prototype.fn = function() {
                var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
                return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(e.P);
          }, 766: function(n2, t2, r2) {
            r2.d(t2, { SHA224: function() {
              return f;
            } });
            var i2, e = r2(3354), o = r2(5561), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
              }, t3.prototype.fn = function() {
                var t4 = n3.prototype.fn.call(this);
                return t4.nSigBytes -= 4, t4;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(o.SHA256);
          }, 5561: function(n2, t2, r2) {
            r2.d(t2, { SHA256: function() {
              return v;
            } });
            var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = [], c = [];
            function s(n3) {
              for (var t3 = Math.sqrt(n3), r3 = 2; r3 <= t3; r3++)
                if (!(n3 % r3))
                  return false;
              return true;
            }
            function a(n3) {
              return 4294967296 * (n3 - (0 | n3)) | 0;
            }
            !function() {
              for (var n3 = 2, t3 = 0; t3 < 64; )
                s(n3) && (t3 < 8 && (f[t3] = a(Math.pow(n3, 0.5))), c[t3] = a(Math.pow(n3, 1 / 3)), t3++), n3++;
            }();
            var h = [], v = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new o.e(f.slice(0)), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new o.e(f.slice(0));
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], f2 = r3[4], s2 = r3[5], a2 = r3[6], v2 = r3[7], w = 0; w < 64; w++) {
                  if (w < 16)
                    h[w] = 0 | n4[t4 + w];
                  else {
                    var l = h[w - 15], b = (l << 25 | l >>> 7) ^ (l << 14 | l >>> 18) ^ l >>> 3, d = h[w - 2], y = (d << 15 | d >>> 17) ^ (d << 13 | d >>> 19) ^ d >>> 10;
                    h[w] = b + h[w - 7] + y + h[w - 16];
                  }
                  var p = i3 & e2 ^ i3 & o2 ^ e2 & o2, O = (i3 << 30 | i3 >>> 2) ^ (i3 << 19 | i3 >>> 13) ^ (i3 << 10 | i3 >>> 22), j = v2 + ((f2 << 26 | f2 >>> 6) ^ (f2 << 21 | f2 >>> 11) ^ (f2 << 7 | f2 >>> 25)) + (f2 & s2 ^ ~f2 & a2) + c[w] + h[w];
                  v2 = a2, a2 = s2, s2 = f2, f2 = u2 + j | 0, u2 = o2, o2 = e2, e2 = i3, i3 = j + (O + p) | 0;
                }
                r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + f2 | 0, r3[5] = r3[5] + s2 | 0, r3[6] = r3[6] + a2 | 0, r3[7] = r3[7] + v2 | 0;
              }, t3.prototype.fn = function() {
                var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
                return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(e.P);
          }, 3408: function(n2, t2, r2) {
            r2.d(t2, { SHA3: function() {
              return v;
            } });
            var i2, e = r2(6957), o = r2(1868), u = r2(3354), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = [], s = [], a = [];
            !function() {
              for (var n3 = 1, t3 = 0, r3 = 0; r3 < 24; r3++) {
                c[n3 + 5 * t3] = (r3 + 1) * (r3 + 2) / 2 % 64;
                var i3 = (2 * n3 + 3 * t3) % 5;
                n3 = t3 % 5, t3 = i3;
              }
              for (var o2 = 0; o2 < 5; o2++)
                for (var u2 = 0; u2 < 5; u2++)
                  s[o2 + 5 * u2] = u2 + (2 * o2 + 3 * u2) % 5 * 5;
              for (var f2 = 1, h2 = 0; h2 < 24; h2++) {
                for (var v2 = 0, w = 0, l = 0; l < 7; l++) {
                  if (1 & f2) {
                    var b = (1 << l) - 1;
                    b < 32 ? w ^= 1 << b : v2 ^= 1 << b - 32;
                  }
                  128 & f2 ? f2 = f2 << 1 ^ 113 : f2 <<= 1;
                }
                a[h2] = new e.r(v2, w);
              }
            }();
            var h = [];
            !function() {
              for (var n3 = 0; n3 < 25; n3++)
                h[n3] = new e.r(0, 0);
            }();
            var v = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                if (r3.N = 32, r3.bn = [], r3.dn = 512, r3.O = t4, t4) {
                  if (void 0 !== t4.outputLength) {
                    if (![224, 256, 384, 512].includes(t4.outputLength))
                      throw new Error("Unsupported output length.");
                    r3.dn = t4.outputLength;
                  }
                  void 0 !== t4.state && (r3.bn = t4.state.map(function(n4) {
                    return n4.clone();
                  }));
                }
                if (0 === r3.bn.length)
                  for (var i3 = 0; i3 < 25; i3++)
                    r3.bn[i3] = new e.r(0, 0);
                return r3.N = (1600 - 2 * r3.dn) / 32, r3;
              }
              return f(t3, n3), t3.prototype.A = function() {
                this.bn = [];
                for (var n4 = 0; n4 < 25; n4++)
                  this.bn[n4] = new e.r(0, 0);
                this.N = (1600 - 2 * this.dn) / 32;
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = this.bn, i3 = this.N / 2, e2 = 0; e2 < i3; e2++) {
                  var o2 = n4[t4 + 2 * e2], u2 = n4[t4 + 2 * e2 + 1];
                  o2 = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), u2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), r3[e2].high ^= u2, r3[e2].low ^= o2;
                }
                for (var f2 = 0; f2 < 24; f2++) {
                  for (var v2 = 0; v2 < 5; v2++) {
                    for (var w = 0, l = 0, b = 0; b < 5; b++) {
                      w ^= (k = r3[v2 + 5 * b]).high, l ^= k.low;
                    }
                    var d = h[v2];
                    d.high = w, d.low = l;
                  }
                  for (v2 = 0; v2 < 5; v2++) {
                    var y = h[(v2 + 4) % 5], p = h[(v2 + 1) % 5], O = p.high, j = p.low;
                    for (w = y.high ^ (O << 1 | j >>> 31), l = y.low ^ (j << 1 | O >>> 31), b = 0; b < 5; b++) {
                      (k = r3[v2 + 5 * b]).high ^= w, k.low ^= l;
                    }
                  }
                  for (var _ = 1; _ < 25; _++) {
                    w = void 0, l = void 0;
                    var m = r3[_].high, A = r3[_].low, g = c[_];
                    g < 32 ? (w = m << g | A >>> 32 - g, l = A << g | m >>> 32 - g) : (w = A << g - 32 | m >>> 64 - g, l = m << g - 32 | A >>> 64 - g);
                    var E = h[s[_]];
                    E.high = w, E.low = l;
                  }
                  var S = h[0], M = r3[0];
                  S.high = M.high, S.low = M.low;
                  for (v2 = 0; v2 < 5; v2++)
                    for (b = 0; b < 5; b++) {
                      var k = r3[_ = v2 + 5 * b], H2 = h[_], C = h[(v2 + 1) % 5 + 5 * b], B = h[(v2 + 2) % 5 + 5 * b];
                      k.high = H2.high ^ ~C.high & B.high, k.low = H2.low ^ ~C.low & B.low;
                    }
                  var N = r3[0], I = a[f2];
                  N.high ^= I.high, N.low ^= I.low;
                }
              }, t3.prototype.fn = function() {
                var n4 = this.cn, t4 = n4.words, r3 = 8 * n4.nSigBytes, i3 = 32 * this.blockSize;
                t4[r3 >>> 5] |= 1 << 24 - r3 % 32, t4[(Math.ceil((r3 + 1) / i3) * i3 >>> 5) - 1] |= 128, n4.nSigBytes = 4 * t4.length, this.an();
                for (var e2 = this.bn, o2 = this.dn / 8, f2 = o2 / 8, c2 = [], s2 = 0; s2 < f2; s2++) {
                  var a2 = e2[s2], h2 = a2.high, v2 = a2.low;
                  h2 = 16711935 & (h2 << 8 | h2 >>> 24) | 4278255360 & (h2 << 24 | h2 >>> 8), v2 = 16711935 & (v2 << 8 | v2 >>> 24) | 4278255360 & (v2 << 24 | v2 >>> 8), c2.push(v2), c2.push(h2);
                }
                return new u.e(c2, o2);
              }, t3.prototype.clone = function() {
                return new t3({ outputLength: this.dn, state: this.bn, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(o.P);
          }, 6324: function(n2, t2, r2) {
            r2.d(t2, { SHA384: function() {
              return f;
            } });
            var i2, e = r2(6957), o = r2(7491), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]);
              }, t3.prototype.fn = function() {
                var t4 = n3.prototype.fn.call(this);
                return t4.nSigBytes -= 16, t4;
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(o.SHA512);
          }, 7491: function(n2, t2, r2) {
            r2.d(t2, { SHA512: function() {
              return s;
            } });
            var i2, e = r2(1868), o = r2(6957), u = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), f = [new o.r(1116352408, 3609767458), new o.r(1899447441, 602891725), new o.r(3049323471, 3964484399), new o.r(3921009573, 2173295548), new o.r(961987163, 4081628472), new o.r(1508970993, 3053834265), new o.r(2453635748, 2937671579), new o.r(2870763221, 3664609560), new o.r(3624381080, 2734883394), new o.r(310598401, 1164996542), new o.r(607225278, 1323610764), new o.r(1426881987, 3590304994), new o.r(1925078388, 4068182383), new o.r(2162078206, 991336113), new o.r(2614888103, 633803317), new o.r(3248222580, 3479774868), new o.r(3835390401, 2666613458), new o.r(4022224774, 944711139), new o.r(264347078, 2341262773), new o.r(604807628, 2007800933), new o.r(770255983, 1495990901), new o.r(1249150122, 1856431235), new o.r(1555081692, 3175218132), new o.r(1996064986, 2198950837), new o.r(2554220882, 3999719339), new o.r(2821834349, 766784016), new o.r(2952996808, 2566594879), new o.r(3210313671, 3203337956), new o.r(3336571891, 1034457026), new o.r(3584528711, 2466948901), new o.r(113926993, 3758326383), new o.r(338241895, 168717936), new o.r(666307205, 1188179964), new o.r(773529912, 1546045734), new o.r(1294757372, 1522805485), new o.r(1396182291, 2643833823), new o.r(1695183700, 2343527390), new o.r(1986661051, 1014477480), new o.r(2177026350, 1206759142), new o.r(2456956037, 344077627), new o.r(2730485921, 1290863460), new o.r(2820302411, 3158454273), new o.r(3259730800, 3505952657), new o.r(3345764771, 106217008), new o.r(3516065817, 3606008344), new o.r(3600352804, 1432725776), new o.r(4094571909, 1467031594), new o.r(275423344, 851169720), new o.r(430227734, 3100823752), new o.r(506948616, 1363258195), new o.r(659060556, 3750685593), new o.r(883997877, 3785050280), new o.r(958139571, 3318307427), new o.r(1322822218, 3812723403), new o.r(1537002063, 2003034995), new o.r(1747873779, 3602036899), new o.r(1955562222, 1575990012), new o.r(2024104815, 1125592928), new o.r(2227730452, 2716904306), new o.r(2361852424, 442776044), new o.r(2428436474, 593698344), new o.r(2756734187, 3733110249), new o.r(3204031479, 2999351573), new o.r(3329325298, 3815920427), new o.r(3391569614, 3928383900), new o.r(3515267271, 566280711), new o.r(3940187606, 3454069534), new o.r(4118630271, 4000239992), new o.r(116418474, 1914138554), new o.r(174292421, 2731055270), new o.r(289380356, 3203993006), new o.r(460393269, 320620315), new o.r(685471733, 587496836), new o.r(852142971, 1086792851), new o.r(1017036298, 365543100), new o.r(1126000580, 2618297676), new o.r(1288033470, 3409855158), new o.r(1501505948, 4234509866), new o.r(1607167915, 987167468), new o.r(1816402316, 1246189591)], c = [];
            !function() {
              for (var n3 = 0; n3 < 80; n3++)
                c[n3] = new o.r(0, 0);
            }();
            var s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 32, r3.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
              }
              return u(t3, n3), t3.prototype.A = function() {
                this.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]);
              }, t3.prototype.un = function(n4, t4) {
                for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], s2 = r3[4], a = r3[5], h = r3[6], v = r3[7], w = i3.high, l = i3.low, b = e2.high, d = e2.low, y = o2.high, p = o2.low, O = u2.high, j = u2.low, _ = s2.high, m = s2.low, A = a.high, g = a.low, E = h.high, S = h.low, M = v.high, k = v.low, H2 = w, C = l, B = b, N = d, I = y, z = p, D = O, U = j, L = _, F = m, x = A, P = g, R = E, T = S, K2 = M, W2 = k, G = 0; G < 80; G++) {
                  var q = void 0, Q = void 0, X = c[G];
                  if (G < 16)
                    Q = X.high = 0 | n4[t4 + 2 * G], q = X.low = 0 | n4[t4 + 2 * G + 1];
                  else {
                    var V = c[G - 15], Z = V.high, J = V.low, Y = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7, $ = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25), nn = c[G - 2], tn = nn.high, rn = nn.low, en = (tn >>> 19 | rn << 13) ^ (tn << 3 | rn >>> 29) ^ tn >>> 6, on = (rn >>> 19 | tn << 13) ^ (rn << 3 | tn >>> 29) ^ (rn >>> 6 | tn << 26), un = c[G - 7], fn = un.high, cn = un.low, sn = c[G - 16], an = sn.high, hn = sn.low;
                    Q = (Q = (Q = Y + fn + ((q = $ + cn) >>> 0 < $ >>> 0 ? 1 : 0)) + en + ((q += on) >>> 0 < on >>> 0 ? 1 : 0)) + an + ((q += hn) >>> 0 < hn >>> 0 ? 1 : 0), X.high = Q, X.low = q;
                  }
                  var vn = L & x ^ ~L & R, wn = F & P ^ ~F & T, ln = H2 & B ^ H2 & I ^ B & I, bn = C & N ^ C & z ^ N & z, dn = (H2 >>> 28 | C << 4) ^ (H2 << 30 | C >>> 2) ^ (H2 << 25 | C >>> 7), yn = (C >>> 28 | H2 << 4) ^ (C << 30 | H2 >>> 2) ^ (C << 25 | H2 >>> 7), pn = (L >>> 14 | F << 18) ^ (L >>> 18 | F << 14) ^ (L << 23 | F >>> 9), On = (F >>> 14 | L << 18) ^ (F >>> 18 | L << 14) ^ (F << 23 | L >>> 9), jn = f[G], _n = jn.high, mn = jn.low, An = W2 + On, gn = K2 + pn + (An >>> 0 < W2 >>> 0 ? 1 : 0), En = yn + bn;
                  K2 = R, W2 = T, R = x, T = P, x = L, P = F, L = D + (gn = (gn = (gn = gn + vn + ((An += wn) >>> 0 < wn >>> 0 ? 1 : 0)) + _n + ((An += mn) >>> 0 < mn >>> 0 ? 1 : 0)) + Q + ((An += q) >>> 0 < q >>> 0 ? 1 : 0)) + ((F = U + An | 0) >>> 0 < U >>> 0 ? 1 : 0) | 0, D = I, U = z, I = B, z = N, B = H2, N = C, H2 = gn + (dn + ln + (En >>> 0 < yn >>> 0 ? 1 : 0)) + ((C = An + En | 0) >>> 0 < An >>> 0 ? 1 : 0) | 0;
                }
                l = i3.low = l + C, i3.high = w + H2 + (l >>> 0 < C >>> 0 ? 1 : 0), d = e2.low = d + N, e2.high = b + B + (d >>> 0 < N >>> 0 ? 1 : 0), p = o2.low = p + z, o2.high = y + I + (p >>> 0 < z >>> 0 ? 1 : 0), j = u2.low = j + U, u2.high = O + D + (j >>> 0 < U >>> 0 ? 1 : 0), m = s2.low = m + F, s2.high = _ + L + (m >>> 0 < F >>> 0 ? 1 : 0), g = a.low = g + P, a.high = A + x + (g >>> 0 < P >>> 0 ? 1 : 0), S = h.low = S + T, h.high = E + R + (S >>> 0 < T >>> 0 ? 1 : 0), k = v.low = k + W2, v.high = M + K2 + (k >>> 0 < W2 >>> 0 ? 1 : 0);
              }, t3.prototype.fn = function() {
                var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
                return t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[30 + (i3 + 128 >>> 10 << 5)] = Math.floor(r3 / 4294967296), t4[31 + (i3 + 128 >>> 10 << 5)] = r3, n4.nSigBytes = 4 * t4.length, this.an(), this.on.to32();
              }, t3.prototype.clone = function() {
                return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
              }, t3.hash = function(n4, r3) {
                return new t3(r3).finalize(n4);
              }, t3;
            }(e.P);
          }, 3354: function(n2, t2, r2) {
            r2.d(t2, { e: function() {
              return o;
            } });
            var i2 = r2(5720), e = r2(9054), o = function() {
              function n3(t3, r3) {
                if (Array.isArray(t3) || !t3)
                  return this.yn = Array.isArray(t3) ? t3 : [], void (this.pn = "number" == typeof r3 ? r3 : 4 * this.yn.length);
                if (t3 instanceof n3)
                  return this.yn = t3.words.slice(), void (this.pn = t3.nSigBytes);
                var i3;
                try {
                  t3 instanceof ArrayBuffer ? i3 = new Uint8Array(t3) : (t3 instanceof Uint8Array || t3 instanceof Int8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array) && (i3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
                } catch (n4) {
                  throw new Error("Invalid argument");
                }
                if (!i3)
                  throw new Error("Invalid argument");
                for (var e2 = i3.byteLength, o2 = [], u = 0; u < e2; u++)
                  o2[u >>> 2] |= i3[u] << 24 - u % 4 * 8;
                this.yn = o2, this.pn = e2;
              }
              return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
                return this.pn;
              }, set: function(n4) {
                this.pn = n4;
              }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
                return this.yn;
              }, enumerable: false, configurable: true }), n3.prototype.toString = function(n4) {
                return n4 ? n4.stringify(this) : i2.p.stringify(this);
              }, n3.prototype.toUint8Array = function() {
                for (var n4 = this.yn, t3 = this.pn, r3 = new Uint8Array(t3), i3 = 0; i3 < t3; i3++)
                  r3[i3] = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                return r3;
              }, n3.prototype.concat = function(n4) {
                var t3 = n4.words.slice(), r3 = n4.nSigBytes;
                if (this.clamp(), this.pn % 4)
                  for (var i3 = 0; i3 < r3; i3++) {
                    var e2 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                    this.yn[this.pn + i3 >>> 2] |= e2 << 24 - (this.pn + i3) % 4 * 8;
                  }
                else
                  for (i3 = 0; i3 < r3; i3 += 4)
                    this.yn[this.pn + i3 >>> 2] = t3[i3 >>> 2];
                return this.pn += r3, this;
              }, n3.prototype.clamp = function() {
                var n4 = this.pn;
                this.yn[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, this.yn.length = Math.ceil(n4 / 4);
              }, n3.prototype.clone = function() {
                return new n3(this.yn.slice(), this.pn);
              }, n3.random = function(t3) {
                for (var r3 = [], i3 = 0; i3 < t3; i3 += 4)
                  r3.push((0, e.M)());
                return new n3(r3, t3);
              }, n3;
            }();
          }, 6957: function(n2, t2, r2) {
            r2.d(t2, { r: function() {
              return o;
            }, m: function() {
              return u;
            } });
            var i2 = r2(5720), e = r2(3354), o = function() {
              function n3(n4, t3) {
                this.high = n4, this.low = t3;
              }
              return n3.prototype.clone = function() {
                return new n3(this.high, this.low);
              }, n3;
            }(), u = function() {
              function n3(n4, t3) {
                this.yn = n4 || [], this.pn = "number" == typeof t3 ? t3 : 8 * this.yn.length;
              }
              return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
                return this.pn;
              }, set: function(n4) {
                this.pn = n4;
              }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
                return this.yn;
              }, enumerable: false, configurable: true }), n3.prototype.to32 = function() {
                for (var n4 = [], t3 = 0; t3 < this.yn.length; t3++) {
                  var r3 = this.yn[t3];
                  n4.push(r3.high), n4.push(r3.low);
                }
                return new e.e(n4, this.pn);
              }, n3.prototype.toString = function(n4) {
                return n4 ? n4.stringify(this.to32()) : i2.p.stringify(this.to32());
              }, n3.prototype.clone = function() {
                for (var t3 = this.yn.slice(), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = t3[r3].clone();
                return new n3(t3, this.pn);
              }, n3;
            }();
          }, 7211: function(n2, t2, r2) {
            r2.d(t2, { C: function() {
              return o;
            } });
            var i2 = r2(3354), e = r2(4768), o = function() {
              function n3(n4) {
                this.On = 0, this.N = 0, this.O = n4, this.cn = n4 && void 0 !== n4.data ? n4.data.clone() : new i2.e(), this.sn = n4 && "number" == typeof n4.nBytes ? n4.nBytes : 0;
              }
              return Object.defineProperty(n3.prototype, "blockSize", { get: function() {
                return this.N;
              }, enumerable: false, configurable: true }), n3.prototype.reset = function(n4, t3) {
                this.cn = void 0 !== n4 ? n4.clone() : new i2.e(), this.sn = "number" == typeof t3 ? t3 : 0;
              }, n3.prototype.jn = function(n4) {
                var t3 = "string" == typeof n4 ? e.d.parse(n4) : n4;
                this.cn.concat(t3), this.sn += t3.nSigBytes;
              }, n3.prototype.an = function(n4) {
                var t3, r3 = this.cn.words, e2 = this.cn.nSigBytes, o2 = this.N, u = e2 / (4 * this.N), f = (u = n4 ? Math.ceil(u) : Math.max((0 | u) - this.On, 0)) * o2, c = Math.min(4 * f, e2);
                if (f) {
                  for (var s = 0; s < f; s += o2)
                    this.un(r3, s);
                  t3 = r3.splice(0, f), this.cn.nSigBytes -= c;
                }
                return new i2.e(t3, c);
              }, n3.prototype.un = function(n4, t3) {
                throw new Error("Not implemented");
              }, n3;
            }();
          }, 1868: function(n2, t2, r2) {
            r2.d(t2, { P: function() {
              return u;
            } });
            var i2, e = r2(7211), o = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), u = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 16, r3.O = t4, t4 && "number" == typeof t4.blockSize && (r3.N = t4.blockSize), r3.reset(t4 ? t4.data : void 0, t4 ? t4.nBytes : void 0), r3;
              }
              return o(t3, n3), Object.defineProperty(t3.prototype, "blockSize", { get: function() {
                return this.N;
              }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                n3.prototype.reset.call(this, t4, r3), this.A();
              }, t3.prototype.update = function(n4) {
                return this.jn(n4), this.an(), this;
              }, t3.prototype.finalize = function(n4) {
                return n4 && this.jn(n4), this.fn();
              }, t3.prototype.A = function() {
                throw new Error("Not implemented");
              }, t3.prototype.fn = function() {
                throw new Error("Not implemented");
              }, t3;
            }(e.C);
          }, 787: function(n2, t2, r2) {
            r2.d(t2, { G: function() {
              return s;
            } });
            var i2, e = r2(9456), o = r2(4344), u = r2(7919), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function() {
              return (c = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 4, r3._n = o.n, r3.mn = u.l, r3.O = t4, r3._n = void 0 !== t4.mode ? t4.mode : r3._n, r3.mn = void 0 !== t4.padding ? t4.padding : r3.mn, r3.reset(null == t4 ? void 0 : t4.data, null == t4 ? void 0 : t4.nBytes), r3;
              }
              return f(t3, n3), Object.defineProperty(t3.prototype, "mode", { get: function() {
                return this.An;
              }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "padding", { get: function() {
                return this.mn;
              }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                var i3;
                n3.prototype.reset.call(this, t4, r3), this.gn === e.t.ENC_TRANSFORM_MODE ? i3 = this._n.createEncryptor : (i3 = this._n.createDecryptor, this.On = 1), this._n && this.En === i3 ? this.An = new this._n({ cipher: this, iv: this.ln }) : (this.An = i3.call(this._n, { cipher: this, iv: this.ln }), this.En = i3);
              }, t3.prototype.un = function(n4, t4) {
                var r3;
                null === (r3 = this.An) || void 0 === r3 || r3.processBlock(n4, t4);
              }, t3.prototype.fn = function() {
                var n4, t4 = this.mn;
                return this.gn === e.t.ENC_TRANSFORM_MODE ? (t4.pad(this.cn, this.blockSize), n4 = this.an(true)) : (n4 = this.an(true), t4.unpad(n4)), n4;
              }, t3.prototype.encryptBlock = function(n4, t4) {
                throw new Error("Not implemented");
              }, t3.prototype.decryptBlock = function(n4, t4) {
                throw new Error("Not implemented");
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
              }, t3;
            }(e.t);
          }, 9456: function(n2, t2, r2) {
            r2.d(t2, { t: function() {
              return f;
            } });
            var i2, e = r2(7211), o = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), u = function() {
              return (u = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, f = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.gn = 1, r3.O = t4, r3.H = t4.key, r3.ln = void 0 !== t4.iv ? t4.iv : r3.ln, r3.gn = void 0 !== t4.transformMode ? t4.transformMode : r3.gn, r3;
              }
              return o(t3, n3), Object.defineProperty(t3.prototype, "iv", { get: function() {
                return this.ln;
              }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
                n3.prototype.reset.call(this, t4, r3), this.A();
              }, t3.prototype.process = function(n4) {
                return this.jn(n4), this.an();
              }, t3.prototype.finalize = function(n4) {
                return n4 && this.jn(n4), this.fn();
              }, t3.prototype.A = function() {
                throw new Error("Not implemented");
              }, t3.prototype.un = function(n4, t4) {
                throw new Error("Not implemented");
              }, t3.prototype.fn = function() {
                throw new Error("Not implemented");
              }, t3.createEncryptor = function(n4, r3) {
                return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.ENC_TRANSFORM_MODE }));
              }, t3.createDecryptor = function(n4, r3) {
                return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.DEC_TRANSFORM_MODE }));
              }, t3.ENC_TRANSFORM_MODE = 1, t3.DEC_TRANSFORM_MODE = 2, t3.keySize = 4, t3.ivSize = 4, t3;
            }(e.C);
          }, 2505: function(n2, t2, r2) {
            r2.d(t2, { Q: function() {
              return e;
            } });
            var i2 = r2(1232), e = function() {
              function n3(n4) {
                this.formatter = i2.w, n4 && (this.cipherText = n4.cipherText, this.key = n4.key, this.iv = n4.iv, this.salt = n4.salt, this.Algorithm = n4.Algorithm, this.mode = n4.mode, this.padding = n4.padding, this.blockSize = n4.blockSize, this.formatter = n4.formatter || i2.w);
              }
              return n3.prototype.toString = function(n4) {
                return (n4 || this.formatter).stringify(this);
              }, n3;
            }();
          }, 5693: function(n2, t2, r2) {
            r2.d(t2, { E: function() {
              return c;
            } });
            var i2 = r2(9109), e = r2(2214), o = r2(2505), u = r2(1232), f = function() {
              return (f = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, c = { encrypt: function(n3, t3, r3, u2) {
              var c2 = u2 ? f({}, u2) : {}, s = u2 && u2.KDF ? u2.KDF : e.s, a = {};
              u2 && u2.kdfHasher && (a.kdfHasher = u2.kdfHasher), u2 && u2.kdfIterations && (a.kdfIterations = u2.kdfIterations), u2 && u2.kdfModule && (a.kdfModule = u2.kdfModule);
              var h = s.execute(r3, n3.keySize, n3.ivSize, c2.kdfSalt, a);
              c2.iv = h.iv;
              var v = i2.D.encrypt(n3, t3, h.key, c2);
              return new o.Q(f(f({}, v), { key: h.key, iv: h.iv, salt: h.salt }));
            }, decrypt: function(n3, t3, r3, o2) {
              var c2 = o2 ? f({}, o2) : {}, s = c2.KDF ? c2.KDF : e.s, a = c2.formatter ? c2.formatter : u.w, h = (0, i2.W)(t3, a), v = {};
              o2 && o2.kdfHasher && (v.kdfHasher = o2.kdfHasher), o2 && o2.kdfIterations && (v.kdfIterations = o2.kdfIterations), o2 && o2.kdfModule && (v.kdfModule = o2.kdfModule);
              var w = s.execute(r3, n3.keySize, n3.ivSize, h.salt, v);
              return c2.iv = w.iv, i2.D.decrypt(n3, h, w.key, c2);
            } };
          }, 9109: function(n2, t2, r2) {
            r2.d(t2, { W: function() {
              return o;
            }, D: function() {
              return u;
            } });
            var i2 = r2(1232), e = r2(2505);
            function o(n3, t3) {
              return "string" == typeof n3 ? t3.parse(n3) : n3;
            }
            var u = { encrypt: function(n3, t3, r3, o2) {
              var u2 = n3.createEncryptor(r3, o2), f = u2.finalize(t3);
              return new e.Q({ cipherText: f, key: r3, iv: u2.iv, Algorithm: n3, mode: u2.mode, padding: u2.padding, blockSize: u2.blockSize, formatter: (null == o2 ? void 0 : o2.formatter) || i2.w });
            }, decrypt: function(n3, t3, r3, e2) {
              var u2 = n3.createDecryptor(r3, e2), f = o(t3, (null == e2 ? void 0 : e2.formatter) || i2.w);
              return u2.finalize(f.cipherText || "");
            } };
          }, 30: function(n2, t2, r2) {
            r2.d(t2, { q: function() {
              return u;
            } });
            var i2, e = r2(9456), o = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), u = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.N = 1, r3;
              }
              return o(t3, n3), t3.prototype.fn = function() {
                return this.an(true);
              }, t3;
            }(e.t);
          }, 1232: function(n2, t2, r2) {
            r2.d(t2, { w: function() {
              return u;
            } });
            var i2 = r2(2505), e = r2(3354), o = r2(1773), u = { stringify: function(n3) {
              var t3 = n3.cipherText, r3 = n3.salt;
              return t3 ? r3 ? new e.e([1398893684, 1701076831]).concat(r3).concat(t3).toString(o.D) : t3.toString(o.D) : "";
            }, parse: function(n3) {
              var t3, r3 = o.D.parse(n3), u2 = r3.words;
              return 1398893684 === u2[0] && 1701076831 === u2[1] && (t3 = new e.e(u2.slice(2, 4)), u2.splice(0, 4), r3.nSigBytes -= 16), new i2.Q({ cipherText: r3, salt: t3 });
            } };
          }, 2214: function(n2, t2, r2) {
            r2.d(t2, { s: function() {
              return f;
            } });
            var i2 = r2(3354), e = r2(2505), o = r2(7008), u = function() {
              return (u = Object.assign || function(n3) {
                for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++)
                  for (var e2 in t3 = arguments[r3])
                    Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
                return n3;
              }).apply(this, arguments);
            }, f = { execute: function(n3, t3, r3, f2, c) {
              f2 || (f2 = i2.e.random(8));
              var s = c && c.kdfModule || o.E, a = c ? { Hasher: c.kdfHasher, iterations: c.kdfIterations } : {}, h = s.getKey(n3, f2, u(u({}, a), { keySize: t3 + r3 })), v = new i2.e(h.words.slice(t3), 4 * r3);
              return h.nSigBytes = 4 * t3, new e.Q({ key: h, iv: v, salt: f2 });
            } };
          }, 7008: function(n2, t2, r2) {
            r2.d(t2, { E: function() {
              return s;
            } });
            var i2, e = r2(5561), o = r2(6367), u = r2(3354), f = r2(9541), c = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), s = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.Sn = 4, r3.Mn = e.SHA256, r3.kn = 1e4, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
              }
              return c(t3, n3), t3.prototype.compute = function(n4, t4) {
                for (var r3 = new o.Hmac(new this.Mn(), n4), i3 = new u.e(), e2 = new u.e([1]), f2 = i3.words, c2 = e2.words, s2 = this.Sn, a = this.kn; f2.length < s2; ) {
                  var h = r3.update(t4).finalize(e2);
                  r3.reset();
                  for (var v = h.words, w = v.length, l = h, b = 1; b < a; b++) {
                    l = r3.finalize(l), r3.reset();
                    for (var d = l.words, y = 0; y < w; y++)
                      v[y] ^= d[y];
                  }
                  i3.concat(h), c2[0]++;
                }
                return i3.nSigBytes = 4 * s2, i3;
              }, t3.getKey = function(n4, r3, i3) {
                return new t3(i3).compute(n4, r3);
              }, t3;
            }(f._);
          }, 9541: function(n2, t2, r2) {
            r2.d(t2, { _: function() {
              return i2;
            } });
            var i2 = function() {
              function n3(n4) {
                this.O = n4;
              }
              return n3.prototype.compute = function(n4, t3) {
                throw new Error("Not implemented");
              }, n3.getKey = function(n4, t3, r3) {
                throw new Error("Not implemented");
              }, n3;
            }();
          }, 1863: function(n2, t2, r2) {
            r2.d(t2, { T: function() {
              return i2;
            } });
            var i2 = function() {
              function n3(n4) {
                this.O = n4, this.Hn = n4.cipher, this.ln = n4.iv;
              }
              return n3.prototype.processBlock = function(n4, t3) {
              }, n3.createEncryptor = function(n4) {
                throw new Error("Not implemented yet");
              }, n3.createDecryptor = function(n4) {
                throw new Error("Not implemented yet");
              }, n3;
            }();
          }, 4344: function(n2, t2, r2) {
            r2.d(t2, { n: function() {
              return u;
            } });
            var i2, e = r2(1863), o = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), u = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.Cn = [], r3;
              }
              return o(t3, n3), t3.prototype.xorBlock = function(n4, t4, r3) {
                var i3, e2 = this.ln;
                e2 ? (i3 = e2.words, this.ln = void 0) : i3 = this.Cn;
                for (var o2 = 0; o2 < r3; o2++)
                  n4[t4 + o2] ^= i3[o2];
              }, t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  var r3 = this.Hn, i3 = r3.blockSize;
                  this.xorBlock(n5, t5, i3), r3.encryptBlock(n5, t5), this.Cn = n5.slice(t5, t5 + i3);
                }, t4;
              }(t3), t3.Decryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  var r3 = this.Hn, i3 = r3.blockSize, e2 = n5.slice(t5, t5 + i3);
                  r3.decryptBlock(n5, t5), this.xorBlock(n5, t5, i3), this.Cn = e2;
                }, t4;
              }(t3), t3;
            }(e.T);
          }, 4055: function(n2, t2, r2) {
            r2.d(t2, { I4: function() {
              return e;
            }, z6: function() {
              return o;
            }, ur: function() {
              return u;
            } });
            var i2 = r2(3354);
            function e(n3) {
              var t3 = n3.nSigBytes % 16;
              if (0 !== t3) {
                for (var r3 = 16 - t3, e2 = [], o2 = Math.floor(r3 / 4), u2 = 0; u2 < o2; u2++)
                  e2.push(0);
                r3 % 4 > 0 && e2.push(0), n3.concat(new i2.e(e2, r3));
              }
            }
            function o(n3, t3) {
              return new i2.e(n3.words.slice(), t3);
            }
            function u(n3, t3) {
              for (var r3 = n3.nSigBytes - t3, e2 = [], o2 = 0; o2 < t3; o2++) {
                var u2 = o2 >>> 2, f = r3 + o2, c = f >>> 2, s = n3.words[c] >>> 24 - f % 4 * 8 & 255;
                e2[u2] = 0 | e2[u2] | s << 24 - o2 % 4 * 8;
              }
              var a = new i2.e(e2, t3);
              return a.clamp(), a;
            }
          }, 7919: function(n2, t2, r2) {
            r2.d(t2, { l: function() {
              return e;
            } });
            var i2 = r2(3354);
            var e = { pad: function(n3, t3) {
              for (var r3 = 4 * t3, e2 = r3 - n3.nSigBytes % r3, o = e2 << 24 | e2 << 16 | e2 << 8 | e2, u = [], f = 0; f < e2; f += 4)
                u.push(o);
              var c = new i2.e(u, e2);
              n3.concat(c);
            }, unpad: function(n3) {
              var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
              n3.nSigBytes -= t3;
            } };
          }, 1756: function(n2, t2, r2) {
            r2.d(t2, { w: function() {
              return u;
            } });
            var i2, e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", o = (i2 = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(i2) ? (i2 = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(i2) && i2) : i2);
            function u(n3, t3) {
              return false !== o && (!t3 || ("<" === n3 ? o < t3 : "<=" === n3 ? o <= t3 : ">" === n3 ? o > t3 : ">=" === n3 ? o >= t3 : o === t3));
            }
          }, 1773: function(n2, t2, r2) {
            r2.d(t2, { D: function() {
              return f;
            } });
            for (var i2 = r2(3354), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = [], u = 0; u < e.length; u++)
              o[e.charCodeAt(u)] = u;
            var f = { stringify: function(n3) {
              var t3 = n3.words, r3 = n3.nSigBytes;
              n3.clamp();
              for (var i3 = [], o2 = 0; o2 < r3; o2 += 3)
                for (var u2 = (t3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (t3[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | t3[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, f2 = 0; f2 < 4 && o2 + 0.75 * f2 < r3; f2++)
                  i3.push(e.charAt(u2 >>> 6 * (3 - f2) & 63));
              var c = e.charAt(64);
              if (c)
                for (; i3.length % 4; )
                  i3.push(c);
              return i3.join("");
            }, parse: function(n3) {
              var t3 = n3.length, r3 = e.charAt(64);
              if (r3) {
                var u2 = n3.indexOf(r3);
                -1 !== u2 && (t3 = u2);
              }
              for (var f2 = [], c = 0, s = 0; s < t3; s++)
                if (s % 4) {
                  var a = o[n3.charCodeAt(s - 1)] << s % 4 * 2 | o[n3.charCodeAt(s)] >>> 6 - s % 4 * 2;
                  f2[c >>> 2] |= a << 24 - c % 4 * 8, c++;
                }
              return new i2.e(f2, c);
            } };
          }, 5720: function(n2, t2, r2) {
            r2.d(t2, { p: function() {
              return e;
            } });
            var i2 = r2(3354), e = { stringify: function(n3) {
              for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
                var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
                i3.push((o >>> 4).toString(16)), i3.push((15 & o).toString(16));
              }
              return i3.join("");
            }, parse: function(n3) {
              var t3 = n3.length;
              if (t3 % 2 != 0)
                throw new Error("Hex string count must be even");
              if (!/^[a-fA-F0-9]+$/.test(n3))
                throw new Error("Invalid Hex string: " + n3);
              for (var r3 = [], e2 = 0; e2 < t3; e2 += 2)
                r3[e2 >>> 3] |= parseInt(n3.substr(e2, 2), 16) << 24 - e2 % 8 * 4;
              return new i2.e(r3, t3 / 2);
            } };
          }, 8702: function(n2, t2, r2) {
            r2.d(t2, { m: function() {
              return e;
            } });
            var i2 = r2(3354), e = { stringify: function(n3) {
              for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
                var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
                i3.push(String.fromCharCode(o));
              }
              return i3.join("");
            }, parse: function(n3) {
              for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++)
                r3[e2 >>> 2] |= (255 & n3.charCodeAt(e2)) << 24 - e2 % 4 * 8;
              return new i2.e(r3, t3);
            } };
          }, 4768: function(n2, t2, r2) {
            r2.d(t2, { d: function() {
              return e;
            } });
            var i2 = r2(8702), e = { stringify: function(n3) {
              try {
                return decodeURIComponent(escape(i2.m.stringify(n3)));
              } catch (n4) {
                throw new Error("Malformed UTF-8 data");
              }
            }, parse: function(n3) {
              return i2.m.parse(unescape(encodeURIComponent(n3)));
            } };
          }, 2688: function(n2, t2, r2) {
            r2.d(t2, { Base64: function() {
              return o.D;
            }, EvpKDF: function() {
              return O;
            }, Hex: function() {
              return c.p;
            }, Latin1: function() {
              return f.m;
            }, OpenSSLKDF: function() {
              return l.s;
            }, PBKDF2: function() {
              return b.E;
            }, Utf16: function() {
              return w;
            }, Utf16BE: function() {
              return s;
            }, Utf16LE: function() {
              return v;
            }, Utf8: function() {
              return u.d;
            }, Word32Array: function() {
              return i2.e;
            }, Word64: function() {
              return e.r;
            }, Word64Array: function() {
              return e.m;
            } });
            r2(9054);
            var i2 = r2(3354), e = r2(6957), o = (r2(1756), r2(1773)), u = r2(4768), f = r2(8702), c = r2(5720), s = { stringify: function(n3) {
              for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
                var o2 = t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535;
                i3.push(String.fromCharCode(o2));
              }
              return i3.join("");
            }, parse: function(n3) {
              for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++)
                r3[e2 >>> 1] |= n3.charCodeAt(e2) << 16 - e2 % 2 * 16;
              return new i2.e(r3, 2 * t3);
            } };
            function a(n3) {
              return n3 << 8 & 4278255360 | n3 >>> 8 & 16711935;
            }
            var h, v = { stringify: function(n3) {
              for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
                var o2 = a(t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535);
                i3.push(String.fromCharCode(o2));
              }
              return i3.join("");
            }, parse: function(n3) {
              for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++)
                r3[e2 >>> 1] |= a(n3.charCodeAt(e2) << 16 - e2 % 2 * 16);
              return new i2.e(r3, 2 * t3);
            } }, w = s, l = r2(2214), b = r2(7008), d = r2(670), y = r2(9541), p = (h = function(n3, t3) {
              return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              h(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), O = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                return r3.Sn = 4, r3.Mn = d.MD5, r3.kn = 1, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
              }
              return p(t3, n3), t3.prototype.compute = function(n4, t4) {
                for (var r3, e2 = new this.Mn(), o2 = new i2.e(), u2 = o2.words, f2 = this.Sn, c2 = this.kn; u2.length < f2; ) {
                  r3 && e2.update(r3), r3 = e2.update(n4).finalize(t4), e2.reset();
                  for (var s2 = 1; s2 < c2; s2++)
                    r3 = e2.finalize(r3), e2.reset();
                  o2.concat(r3);
                }
                return o2.nSigBytes = 4 * f2, o2;
              }, t3.getKey = function(n4, r3, i3) {
                return new t3(i3).compute(n4, r3);
              }, t3;
            }(y._);
          }, 9054: function(n2, t2, r2) {
            r2.d(t2, { M: function() {
              return e;
            } });
            var i2 = r2(1756);
            var e = function() {
              if ("undefined" != typeof window) {
                var n3 = window.crypto || window.msCrypto;
                if (!n3) {
                  if ((0, i2.w)("<", 11))
                    return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function() {
                      return Math.floor(512 * Math.random()) % 256;
                    };
                  throw new Error("Crypto module not found");
                }
                return function() {
                  return n3.getRandomValues(new Uint32Array(1))[0];
                };
              }
              return void 0 !== r2.g && r2.g.crypto ? function() {
                return r2.g.crypto.randomBytes(4).readInt32LE();
              } : function() {
                return require_crypto().randomBytes(4).readInt32LE();
              };
            }();
          }, 3664: function(n2, t2, r2) {
            r2.d(t2, { K: function() {
              return c;
            } });
            var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function(n3) {
              function t3(t4) {
                var r3 = n3.call(this, t4) || this;
                r3.Bn = 1;
                var i3 = t4.cipher, e2 = t4.iv;
                if (4 !== i3.blockSize)
                  throw new Error("In CCM, cipher block size must be 128bit");
                if (e2 && (e2.nSigBytes > 13 || e2.nSigBytes < 7))
                  throw new Error("Byte size of iv must be between 7 and 13");
                return r3.Nn = e2 || new o.e([0, 0], 8), r3.In = 15 - r3.Nn.nSigBytes, r3;
              }
              return f(t3, n3), t3.getB0 = function(n4, t4, r3, i3) {
                if (r3.nSigBytes + i3.nSigBytes !== 15)
                  throw new Error("LEN(Q)+LEN(N) must be 15");
                var e2 = 255 & (0 | (n4 ? 1 : 0) << 6 | (t4 - 2) / 2 << 3 | r3.nSigBytes - 1), u2 = i3.clone().concat(r3);
                return new o.e([e2 << 24], 1).concat(u2);
              }, t3.formatAssociatedDataAndPayload = function(n4, t4) {
                var r3, i3 = n4.nSigBytes;
                if (0 === i3)
                  r3 = new o.e([0], 0);
                else if (i3 < Math.pow(2, 16) - Math.pow(2, 8))
                  r3 = new o.e([i3 << 16], 2);
                else {
                  if (!(i3 < Math.pow(2, 32)))
                    throw new Error("LEN(A) larger than 2**32-1 is not supported");
                  r3 = new o.e([4294836224], 2).concat(new o.e([i3], 4));
                }
                for (var e2 = Math.floor(n4.nSigBytes / 4), u2 = 0; u2 < e2; u2++)
                  r3.concat(new o.e([n4.words[u2]], 4));
                n4.nSigBytes % 4 && (r3.concat(new o.e([n4.words[e2]], n4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - n4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16));
                var f2 = Math.floor(t4.nSigBytes / 4);
                for (u2 = 0; u2 < f2; u2++)
                  r3.concat(new o.e([t4.words[u2]], 4));
                return t4.nSigBytes % 4 && (r3.concat(new o.e([t4.words[f2]], t4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - t4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16)), r3;
              }, t3.genCtr = function(n4, t4, r3) {
                if (t4.nSigBytes + n4 !== 15)
                  throw new Error("LEN(Q)+LEN(N) must be 15");
                for (var i3 = new o.e([(n4 - 1 & 7) << 24], 1), e2 = new o.e([], 0), u2 = Math.floor(n4 / 4), f2 = 0; f2 < u2 - 1; f2++)
                  e2.concat(new o.e([0], 4));
                return n4 % 4 ? n4 > 4 ? (e2.concat(new o.e([0], n4 % 4)), e2.concat(new o.e([r3], 4))) : e2.concat(new o.e([r3 << 32 - 8 * n4], n4)) : e2.concat(new o.e([r3], 4)), i3.concat(t4).concat(e2);
              }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
                var s = new n4({ key: r3, iv: i3 });
                if (4 !== s.blockSize)
                  throw new Error("In CCM, cipher block size must be 128bit");
                if (i3 && (i3.nSigBytes > 13 || i3.nSigBytes < 7))
                  throw new Error("Byte size of iv must be between 7 and 13");
                var a = i3 || new o.e([0, 0], 8), h = (null == e2 ? void 0 : e2.clone()) || new o.e(), v = h.nSigBytes, w = (null == f2 ? void 0 : f2.clone()) || new o.e(), l = w.nSigBytes;
                if (l >>> 0 > 4294967295)
                  throw new Error("Byte length of Payload(plainText) larger than 2^32-1 (4,294,967,295byte) is not supported at this time.");
                var b = 15 - a.nSigBytes, d = (0, u.ur)(new o.e([0, l], 8), b), y = c2 || 16, p = t3.getB0(Boolean(v), y, d, a), O = t3.formatAssociatedDataAndPayload(h, w), j = p.words.slice();
                s.encryptBlock(j, 0);
                for (var _ = O.nSigBytes / 16, m = O.words, A = j, g = 0; g < _; g++) {
                  var E = [m[4 * g] ^ A[0], m[4 * g + 1] ^ A[1], m[4 * g + 2] ^ A[2], m[4 * g + 3] ^ A[3]];
                  s.encryptBlock(E, 0), A = E;
                }
                var S = new o.e(A, y), M = t3.genCtr(b, a, 0);
                s.encryptBlock(M.words, 0);
                for (g = 0; g < 4; g++)
                  S.words[g] ^= M.words[g];
                return S.clamp(), S;
              }, t3.combineCipherTextAndAuthTag = function(n4, t4) {
                return n4.clone().concat(t4);
              }, t3.splitCipherTextAndAuthTag = function(n4, t4) {
                var r3 = t4 || 16;
                return { cipherText: (0, u.z6)(n4, n4.nSigBytes - r3), authTag: (0, u.ur)(n4, r3) };
              }, t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function r3() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                  var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                  i3.encryptBlock(o2.words, 0);
                  for (var u2 = 0; u2 < e2; u2++)
                    n5[r4 + u2] ^= o2.words[u2];
                  this.Bn++;
                }, r3;
              }(t3), t3.Decryptor = function(n4) {
                function r3() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                  var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                  i3.encryptBlock(o2.words, 0);
                  for (var u2 = 0; u2 < e2; u2++)
                    n5[r4 + u2] ^= o2.words[u2];
                  this.Bn++;
                }, r3;
              }(t3), t3;
            }(e.T);
          }, 5607: function(n2, t2, r2) {
            r2.d(t2, { V: function() {
              return c;
            } });
            var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
              return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(n3, t3);
            }, function(n3, t3) {
              function r3() {
                this.constructor = n3;
              }
              i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            }), c = function(n3) {
              function t3(r3) {
                var i3 = n3.call(this, r3) || this;
                if (i3.zn = [], i3.Dn = [], i3.Un = [], 4 !== r3.cipher.blockSize)
                  throw new Error("In GCM block cipher mode, cipher block size must be 128bit");
                var e2 = r3.cipher, o2 = r3.iv, u2 = [0, 0, 0, 0];
                return e2.encryptBlock(u2, 0), i3.zn = u2, i3.Dn = t3.getJ0(u2, null == o2 ? void 0 : o2.words), i3.Un = i3.Dn.slice(), i3;
              }
              return f(t3, n3), t3.getJ0 = function(n4, r3) {
                var i3;
                if (r3 && 0 !== r3.length)
                  if (3 === r3.length)
                    i3 = [r3[0], r3[1], r3[2], 1];
                  else {
                    for (var e2 = r3.length % 4 > 0 ? 4 - r3.length % 4 : 0, o2 = r3.slice(), u2 = 0; u2 < e2 + 2; u2++)
                      o2.push(0);
                    o2.push(0), o2.push(32 * r3.length), i3 = t3.GHASH(n4, o2);
                  }
                else
                  i3 = [0, 0, 0, 1];
                return i3;
              }, t3.inc32 = function(n4) {
                var t4 = n4.slice(), r3 = t4[3] >>> 0, i3 = r3 + 1 >>> 0 < r3;
                if (t4[3] = t4[3] + 1 | 0, i3) {
                  var e2 = t4[2] >>> 0, o2 = e2 + 1 >>> 0 < e2;
                  t4[2] = t4[2] + 1 | 0, o2 && (t4[1] = t4[1] + 1 | 0);
                }
                return t4;
              }, t3.mul = function(n4, t4) {
                for (var r3 = [3774873600, 0, 0, 0], i3 = [0, 0, 0, 0], e2 = t4.slice(), o2 = 0; o2 < 128; o2++) {
                  (n4[o2 >>> 5] >>> 31 - o2 % 32 & 1) > 0 && (i3[0] = i3[0] ^ e2[0], i3[1] = i3[1] ^ e2[1], i3[2] = i3[2] ^ e2[2], i3[3] = i3[3] ^ e2[3]);
                  var u2 = (1 & e2[3]) >>> 0, f2 = (1 & e2[0]) >>> 0, c2 = (1 & e2[1]) >>> 0, s = (1 & e2[2]) >>> 0;
                  e2[0] = e2[0] >>> 1, e2[1] = e2[1] >>> 1 | (f2 ? 2147483648 : 0), e2[2] = e2[2] >>> 1 | (c2 ? 2147483648 : 0), e2[3] = e2[3] >>> 1 | (s ? 2147483648 : 0), u2 > 0 && (e2[0] ^= r3[0], e2[1] ^= r3[1], e2[2] ^= r3[2], e2[3] ^= r3[3]);
                }
                return i3;
              }, t3.GHASH = function(n4, r3) {
                if (n4.length % 4 != 0)
                  throw new Error("Length of 32bit word array 'H' must be multiple of 4(128bit)");
                if (r3.length % 4 != 0)
                  throw new Error("Length of 32bit word array 'X' must be multiple of 4(128bit)");
                for (var i3 = r3.length, e2 = [0, 0, 0, 0], o2 = 0; o2 < i3; o2 += 4)
                  e2[0] = e2[0] ^ r3[o2], e2[1] = e2[1] ^ r3[o2 + 1], e2[2] = e2[2] ^ r3[o2 + 2], e2[3] = e2[3] ^ r3[o2 + 3], e2 = t3.mul(e2, n4);
                return e2;
              }, t3.GCTR = function(n4, r3, i3) {
                if (0 === i3.nSigBytes)
                  return i3.clone();
                if (4 !== r3.length)
                  throw new Error("Initial Counter Block size must be 128bit");
                for (var e2 = i3.words, u2 = Math.ceil(i3.nSigBytes / 16), f2 = [r3.slice()], c2 = 1; c2 < u2; c2++) {
                  var s = t3.inc32(f2[c2 - 1]);
                  f2.push(s);
                }
                var a = new o.e();
                for (c2 = 0; c2 < u2; c2++) {
                  n4.encryptBlock(f2[c2], 0);
                  var h = i3.nSigBytes % 16;
                  if (c2 < u2 - 1 || 0 === h) {
                    var v = e2[4 * c2] ^ f2[c2][0], w = e2[4 * c2 + 1] ^ f2[c2][1], l = e2[4 * c2 + 2] ^ f2[c2][2], b = e2[4 * c2 + 3] ^ f2[c2][3], d = new o.e([v, w, l, b]);
                    a.concat(d);
                  } else {
                    for (var y = [], p = 0, O = Math.floor(h / 4), j = 0; j < O; j++) {
                      var _ = e2[4 * c2 + j] ^ f2[c2][j];
                      y.push(_), p += 4;
                    }
                    var m = h % 4;
                    if (m > 0) {
                      var A = e2[4 * c2 + O] << 32 - 8 * m ^ f2[c2][O];
                      y.push(A), p += m;
                    }
                    var g = new o.e(y, p);
                    a.concat(g);
                  }
                }
                return a.nSigBytes = i3.nSigBytes, a.clamp(), a;
              }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
                var s = new n4({ key: r3, iv: i3 }), a = [0, 0, 0, 0];
                s.encryptBlock(a, 0);
                var h = t3.getJ0(a, i3.words), v = (null == e2 ? void 0 : e2.clone()) || new o.e(), w = [0, 8 * v.nSigBytes], l = (null == f2 ? void 0 : f2.clone()) || new o.e(), b = [0, 8 * l.nSigBytes], d = c2 || 16;
                (0, u.I4)(v), (0, u.I4)(l);
                var y = v.words.concat(l.words).concat(w).concat(b), p = t3.GHASH(a, y), O = t3.GCTR(s, h, new o.e(p));
                return (0, u.z6)(O, d);
              }, t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function r3() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                  var i3 = this.Hn.blockSize;
                  this.Un = t3.inc32(this.Un);
                  for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++)
                    n5[r4 + f2] = u2.words[f2];
                }, r3;
              }(t3), t3.Decryptor = function(n4) {
                function r3() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                  var i3 = this.Hn.blockSize;
                  this.Un = t3.inc32(this.Un);
                  for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++)
                    n5[r4 + f2] = u2.words[f2];
                }, r3;
              }(t3), t3;
            }(e.T);
          } }, t = {};
          function r(i2) {
            var e = t[i2];
            if (void 0 !== e)
              return e.exports;
            var o = t[i2] = { exports: {} };
            return n[i2](o, o.exports, r), o.exports;
          }
          r.d = function(n2, t2) {
            for (var i2 in t2)
              r.o(t2, i2) && !r.o(n2, i2) && Object.defineProperty(n2, i2, { enumerable: true, get: t2[i2] });
          }, r.g = function() {
            if ("object" == typeof globalThis)
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (n2) {
              if ("object" == typeof window)
                return window;
            }
          }(), r.o = function(n2, t2) {
            return Object.prototype.hasOwnProperty.call(n2, t2);
          }, r.r = function(n2) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "Ln", { value: true });
          };
          var i = {};
          return function() {
            r.r(i), r.d(i, { AES: function() {
              return A.AES;
            }, Base64: function() {
              return t2.Base64;
            }, CBCMAC: function() {
              return b.CBCMAC;
            }, CipherParams: function() {
              return u.Q;
            }, DES: function() {
              return g.DES;
            }, DES3: function() {
              return E.DES3;
            }, EvpKDF: function() {
              return t2.EvpKDF;
            }, GMAC: function() {
              return l.GMAC;
            }, Hex: function() {
              return t2.Hex;
            }, Hmac: function() {
              return f.Hmac;
            }, HmacMD5: function() {
              return c.HmacMD5;
            }, HmacSHA1: function() {
              return s.HmacSHA1;
            }, HmacSHA224: function() {
              return a.HmacSHA224;
            }, HmacSHA256: function() {
              return h.HmacSHA256;
            }, HmacSHA384: function() {
              return v.HmacSHA384;
            }, HmacSHA512: function() {
              return w.HmacSHA512;
            }, Latin1: function() {
              return t2.Latin1;
            }, MD5: function() {
              return d.MD5;
            }, OpenSSLKDF: function() {
              return t2.OpenSSLKDF;
            }, PBKDF2: function() {
              return t2.PBKDF2;
            }, PasswordBasedCipher: function() {
              return o.E;
            }, RC4: function() {
              return k.RC4;
            }, RC4Drop: function() {
              return H2.RC4Drop;
            }, RIPEMD160: function() {
              return S.RIPEMD160;
            }, Rabbit: function() {
              return M.Rabbit;
            }, SHA1: function() {
              return y.SHA1;
            }, SHA224: function() {
              return p.SHA224;
            }, SHA256: function() {
              return O.SHA256;
            }, SHA3: function() {
              return m.SHA3;
            }, SHA384: function() {
              return j.SHA384;
            }, SHA512: function() {
              return _.SHA512;
            }, SerializableCipher: function() {
              return e.D;
            }, Utf16: function() {
              return t2.Utf16;
            }, Utf16BE: function() {
              return t2.Utf16BE;
            }, Utf16LE: function() {
              return t2.Utf16LE;
            }, Utf8: function() {
              return t2.Utf8;
            }, Word32Array: function() {
              return t2.Word32Array;
            }, Word64: function() {
              return t2.Word64;
            }, Word64Array: function() {
              return t2.Word64Array;
            }, formatter: function() {
              return Y;
            }, mode: function() {
              return Z;
            }, pad: function() {
              return J;
            } });
            var n2, t2 = r(2688), e = r(9109), o = r(5693), u = r(2505), f = r(6367), c = r(3027), s = r(149), a = r(4105), h = r(980), v = r(5838), w = r(9902), l = r(7753), b = r(3967), d = r(670), y = r(3173), p = r(766), O = r(5561), j = r(6324), _ = r(7491), m = r(3408), A = r(9691), g = r(9910), E = r(6739), S = r(7104), M = r(5187), k = r(4615), H2 = r(9639), C = r(4344), B = r(1863), N = (n2 = function(t3, r2) {
              return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, t4) {
                n3.__proto__ = t4;
              } || function(n3, t4) {
                for (var r3 in t4)
                  Object.prototype.hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
              })(t3, r2);
            }, function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n2(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            }), I = function(n3) {
              function t3(t4) {
                var r2 = n3.call(this, t4) || this;
                return r2.Cn = [], r2;
              }
              return N(t3, n3), t3.prototype.generateKeyStreamAndEncrypt = function(n4, t4, r2, i2) {
                var e2, o2 = this.ln;
                o2 ? (e2 = o2.words.slice(0), this.ln = void 0) : e2 = this.Cn, i2.encryptBlock(e2, 0);
                for (var u2 = 0; u2 < r2; u2++)
                  n4[t4 + u2] ^= e2[u2];
              }, t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = n5.slice(t5, t5 + this.Hn.blockSize);
                }, t4;
              }(t3), t3.Decryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  var r2 = n5.slice(t5, t5 + this.Hn.blockSize);
                  this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = r2;
                }, t4;
              }(t3), t3;
            }(B.T), z = function() {
              var n3 = function(t3, r2) {
                return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4)
                    Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(t3, r2);
              };
              return function(t3, r2) {
                function i2() {
                  this.constructor = t3;
                }
                n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
              };
            }(), D = function(n3) {
              function t3(t4) {
                var r2 = n3.call(this, t4) || this;
                return r2.Fn = [], r2;
              }
              return z(t3, n3), t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return z(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.Fn;
                  e2 && (o2 = this.Fn = e2.words.slice(0), this.ln = void 0);
                  var u2 = o2.slice(0);
                  r2.encryptBlock(u2, 0), o2[i2 - 1] = o2[i2 - 1] + 1 | 0;
                  for (var f2 = 0; f2 < i2; f2++)
                    n5[t5 + f2] ^= u2[f2];
                }, t4;
              }(t3), t3.Decryptor = t3.Encryptor, t3;
            }(B.T), U = function() {
              var n3 = function(t3, r2) {
                return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4)
                    Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(t3, r2);
              };
              return function(t3, r2) {
                function i2() {
                  this.constructor = t3;
                }
                n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
              };
            }(), L = function(n3) {
              function t3(t4) {
                return n3.call(this, t4) || this;
              }
              return U(t3, n3), t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  this.Hn.encryptBlock(n5, t5);
                }, t4;
              }(t3), t3.Decryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  this.Hn.decryptBlock(n5, t5);
                }, t4;
              }(t3), t3;
            }(B.T), F = function() {
              var n3 = function(t3, r2) {
                return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                  n4.__proto__ = t4;
                } || function(n4, t4) {
                  for (var r3 in t4)
                    Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
                })(t3, r2);
              };
              return function(t3, r2) {
                function i2() {
                  this.constructor = t3;
                }
                n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
              };
            }(), x = function(n3) {
              function t3(t4) {
                var r2 = n3.call(this, t4) || this;
                return r2.xn = [], r2;
              }
              return F(t3, n3), t3.createEncryptor = function(n4) {
                return new t3.Encryptor(n4);
              }, t3.createDecryptor = function(n4) {
                return new t3.Decryptor(n4);
              }, t3.Encryptor = function(n4) {
                function t4() {
                  return null !== n4 && n4.apply(this, arguments) || this;
                }
                return F(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                  var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.xn;
                  e2 && (o2 = this.xn = e2.words.slice(0), this.ln = void 0), r2.encryptBlock(o2, 0);
                  for (var u2 = 0; u2 < i2; u2++)
                    n5[t5 + u2] ^= o2[u2];
                }, t4;
              }(t3), t3.Decryptor = t3.Encryptor, t3;
            }(B.T), P = r(5607), R = r(3664);
            var T = { pad: function(n3, t3) {
              var r2 = n3.nSigBytes, i2 = 4 * t3, e2 = i2 - r2 % i2, o2 = r2 + e2 - 1;
              n3.clamp(), n3.words[o2 >>> 2] |= e2 << 24 - o2 % 4 * 8, n3.nSigBytes += e2;
            }, unpad: function(n3) {
              var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
              n3.nSigBytes -= t3;
            } }, K2 = r(3354);
            var W2 = { pad: function(n3, t3) {
              var r2 = 4 * t3, i2 = r2 - n3.nSigBytes % r2;
              n3.concat(K2.e.random(i2 - 1)).concat(new K2.e([i2 << 24], 1));
            }, unpad: function(n3) {
              var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
              n3.nSigBytes -= t3;
            } };
            var G = { pad: function(n3, t3) {
              var r2 = 4 * t3;
              n3.clamp(), n3.nSigBytes += r2 - (n3.nSigBytes % r2 || r2);
            }, unpad: function(n3) {
              for (var t3 = n3.words, r2 = n3.nSigBytes - 1; r2 >= 0; r2--)
                if (t3[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255) {
                  n3.nSigBytes = r2 + 1;
                  break;
                }
            } };
            var q = { pad: function(n3, t3) {
              n3.concat(new K2.e([2147483648], 1)), G.pad(n3, t3);
            }, unpad: function(n3) {
              G.unpad(n3), n3.nSigBytes -= 1;
            } }, Q = r(7919);
            var X = { pad: function(n3, t3) {
            }, unpad: function(n3) {
            } }, V = r(1232), Z = { CBC: C.n, CFB: I, CTR: D, ECB: L, OFB: x, GCM: P.V, CCM: R.K }, J = { AnsiX923: T, ISO10126: W2, ISO97971: q, Pkcs7: Q.l, NoPadding: X, Zero: G }, Y = { OpenSSLFormatter: V.w };
          }(), i;
        }();
      });
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      init_polyfills();
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener2(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener2(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener2(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter2;
      }
    }
  });

  // (disabled):canvas
  var require_canvas = __commonJS({
    "(disabled):canvas"() {
      init_polyfills();
    }
  });

  // (disabled):zlib
  var require_zlib = __commonJS({
    "(disabled):zlib"() {
      init_polyfills();
    }
  });

  // (disabled):http
  var require_http = __commonJS({
    "(disabled):http"() {
      init_polyfills();
    }
  });

  // (disabled):https
  var require_https = __commonJS({
    "(disabled):https"() {
      init_polyfills();
    }
  });

  // node_modules/pdfjs-dist/build/pdf.js
  var require_pdf = __commonJS({
    "node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
      init_polyfills();
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define("pdfjs-dist/build/pdf", [], factory);
        else if (typeof exports === "object")
          exports["pdfjs-dist/build/pdf"] = factory();
        else
          root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
      })(exports, () => {
        return (
          /******/
          (() => {
            "use strict";
            var __webpack_modules__ = [
              ,
              /* 1 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
                exports2.arrayByteLength = arrayByteLength;
                exports2.arraysToBytes = arraysToBytes;
                exports2.assert = assert;
                exports2.bytesToString = bytesToString;
                exports2.createPromiseCapability = createPromiseCapability;
                exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
                exports2.escapeString = escapeString;
                exports2.getModificationDate = getModificationDate;
                exports2.getVerbosityLevel = getVerbosityLevel;
                exports2.info = info;
                exports2.isArrayBuffer = isArrayBuffer;
                exports2.isArrayEqual = isArrayEqual;
                exports2.isAscii = isAscii;
                exports2.objectFromMap = objectFromMap;
                exports2.objectSize = objectSize;
                exports2.setVerbosityLevel = setVerbosityLevel;
                exports2.shadow = shadow;
                exports2.string32 = string32;
                exports2.stringToBytes = stringToBytes;
                exports2.stringToPDFString = stringToPDFString;
                exports2.stringToUTF16BEString = stringToUTF16BEString;
                exports2.stringToUTF8String = stringToUTF8String;
                exports2.unreachable = unreachable;
                exports2.utf8StringToString = utf8StringToString;
                exports2.warn = warn;
                __w_pdfjs_require__2(2);
                const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
                exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
                const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
                exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
                const RenderingIntentFlag = {
                  ANY: 1,
                  DISPLAY: 2,
                  PRINT: 4,
                  ANNOTATIONS_FORMS: 16,
                  ANNOTATIONS_STORAGE: 32,
                  ANNOTATIONS_DISABLE: 64,
                  OPLIST: 256
                };
                exports2.RenderingIntentFlag = RenderingIntentFlag;
                const AnnotationMode = {
                  DISABLE: 0,
                  ENABLE: 1,
                  ENABLE_FORMS: 2,
                  ENABLE_STORAGE: 3
                };
                exports2.AnnotationMode = AnnotationMode;
                const PermissionFlag = {
                  PRINT: 4,
                  MODIFY_CONTENTS: 8,
                  COPY: 16,
                  MODIFY_ANNOTATIONS: 32,
                  FILL_INTERACTIVE_FORMS: 256,
                  COPY_FOR_ACCESSIBILITY: 512,
                  ASSEMBLE: 1024,
                  PRINT_HIGH_QUALITY: 2048
                };
                exports2.PermissionFlag = PermissionFlag;
                const TextRenderingMode = {
                  FILL: 0,
                  STROKE: 1,
                  FILL_STROKE: 2,
                  INVISIBLE: 3,
                  FILL_ADD_TO_PATH: 4,
                  STROKE_ADD_TO_PATH: 5,
                  FILL_STROKE_ADD_TO_PATH: 6,
                  ADD_TO_PATH: 7,
                  FILL_STROKE_MASK: 3,
                  ADD_TO_PATH_FLAG: 4
                };
                exports2.TextRenderingMode = TextRenderingMode;
                const ImageKind = {
                  GRAYSCALE_1BPP: 1,
                  RGB_24BPP: 2,
                  RGBA_32BPP: 3
                };
                exports2.ImageKind = ImageKind;
                const AnnotationType2 = {
                  TEXT: 1,
                  LINK: 2,
                  FREETEXT: 3,
                  LINE: 4,
                  SQUARE: 5,
                  CIRCLE: 6,
                  POLYGON: 7,
                  POLYLINE: 8,
                  HIGHLIGHT: 9,
                  UNDERLINE: 10,
                  SQUIGGLY: 11,
                  STRIKEOUT: 12,
                  STAMP: 13,
                  CARET: 14,
                  INK: 15,
                  POPUP: 16,
                  FILEATTACHMENT: 17,
                  SOUND: 18,
                  MOVIE: 19,
                  WIDGET: 20,
                  SCREEN: 21,
                  PRINTERMARK: 22,
                  TRAPNET: 23,
                  WATERMARK: 24,
                  THREED: 25,
                  REDACT: 26
                };
                exports2.AnnotationType = AnnotationType2;
                const AnnotationStateModelType = {
                  MARKED: "Marked",
                  REVIEW: "Review"
                };
                exports2.AnnotationStateModelType = AnnotationStateModelType;
                const AnnotationMarkedState = {
                  MARKED: "Marked",
                  UNMARKED: "Unmarked"
                };
                exports2.AnnotationMarkedState = AnnotationMarkedState;
                const AnnotationReviewState = {
                  ACCEPTED: "Accepted",
                  REJECTED: "Rejected",
                  CANCELLED: "Cancelled",
                  COMPLETED: "Completed",
                  NONE: "None"
                };
                exports2.AnnotationReviewState = AnnotationReviewState;
                const AnnotationReplyType = {
                  GROUP: "Group",
                  REPLY: "R"
                };
                exports2.AnnotationReplyType = AnnotationReplyType;
                const AnnotationFlag = {
                  INVISIBLE: 1,
                  HIDDEN: 2,
                  PRINT: 4,
                  NOZOOM: 8,
                  NOROTATE: 16,
                  NOVIEW: 32,
                  READONLY: 64,
                  LOCKED: 128,
                  TOGGLENOVIEW: 256,
                  LOCKEDCONTENTS: 512
                };
                exports2.AnnotationFlag = AnnotationFlag;
                const AnnotationFieldFlag = {
                  READONLY: 1,
                  REQUIRED: 2,
                  NOEXPORT: 4,
                  MULTILINE: 4096,
                  PASSWORD: 8192,
                  NOTOGGLETOOFF: 16384,
                  RADIO: 32768,
                  PUSHBUTTON: 65536,
                  COMBO: 131072,
                  EDIT: 262144,
                  SORT: 524288,
                  FILESELECT: 1048576,
                  MULTISELECT: 2097152,
                  DONOTSPELLCHECK: 4194304,
                  DONOTSCROLL: 8388608,
                  COMB: 16777216,
                  RICHTEXT: 33554432,
                  RADIOSINUNISON: 33554432,
                  COMMITONSELCHANGE: 67108864
                };
                exports2.AnnotationFieldFlag = AnnotationFieldFlag;
                const AnnotationBorderStyleType = {
                  SOLID: 1,
                  DASHED: 2,
                  BEVELED: 3,
                  INSET: 4,
                  UNDERLINE: 5
                };
                exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
                const AnnotationActionEventType = {
                  E: "Mouse Enter",
                  X: "Mouse Exit",
                  D: "Mouse Down",
                  U: "Mouse Up",
                  Fo: "Focus",
                  Bl: "Blur",
                  PO: "PageOpen",
                  PC: "PageClose",
                  PV: "PageVisible",
                  PI: "PageInvisible",
                  K: "Keystroke",
                  F: "Format",
                  V: "Validate",
                  C: "Calculate"
                };
                exports2.AnnotationActionEventType = AnnotationActionEventType;
                const DocumentActionEventType = {
                  WC: "WillClose",
                  WS: "WillSave",
                  DS: "DidSave",
                  WP: "WillPrint",
                  DP: "DidPrint"
                };
                exports2.DocumentActionEventType = DocumentActionEventType;
                const PageActionEventType = {
                  O: "PageOpen",
                  C: "PageClose"
                };
                exports2.PageActionEventType = PageActionEventType;
                const StreamType = {
                  UNKNOWN: "UNKNOWN",
                  FLATE: "FLATE",
                  LZW: "LZW",
                  DCT: "DCT",
                  JPX: "JPX",
                  JBIG: "JBIG",
                  A85: "A85",
                  AHX: "AHX",
                  CCF: "CCF",
                  RLX: "RLX"
                };
                exports2.StreamType = StreamType;
                const FontType = {
                  UNKNOWN: "UNKNOWN",
                  TYPE1: "TYPE1",
                  TYPE1STANDARD: "TYPE1STANDARD",
                  TYPE1C: "TYPE1C",
                  CIDFONTTYPE0: "CIDFONTTYPE0",
                  CIDFONTTYPE0C: "CIDFONTTYPE0C",
                  TRUETYPE: "TRUETYPE",
                  CIDFONTTYPE2: "CIDFONTTYPE2",
                  TYPE3: "TYPE3",
                  OPENTYPE: "OPENTYPE",
                  TYPE0: "TYPE0",
                  MMTYPE1: "MMTYPE1"
                };
                exports2.FontType = FontType;
                const VerbosityLevel = {
                  ERRORS: 0,
                  WARNINGS: 1,
                  INFOS: 5
                };
                exports2.VerbosityLevel = VerbosityLevel;
                const CMapCompressionType = {
                  NONE: 0,
                  BINARY: 1,
                  STREAM: 2
                };
                exports2.CMapCompressionType = CMapCompressionType;
                const OPS = {
                  dependency: 1,
                  setLineWidth: 2,
                  setLineCap: 3,
                  setLineJoin: 4,
                  setMiterLimit: 5,
                  setDash: 6,
                  setRenderingIntent: 7,
                  setFlatness: 8,
                  setGState: 9,
                  save: 10,
                  restore: 11,
                  transform: 12,
                  moveTo: 13,
                  lineTo: 14,
                  curveTo: 15,
                  curveTo2: 16,
                  curveTo3: 17,
                  closePath: 18,
                  rectangle: 19,
                  stroke: 20,
                  closeStroke: 21,
                  fill: 22,
                  eoFill: 23,
                  fillStroke: 24,
                  eoFillStroke: 25,
                  closeFillStroke: 26,
                  closeEOFillStroke: 27,
                  endPath: 28,
                  clip: 29,
                  eoClip: 30,
                  beginText: 31,
                  endText: 32,
                  setCharSpacing: 33,
                  setWordSpacing: 34,
                  setHScale: 35,
                  setLeading: 36,
                  setFont: 37,
                  setTextRenderingMode: 38,
                  setTextRise: 39,
                  moveText: 40,
                  setLeadingMoveText: 41,
                  setTextMatrix: 42,
                  nextLine: 43,
                  showText: 44,
                  showSpacedText: 45,
                  nextLineShowText: 46,
                  nextLineSetSpacingShowText: 47,
                  setCharWidth: 48,
                  setCharWidthAndBounds: 49,
                  setStrokeColorSpace: 50,
                  setFillColorSpace: 51,
                  setStrokeColor: 52,
                  setStrokeColorN: 53,
                  setFillColor: 54,
                  setFillColorN: 55,
                  setStrokeGray: 56,
                  setFillGray: 57,
                  setStrokeRGBColor: 58,
                  setFillRGBColor: 59,
                  setStrokeCMYKColor: 60,
                  setFillCMYKColor: 61,
                  shadingFill: 62,
                  beginInlineImage: 63,
                  beginImageData: 64,
                  endInlineImage: 65,
                  paintXObject: 66,
                  markPoint: 67,
                  markPointProps: 68,
                  beginMarkedContent: 69,
                  beginMarkedContentProps: 70,
                  endMarkedContent: 71,
                  beginCompat: 72,
                  endCompat: 73,
                  paintFormXObjectBegin: 74,
                  paintFormXObjectEnd: 75,
                  beginGroup: 76,
                  endGroup: 77,
                  beginAnnotations: 78,
                  endAnnotations: 79,
                  beginAnnotation: 80,
                  endAnnotation: 81,
                  paintJpegXObject: 82,
                  paintImageMaskXObject: 83,
                  paintImageMaskXObjectGroup: 84,
                  paintImageXObject: 85,
                  paintInlineImageXObject: 86,
                  paintInlineImageXObjectGroup: 87,
                  paintImageXObjectRepeat: 88,
                  paintImageMaskXObjectRepeat: 89,
                  paintSolidColorImageMask: 90,
                  constructPath: 91
                };
                exports2.OPS = OPS;
                const UNSUPPORTED_FEATURES = {
                  unknown: "unknown",
                  forms: "forms",
                  javaScript: "javaScript",
                  signatures: "signatures",
                  smask: "smask",
                  shadingPattern: "shadingPattern",
                  font: "font",
                  errorTilingPattern: "errorTilingPattern",
                  errorExtGState: "errorExtGState",
                  errorXObject: "errorXObject",
                  errorFontLoadType3: "errorFontLoadType3",
                  errorFontState: "errorFontState",
                  errorFontMissing: "errorFontMissing",
                  errorFontTranslate: "errorFontTranslate",
                  errorColorSpace: "errorColorSpace",
                  errorOperatorList: "errorOperatorList",
                  errorFontToUnicode: "errorFontToUnicode",
                  errorFontLoadNative: "errorFontLoadNative",
                  errorFontBuildPath: "errorFontBuildPath",
                  errorFontGetPath: "errorFontGetPath",
                  errorMarkedContent: "errorMarkedContent",
                  errorContentSubStream: "errorContentSubStream"
                };
                exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
                const PasswordResponses = {
                  NEED_PASSWORD: 1,
                  INCORRECT_PASSWORD: 2
                };
                exports2.PasswordResponses = PasswordResponses;
                let verbosity = VerbosityLevel.WARNINGS;
                function setVerbosityLevel(level) {
                  if (Number.isInteger(level)) {
                    verbosity = level;
                  }
                }
                function getVerbosityLevel() {
                  return verbosity;
                }
                function info(msg) {
                  if (verbosity >= VerbosityLevel.INFOS) {
                    console.log(`Info: ${msg}`);
                  }
                }
                function warn(msg) {
                  if (verbosity >= VerbosityLevel.WARNINGS) {
                    console.log(`Warning: ${msg}`);
                  }
                }
                function unreachable(msg) {
                  throw new Error(msg);
                }
                function assert(cond, msg) {
                  if (!cond) {
                    unreachable(msg);
                  }
                }
                function _isValidProtocol(url) {
                  if (!url) {
                    return false;
                  }
                  switch (url.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "mailto:":
                    case "tel:":
                      return true;
                    default:
                      return false;
                  }
                }
                function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
                  if (!url) {
                    return null;
                  }
                  try {
                    if (options && typeof url === "string") {
                      if (options.addDefaultProtocol && url.startsWith("www.")) {
                        const dots = url.match(/\./g);
                        if (dots && dots.length >= 2) {
                          url = `http://${url}`;
                        }
                      }
                      if (options.tryConvertEncoding) {
                        try {
                          url = stringToUTF8String(url);
                        } catch (ex) {
                        }
                      }
                    }
                    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                    if (_isValidProtocol(absoluteUrl)) {
                      return absoluteUrl;
                    }
                  } catch (ex) {
                  }
                  return null;
                }
                function shadow(obj, prop, value) {
                  Object.defineProperty(obj, prop, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: false
                  });
                  return value;
                }
                const BaseException = function BaseExceptionClosure() {
                  function BaseException2(message, name) {
                    if (this.constructor === BaseException2) {
                      unreachable("Cannot initialize BaseException.");
                    }
                    this.message = message;
                    this.name = name;
                  }
                  BaseException2.prototype = new Error();
                  BaseException2.constructor = BaseException2;
                  return BaseException2;
                }();
                exports2.BaseException = BaseException;
                class PasswordException extends BaseException {
                  constructor(msg, code) {
                    super(msg, "PasswordException");
                    this.code = code;
                  }
                }
                exports2.PasswordException = PasswordException;
                class UnknownErrorException extends BaseException {
                  constructor(msg, details) {
                    super(msg, "UnknownErrorException");
                    this.details = details;
                  }
                }
                exports2.UnknownErrorException = UnknownErrorException;
                class InvalidPDFException extends BaseException {
                  constructor(msg) {
                    super(msg, "InvalidPDFException");
                  }
                }
                exports2.InvalidPDFException = InvalidPDFException;
                class MissingPDFException extends BaseException {
                  constructor(msg) {
                    super(msg, "MissingPDFException");
                  }
                }
                exports2.MissingPDFException = MissingPDFException;
                class UnexpectedResponseException extends BaseException {
                  constructor(msg, status) {
                    super(msg, "UnexpectedResponseException");
                    this.status = status;
                  }
                }
                exports2.UnexpectedResponseException = UnexpectedResponseException;
                class FormatError extends BaseException {
                  constructor(msg) {
                    super(msg, "FormatError");
                  }
                }
                exports2.FormatError = FormatError;
                class AbortException extends BaseException {
                  constructor(msg) {
                    super(msg, "AbortException");
                  }
                }
                exports2.AbortException = AbortException;
                function bytesToString(bytes) {
                  if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                    unreachable("Invalid argument for bytesToString");
                  }
                  const length = bytes.length;
                  const MAX_ARGUMENT_COUNT = 8192;
                  if (length < MAX_ARGUMENT_COUNT) {
                    return String.fromCharCode.apply(null, bytes);
                  }
                  const strBuf = [];
                  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                    const chunk = bytes.subarray(i, chunkEnd);
                    strBuf.push(String.fromCharCode.apply(null, chunk));
                  }
                  return strBuf.join("");
                }
                function stringToBytes(str) {
                  if (typeof str !== "string") {
                    unreachable("Invalid argument for stringToBytes");
                  }
                  const length = str.length;
                  const bytes = new Uint8Array(length);
                  for (let i = 0; i < length; ++i) {
                    bytes[i] = str.charCodeAt(i) & 255;
                  }
                  return bytes;
                }
                function arrayByteLength(arr) {
                  if (arr.length !== void 0) {
                    return arr.length;
                  }
                  if (arr.byteLength !== void 0) {
                    return arr.byteLength;
                  }
                  unreachable("Invalid argument for arrayByteLength");
                }
                function arraysToBytes(arr) {
                  const length = arr.length;
                  if (length === 1 && arr[0] instanceof Uint8Array) {
                    return arr[0];
                  }
                  let resultLength = 0;
                  for (let i = 0; i < length; i++) {
                    resultLength += arrayByteLength(arr[i]);
                  }
                  let pos = 0;
                  const data = new Uint8Array(resultLength);
                  for (let i = 0; i < length; i++) {
                    let item = arr[i];
                    if (!(item instanceof Uint8Array)) {
                      if (typeof item === "string") {
                        item = stringToBytes(item);
                      } else {
                        item = new Uint8Array(item);
                      }
                    }
                    const itemLength = item.byteLength;
                    data.set(item, pos);
                    pos += itemLength;
                  }
                  return data;
                }
                function string32(value) {
                  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                }
                function objectSize(obj) {
                  return Object.keys(obj).length;
                }
                function objectFromMap(map) {
                  const obj = /* @__PURE__ */ Object.create(null);
                  for (const [key, value] of map) {
                    obj[key] = value;
                  }
                  return obj;
                }
                function isLittleEndian() {
                  const buffer8 = new Uint8Array(4);
                  buffer8[0] = 1;
                  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                  return view32[0] === 1;
                }
                function isEvalSupported() {
                  try {
                    new Function("");
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                class FeatureTest {
                  static get isLittleEndian() {
                    return shadow(this, "isLittleEndian", isLittleEndian());
                  }
                  static get isEvalSupported() {
                    return shadow(this, "isEvalSupported", isEvalSupported());
                  }
                  static get isOffscreenCanvasSupported() {
                    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                  }
                }
                exports2.FeatureTest = FeatureTest;
                const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
                class Util {
                  static makeHexColor(r, g, b) {
                    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                  }
                  static scaleMinMax(transform, minMax) {
                    let temp;
                    if (transform[0]) {
                      if (transform[0] < 0) {
                        temp = minMax[0];
                        minMax[0] = minMax[1];
                        minMax[1] = temp;
                      }
                      minMax[0] *= transform[0];
                      minMax[1] *= transform[0];
                      if (transform[3] < 0) {
                        temp = minMax[2];
                        minMax[2] = minMax[3];
                        minMax[3] = temp;
                      }
                      minMax[2] *= transform[3];
                      minMax[3] *= transform[3];
                    } else {
                      temp = minMax[0];
                      minMax[0] = minMax[2];
                      minMax[2] = temp;
                      temp = minMax[1];
                      minMax[1] = minMax[3];
                      minMax[3] = temp;
                      if (transform[1] < 0) {
                        temp = minMax[2];
                        minMax[2] = minMax[3];
                        minMax[3] = temp;
                      }
                      minMax[2] *= transform[1];
                      minMax[3] *= transform[1];
                      if (transform[2] < 0) {
                        temp = minMax[0];
                        minMax[0] = minMax[1];
                        minMax[1] = temp;
                      }
                      minMax[0] *= transform[2];
                      minMax[1] *= transform[2];
                    }
                    minMax[0] += transform[4];
                    minMax[1] += transform[4];
                    minMax[2] += transform[5];
                    minMax[3] += transform[5];
                  }
                  static transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                  }
                  static applyTransform(p, m) {
                    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                  }
                  static applyInverseTransform(p, m) {
                    const d = m[0] * m[3] - m[1] * m[2];
                    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                  }
                  static getAxialAlignedBoundingBox(r, m) {
                    const p1 = Util.applyTransform(r, m);
                    const p2 = Util.applyTransform(r.slice(2, 4), m);
                    const p3 = Util.applyTransform([r[0], r[3]], m);
                    const p4 = Util.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                  }
                  static inverseTransform(m) {
                    const d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                  }
                  static apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                  }
                  static singularValueDecompose2dScale(m) {
                    const transpose = [m[0], m[2], m[1], m[3]];
                    const a = m[0] * transpose[0] + m[1] * transpose[2];
                    const b = m[0] * transpose[1] + m[1] * transpose[3];
                    const c = m[2] * transpose[0] + m[3] * transpose[2];
                    const d = m[2] * transpose[1] + m[3] * transpose[3];
                    const first = (a + d) / 2;
                    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                    const sx = first + second || 1;
                    const sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                  }
                  static normalizeRect(rect) {
                    const r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                      r[0] = rect[2];
                      r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                      r[1] = rect[3];
                      r[3] = rect[1];
                    }
                    return r;
                  }
                  static intersect(rect1, rect2) {
                    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                    if (xLow > xHigh) {
                      return null;
                    }
                    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                    if (yLow > yHigh) {
                      return null;
                    }
                    return [xLow, yLow, xHigh, yHigh];
                  }
                  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                    const tvalues = [], bounds = [[], []];
                    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                    for (let i = 0; i < 2; ++i) {
                      if (i === 0) {
                        b = 6 * x0 - 12 * x1 + 6 * x2;
                        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                        c = 3 * x1 - 3 * x0;
                      } else {
                        b = 6 * y0 - 12 * y1 + 6 * y2;
                        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                        c = 3 * y1 - 3 * y0;
                      }
                      if (Math.abs(a) < 1e-12) {
                        if (Math.abs(b) < 1e-12) {
                          continue;
                        }
                        t = -c / b;
                        if (0 < t && t < 1) {
                          tvalues.push(t);
                        }
                        continue;
                      }
                      b2ac = b * b - 4 * c * a;
                      sqrtb2ac = Math.sqrt(b2ac);
                      if (b2ac < 0) {
                        continue;
                      }
                      t1 = (-b + sqrtb2ac) / (2 * a);
                      if (0 < t1 && t1 < 1) {
                        tvalues.push(t1);
                      }
                      t2 = (-b - sqrtb2ac) / (2 * a);
                      if (0 < t2 && t2 < 1) {
                        tvalues.push(t2);
                      }
                    }
                    let j = tvalues.length, mt;
                    const jlen = j;
                    while (j--) {
                      t = tvalues[j];
                      mt = 1 - t;
                      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                    }
                    bounds[0][jlen] = x0;
                    bounds[1][jlen] = y0;
                    bounds[0][jlen + 1] = x3;
                    bounds[1][jlen + 1] = y3;
                    bounds[0].length = bounds[1].length = jlen + 2;
                    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                  }
                }
                exports2.Util = Util;
                const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
                function stringToPDFString(str) {
                  if (str[0] >= "\xEF") {
                    let encoding;
                    if (str[0] === "\xFE" && str[1] === "\xFF") {
                      encoding = "utf-16be";
                    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                      encoding = "utf-16le";
                    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
                      encoding = "utf-8";
                    }
                    if (encoding) {
                      try {
                        const decoder = new TextDecoder(encoding, {
                          fatal: true
                        });
                        const buffer = stringToBytes(str);
                        return decoder.decode(buffer);
                      } catch (ex) {
                        warn(`stringToPDFString: "${ex}".`);
                      }
                    }
                  }
                  const strBuf = [];
                  for (let i = 0, ii = str.length; i < ii; i++) {
                    const code = PDFStringTranslateTable[str.charCodeAt(i)];
                    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                  }
                  return strBuf.join("");
                }
                function escapeString(str) {
                  return str.replace(/([()\\\n\r])/g, (match) => {
                    if (match === "\n") {
                      return "\\n";
                    } else if (match === "\r") {
                      return "\\r";
                    }
                    return `\\${match}`;
                  });
                }
                function isAscii(str) {
                  return /^[\x00-\x7F]*$/.test(str);
                }
                function stringToUTF16BEString(str) {
                  const buf = ["\xFE\xFF"];
                  for (let i = 0, ii = str.length; i < ii; i++) {
                    const char = str.charCodeAt(i);
                    buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                  }
                  return buf.join("");
                }
                function stringToUTF8String(str) {
                  return decodeURIComponent(escape(str));
                }
                function utf8StringToString(str) {
                  return unescape(encodeURIComponent(str));
                }
                function isArrayBuffer(v) {
                  return typeof v === "object" && v !== null && v.byteLength !== void 0;
                }
                function isArrayEqual(arr1, arr2) {
                  if (arr1.length !== arr2.length) {
                    return false;
                  }
                  for (let i = 0, ii = arr1.length; i < ii; i++) {
                    if (arr1[i] !== arr2[i]) {
                      return false;
                    }
                  }
                  return true;
                }
                function getModificationDate(date = /* @__PURE__ */ new Date()) {
                  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                  return buffer.join("");
                }
                function createPromiseCapability() {
                  const capability = /* @__PURE__ */ Object.create(null);
                  let isSettled = false;
                  Object.defineProperty(capability, "settled", {
                    get() {
                      return isSettled;
                    }
                  });
                  capability.promise = new Promise(function(resolve, reject) {
                    capability.resolve = function(data) {
                      isSettled = true;
                      resolve(data);
                    };
                    capability.reject = function(reason) {
                      isSettled = true;
                      reject(reason);
                    };
                  });
                  return capability;
                }
              },
              /* 2 */
              /***/
              (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
                var _is_node2 = __w_pdfjs_require__2(3);
                ;
              },
              /* 3 */
              /***/
              (__unused_webpack_module2, exports2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.isNodeJS = void 0;
                const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
                exports2.isNodeJS = isNodeJS;
              },
              /* 4 */
              /***/
              (__unused_webpack_module, exports, __w_pdfjs_require__) => {
                var _docId, _a, _workerPorts, _docStats, _pageCache, _pagePromises, _metadataPromise, _objs, _ensureObj, ensureObj_fn, _canvasInUse;
                Object.defineProperty(exports, "__esModule", {
                  value: true
                });
                exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
                exports.getDocument = getDocument;
                exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
                exports.version = void 0;
                var _util = __w_pdfjs_require__(1);
                var _display_utils = __w_pdfjs_require__(5);
                var _font_loader = __w_pdfjs_require__(7);
                var _annotation_storage = __w_pdfjs_require__(8);
                var _canvas = __w_pdfjs_require__(10);
                var _worker_options = __w_pdfjs_require__(13);
                var _is_node = __w_pdfjs_require__(3);
                var _message_handler = __w_pdfjs_require__(14);
                var _metadata = __w_pdfjs_require__(15);
                var _optional_content_config = __w_pdfjs_require__(16);
                var _transport_stream = __w_pdfjs_require__(17);
                var _xfa_text = __w_pdfjs_require__(18);
                const DEFAULT_RANGE_CHUNK_SIZE = 65536;
                const RENDERING_CANCELLED_TIMEOUT = 100;
                let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
                exports.DefaultCanvasFactory = DefaultCanvasFactory;
                let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
                let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
                if (_is_node.isNodeJS) {
                  const {
                    NodeCanvasFactory,
                    NodeCMapReaderFactory,
                    NodeStandardFontDataFactory
                  } = __w_pdfjs_require__(19);
                  exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                  exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
                }
                let createPDFNetworkStream;
                function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                  createPDFNetworkStream = pdfNetworkStreamFactory;
                }
                function getDocument(src) {
                  const task = new PDFDocumentLoadingTask();
                  let source;
                  if (typeof src === "string" || src instanceof URL) {
                    source = {
                      url: src
                    };
                  } else if ((0, _util.isArrayBuffer)(src)) {
                    source = {
                      data: src
                    };
                  } else if (src instanceof PDFDataRangeTransport) {
                    source = {
                      range: src
                    };
                  } else {
                    if (typeof src !== "object") {
                      throw new Error("Invalid parameter in getDocument, need either string, URL, Uint8Array, or parameter object.");
                    }
                    if (!src.url && !src.data && !src.range) {
                      throw new Error("Invalid parameter object: need either .data, .range or .url");
                    }
                    source = src;
                  }
                  const params = /* @__PURE__ */ Object.create(null);
                  let rangeTransport = null, worker2 = null;
                  for (const key in source) {
                    const value = source[key];
                    switch (key) {
                      case "url":
                        if (typeof window !== "undefined") {
                          try {
                            params[key] = new URL(value, window.location).href;
                            continue;
                          } catch (ex) {
                            (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                          }
                        } else if (typeof value === "string" || value instanceof URL) {
                          params[key] = value.toString();
                          continue;
                        }
                        throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                      case "range":
                        rangeTransport = value;
                        continue;
                      case "worker":
                        worker2 = value;
                        continue;
                      case "data":
                        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                          params[key] = new Uint8Array(value);
                        } else if (value instanceof Uint8Array) {
                          break;
                        } else if (typeof value === "string") {
                          params[key] = (0, _util.stringToBytes)(value);
                        } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                          params[key] = new Uint8Array(value);
                        } else if ((0, _util.isArrayBuffer)(value)) {
                          params[key] = new Uint8Array(value);
                        } else {
                          throw new Error("Invalid PDF binary data: either typed array, string, or array-like object is expected in the data property.");
                        }
                        continue;
                    }
                    params[key] = value;
                  }
                  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                  params.ignoreErrors = params.stopAtErrors !== true;
                  params.fontExtraProperties = params.fontExtraProperties === true;
                  params.pdfBug = params.pdfBug === true;
                  params.enableXfa = params.enableXfa === true;
                  if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                    params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                  }
                  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                    params.docBaseUrl = null;
                  }
                  if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                    params.maxImageSize = -1;
                  }
                  if (typeof params.cMapUrl !== "string") {
                    params.cMapUrl = null;
                  }
                  if (typeof params.standardFontDataUrl !== "string") {
                    params.standardFontDataUrl = null;
                  }
                  if (typeof params.useWorkerFetch !== "boolean") {
                    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                  }
                  if (typeof params.isEvalSupported !== "boolean") {
                    params.isEvalSupported = true;
                  }
                  if (typeof params.disableFontFace !== "boolean") {
                    params.disableFontFace = _is_node.isNodeJS;
                  }
                  if (typeof params.useSystemFonts !== "boolean") {
                    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                  }
                  if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
                    params.ownerDocument = globalThis.document;
                  }
                  if (typeof params.disableRange !== "boolean") {
                    params.disableRange = false;
                  }
                  if (typeof params.disableStream !== "boolean") {
                    params.disableStream = false;
                  }
                  if (typeof params.disableAutoFetch !== "boolean") {
                    params.disableAutoFetch = false;
                  }
                  (0, _util.setVerbosityLevel)(params.verbosity);
                  if (!worker2) {
                    const workerParams = {
                      verbosity: params.verbosity,
                      port: _worker_options.GlobalWorkerOptions.workerPort
                    };
                    worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                    task._worker = worker2;
                  }
                  const docId = task.docId;
                  worker2.promise.then(function() {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                    const networkStreamPromise = new Promise(function(resolve) {
                      let networkStream;
                      if (rangeTransport) {
                        networkStream = new _transport_stream.PDFDataTransportStream({
                          length: params.length,
                          initialData: params.initialData,
                          progressiveDone: params.progressiveDone,
                          contentDispositionFilename: params.contentDispositionFilename,
                          disableRange: params.disableRange,
                          disableStream: params.disableStream
                        }, rangeTransport);
                      } else if (!params.data) {
                        networkStream = createPDFNetworkStream({
                          url: params.url,
                          length: params.length,
                          httpHeaders: params.httpHeaders,
                          withCredentials: params.withCredentials,
                          rangeChunkSize: params.rangeChunkSize,
                          disableRange: params.disableRange,
                          disableStream: params.disableStream
                        });
                      }
                      resolve(networkStream);
                    });
                    return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                      if (task.destroyed) {
                        throw new Error("Loading aborted");
                      }
                      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                      task._transport = transport;
                      messageHandler.send("Ready", null);
                    });
                  }).catch(task._capability.reject);
                  return task;
                }
                async function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                  if (worker2.destroyed) {
                    throw new Error("Worker was destroyed");
                  }
                  if (pdfDataRangeTransport) {
                    source.length = pdfDataRangeTransport.length;
                    source.initialData = pdfDataRangeTransport.initialData;
                    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                  }
                  const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", {
                    docId,
                    apiVersion: "2.14.305",
                    source: {
                      data: source.data,
                      url: source.url,
                      password: source.password,
                      disableAutoFetch: source.disableAutoFetch,
                      rangeChunkSize: source.rangeChunkSize,
                      length: source.length
                    },
                    maxImageSize: source.maxImageSize,
                    disableFontFace: source.disableFontFace,
                    docBaseUrl: source.docBaseUrl,
                    ignoreErrors: source.ignoreErrors,
                    isEvalSupported: source.isEvalSupported,
                    fontExtraProperties: source.fontExtraProperties,
                    enableXfa: source.enableXfa,
                    useSystemFonts: source.useSystemFonts,
                    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                  });
                  if (worker2.destroyed) {
                    throw new Error("Worker was destroyed");
                  }
                  return workerId;
                }
                const _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
                  constructor() {
                    this._capability = (0, _util.createPromiseCapability)();
                    this._transport = null;
                    this._worker = null;
                    this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                    this.destroyed = false;
                    this.onPassword = null;
                    this.onProgress = null;
                    this.onUnsupportedFeature = null;
                  }
                  get promise() {
                    return this._capability.promise;
                  }
                  async destroy() {
                    var _a2;
                    this.destroyed = true;
                    await ((_a2 = this._transport) == null ? void 0 : _a2.destroy());
                    this._transport = null;
                    if (this._worker) {
                      this._worker.destroy();
                      this._worker = null;
                    }
                  }
                };
                _docId = new WeakMap();
                __privateAdd(_PDFDocumentLoadingTask, _docId, 0);
                let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
                exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
                class PDFDataRangeTransport {
                  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
                    this.length = length;
                    this.initialData = initialData;
                    this.progressiveDone = progressiveDone;
                    this.contentDispositionFilename = contentDispositionFilename;
                    this._rangeListeners = [];
                    this._progressListeners = [];
                    this._progressiveReadListeners = [];
                    this._progressiveDoneListeners = [];
                    this._readyCapability = (0, _util.createPromiseCapability)();
                  }
                  addRangeListener(listener) {
                    this._rangeListeners.push(listener);
                  }
                  addProgressListener(listener) {
                    this._progressListeners.push(listener);
                  }
                  addProgressiveReadListener(listener) {
                    this._progressiveReadListeners.push(listener);
                  }
                  addProgressiveDoneListener(listener) {
                    this._progressiveDoneListeners.push(listener);
                  }
                  onDataRange(begin, chunk) {
                    for (const listener of this._rangeListeners) {
                      listener(begin, chunk);
                    }
                  }
                  onDataProgress(loaded, total) {
                    this._readyCapability.promise.then(() => {
                      for (const listener of this._progressListeners) {
                        listener(loaded, total);
                      }
                    });
                  }
                  onDataProgressiveRead(chunk) {
                    this._readyCapability.promise.then(() => {
                      for (const listener of this._progressiveReadListeners) {
                        listener(chunk);
                      }
                    });
                  }
                  onDataProgressiveDone() {
                    this._readyCapability.promise.then(() => {
                      for (const listener of this._progressiveDoneListeners) {
                        listener();
                      }
                    });
                  }
                  transportReady() {
                    this._readyCapability.resolve();
                  }
                  requestDataRange(begin, end) {
                    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                  }
                  abort() {
                  }
                }
                exports.PDFDataRangeTransport = PDFDataRangeTransport;
                class PDFDocumentProxy {
                  constructor(pdfInfo, transport) {
                    this._pdfInfo = pdfInfo;
                    this._transport = transport;
                    Object.defineProperty(this, "fingerprint", {
                      get() {
                        (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                        return this.fingerprints[0];
                      }
                    });
                    Object.defineProperty(this, "getStats", {
                      value: async () => {
                        (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                        return this.stats || {
                          streamTypes: {},
                          fontTypes: {}
                        };
                      }
                    });
                  }
                  get annotationStorage() {
                    return this._transport.annotationStorage;
                  }
                  get numPages() {
                    return this._pdfInfo.numPages;
                  }
                  get fingerprints() {
                    return this._pdfInfo.fingerprints;
                  }
                  get stats() {
                    return this._transport.stats;
                  }
                  get isPureXfa() {
                    return !!this._transport._htmlForXfa;
                  }
                  get allXfaHtml() {
                    return this._transport._htmlForXfa;
                  }
                  getPage(pageNumber) {
                    return this._transport.getPage(pageNumber);
                  }
                  getPageIndex(ref) {
                    return this._transport.getPageIndex(ref);
                  }
                  getDestinations() {
                    return this._transport.getDestinations();
                  }
                  getDestination(id2) {
                    return this._transport.getDestination(id2);
                  }
                  getPageLabels() {
                    return this._transport.getPageLabels();
                  }
                  getPageLayout() {
                    return this._transport.getPageLayout();
                  }
                  getPageMode() {
                    return this._transport.getPageMode();
                  }
                  getViewerPreferences() {
                    return this._transport.getViewerPreferences();
                  }
                  getOpenAction() {
                    return this._transport.getOpenAction();
                  }
                  getAttachments() {
                    return this._transport.getAttachments();
                  }
                  getJavaScript() {
                    return this._transport.getJavaScript();
                  }
                  getJSActions() {
                    return this._transport.getDocJSActions();
                  }
                  getOutline() {
                    return this._transport.getOutline();
                  }
                  getOptionalContentConfig() {
                    return this._transport.getOptionalContentConfig();
                  }
                  getPermissions() {
                    return this._transport.getPermissions();
                  }
                  getMetadata() {
                    return this._transport.getMetadata();
                  }
                  getMarkInfo() {
                    return this._transport.getMarkInfo();
                  }
                  getData() {
                    return this._transport.getData();
                  }
                  getDownloadInfo() {
                    return this._transport.downloadInfoCapability.promise;
                  }
                  cleanup(keepLoadedFonts = false) {
                    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                  }
                  destroy() {
                    return this.loadingTask.destroy();
                  }
                  get loadingParams() {
                    return this._transport.loadingParams;
                  }
                  get loadingTask() {
                    return this._transport.loadingTask;
                  }
                  saveDocument() {
                    if (this._transport.annotationStorage.size <= 0) {
                      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                    }
                    return this._transport.saveDocument();
                  }
                  getFieldObjects() {
                    return this._transport.getFieldObjects();
                  }
                  hasJSActions() {
                    return this._transport.hasJSActions();
                  }
                  getCalculationOrderIds() {
                    return this._transport.getCalculationOrderIds();
                  }
                }
                exports.PDFDocumentProxy = PDFDocumentProxy;
                class PDFPageProxy {
                  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
                    this._pageIndex = pageIndex;
                    this._pageInfo = pageInfo;
                    this._ownerDocument = ownerDocument;
                    this._transport = transport;
                    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                    this._pdfBug = pdfBug;
                    this.commonObjs = transport.commonObjs;
                    this.objs = new PDFObjects();
                    this._bitmaps = /* @__PURE__ */ new Set();
                    this.cleanupAfterRender = false;
                    this.pendingCleanup = false;
                    this._intentStates = /* @__PURE__ */ new Map();
                    this._annotationPromises = /* @__PURE__ */ new Map();
                    this.destroyed = false;
                  }
                  get pageNumber() {
                    return this._pageIndex + 1;
                  }
                  get rotate() {
                    return this._pageInfo.rotate;
                  }
                  get ref() {
                    return this._pageInfo.ref;
                  }
                  get userUnit() {
                    return this._pageInfo.userUnit;
                  }
                  get view() {
                    return this._pageInfo.view;
                  }
                  getViewport({
                    scale,
                    rotation = this.rotate,
                    offsetX = 0,
                    offsetY = 0,
                    dontFlip = false
                  } = {}) {
                    return new _display_utils.PageViewport({
                      viewBox: this.view,
                      scale,
                      rotation,
                      offsetX,
                      offsetY,
                      dontFlip
                    });
                  }
                  getAnnotations({
                    intent = "display"
                  } = {}) {
                    const intentArgs = this._transport.getRenderingIntent(intent);
                    let promise = this._annotationPromises.get(intentArgs.cacheKey);
                    if (!promise) {
                      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                      this._annotationPromises.set(intentArgs.cacheKey, promise);
                      promise = promise.then((annotations) => {
                        for (const annotation of annotations) {
                          if (annotation.titleObj !== void 0) {
                            Object.defineProperty(annotation, "title", {
                              get() {
                                (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                                return annotation.titleObj.str;
                              }
                            });
                          }
                          if (annotation.contentsObj !== void 0) {
                            Object.defineProperty(annotation, "contents", {
                              get() {
                                (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                                return annotation.contentsObj.str;
                              }
                            });
                          }
                        }
                        return annotations;
                      });
                    }
                    return promise;
                  }
                  getJSActions() {
                    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
                  }
                  async getXfa() {
                    var _a2;
                    return ((_a2 = this._transport._htmlForXfa) == null ? void 0 : _a2.children[this._pageIndex]) || null;
                  }
                  render({
                    canvasContext,
                    viewport,
                    intent = "display",
                    annotationMode = _util.AnnotationMode.ENABLE,
                    transform = null,
                    imageLayer = null,
                    canvasFactory = null,
                    background = null,
                    optionalContentConfigPromise = null,
                    annotationCanvasMap = null,
                    pageColors = null
                  }) {
                    var _a2, _b;
                    if (((_a2 = arguments[0]) == null ? void 0 : _a2.renderInteractiveForms) !== void 0) {
                      (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                        annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                      }
                    }
                    if (((_b = arguments[0]) == null ? void 0 : _b.includeAnnotationStorage) !== void 0) {
                      (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                      }
                    }
                    if (this._stats) {
                      this._stats.time("Overall");
                    }
                    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);
                    this.pendingCleanup = false;
                    if (!optionalContentConfigPromise) {
                      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                    }
                    let intentState = this._intentStates.get(intentArgs.cacheKey);
                    if (!intentState) {
                      intentState = /* @__PURE__ */ Object.create(null);
                      this._intentStates.set(intentArgs.cacheKey, intentState);
                    }
                    if (intentState.streamReaderCancelTimeout) {
                      clearTimeout(intentState.streamReaderCancelTimeout);
                      intentState.streamReaderCancelTimeout = null;
                    }
                    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                      ownerDocument: this._ownerDocument
                    });
                    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                    if (!intentState.displayReadyCapability) {
                      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                      intentState.operatorList = {
                        fnArray: [],
                        argsArray: [],
                        lastChunk: false
                      };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList(intentArgs);
                    }
                    const complete = (error) => {
                      intentState.renderTasks.delete(internalRenderTask);
                      if (this.cleanupAfterRender || intentPrint) {
                        this.pendingCleanup = true;
                      }
                      this._tryCleanup();
                      if (error) {
                        internalRenderTask.capability.reject(error);
                        this._abortOperatorList({
                          intentState,
                          reason: error instanceof Error ? error : new Error(error)
                        });
                      } else {
                        internalRenderTask.capability.resolve();
                      }
                      if (this._stats) {
                        this._stats.timeEnd("Rendering");
                        this._stats.timeEnd("Overall");
                      }
                    };
                    const internalRenderTask = new InternalRenderTask({
                      callback: complete,
                      params: {
                        canvasContext,
                        viewport,
                        transform,
                        imageLayer,
                        background
                      },
                      objs: this.objs,
                      commonObjs: this.commonObjs,
                      annotationCanvasMap,
                      operatorList: intentState.operatorList,
                      pageIndex: this._pageIndex,
                      canvasFactory: canvasFactoryInstance,
                      useRequestAnimationFrame: !intentPrint,
                      pdfBug: this._pdfBug,
                      pageColors
                    });
                    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
                    const renderTask = internalRenderTask.task;
                    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                      if (this.pendingCleanup) {
                        complete();
                        return;
                      }
                      if (this._stats) {
                        this._stats.time("Rendering");
                      }
                      internalRenderTask.initializeGraphics({
                        transparency,
                        optionalContentConfig
                      });
                      internalRenderTask.operatorListChanged();
                    }).catch(complete);
                    return renderTask;
                  }
                  getOperatorList({
                    intent = "display",
                    annotationMode = _util.AnnotationMode.ENABLE
                  } = {}) {
                    function operatorListChanged() {
                      if (intentState.operatorList.lastChunk) {
                        intentState.opListReadCapability.resolve(intentState.operatorList);
                        intentState.renderTasks.delete(opListTask);
                      }
                    }
                    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);
                    let intentState = this._intentStates.get(intentArgs.cacheKey);
                    if (!intentState) {
                      intentState = /* @__PURE__ */ Object.create(null);
                      this._intentStates.set(intentArgs.cacheKey, intentState);
                    }
                    let opListTask;
                    if (!intentState.opListReadCapability) {
                      opListTask = /* @__PURE__ */ Object.create(null);
                      opListTask.operatorListChanged = operatorListChanged;
                      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                      (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
                      intentState.operatorList = {
                        fnArray: [],
                        argsArray: [],
                        lastChunk: false
                      };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList(intentArgs);
                    }
                    return intentState.opListReadCapability.promise;
                  }
                  streamTextContent({
                    disableCombineTextItems = false,
                    includeMarkedContent = false
                  } = {}) {
                    const TEXT_CONTENT_CHUNK_SIZE = 100;
                    return this._transport.messageHandler.sendWithStream("GetTextContent", {
                      pageIndex: this._pageIndex,
                      combineTextItems: disableCombineTextItems !== true,
                      includeMarkedContent: includeMarkedContent === true
                    }, {
                      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                      size(textContent) {
                        return textContent.items.length;
                      }
                    });
                  }
                  getTextContent(params = {}) {
                    if (this._transport._htmlForXfa) {
                      return this.getXfa().then((xfa) => {
                        return _xfa_text.XfaText.textContent(xfa);
                      });
                    }
                    const readableStream = this.streamTextContent(params);
                    return new Promise(function(resolve, reject) {
                      function pump() {
                        reader.read().then(function({
                          value,
                          done
                        }) {
                          if (done) {
                            resolve(textContent);
                            return;
                          }
                          Object.assign(textContent.styles, value.styles);
                          textContent.items.push(...value.items);
                          pump();
                        }, reject);
                      }
                      const reader = readableStream.getReader();
                      const textContent = {
                        items: [],
                        styles: /* @__PURE__ */ Object.create(null)
                      };
                      pump();
                    });
                  }
                  getStructTree() {
                    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
                  }
                  _destroy() {
                    this.destroyed = true;
                    const waitOn = [];
                    for (const intentState of this._intentStates.values()) {
                      this._abortOperatorList({
                        intentState,
                        reason: new Error("Page was destroyed."),
                        force: true
                      });
                      if (intentState.opListReadCapability) {
                        continue;
                      }
                      for (const internalRenderTask of intentState.renderTasks) {
                        waitOn.push(internalRenderTask.completed);
                        internalRenderTask.cancel();
                      }
                    }
                    this.objs.clear();
                    for (const bitmap of this._bitmaps) {
                      bitmap.close();
                    }
                    this._bitmaps.clear();
                    this._annotationPromises.clear();
                    this._jsActionsPromise = null;
                    this._structTreePromise = null;
                    this.pendingCleanup = false;
                    return Promise.all(waitOn);
                  }
                  cleanup(resetStats = false) {
                    this.pendingCleanup = true;
                    return this._tryCleanup(resetStats);
                  }
                  _tryCleanup(resetStats = false) {
                    if (!this.pendingCleanup) {
                      return false;
                    }
                    for (const {
                      renderTasks,
                      operatorList
                    } of this._intentStates.values()) {
                      if (renderTasks.size > 0 || !operatorList.lastChunk) {
                        return false;
                      }
                    }
                    this._intentStates.clear();
                    this.objs.clear();
                    this._annotationPromises.clear();
                    this._jsActionsPromise = null;
                    this._structTreePromise = null;
                    if (resetStats && this._stats) {
                      this._stats = new _display_utils.StatTimer();
                    }
                    for (const bitmap of this._bitmaps) {
                      bitmap.close();
                    }
                    this._bitmaps.clear();
                    this.pendingCleanup = false;
                    return true;
                  }
                  _startRenderPage(transparency, cacheKey) {
                    const intentState = this._intentStates.get(cacheKey);
                    if (!intentState) {
                      return;
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Page Request");
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.resolve(transparency);
                    }
                  }
                  _renderPageChunk(operatorListChunk, intentState) {
                    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                    }
                    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                    for (const internalRenderTask of intentState.renderTasks) {
                      internalRenderTask.operatorListChanged();
                    }
                    if (operatorListChunk.lastChunk) {
                      this._tryCleanup();
                    }
                  }
                  _pumpOperatorList({
                    renderingIntent,
                    cacheKey
                  }) {
                    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                      pageIndex: this._pageIndex,
                      intent: renderingIntent,
                      cacheKey,
                      annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
                    });
                    const reader = readableStream.getReader();
                    const intentState = this._intentStates.get(cacheKey);
                    intentState.streamReader = reader;
                    const pump = () => {
                      reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          intentState.streamReader = null;
                          return;
                        }
                        if (this._transport.destroyed) {
                          return;
                        }
                        this._renderPageChunk(value, intentState);
                        pump();
                      }, (reason) => {
                        intentState.streamReader = null;
                        if (this._transport.destroyed) {
                          return;
                        }
                        if (intentState.operatorList) {
                          intentState.operatorList.lastChunk = true;
                          for (const internalRenderTask of intentState.renderTasks) {
                            internalRenderTask.operatorListChanged();
                          }
                          this._tryCleanup();
                        }
                        if (intentState.displayReadyCapability) {
                          intentState.displayReadyCapability.reject(reason);
                        } else if (intentState.opListReadCapability) {
                          intentState.opListReadCapability.reject(reason);
                        } else {
                          throw reason;
                        }
                      });
                    };
                    pump();
                  }
                  _abortOperatorList({
                    intentState,
                    reason,
                    force = false
                  }) {
                    if (!intentState.streamReader) {
                      return;
                    }
                    if (!force) {
                      if (intentState.renderTasks.size > 0) {
                        return;
                      }
                      if (reason instanceof _display_utils.RenderingCancelledException) {
                        intentState.streamReaderCancelTimeout = setTimeout(() => {
                          this._abortOperatorList({
                            intentState,
                            reason,
                            force: true
                          });
                          intentState.streamReaderCancelTimeout = null;
                        }, RENDERING_CANCELLED_TIMEOUT);
                        return;
                      }
                    }
                    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                    });
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    for (const [curCacheKey, curIntentState] of this._intentStates) {
                      if (curIntentState === intentState) {
                        this._intentStates.delete(curCacheKey);
                        break;
                      }
                    }
                    this.cleanup();
                  }
                  get stats() {
                    return this._stats;
                  }
                }
                exports.PDFPageProxy = PDFPageProxy;
                class LoopbackPort {
                  constructor() {
                    this._listeners = [];
                    this._deferred = Promise.resolve();
                  }
                  postMessage(obj, transfers) {
                    const event = {
                      data: structuredClone(obj, transfers)
                    };
                    this._deferred.then(() => {
                      for (const listener of this._listeners) {
                        listener.call(this, event);
                      }
                    });
                  }
                  addEventListener(name, listener) {
                    this._listeners.push(listener);
                  }
                  removeEventListener(name, listener) {
                    const i = this._listeners.indexOf(listener);
                    this._listeners.splice(i, 1);
                  }
                  terminate() {
                    this._listeners.length = 0;
                  }
                }
                exports.LoopbackPort = LoopbackPort;
                const PDFWorkerUtil = {
                  isWorkerDisabled: false,
                  fallbackWorkerSrc: null,
                  fakeWorkerId: 0
                };
                exports.PDFWorkerUtil = PDFWorkerUtil;
                {
                  if (_is_node.isNodeJS && typeof __require === "function") {
                    PDFWorkerUtil.isWorkerDisabled = true;
                    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                  } else if (typeof document === "object") {
                    const pdfjsFilePath = (_a = document == null ? void 0 : document.currentScript) == null ? void 0 : _a.src;
                    if (pdfjsFilePath) {
                      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                    }
                  }
                  PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                    let base;
                    try {
                      base = new URL(baseUrl);
                      if (!base.origin || base.origin === "null") {
                        return false;
                      }
                    } catch (e) {
                      return false;
                    }
                    const other = new URL(otherUrl, base);
                    return base.origin === other.origin;
                  };
                  PDFWorkerUtil.createCDNWrapper = function(url) {
                    const wrapper = `importScripts("${url}");`;
                    return URL.createObjectURL(new Blob([wrapper]));
                  };
                }
                const _PDFWorker = class _PDFWorker {
                  constructor({
                    name = null,
                    port = null,
                    verbosity = (0, _util.getVerbosityLevel)()
                  } = {}) {
                    if (port && __privateGet(_PDFWorker, _workerPorts).has(port)) {
                      throw new Error("Cannot use more than one PDFWorker per port.");
                    }
                    this.name = name;
                    this.destroyed = false;
                    this.verbosity = verbosity;
                    this._readyCapability = (0, _util.createPromiseCapability)();
                    this._port = null;
                    this._webWorker = null;
                    this._messageHandler = null;
                    if (port) {
                      __privateGet(_PDFWorker, _workerPorts).set(port, this);
                      this._initializeFromPort(port);
                      return;
                    }
                    this._initialize();
                  }
                  get promise() {
                    return this._readyCapability.promise;
                  }
                  get port() {
                    return this._port;
                  }
                  get messageHandler() {
                    return this._messageHandler;
                  }
                  _initializeFromPort(port) {
                    this._port = port;
                    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                    this._messageHandler.on("ready", function() {
                    });
                    this._readyCapability.resolve();
                  }
                  _initialize() {
                    if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                      let workerSrc = _PDFWorker.workerSrc;
                      try {
                        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                        }
                        const worker2 = new Worker(workerSrc);
                        const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                        const terminateEarly = () => {
                          worker2.removeEventListener("error", onWorkerError);
                          messageHandler.destroy();
                          worker2.terminate();
                          if (this.destroyed) {
                            this._readyCapability.reject(new Error("Worker was destroyed"));
                          } else {
                            this._setupFakeWorker();
                          }
                        };
                        const onWorkerError = () => {
                          if (!this._webWorker) {
                            terminateEarly();
                          }
                        };
                        worker2.addEventListener("error", onWorkerError);
                        messageHandler.on("test", (data) => {
                          worker2.removeEventListener("error", onWorkerError);
                          if (this.destroyed) {
                            terminateEarly();
                            return;
                          }
                          if (data) {
                            this._messageHandler = messageHandler;
                            this._port = worker2;
                            this._webWorker = worker2;
                            this._readyCapability.resolve();
                            messageHandler.send("configure", {
                              verbosity: this.verbosity
                            });
                          } else {
                            this._setupFakeWorker();
                            messageHandler.destroy();
                            worker2.terminate();
                          }
                        });
                        messageHandler.on("ready", (data) => {
                          worker2.removeEventListener("error", onWorkerError);
                          if (this.destroyed) {
                            terminateEarly();
                            return;
                          }
                          try {
                            sendTest();
                          } catch (e) {
                            this._setupFakeWorker();
                          }
                        });
                        const sendTest = () => {
                          const testObj = new Uint8Array();
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        };
                        sendTest();
                        return;
                      } catch (e) {
                        (0, _util.info)("The worker has been disabled.");
                      }
                    }
                    this._setupFakeWorker();
                  }
                  _setupFakeWorker() {
                    if (!PDFWorkerUtil.isWorkerDisabled) {
                      (0, _util.warn)("Setting up fake worker.");
                      PDFWorkerUtil.isWorkerDisabled = true;
                    }
                    _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                      if (this.destroyed) {
                        this._readyCapability.reject(new Error("Worker was destroyed"));
                        return;
                      }
                      const port = new LoopbackPort();
                      this._port = port;
                      const id2 = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                      const workerHandler = new _message_handler.MessageHandler(id2 + "_worker", id2, port);
                      WorkerMessageHandler.setup(workerHandler, port);
                      const messageHandler = new _message_handler.MessageHandler(id2, id2 + "_worker", port);
                      this._messageHandler = messageHandler;
                      this._readyCapability.resolve();
                      messageHandler.send("configure", {
                        verbosity: this.verbosity
                      });
                    }).catch((reason) => {
                      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                    });
                  }
                  destroy() {
                    this.destroyed = true;
                    if (this._webWorker) {
                      this._webWorker.terminate();
                      this._webWorker = null;
                    }
                    __privateGet(_PDFWorker, _workerPorts).delete(this._port);
                    this._port = null;
                    if (this._messageHandler) {
                      this._messageHandler.destroy();
                      this._messageHandler = null;
                    }
                  }
                  static fromPort(params) {
                    if (!(params == null ? void 0 : params.port)) {
                      throw new Error("PDFWorker.fromPort - invalid method signature.");
                    }
                    if (__privateGet(this, _workerPorts).has(params.port)) {
                      return __privateGet(this, _workerPorts).get(params.port);
                    }
                    return new _PDFWorker(params);
                  }
                  static get workerSrc() {
                    if (_worker_options.GlobalWorkerOptions.workerSrc) {
                      return _worker_options.GlobalWorkerOptions.workerSrc;
                    }
                    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                      if (!_is_node.isNodeJS) {
                        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                      }
                      return PDFWorkerUtil.fallbackWorkerSrc;
                    }
                    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  static get _mainThreadWorkerMessageHandler() {
                    var _a2;
                    try {
                      return ((_a2 = globalThis.pdfjsWorker) == null ? void 0 : _a2.WorkerMessageHandler) || null;
                    } catch (ex) {
                      return null;
                    }
                  }
                  static get _setupFakeWorkerGlobal() {
                    const loader = async () => {
                      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                      if (mainWorkerMessageHandler) {
                        return mainWorkerMessageHandler;
                      }
                      if (_is_node.isNodeJS && typeof __require === "function") {
                        const worker = eval("require")(this.workerSrc);
                        return worker.WorkerMessageHandler;
                      }
                      await (0, _display_utils.loadScript)(this.workerSrc);
                      return window.pdfjsWorker.WorkerMessageHandler;
                    };
                    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                  }
                };
                _workerPorts = new WeakMap();
                __privateAdd(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
                let PDFWorker = _PDFWorker;
                exports.PDFWorker = PDFWorker;
                {
                  PDFWorker.getWorkerSrc = function() {
                    (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                    return this.workerSrc;
                  };
                }
                class WorkerTransport {
                  constructor(messageHandler, loadingTask, networkStream, params) {
                    __privateAdd(this, _docStats, null);
                    __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                    __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                    __privateAdd(this, _metadataPromise, null);
                    this.messageHandler = messageHandler;
                    this.loadingTask = loadingTask;
                    this.commonObjs = new PDFObjects();
                    this.fontLoader = new _font_loader.FontLoader({
                      docId: loadingTask.docId,
                      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                      ownerDocument: params.ownerDocument,
                      styleElement: params.styleElement
                    });
                    this._params = params;
                    if (!params.useWorkerFetch) {
                      this.CMapReaderFactory = new params.CMapReaderFactory({
                        baseUrl: params.cMapUrl,
                        isCompressed: params.cMapPacked
                      });
                      this.StandardFontDataFactory = new params.StandardFontDataFactory({
                        baseUrl: params.standardFontDataUrl
                      });
                    }
                    this.destroyed = false;
                    this.destroyCapability = null;
                    this._passwordCapability = null;
                    this._networkStream = networkStream;
                    this._fullReader = null;
                    this._lastProgress = null;
                    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                    this.setupMessageHandler();
                  }
                  get annotationStorage() {
                    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                  }
                  get stats() {
                    return __privateGet(this, _docStats);
                  }
                  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {
                    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                    let annotationHash = "";
                    switch (intent) {
                      case "any":
                        renderingIntent = _util.RenderingIntentFlag.ANY;
                        break;
                      case "display":
                        break;
                      case "print":
                        renderingIntent = _util.RenderingIntentFlag.PRINT;
                        break;
                      default:
                        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                    }
                    switch (annotationMode) {
                      case _util.AnnotationMode.DISABLE:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                        break;
                      case _util.AnnotationMode.ENABLE:
                        break;
                      case _util.AnnotationMode.ENABLE_FORMS:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                        break;
                      case _util.AnnotationMode.ENABLE_STORAGE:
                        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                        annotationHash = this.annotationStorage.hash;
                        break;
                      default:
                        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                    }
                    if (isOpList) {
                      renderingIntent += _util.RenderingIntentFlag.OPLIST;
                    }
                    return {
                      renderingIntent,
                      cacheKey: `${renderingIntent}_${annotationHash}`
                    };
                  }
                  destroy() {
                    if (this.destroyCapability) {
                      return this.destroyCapability.promise;
                    }
                    this.destroyed = true;
                    this.destroyCapability = (0, _util.createPromiseCapability)();
                    if (this._passwordCapability) {
                      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                    }
                    const waitOn = [];
                    for (const page of __privateGet(this, _pageCache).values()) {
                      waitOn.push(page._destroy());
                    }
                    __privateGet(this, _pageCache).clear();
                    __privateGet(this, _pagePromises).clear();
                    if (this.hasOwnProperty("annotationStorage")) {
                      this.annotationStorage.resetModified();
                    }
                    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                    waitOn.push(terminated);
                    Promise.all(waitOn).then(() => {
                      this.commonObjs.clear();
                      this.fontLoader.clear();
                      __privateSet(this, _metadataPromise, null);
                      this._getFieldObjectsPromise = null;
                      this._hasJSActionsPromise = null;
                      if (this._networkStream) {
                        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                      }
                      if (this.messageHandler) {
                        this.messageHandler.destroy();
                        this.messageHandler = null;
                      }
                      this.destroyCapability.resolve();
                    }, this.destroyCapability.reject);
                    return this.destroyCapability.promise;
                  }
                  setupMessageHandler() {
                    const {
                      messageHandler,
                      loadingTask
                    } = this;
                    messageHandler.on("GetReader", (data, sink) => {
                      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                      this._fullReader = this._networkStream.getFullReader();
                      this._fullReader.onProgress = (evt) => {
                        this._lastProgress = {
                          loaded: evt.loaded,
                          total: evt.total
                        };
                      };
                      sink.onPull = () => {
                        this._fullReader.read().then(function({
                          value,
                          done
                        }) {
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        }).catch((reason) => {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = (reason) => {
                        this._fullReader.cancel(reason);
                        sink.ready.catch((readyReason) => {
                          if (this.destroyed) {
                            return;
                          }
                          throw readyReason;
                        });
                      };
                    });
                    messageHandler.on("ReaderHeadersReady", (data) => {
                      const headersCapability = (0, _util.createPromiseCapability)();
                      const fullReader = this._fullReader;
                      fullReader.headersReady.then(() => {
                        var _a2;
                        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                          if (this._lastProgress) {
                            (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, this._lastProgress);
                          }
                          fullReader.onProgress = (evt) => {
                            var _a3;
                            (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, {
                              loaded: evt.loaded,
                              total: evt.total
                            });
                          };
                        }
                        headersCapability.resolve({
                          isStreamingSupported: fullReader.isStreamingSupported,
                          isRangeSupported: fullReader.isRangeSupported,
                          contentLength: fullReader.contentLength
                        });
                      }, headersCapability.reject);
                      return headersCapability.promise;
                    });
                    messageHandler.on("GetRangeReader", (data, sink) => {
                      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                      if (!rangeReader) {
                        sink.close();
                        return;
                      }
                      sink.onPull = () => {
                        rangeReader.read().then(function({
                          value,
                          done
                        }) {
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        }).catch((reason) => {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = (reason) => {
                        rangeReader.cancel(reason);
                        sink.ready.catch((readyReason) => {
                          if (this.destroyed) {
                            return;
                          }
                          throw readyReason;
                        });
                      };
                    });
                    messageHandler.on("GetDoc", ({
                      pdfInfo
                    }) => {
                      this._numPages = pdfInfo.numPages;
                      this._htmlForXfa = pdfInfo.htmlForXfa;
                      delete pdfInfo.htmlForXfa;
                      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                    });
                    messageHandler.on("DocException", function(ex) {
                      let reason;
                      switch (ex.name) {
                        case "PasswordException":
                          reason = new _util.PasswordException(ex.message, ex.code);
                          break;
                        case "InvalidPDFException":
                          reason = new _util.InvalidPDFException(ex.message);
                          break;
                        case "MissingPDFException":
                          reason = new _util.MissingPDFException(ex.message);
                          break;
                        case "UnexpectedResponseException":
                          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                          break;
                        case "UnknownErrorException":
                          reason = new _util.UnknownErrorException(ex.message, ex.details);
                          break;
                        default:
                          (0, _util.unreachable)("DocException - expected a valid Error.");
                      }
                      loadingTask._capability.reject(reason);
                    });
                    messageHandler.on("PasswordRequest", (exception) => {
                      this._passwordCapability = (0, _util.createPromiseCapability)();
                      if (loadingTask.onPassword) {
                        const updatePassword = (password) => {
                          if (password instanceof Error) {
                            this._passwordCapability.reject(password);
                          } else {
                            this._passwordCapability.resolve({
                              password
                            });
                          }
                        };
                        try {
                          loadingTask.onPassword(updatePassword, exception.code);
                        } catch (ex) {
                          this._passwordCapability.reject(ex);
                        }
                      } else {
                        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                      }
                      return this._passwordCapability.promise;
                    });
                    messageHandler.on("DataLoaded", (data) => {
                      var _a2;
                      (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
                        loaded: data.length,
                        total: data.length
                      });
                      this.downloadInfoCapability.resolve(data);
                    });
                    messageHandler.on("StartRenderPage", (data) => {
                      if (this.destroyed) {
                        return;
                      }
                      const page = __privateGet(this, _pageCache).get(data.pageIndex);
                      page._startRenderPage(data.transparency, data.cacheKey);
                    });
                    messageHandler.on("commonobj", ([id2, type, exportedData]) => {
                      var _a2;
                      if (this.destroyed) {
                        return;
                      }
                      if (this.commonObjs.has(id2)) {
                        return;
                      }
                      switch (type) {
                        case "Font":
                          const params = this._params;
                          if ("error" in exportedData) {
                            const exportedError = exportedData.error;
                            (0, _util.warn)(`Error during font loading: ${exportedError}`);
                            this.commonObjs.resolve(id2, exportedError);
                            break;
                          }
                          let fontRegistry = null;
                          if (params.pdfBug && ((_a2 = globalThis.FontInspector) == null ? void 0 : _a2.enabled)) {
                            fontRegistry = {
                              registerFont(font2, url) {
                                globalThis.FontInspector.fontAdded(font2, url);
                              }
                            };
                          }
                          const font = new _font_loader.FontFaceObject(exportedData, {
                            isEvalSupported: params.isEvalSupported,
                            disableFontFace: params.disableFontFace,
                            ignoreErrors: params.ignoreErrors,
                            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                            fontRegistry
                          });
                          this.fontLoader.bind(font).catch((reason) => {
                            return messageHandler.sendWithPromise("FontFallback", {
                              id: id2
                            });
                          }).finally(() => {
                            if (!params.fontExtraProperties && font.data) {
                              font.data = null;
                            }
                            this.commonObjs.resolve(id2, font);
                          });
                          break;
                        case "FontPath":
                        case "Image":
                          this.commonObjs.resolve(id2, exportedData);
                          break;
                        default:
                          throw new Error(`Got unknown common object type ${type}`);
                      }
                    });
                    messageHandler.on("obj", ([id2, pageIndex, type, imageData]) => {
                      var _a2;
                      if (this.destroyed) {
                        return;
                      }
                      const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                      if (pageProxy.objs.has(id2)) {
                        return;
                      }
                      switch (type) {
                        case "Image":
                          pageProxy.objs.resolve(id2, imageData);
                          const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                          if (imageData) {
                            let length;
                            if (imageData.bitmap) {
                              const {
                                bitmap,
                                width,
                                height
                              } = imageData;
                              length = width * height * 4;
                              pageProxy._bitmaps.add(bitmap);
                            } else {
                              length = ((_a2 = imageData.data) == null ? void 0 : _a2.length) || 0;
                            }
                            if (length > MAX_IMAGE_SIZE_TO_STORE) {
                              pageProxy.cleanupAfterRender = true;
                            }
                          }
                          break;
                        case "Pattern":
                          pageProxy.objs.resolve(id2, imageData);
                          break;
                        default:
                          throw new Error(`Got unknown object type ${type}`);
                      }
                    });
                    messageHandler.on("DocProgress", (data) => {
                      var _a2;
                      if (this.destroyed) {
                        return;
                      }
                      (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
                        loaded: data.loaded,
                        total: data.total
                      });
                    });
                    messageHandler.on("DocStats", (data) => {
                      if (this.destroyed) {
                        return;
                      }
                      __privateSet(this, _docStats, Object.freeze({
                        streamTypes: Object.freeze(data.streamTypes),
                        fontTypes: Object.freeze(data.fontTypes)
                      }));
                    });
                    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                    messageHandler.on("FetchBuiltInCMap", (data) => {
                      if (this.destroyed) {
                        return Promise.reject(new Error("Worker was destroyed."));
                      }
                      if (!this.CMapReaderFactory) {
                        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                      }
                      return this.CMapReaderFactory.fetch(data);
                    });
                    messageHandler.on("FetchStandardFontData", (data) => {
                      if (this.destroyed) {
                        return Promise.reject(new Error("Worker was destroyed."));
                      }
                      if (!this.StandardFontDataFactory) {
                        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                      }
                      return this.StandardFontDataFactory.fetch(data);
                    });
                  }
                  _onUnsupportedFeature({
                    featureId
                  }) {
                    var _a2, _b;
                    if (this.destroyed) {
                      return;
                    }
                    (_b = (_a2 = this.loadingTask).onUnsupportedFeature) == null ? void 0 : _b.call(_a2, featureId);
                  }
                  getData() {
                    return this.messageHandler.sendWithPromise("GetData", null);
                  }
                  getPage(pageNumber) {
                    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                      return Promise.reject(new Error("Invalid page request."));
                    }
                    const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                    if (cachedPromise) {
                      return cachedPromise;
                    }
                    const promise = this.messageHandler.sendWithPromise("GetPage", {
                      pageIndex
                    }).then((pageInfo) => {
                      if (this.destroyed) {
                        throw new Error("Transport destroyed");
                      }
                      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                      __privateGet(this, _pageCache).set(pageIndex, page);
                      return page;
                    });
                    __privateGet(this, _pagePromises).set(pageIndex, promise);
                    return promise;
                  }
                  getPageIndex(ref) {
                    if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                      return Promise.reject(new Error("Invalid pageIndex request."));
                    }
                    return this.messageHandler.sendWithPromise("GetPageIndex", {
                      num: ref.num,
                      gen: ref.gen
                    });
                  }
                  getAnnotations(pageIndex, intent) {
                    return this.messageHandler.sendWithPromise("GetAnnotations", {
                      pageIndex,
                      intent
                    });
                  }
                  saveDocument() {
                    var _a2;
                    return this.messageHandler.sendWithPromise("SaveDocument", {
                      isPureXfa: !!this._htmlForXfa,
                      numPages: this._numPages,
                      annotationStorage: this.annotationStorage.serializable,
                      filename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null
                    }).finally(() => {
                      this.annotationStorage.resetModified();
                    });
                  }
                  getFieldObjects() {
                    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
                  }
                  hasJSActions() {
                    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
                  }
                  getCalculationOrderIds() {
                    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                  }
                  getDestinations() {
                    return this.messageHandler.sendWithPromise("GetDestinations", null);
                  }
                  getDestination(id2) {
                    if (typeof id2 !== "string") {
                      return Promise.reject(new Error("Invalid destination request."));
                    }
                    return this.messageHandler.sendWithPromise("GetDestination", {
                      id: id2
                    });
                  }
                  getPageLabels() {
                    return this.messageHandler.sendWithPromise("GetPageLabels", null);
                  }
                  getPageLayout() {
                    return this.messageHandler.sendWithPromise("GetPageLayout", null);
                  }
                  getPageMode() {
                    return this.messageHandler.sendWithPromise("GetPageMode", null);
                  }
                  getViewerPreferences() {
                    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                  }
                  getOpenAction() {
                    return this.messageHandler.sendWithPromise("GetOpenAction", null);
                  }
                  getAttachments() {
                    return this.messageHandler.sendWithPromise("GetAttachments", null);
                  }
                  getJavaScript() {
                    return this.messageHandler.sendWithPromise("GetJavaScript", null);
                  }
                  getDocJSActions() {
                    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                  }
                  getPageJSActions(pageIndex) {
                    return this.messageHandler.sendWithPromise("GetPageJSActions", {
                      pageIndex
                    });
                  }
                  getStructTree(pageIndex) {
                    return this.messageHandler.sendWithPromise("GetStructTree", {
                      pageIndex
                    });
                  }
                  getOutline() {
                    return this.messageHandler.sendWithPromise("GetOutline", null);
                  }
                  getOptionalContentConfig() {
                    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                      return new _optional_content_config.OptionalContentConfig(results);
                    });
                  }
                  getPermissions() {
                    return this.messageHandler.sendWithPromise("GetPermissions", null);
                  }
                  getMetadata() {
                    return __privateGet(this, _metadataPromise) || __privateSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                      var _a2, _b;
                      return {
                        info: results[0],
                        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                        contentDispositionFilename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null,
                        contentLength: ((_b = this._fullReader) == null ? void 0 : _b.contentLength) ?? null
                      };
                    }));
                  }
                  getMarkInfo() {
                    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                  }
                  async startCleanup(keepLoadedFonts = false) {
                    await this.messageHandler.sendWithPromise("Cleanup", null);
                    if (this.destroyed) {
                      return;
                    }
                    for (const page of __privateGet(this, _pageCache).values()) {
                      const cleanupSuccessful = page.cleanup();
                      if (!cleanupSuccessful) {
                        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                      }
                    }
                    this.commonObjs.clear();
                    if (!keepLoadedFonts) {
                      this.fontLoader.clear();
                    }
                    __privateSet(this, _metadataPromise, null);
                    this._getFieldObjectsPromise = null;
                    this._hasJSActionsPromise = null;
                  }
                  get loadingParams() {
                    const params = this._params;
                    return (0, _util.shadow)(this, "loadingParams", {
                      disableAutoFetch: params.disableAutoFetch,
                      enableXfa: params.enableXfa
                    });
                  }
                }
                _docStats = new WeakMap();
                _pageCache = new WeakMap();
                _pagePromises = new WeakMap();
                _metadataPromise = new WeakMap();
                class PDFObjects {
                  constructor() {
                    __privateAdd(this, _ensureObj);
                    __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                  }
                  get(objId, callback = null) {
                    if (callback) {
                      const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                      obj2.capability.promise.then(() => callback(obj2.data));
                      return null;
                    }
                    const obj = __privateGet(this, _objs)[objId];
                    if (!(obj == null ? void 0 : obj.capability.settled)) {
                      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                    }
                    return obj.data;
                  }
                  has(objId) {
                    const obj = __privateGet(this, _objs)[objId];
                    return (obj == null ? void 0 : obj.capability.settled) || false;
                  }
                  resolve(objId, data = null) {
                    const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj.data = data;
                    obj.capability.resolve();
                  }
                  clear() {
                    __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                  }
                }
                _objs = new WeakMap();
                _ensureObj = new WeakSet();
                ensureObj_fn = function(objId) {
                  const obj = __privateGet(this, _objs)[objId];
                  if (obj) {
                    return obj;
                  }
                  return __privateGet(this, _objs)[objId] = {
                    capability: (0, _util.createPromiseCapability)(),
                    data: null
                  };
                };
                class RenderTask {
                  constructor(internalRenderTask) {
                    this._internalRenderTask = internalRenderTask;
                    this.onContinue = null;
                  }
                  get promise() {
                    return this._internalRenderTask.capability.promise;
                  }
                  cancel() {
                    this._internalRenderTask.cancel();
                  }
                }
                exports.RenderTask = RenderTask;
                const _InternalRenderTask = class _InternalRenderTask {
                  constructor({
                    callback,
                    params,
                    objs,
                    commonObjs,
                    annotationCanvasMap,
                    operatorList,
                    pageIndex,
                    canvasFactory,
                    useRequestAnimationFrame = false,
                    pdfBug = false,
                    pageColors = null
                  }) {
                    this.callback = callback;
                    this.params = params;
                    this.objs = objs;
                    this.commonObjs = commonObjs;
                    this.annotationCanvasMap = annotationCanvasMap;
                    this.operatorListIdx = null;
                    this.operatorList = operatorList;
                    this._pageIndex = pageIndex;
                    this.canvasFactory = canvasFactory;
                    this._pdfBug = pdfBug;
                    this.pageColors = pageColors;
                    this.running = false;
                    this.graphicsReadyCallback = null;
                    this.graphicsReady = false;
                    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                    this.cancelled = false;
                    this.capability = (0, _util.createPromiseCapability)();
                    this.task = new RenderTask(this);
                    this._cancelBound = this.cancel.bind(this);
                    this._continueBound = this._continue.bind(this);
                    this._scheduleNextBound = this._scheduleNext.bind(this);
                    this._nextBound = this._next.bind(this);
                    this._canvas = params.canvasContext.canvas;
                  }
                  get completed() {
                    return this.capability.promise.catch(function() {
                    });
                  }
                  initializeGraphics({
                    transparency = false,
                    optionalContentConfig
                  }) {
                    var _a2;
                    if (this.cancelled) {
                      return;
                    }
                    if (this._canvas) {
                      if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                      }
                      __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                    }
                    if (this._pdfBug && ((_a2 = globalThis.StepperManager) == null ? void 0 : _a2.enabled)) {
                      this.stepper = globalThis.StepperManager.create(this._pageIndex);
                      this.stepper.init(this.operatorList);
                      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                    }
                    const {
                      canvasContext,
                      viewport,
                      transform,
                      imageLayer,
                      background
                    } = this.params;
                    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                    this.gfx.beginDrawing({
                      transform,
                      viewport,
                      transparency,
                      background
                    });
                    this.operatorListIdx = 0;
                    this.graphicsReady = true;
                    if (this.graphicsReadyCallback) {
                      this.graphicsReadyCallback();
                    }
                  }
                  cancel(error = null) {
                    this.running = false;
                    this.cancelled = true;
                    if (this.gfx) {
                      this.gfx.endDrawing();
                    }
                    if (this._canvas) {
                      __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                    }
                    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                  }
                  operatorListChanged() {
                    if (!this.graphicsReady) {
                      if (!this.graphicsReadyCallback) {
                        this.graphicsReadyCallback = this._continueBound;
                      }
                      return;
                    }
                    if (this.stepper) {
                      this.stepper.updateOperatorList(this.operatorList);
                    }
                    if (this.running) {
                      return;
                    }
                    this._continue();
                  }
                  _continue() {
                    this.running = true;
                    if (this.cancelled) {
                      return;
                    }
                    if (this.task.onContinue) {
                      this.task.onContinue(this._scheduleNextBound);
                    } else {
                      this._scheduleNext();
                    }
                  }
                  _scheduleNext() {
                    if (this._useRequestAnimationFrame) {
                      window.requestAnimationFrame(() => {
                        this._nextBound().catch(this._cancelBound);
                      });
                    } else {
                      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                    }
                  }
                  async _next() {
                    if (this.cancelled) {
                      return;
                    }
                    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                    if (this.operatorListIdx === this.operatorList.argsArray.length) {
                      this.running = false;
                      if (this.operatorList.lastChunk) {
                        this.gfx.endDrawing();
                        if (this._canvas) {
                          __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                        }
                        this.callback();
                      }
                    }
                  }
                };
                _canvasInUse = new WeakMap();
                __privateAdd(_InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
                let InternalRenderTask = _InternalRenderTask;
                const version = "2.14.305";
                exports.version = version;
                const build = "eaaa8b4ad";
                exports.build = build;
              },
              /* 5 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = void 0;
                exports2.deprecated = deprecated;
                exports2.getFilenameFromUrl = getFilenameFromUrl;
                exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
                exports2.getXfaPageViewport = getXfaPageViewport;
                exports2.isDataScheme = isDataScheme;
                exports2.isPdfFile = isPdfFile;
                exports2.isValidFetchUrl = isValidFetchUrl;
                exports2.loadScript = loadScript;
                var _base_factory = __w_pdfjs_require__2(6);
                var _util2 = __w_pdfjs_require__2(1);
                const SVG_NS = "http://www.w3.org/2000/svg";
                const _PixelsPerInch = class _PixelsPerInch {
                };
                __publicField(_PixelsPerInch, "CSS", 96);
                __publicField(_PixelsPerInch, "PDF", 72);
                __publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
                let PixelsPerInch = _PixelsPerInch;
                exports2.PixelsPerInch = PixelsPerInch;
                class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                  constructor({
                    ownerDocument = globalThis.document
                  } = {}) {
                    super();
                    this._document = ownerDocument;
                  }
                  _createCanvas(width, height) {
                    const canvas = this._document.createElement("canvas");
                    canvas.width = width;
                    canvas.height = height;
                    return canvas;
                  }
                }
                exports2.DOMCanvasFactory = DOMCanvasFactory;
                async function fetchData(url, asTypedArray = false) {
                  if (isValidFetchUrl(url, document.baseURI)) {
                    const response = await fetch(url);
                    if (!response.ok) {
                      throw new Error(response.statusText);
                    }
                    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                  }
                  return new Promise((resolve, reject) => {
                    const request = new XMLHttpRequest();
                    request.open("GET", url, true);
                    if (asTypedArray) {
                      request.responseType = "arraybuffer";
                    }
                    request.onreadystatechange = () => {
                      if (request.readyState !== XMLHttpRequest.DONE) {
                        return;
                      }
                      if (request.status === 200 || request.status === 0) {
                        let data;
                        if (asTypedArray && request.response) {
                          data = new Uint8Array(request.response);
                        } else if (!asTypedArray && request.responseText) {
                          data = (0, _util2.stringToBytes)(request.responseText);
                        }
                        if (data) {
                          resolve(data);
                          return;
                        }
                      }
                      reject(new Error(request.statusText));
                    };
                    request.send(null);
                  });
                }
                class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                  _fetchData(url, compressionType) {
                    return fetchData(url, this.isCompressed).then((data) => {
                      return {
                        cMapData: data,
                        compressionType
                      };
                    });
                  }
                }
                exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
                class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                  _fetchData(url) {
                    return fetchData(url, true);
                  }
                }
                exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
                class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                  _createSVG(type) {
                    return document.createElementNS(SVG_NS, type);
                  }
                }
                exports2.DOMSVGFactory = DOMSVGFactory;
                class PageViewport {
                  constructor({
                    viewBox,
                    scale,
                    rotation,
                    offsetX = 0,
                    offsetY = 0,
                    dontFlip = false
                  }) {
                    this.viewBox = viewBox;
                    this.scale = scale;
                    this.rotation = rotation;
                    this.offsetX = offsetX;
                    this.offsetY = offsetY;
                    const centerX = (viewBox[2] + viewBox[0]) / 2;
                    const centerY = (viewBox[3] + viewBox[1]) / 2;
                    let rotateA, rotateB, rotateC, rotateD;
                    rotation %= 360;
                    if (rotation < 0) {
                      rotation += 360;
                    }
                    switch (rotation) {
                      case 180:
                        rotateA = -1;
                        rotateB = 0;
                        rotateC = 0;
                        rotateD = 1;
                        break;
                      case 90:
                        rotateA = 0;
                        rotateB = 1;
                        rotateC = 1;
                        rotateD = 0;
                        break;
                      case 270:
                        rotateA = 0;
                        rotateB = -1;
                        rotateC = -1;
                        rotateD = 0;
                        break;
                      case 0:
                        rotateA = 1;
                        rotateB = 0;
                        rotateC = 0;
                        rotateD = -1;
                        break;
                      default:
                        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                    }
                    if (dontFlip) {
                      rotateC = -rotateC;
                      rotateD = -rotateD;
                    }
                    let offsetCanvasX, offsetCanvasY;
                    let width, height;
                    if (rotateA === 0) {
                      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    } else {
                      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    }
                    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                    this.width = width;
                    this.height = height;
                  }
                  clone({
                    scale = this.scale,
                    rotation = this.rotation,
                    offsetX = this.offsetX,
                    offsetY = this.offsetY,
                    dontFlip = false
                  } = {}) {
                    return new PageViewport({
                      viewBox: this.viewBox.slice(),
                      scale,
                      rotation,
                      offsetX,
                      offsetY,
                      dontFlip
                    });
                  }
                  convertToViewportPoint(x, y) {
                    return _util2.Util.applyTransform([x, y], this.transform);
                  }
                  convertToViewportRectangle(rect) {
                    const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                    const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                  }
                  convertToPdfPoint(x, y) {
                    return _util2.Util.applyInverseTransform([x, y], this.transform);
                  }
                }
                exports2.PageViewport = PageViewport;
                class RenderingCancelledException extends _util2.BaseException {
                  constructor(msg, type) {
                    super(msg, "RenderingCancelledException");
                    this.type = type;
                  }
                }
                exports2.RenderingCancelledException = RenderingCancelledException;
                function isDataScheme(url) {
                  const ii = url.length;
                  let i = 0;
                  while (i < ii && url[i].trim() === "") {
                    i++;
                  }
                  return url.substring(i, i + 5).toLowerCase() === "data:";
                }
                function isPdfFile(filename) {
                  return typeof filename === "string" && /\.pdf$/i.test(filename);
                }
                function getFilenameFromUrl(url) {
                  const anchor = url.indexOf("#");
                  const query = url.indexOf("?");
                  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
                  return url.substring(url.lastIndexOf("/", end) + 1, end);
                }
                function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
                  if (typeof url !== "string") {
                    return defaultFilename;
                  }
                  if (isDataScheme(url)) {
                    (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                    return defaultFilename;
                  }
                  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                  const splitURI = reURI.exec(url);
                  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                  if (suggestedFilename) {
                    suggestedFilename = suggestedFilename[0];
                    if (suggestedFilename.includes("%")) {
                      try {
                        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                      } catch (ex) {
                      }
                    }
                  }
                  return suggestedFilename || defaultFilename;
                }
                class StatTimer {
                  constructor() {
                    this.started = /* @__PURE__ */ Object.create(null);
                    this.times = [];
                  }
                  time(name) {
                    if (name in this.started) {
                      (0, _util2.warn)(`Timer is already running for ${name}`);
                    }
                    this.started[name] = Date.now();
                  }
                  timeEnd(name) {
                    if (!(name in this.started)) {
                      (0, _util2.warn)(`Timer has not been started for ${name}`);
                    }
                    this.times.push({
                      name,
                      start: this.started[name],
                      end: Date.now()
                    });
                    delete this.started[name];
                  }
                  toString() {
                    const outBuf = [];
                    let longest = 0;
                    for (const time of this.times) {
                      const name = time.name;
                      if (name.length > longest) {
                        longest = name.length;
                      }
                    }
                    for (const time of this.times) {
                      const duration = time.end - time.start;
                      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                    }
                    return outBuf.join("");
                  }
                }
                exports2.StatTimer = StatTimer;
                function isValidFetchUrl(url, baseUrl) {
                  try {
                    const {
                      protocol
                    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                    return protocol === "http:" || protocol === "https:";
                  } catch (ex) {
                    return false;
                  }
                }
                function loadScript(src, removeScriptElement = false) {
                  return new Promise((resolve, reject) => {
                    const script = document.createElement("script");
                    script.src = src;
                    script.onload = function(evt) {
                      if (removeScriptElement) {
                        script.remove();
                      }
                      resolve(evt);
                    };
                    script.onerror = function() {
                      reject(new Error(`Cannot load script at: ${script.src}`));
                    };
                    (document.head || document.documentElement).appendChild(script);
                  });
                }
                function deprecated(details) {
                  console.log("Deprecated API usage: " + details);
                }
                let pdfDateStringRegex;
                class PDFDateString {
                  static toDateObject(input) {
                    if (!input || typeof input !== "string") {
                      return null;
                    }
                    if (!pdfDateStringRegex) {
                      pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                    }
                    const matches = pdfDateStringRegex.exec(input);
                    if (!matches) {
                      return null;
                    }
                    const year = parseInt(matches[1], 10);
                    let month = parseInt(matches[2], 10);
                    month = month >= 1 && month <= 12 ? month - 1 : 0;
                    let day = parseInt(matches[3], 10);
                    day = day >= 1 && day <= 31 ? day : 1;
                    let hour = parseInt(matches[4], 10);
                    hour = hour >= 0 && hour <= 23 ? hour : 0;
                    let minute = parseInt(matches[5], 10);
                    minute = minute >= 0 && minute <= 59 ? minute : 0;
                    let second = parseInt(matches[6], 10);
                    second = second >= 0 && second <= 59 ? second : 0;
                    const universalTimeRelation = matches[7] || "Z";
                    let offsetHour = parseInt(matches[8], 10);
                    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                    let offsetMinute = parseInt(matches[9], 10) || 0;
                    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                    if (universalTimeRelation === "-") {
                      hour += offsetHour;
                      minute += offsetMinute;
                    } else if (universalTimeRelation === "+") {
                      hour -= offsetHour;
                      minute -= offsetMinute;
                    }
                    return new Date(Date.UTC(year, month, day, hour, minute, second));
                  }
                }
                exports2.PDFDateString = PDFDateString;
                function getXfaPageViewport(xfaPage, {
                  scale = 1,
                  rotation = 0
                }) {
                  const {
                    width,
                    height
                  } = xfaPage.attributes.style;
                  const viewBox = [0, 0, parseInt(width), parseInt(height)];
                  return new PageViewport({
                    viewBox,
                    scale,
                    rotation
                  });
                }
              },
              /* 6 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                class BaseCanvasFactory {
                  constructor() {
                    if (this.constructor === BaseCanvasFactory) {
                      (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                    }
                  }
                  create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    const canvas = this._createCanvas(width, height);
                    return {
                      canvas,
                      context: canvas.getContext("2d")
                    };
                  }
                  reset(canvasAndContext, width, height) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    canvasAndContext.canvas.width = width;
                    canvasAndContext.canvas.height = height;
                  }
                  destroy(canvasAndContext) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    canvasAndContext.canvas.width = 0;
                    canvasAndContext.canvas.height = 0;
                    canvasAndContext.canvas = null;
                    canvasAndContext.context = null;
                  }
                  _createCanvas(width, height) {
                    (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                  }
                }
                exports2.BaseCanvasFactory = BaseCanvasFactory;
                class BaseCMapReaderFactory {
                  constructor({
                    baseUrl = null,
                    isCompressed = false
                  }) {
                    if (this.constructor === BaseCMapReaderFactory) {
                      (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                    }
                    this.baseUrl = baseUrl;
                    this.isCompressed = isCompressed;
                  }
                  async fetch({
                    name
                  }) {
                    if (!this.baseUrl) {
                      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                    }
                    if (!name) {
                      throw new Error("CMap name must be specified.");
                    }
                    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                    const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                    return this._fetchData(url, compressionType).catch((reason) => {
                      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                    });
                  }
                  _fetchData(url, compressionType) {
                    (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                  }
                }
                exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
                class BaseStandardFontDataFactory {
                  constructor({
                    baseUrl = null
                  }) {
                    if (this.constructor === BaseStandardFontDataFactory) {
                      (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                    }
                    this.baseUrl = baseUrl;
                  }
                  async fetch({
                    filename
                  }) {
                    if (!this.baseUrl) {
                      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                    }
                    if (!filename) {
                      throw new Error("Font filename must be specified.");
                    }
                    const url = `${this.baseUrl}${filename}`;
                    return this._fetchData(url).catch((reason) => {
                      throw new Error(`Unable to load font data at: ${url}`);
                    });
                  }
                  _fetchData(url) {
                    (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                  }
                }
                exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
                class BaseSVGFactory {
                  constructor() {
                    if (this.constructor === BaseSVGFactory) {
                      (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                    }
                  }
                  create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid SVG dimensions");
                    }
                    const svg = this._createSVG("svg:svg");
                    svg.setAttribute("version", "1.1");
                    svg.setAttribute("width", `${width}px`);
                    svg.setAttribute("height", `${height}px`);
                    svg.setAttribute("preserveAspectRatio", "none");
                    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                    return svg;
                  }
                  createElement(type) {
                    if (typeof type !== "string") {
                      throw new Error("Invalid SVG element type");
                    }
                    return this._createSVG(type);
                  }
                  _createSVG(type) {
                    (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                  }
                }
                exports2.BaseSVGFactory = BaseSVGFactory;
              },
              /* 7 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.FontLoader = exports2.FontFaceObject = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                class BaseFontLoader {
                  constructor({
                    docId,
                    onUnsupportedFeature,
                    ownerDocument = globalThis.document,
                    styleElement = null
                  }) {
                    if (this.constructor === BaseFontLoader) {
                      (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                    }
                    this.docId = docId;
                    this._onUnsupportedFeature = onUnsupportedFeature;
                    this._document = ownerDocument;
                    this.nativeFontFaces = [];
                    this.styleElement = null;
                  }
                  addNativeFontFace(nativeFontFace) {
                    this.nativeFontFaces.push(nativeFontFace);
                    this._document.fonts.add(nativeFontFace);
                  }
                  insertRule(rule) {
                    let styleElement = this.styleElement;
                    if (!styleElement) {
                      styleElement = this.styleElement = this._document.createElement("style");
                      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                    }
                    const styleSheet = styleElement.sheet;
                    styleSheet.insertRule(rule, styleSheet.cssRules.length);
                  }
                  clear() {
                    for (const nativeFontFace of this.nativeFontFaces) {
                      this._document.fonts.delete(nativeFontFace);
                    }
                    this.nativeFontFaces.length = 0;
                    if (this.styleElement) {
                      this.styleElement.remove();
                      this.styleElement = null;
                    }
                  }
                  async bind(font) {
                    if (font.attached || font.missingFile) {
                      return;
                    }
                    font.attached = true;
                    if (this.isFontLoadingAPISupported) {
                      const nativeFontFace = font.createNativeFontFace();
                      if (nativeFontFace) {
                        this.addNativeFontFace(nativeFontFace);
                        try {
                          await nativeFontFace.loaded;
                        } catch (ex) {
                          this._onUnsupportedFeature({
                            featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                          });
                          (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                          font.disableFontFace = true;
                          throw ex;
                        }
                      }
                      return;
                    }
                    const rule = font.createFontFaceRule();
                    if (rule) {
                      this.insertRule(rule);
                      if (this.isSyncFontLoadingSupported) {
                        return;
                      }
                      await new Promise((resolve) => {
                        const request = this._queueLoadingCallback(resolve);
                        this._prepareFontLoadEvent([rule], [font], request);
                      });
                    }
                  }
                  _queueLoadingCallback(callback) {
                    (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                  }
                  get isFontLoadingAPISupported() {
                    var _a;
                    const hasFonts = !!((_a = this._document) == null ? void 0 : _a.fonts);
                    return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                  }
                  get isSyncFontLoadingSupported() {
                    (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                  }
                  get _loadTestFont() {
                    (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                  }
                  _prepareFontLoadEvent(rules, fontsToLoad, request) {
                    (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                  }
                }
                let FontLoader;
                exports2.FontLoader = FontLoader;
                {
                  exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                    constructor(params) {
                      super(params);
                      this.loadingContext = {
                        requests: [],
                        nextRequestId: 0
                      };
                      this.loadTestFontId = 0;
                    }
                    get isSyncFontLoadingSupported() {
                      let supported = false;
                      if (typeof navigator === "undefined") {
                        supported = true;
                      } else {
                        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                        if ((m == null ? void 0 : m[1]) >= 14) {
                          supported = true;
                        }
                      }
                      return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                    }
                    _queueLoadingCallback(callback) {
                      function completeRequest() {
                        (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                        request.done = true;
                        while (context.requests.length > 0 && context.requests[0].done) {
                          const otherRequest = context.requests.shift();
                          setTimeout(otherRequest.callback, 0);
                        }
                      }
                      const context = this.loadingContext;
                      const request = {
                        id: `pdfjs-font-loading-${context.nextRequestId++}`,
                        done: false,
                        complete: completeRequest,
                        callback
                      };
                      context.requests.push(request);
                      return request;
                    }
                    get _loadTestFont() {
                      const getLoadTestFont = function() {
                        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                      };
                      return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                    }
                    _prepareFontLoadEvent(rules, fonts, request) {
                      function int32(data2, offset) {
                        return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                      }
                      function spliceString(s, offset, remove, insert) {
                        const chunk1 = s.substring(0, offset);
                        const chunk2 = s.substring(offset + remove);
                        return chunk1 + insert + chunk2;
                      }
                      let i, ii;
                      const canvas = this._document.createElement("canvas");
                      canvas.width = 1;
                      canvas.height = 1;
                      const ctx = canvas.getContext("2d");
                      let called = 0;
                      function isFontReady(name, callback) {
                        called++;
                        if (called > 30) {
                          (0, _util2.warn)("Load test font never loaded.");
                          callback();
                          return;
                        }
                        ctx.font = "30px " + name;
                        ctx.fillText(".", 0, 20);
                        const imageData = ctx.getImageData(0, 0, 1, 1);
                        if (imageData.data[3] > 0) {
                          callback();
                          return;
                        }
                        setTimeout(isFontReady.bind(null, name, callback));
                      }
                      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                      let data = this._loadTestFont;
                      const COMMENT_OFFSET = 976;
                      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                      const CFF_CHECKSUM_OFFSET = 16;
                      const XXXX_VALUE = 1482184792;
                      let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                      }
                      if (i < loadTestFontId.length) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                      }
                      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                      const url = `url(data:font/opentype;base64,${btoa(data)});`;
                      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                      this.insertRule(rule);
                      const names = [];
                      for (const font of fonts) {
                        names.push(font.loadedName);
                      }
                      names.push(loadTestFontId);
                      const div = this._document.createElement("div");
                      div.style.visibility = "hidden";
                      div.style.width = div.style.height = "10px";
                      div.style.position = "absolute";
                      div.style.top = div.style.left = "0px";
                      for (const name of names) {
                        const span = this._document.createElement("span");
                        span.textContent = "Hi";
                        span.style.fontFamily = name;
                        div.appendChild(span);
                      }
                      this._document.body.appendChild(div);
                      isFontReady(loadTestFontId, () => {
                        div.remove();
                        request.complete();
                      });
                    }
                  };
                }
                class FontFaceObject {
                  constructor(translatedData, {
                    isEvalSupported = true,
                    disableFontFace = false,
                    ignoreErrors = false,
                    onUnsupportedFeature,
                    fontRegistry = null
                  }) {
                    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                    for (const i in translatedData) {
                      this[i] = translatedData[i];
                    }
                    this.isEvalSupported = isEvalSupported !== false;
                    this.disableFontFace = disableFontFace === true;
                    this.ignoreErrors = ignoreErrors === true;
                    this._onUnsupportedFeature = onUnsupportedFeature;
                    this.fontRegistry = fontRegistry;
                  }
                  createNativeFontFace() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    let nativeFontFace;
                    if (!this.cssFontInfo) {
                      nativeFontFace = new FontFace(this.loadedName, this.data, {});
                    } else {
                      const css = {
                        weight: this.cssFontInfo.fontWeight
                      };
                      if (this.cssFontInfo.italicAngle) {
                        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                      }
                      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                    }
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this);
                    }
                    return nativeFontFace;
                  }
                  createFontFaceRule() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    const data = (0, _util2.bytesToString)(this.data);
                    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                    let rule;
                    if (!this.cssFontInfo) {
                      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                    } else {
                      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                      if (this.cssFontInfo.italicAngle) {
                        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                      }
                      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
                    }
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this, url);
                    }
                    return rule;
                  }
                  getPathGenerator(objs, character) {
                    if (this.compiledGlyphs[character] !== void 0) {
                      return this.compiledGlyphs[character];
                    }
                    let cmds;
                    try {
                      cmds = objs.get(this.loadedName + "_path_" + character);
                    } catch (ex) {
                      if (!this.ignoreErrors) {
                        throw ex;
                      }
                      this._onUnsupportedFeature({
                        featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                      });
                      (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                      return this.compiledGlyphs[character] = function(c, size) {
                      };
                    }
                    if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                      const jsBuf = [];
                      for (const current of cmds) {
                        const args = current.args !== void 0 ? current.args.join(",") : "";
                        jsBuf.push("c.", current.cmd, "(", args, ");\n");
                      }
                      return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                    }
                    return this.compiledGlyphs[character] = function(c, size) {
                      for (const current of cmds) {
                        if (current.cmd === "scale") {
                          current.args = [size, -size];
                        }
                        c[current.cmd].apply(c, current.args);
                      }
                    };
                  }
                }
                exports2.FontFaceObject = FontFaceObject;
              },
              /* 8 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.AnnotationStorage = void 0;
                var _murmurhash = __w_pdfjs_require__2(9);
                var _util2 = __w_pdfjs_require__2(1);
                class AnnotationStorage {
                  constructor() {
                    this._storage = /* @__PURE__ */ new Map();
                    this._modified = false;
                    this.onSetModified = null;
                    this.onResetModified = null;
                  }
                  getValue(key, defaultValue) {
                    const value = this._storage.get(key);
                    if (value === void 0) {
                      return defaultValue;
                    }
                    return Object.assign(defaultValue, value);
                  }
                  getRawValue(key) {
                    return this._storage.get(key);
                  }
                  setValue(key, value) {
                    const obj = this._storage.get(key);
                    let modified = false;
                    if (obj !== void 0) {
                      for (const [entry, val] of Object.entries(value)) {
                        if (obj[entry] !== val) {
                          modified = true;
                          obj[entry] = val;
                        }
                      }
                    } else {
                      modified = true;
                      this._storage.set(key, value);
                    }
                    if (modified) {
                      this._setModified();
                    }
                  }
                  getAll() {
                    return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                  }
                  get size() {
                    return this._storage.size;
                  }
                  _setModified() {
                    if (!this._modified) {
                      this._modified = true;
                      if (typeof this.onSetModified === "function") {
                        this.onSetModified();
                      }
                    }
                  }
                  resetModified() {
                    if (this._modified) {
                      this._modified = false;
                      if (typeof this.onResetModified === "function") {
                        this.onResetModified();
                      }
                    }
                  }
                  get serializable() {
                    return this._storage.size > 0 ? this._storage : null;
                  }
                  get hash() {
                    const hash = new _murmurhash.MurmurHash3_64();
                    for (const [key, value] of this._storage) {
                      hash.update(`${key}:${JSON.stringify(value)}`);
                    }
                    return hash.hexdigest();
                  }
                }
                exports2.AnnotationStorage = AnnotationStorage;
              },
              /* 9 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.MurmurHash3_64 = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                const SEED = 3285377520;
                const MASK_HIGH = 4294901760;
                const MASK_LOW = 65535;
                class MurmurHash3_64 {
                  constructor(seed) {
                    this.h1 = seed ? seed & 4294967295 : SEED;
                    this.h2 = seed ? seed & 4294967295 : SEED;
                  }
                  update(input) {
                    let data, length;
                    if (typeof input === "string") {
                      data = new Uint8Array(input.length * 2);
                      length = 0;
                      for (let i = 0, ii = input.length; i < ii; i++) {
                        const code = input.charCodeAt(i);
                        if (code <= 255) {
                          data[length++] = code;
                        } else {
                          data[length++] = code >>> 8;
                          data[length++] = code & 255;
                        }
                      }
                    } else if ((0, _util2.isArrayBuffer)(input)) {
                      data = input.slice();
                      length = data.byteLength;
                    } else {
                      throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                    }
                    const blockCounts = length >> 2;
                    const tailLength = length - blockCounts * 4;
                    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                    let k1 = 0, k2 = 0;
                    let h1 = this.h1, h2 = this.h2;
                    const C1 = 3432918353, C2 = 461845907;
                    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                    for (let i = 0; i < blockCounts; i++) {
                      if (i & 1) {
                        k1 = dataUint32[i];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        h1 ^= k1;
                        h1 = h1 << 13 | h1 >>> 19;
                        h1 = h1 * 5 + 3864292196;
                      } else {
                        k2 = dataUint32[i];
                        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                        k2 = k2 << 15 | k2 >>> 17;
                        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                        h2 ^= k2;
                        h2 = h2 << 13 | h2 >>> 19;
                        h2 = h2 * 5 + 3864292196;
                      }
                    }
                    k1 = 0;
                    switch (tailLength) {
                      case 3:
                        k1 ^= data[blockCounts * 4 + 2] << 16;
                      case 2:
                        k1 ^= data[blockCounts * 4 + 1] << 8;
                      case 1:
                        k1 ^= data[blockCounts * 4];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        if (blockCounts & 1) {
                          h1 ^= k1;
                        } else {
                          h2 ^= k1;
                        }
                    }
                    this.h1 = h1;
                    this.h2 = h2;
                  }
                  hexdigest() {
                    let h1 = this.h1, h2 = this.h2;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                  }
                }
                exports2.MurmurHash3_64 = MurmurHash3_64;
              },
              /* 10 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.CanvasGraphics = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _pattern_helper = __w_pdfjs_require__2(11);
                var _image_utils = __w_pdfjs_require__2(12);
                var _is_node2 = __w_pdfjs_require__2(3);
                var _display_utils2 = __w_pdfjs_require__2(5);
                const MIN_FONT_SIZE = 16;
                const MAX_FONT_SIZE = 100;
                const MAX_GROUP_SIZE = 4096;
                const EXECUTION_TIME = 15;
                const EXECUTION_STEPS = 10;
                const COMPILE_TYPE3_GLYPHS = true;
                const MAX_SIZE_TO_COMPILE = 1e3;
                const FULL_CHUNK_HEIGHT = 16;
                const LINEWIDTH_SCALE_FACTOR = 1.000001;
                function mirrorContextOperations(ctx, destCtx) {
                  if (ctx._removeMirroring) {
                    throw new Error("Context is already forwarding operations.");
                  }
                  ctx.__originalSave = ctx.save;
                  ctx.__originalRestore = ctx.restore;
                  ctx.__originalRotate = ctx.rotate;
                  ctx.__originalScale = ctx.scale;
                  ctx.__originalTranslate = ctx.translate;
                  ctx.__originalTransform = ctx.transform;
                  ctx.__originalSetTransform = ctx.setTransform;
                  ctx.__originalResetTransform = ctx.resetTransform;
                  ctx.__originalClip = ctx.clip;
                  ctx.__originalMoveTo = ctx.moveTo;
                  ctx.__originalLineTo = ctx.lineTo;
                  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                  ctx.__originalRect = ctx.rect;
                  ctx.__originalClosePath = ctx.closePath;
                  ctx.__originalBeginPath = ctx.beginPath;
                  ctx._removeMirroring = () => {
                    ctx.save = ctx.__originalSave;
                    ctx.restore = ctx.__originalRestore;
                    ctx.rotate = ctx.__originalRotate;
                    ctx.scale = ctx.__originalScale;
                    ctx.translate = ctx.__originalTranslate;
                    ctx.transform = ctx.__originalTransform;
                    ctx.setTransform = ctx.__originalSetTransform;
                    ctx.resetTransform = ctx.__originalResetTransform;
                    ctx.clip = ctx.__originalClip;
                    ctx.moveTo = ctx.__originalMoveTo;
                    ctx.lineTo = ctx.__originalLineTo;
                    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                    ctx.rect = ctx.__originalRect;
                    ctx.closePath = ctx.__originalClosePath;
                    ctx.beginPath = ctx.__originalBeginPath;
                    delete ctx._removeMirroring;
                  };
                  ctx.save = function ctxSave() {
                    destCtx.save();
                    this.__originalSave();
                  };
                  ctx.restore = function ctxRestore() {
                    destCtx.restore();
                    this.__originalRestore();
                  };
                  ctx.translate = function ctxTranslate(x, y) {
                    destCtx.translate(x, y);
                    this.__originalTranslate(x, y);
                  };
                  ctx.scale = function ctxScale(x, y) {
                    destCtx.scale(x, y);
                    this.__originalScale(x, y);
                  };
                  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                    destCtx.transform(a, b, c, d, e, f);
                    this.__originalTransform(a, b, c, d, e, f);
                  };
                  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                    destCtx.setTransform(a, b, c, d, e, f);
                    this.__originalSetTransform(a, b, c, d, e, f);
                  };
                  ctx.resetTransform = function ctxResetTransform() {
                    destCtx.resetTransform();
                    this.__originalResetTransform();
                  };
                  ctx.rotate = function ctxRotate(angle) {
                    destCtx.rotate(angle);
                    this.__originalRotate(angle);
                  };
                  ctx.clip = function ctxRotate(rule) {
                    destCtx.clip(rule);
                    this.__originalClip(rule);
                  };
                  ctx.moveTo = function(x, y) {
                    destCtx.moveTo(x, y);
                    this.__originalMoveTo(x, y);
                  };
                  ctx.lineTo = function(x, y) {
                    destCtx.lineTo(x, y);
                    this.__originalLineTo(x, y);
                  };
                  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  };
                  ctx.rect = function(x, y, width, height) {
                    destCtx.rect(x, y, width, height);
                    this.__originalRect(x, y, width, height);
                  };
                  ctx.closePath = function() {
                    destCtx.closePath();
                    this.__originalClosePath();
                  };
                  ctx.beginPath = function() {
                    destCtx.beginPath();
                    this.__originalBeginPath();
                  };
                }
                function addContextCurrentTransform(ctx) {
                  if (ctx._transformStack) {
                    ctx._transformStack = [];
                  }
                  if (ctx.mozCurrentTransform) {
                    return;
                  }
                  ctx._originalSave = ctx.save;
                  ctx._originalRestore = ctx.restore;
                  ctx._originalRotate = ctx.rotate;
                  ctx._originalScale = ctx.scale;
                  ctx._originalTranslate = ctx.translate;
                  ctx._originalTransform = ctx.transform;
                  ctx._originalSetTransform = ctx.setTransform;
                  ctx._originalResetTransform = ctx.resetTransform;
                  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                  ctx._transformStack = [];
                  try {
                    const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
                    ctx._setLineWidth = desc.set;
                    ctx._getLineWidth = desc.get;
                    Object.defineProperty(ctx, "lineWidth", {
                      set: function setLineWidth(width) {
                        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
                      },
                      get: function getLineWidth() {
                        return this._getLineWidth();
                      }
                    });
                  } catch (_) {
                  }
                  Object.defineProperty(ctx, "mozCurrentTransform", {
                    get: function getCurrentTransform() {
                      return this._transformMatrix;
                    }
                  });
                  Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                    get: function getCurrentTransformInverse() {
                      const [a, b, c, d, e, f] = this._transformMatrix;
                      const ad_bc = a * d - b * c;
                      const bc_ad = b * c - a * d;
                      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                    }
                  });
                  ctx.save = function ctxSave() {
                    const old = this._transformMatrix;
                    this._transformStack.push(old);
                    this._transformMatrix = old.slice(0, 6);
                    this._originalSave();
                  };
                  ctx.restore = function ctxRestore() {
                    if (this._transformStack.length === 0) {
                      (0, _util2.warn)("Tried to restore a ctx when the stack was already empty.");
                    }
                    const prev = this._transformStack.pop();
                    if (prev) {
                      this._transformMatrix = prev;
                      this._originalRestore();
                    }
                  };
                  ctx.translate = function ctxTranslate(x, y) {
                    const m = this._transformMatrix;
                    m[4] = m[0] * x + m[2] * y + m[4];
                    m[5] = m[1] * x + m[3] * y + m[5];
                    this._originalTranslate(x, y);
                  };
                  ctx.scale = function ctxScale(x, y) {
                    const m = this._transformMatrix;
                    m[0] *= x;
                    m[1] *= x;
                    m[2] *= y;
                    m[3] *= y;
                    this._originalScale(x, y);
                  };
                  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                    const m = this._transformMatrix;
                    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                    ctx._originalTransform(a, b, c, d, e, f);
                  };
                  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                    this._transformMatrix = [a, b, c, d, e, f];
                    ctx._originalSetTransform(a, b, c, d, e, f);
                  };
                  ctx.resetTransform = function ctxResetTransform() {
                    this._transformMatrix = [1, 0, 0, 1, 0, 0];
                    ctx._originalResetTransform();
                  };
                  ctx.rotate = function ctxRotate(angle) {
                    const cosValue = Math.cos(angle);
                    const sinValue = Math.sin(angle);
                    const m = this._transformMatrix;
                    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                    this._originalRotate(angle);
                  };
                }
                class CachedCanvases {
                  constructor(canvasFactory) {
                    this.canvasFactory = canvasFactory;
                    this.cache = /* @__PURE__ */ Object.create(null);
                  }
                  getCanvas(id2, width, height, trackTransform) {
                    let canvasEntry;
                    if (this.cache[id2] !== void 0) {
                      canvasEntry = this.cache[id2];
                      this.canvasFactory.reset(canvasEntry, width, height);
                      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                    } else {
                      canvasEntry = this.canvasFactory.create(width, height);
                      this.cache[id2] = canvasEntry;
                    }
                    if (trackTransform) {
                      addContextCurrentTransform(canvasEntry.context);
                    }
                    return canvasEntry;
                  }
                  delete(id2) {
                    delete this.cache[id2];
                  }
                  clear() {
                    for (const id2 in this.cache) {
                      const canvasEntry = this.cache[id2];
                      this.canvasFactory.destroy(canvasEntry);
                      delete this.cache[id2];
                    }
                  }
                }
                function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                  const [a, b, c, d, tx, ty] = ctx.mozCurrentTransform;
                  if (b === 0 && c === 0) {
                    const tlX = destX * a + tx;
                    const rTlX = Math.round(tlX);
                    const tlY = destY * d + ty;
                    const rTlY = Math.round(tlY);
                    const brX = (destX + destW) * a + tx;
                    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                    const brY = (destY + destH) * d + ty;
                    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                    ctx.setTransform(a, b, c, d, tx, ty);
                    return [rWidth, rHeight];
                  }
                  if (a === 0 && d === 0) {
                    const tlX = destY * c + tx;
                    const rTlX = Math.round(tlX);
                    const tlY = destX * b + ty;
                    const rTlY = Math.round(tlY);
                    const brX = (destY + destH) * c + tx;
                    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                    const brY = (destX + destW) * b + ty;
                    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                    ctx.setTransform(a, b, c, d, tx, ty);
                    return [rHeight, rWidth];
                  }
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                  const scaleX = Math.hypot(a, b);
                  const scaleY = Math.hypot(c, d);
                  return [scaleX * destW, scaleY * destH];
                }
                function compileType3Glyph(imgData) {
                  const {
                    width,
                    height
                  } = imgData;
                  if (!COMPILE_TYPE3_GLYPHS || width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                    return null;
                  }
                  const POINT_TO_PROCESS_LIMIT = 1e3;
                  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                  const width1 = width + 1;
                  let points = new Uint8Array(width1 * (height + 1));
                  let i, j, j0;
                  const lineSize = width + 7 & ~7;
                  let data = new Uint8Array(lineSize * height), pos = 0;
                  for (const elem of imgData.data) {
                    let mask = 128;
                    while (mask > 0) {
                      data[pos++] = elem & mask ? 0 : 255;
                      mask >>= 1;
                    }
                  }
                  let count = 0;
                  pos = 0;
                  if (data[pos] !== 0) {
                    points[0] = 1;
                    ++count;
                  }
                  for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                      points[j] = data[pos] ? 2 : 1;
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos] !== 0) {
                    points[j] = 2;
                    ++count;
                  }
                  for (i = 1; i < height; i++) {
                    pos = i * lineSize;
                    j0 = i * width1;
                    if (data[pos - lineSize] !== data[pos]) {
                      points[j0] = data[pos] ? 1 : 8;
                      ++count;
                    }
                    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                    for (j = 1; j < width; j++) {
                      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                      if (POINT_TYPES[sum]) {
                        points[j0 + j] = POINT_TYPES[sum];
                        ++count;
                      }
                      pos++;
                    }
                    if (data[pos - lineSize] !== data[pos]) {
                      points[j0 + j] = data[pos] ? 2 : 4;
                      ++count;
                    }
                    if (count > POINT_TO_PROCESS_LIMIT) {
                      return null;
                    }
                  }
                  pos = lineSize * (height - 1);
                  j0 = i * width1;
                  if (data[pos] !== 0) {
                    points[j0] = 8;
                    ++count;
                  }
                  for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                      points[j0 + j] = data[pos] ? 4 : 8;
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos] !== 0) {
                    points[j0 + j] = 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                  let path, outlines, coords;
                  if (!_is_node2.isNodeJS) {
                    path = new Path2D();
                  } else {
                    outlines = [];
                  }
                  for (i = 0; count && i <= height; i++) {
                    let p = i * width1;
                    const end = p + width;
                    while (p < end && !points[p]) {
                      p++;
                    }
                    if (p === end) {
                      continue;
                    }
                    if (path) {
                      path.moveTo(p % width1, i);
                    } else {
                      coords = [p % width1, i];
                    }
                    const p0 = p;
                    let type = points[p];
                    do {
                      const step = steps[type];
                      do {
                        p += step;
                      } while (!points[p]);
                      const pp = points[p];
                      if (pp !== 5 && pp !== 10) {
                        type = pp;
                        points[p] = 0;
                      } else {
                        type = pp & 51 * type >> 4;
                        points[p] &= type >> 2 | type << 2;
                      }
                      if (path) {
                        path.lineTo(p % width1, p / width1 | 0);
                      } else {
                        coords.push(p % width1, p / width1 | 0);
                      }
                      if (!points[p]) {
                        --count;
                      }
                    } while (p0 !== p);
                    if (!path) {
                      outlines.push(coords);
                    }
                    --i;
                  }
                  data = null;
                  points = null;
                  const drawOutline = function(c) {
                    c.save();
                    c.scale(1 / width, -1 / height);
                    c.translate(0, -height);
                    if (path) {
                      c.fill(path);
                    } else {
                      c.beginPath();
                      for (const o of outlines) {
                        c.moveTo(o[0], o[1]);
                        for (let l = 2, ll = o.length; l < ll; l += 2) {
                          c.lineTo(o[l], o[l + 1]);
                        }
                      }
                      c.fill();
                    }
                    c.beginPath();
                    c.restore();
                  };
                  return drawOutline;
                }
                class CanvasExtraState {
                  constructor(width, height) {
                    this.alphaIsShape = false;
                    this.fontSize = 0;
                    this.fontSizeScale = 1;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.textMatrixScale = 1;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textRise = 0;
                    this.fillColor = "#000000";
                    this.strokeColor = "#000000";
                    this.patternFill = false;
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.activeSMask = null;
                    this.transferMaps = null;
                    this.startNewPathAndClipBox([0, 0, width, height]);
                  }
                  clone() {
                    const clone2 = Object.create(this);
                    clone2.clipBox = this.clipBox.slice();
                    return clone2;
                  }
                  setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                  updatePathMinMax(transform, x, y) {
                    [x, y] = _util2.Util.applyTransform([x, y], transform);
                    this.minX = Math.min(this.minX, x);
                    this.minY = Math.min(this.minY, y);
                    this.maxX = Math.max(this.maxX, x);
                    this.maxY = Math.max(this.maxY, y);
                  }
                  updateRectMinMax(transform, rect) {
                    const p1 = _util2.Util.applyTransform(rect, transform);
                    const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                    this.minX = Math.min(this.minX, p1[0], p2[0]);
                    this.minY = Math.min(this.minY, p1[1], p2[1]);
                    this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                    this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                  }
                  updateScalingPathMinMax(transform, minMax) {
                    _util2.Util.scaleMinMax(transform, minMax);
                    this.minX = Math.min(this.minX, minMax[0]);
                    this.maxX = Math.max(this.maxX, minMax[1]);
                    this.minY = Math.min(this.minY, minMax[2]);
                    this.maxY = Math.max(this.maxY, minMax[3]);
                  }
                  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                    const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                    if (minMax) {
                      minMax[0] = Math.min(minMax[0], box[0], box[2]);
                      minMax[1] = Math.max(minMax[1], box[0], box[2]);
                      minMax[2] = Math.min(minMax[2], box[1], box[3]);
                      minMax[3] = Math.max(minMax[3], box[1], box[3]);
                      return;
                    }
                    this.updateRectMinMax(transform, box);
                  }
                  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                    const box = [this.minX, this.minY, this.maxX, this.maxY];
                    if (pathType === _pattern_helper.PathType.STROKE) {
                      if (!transform) {
                        (0, _util2.unreachable)("Stroke bounding box must include transform.");
                      }
                      const scale = _util2.Util.singularValueDecompose2dScale(transform);
                      const xStrokePad = scale[0] * this.lineWidth / 2;
                      const yStrokePad = scale[1] * this.lineWidth / 2;
                      box[0] -= xStrokePad;
                      box[1] -= yStrokePad;
                      box[2] += xStrokePad;
                      box[3] += yStrokePad;
                    }
                    return box;
                  }
                  updateClipFromPath() {
                    const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                  }
                  isEmptyClip() {
                    return this.minX === Infinity;
                  }
                  startNewPathAndClipBox(box) {
                    this.clipBox = box;
                    this.minX = Infinity;
                    this.minY = Infinity;
                    this.maxX = 0;
                    this.maxY = 0;
                  }
                  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                    return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                  }
                }
                function putBinaryImageData(ctx, imgData, transferMaps = null) {
                  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                    ctx.putImageData(imgData, 0, 0);
                    return;
                  }
                  const height = imgData.height, width = imgData.width;
                  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                  let srcPos = 0, destPos;
                  const src = imgData.data;
                  const dest = chunkImgData.data;
                  let i, j, thisChunkHeight, elemsInThisChunk;
                  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                  if (transferMaps) {
                    switch (transferMaps.length) {
                      case 1:
                        transferMapRed = transferMaps[0];
                        transferMapGreen = transferMaps[0];
                        transferMapBlue = transferMaps[0];
                        transferMapGray = transferMaps[0];
                        break;
                      case 4:
                        transferMapRed = transferMaps[0];
                        transferMapGreen = transferMaps[1];
                        transferMapBlue = transferMaps[2];
                        transferMapGray = transferMaps[3];
                        break;
                    }
                  }
                  if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                    const srcLength = src.byteLength;
                    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                    const dest32DataLength = dest32.length;
                    const fullSrcDiff = width + 7 >> 3;
                    let white = 4294967295;
                    let black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                    if (transferMapGray) {
                      if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                        [white, black] = [black, white];
                      }
                    }
                    for (i = 0; i < totalChunks; i++) {
                      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                      destPos = 0;
                      for (j = 0; j < thisChunkHeight; j++) {
                        const srcDiff = srcLength - srcPos;
                        let k = 0;
                        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                        const kEndUnrolled = kEnd & ~7;
                        let mask = 0;
                        let srcByte = 0;
                        for (; k < kEndUnrolled; k += 8) {
                          srcByte = src[srcPos++];
                          dest32[destPos++] = srcByte & 128 ? white : black;
                          dest32[destPos++] = srcByte & 64 ? white : black;
                          dest32[destPos++] = srcByte & 32 ? white : black;
                          dest32[destPos++] = srcByte & 16 ? white : black;
                          dest32[destPos++] = srcByte & 8 ? white : black;
                          dest32[destPos++] = srcByte & 4 ? white : black;
                          dest32[destPos++] = srcByte & 2 ? white : black;
                          dest32[destPos++] = srcByte & 1 ? white : black;
                        }
                        for (; k < kEnd; k++) {
                          if (mask === 0) {
                            srcByte = src[srcPos++];
                            mask = 128;
                          }
                          dest32[destPos++] = srcByte & mask ? white : black;
                          mask >>= 1;
                        }
                      }
                      while (destPos < dest32DataLength) {
                        dest32[destPos++] = 0;
                      }
                      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                    }
                  } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                    j = 0;
                    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                    for (i = 0; i < fullChunks; i++) {
                      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                      srcPos += elemsInThisChunk;
                      if (hasTransferMaps) {
                        for (let k = 0; k < elemsInThisChunk; k += 4) {
                          if (transferMapRed) {
                            dest[k + 0] = transferMapRed[dest[k + 0]];
                          }
                          if (transferMapGreen) {
                            dest[k + 1] = transferMapGreen[dest[k + 1]];
                          }
                          if (transferMapBlue) {
                            dest[k + 2] = transferMapBlue[dest[k + 2]];
                          }
                        }
                      }
                      ctx.putImageData(chunkImgData, 0, j);
                      j += FULL_CHUNK_HEIGHT;
                    }
                    if (i < totalChunks) {
                      elemsInThisChunk = width * partialChunkHeight * 4;
                      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                      if (hasTransferMaps) {
                        for (let k = 0; k < elemsInThisChunk; k += 4) {
                          if (transferMapRed) {
                            dest[k + 0] = transferMapRed[dest[k + 0]];
                          }
                          if (transferMapGreen) {
                            dest[k + 1] = transferMapGreen[dest[k + 1]];
                          }
                          if (transferMapBlue) {
                            dest[k + 2] = transferMapBlue[dest[k + 2]];
                          }
                        }
                      }
                      ctx.putImageData(chunkImgData, 0, j);
                    }
                  } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                    thisChunkHeight = FULL_CHUNK_HEIGHT;
                    elemsInThisChunk = width * thisChunkHeight;
                    for (i = 0; i < totalChunks; i++) {
                      if (i >= fullChunks) {
                        thisChunkHeight = partialChunkHeight;
                        elemsInThisChunk = width * thisChunkHeight;
                      }
                      destPos = 0;
                      for (j = elemsInThisChunk; j--; ) {
                        dest[destPos++] = src[srcPos++];
                        dest[destPos++] = src[srcPos++];
                        dest[destPos++] = src[srcPos++];
                        dest[destPos++] = 255;
                      }
                      if (hasTransferMaps) {
                        for (let k = 0; k < destPos; k += 4) {
                          if (transferMapRed) {
                            dest[k + 0] = transferMapRed[dest[k + 0]];
                          }
                          if (transferMapGreen) {
                            dest[k + 1] = transferMapGreen[dest[k + 1]];
                          }
                          if (transferMapBlue) {
                            dest[k + 2] = transferMapBlue[dest[k + 2]];
                          }
                        }
                      }
                      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                    }
                  } else {
                    throw new Error(`bad image kind: ${imgData.kind}`);
                  }
                }
                function putBinaryImageMask(ctx, imgData) {
                  if (imgData.bitmap) {
                    ctx.drawImage(imgData.bitmap, 0, 0);
                    return;
                  }
                  const height = imgData.height, width = imgData.width;
                  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                  let srcPos = 0;
                  const src = imgData.data;
                  const dest = chunkImgData.data;
                  for (let i = 0; i < totalChunks; i++) {
                    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    ({
                      srcPos
                    } = (0, _image_utils.applyMaskImageData)({
                      src,
                      srcPos,
                      dest,
                      width,
                      height: thisChunkHeight
                    }));
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                }
                function copyCtxState(sourceCtx, destCtx) {
                  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                  for (let i = 0, ii = properties.length; i < ii; i++) {
                    const property = properties[i];
                    if (sourceCtx[property] !== void 0) {
                      destCtx[property] = sourceCtx[property];
                    }
                  }
                  if (sourceCtx.setLineDash !== void 0) {
                    destCtx.setLineDash(sourceCtx.getLineDash());
                    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                  }
                }
                function resetCtxToDefault(ctx, foregroundColor) {
                  ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                  ctx.fillRule = "nonzero";
                  ctx.globalAlpha = 1;
                  ctx.lineWidth = 1;
                  ctx.lineCap = "butt";
                  ctx.lineJoin = "miter";
                  ctx.miterLimit = 10;
                  ctx.globalCompositeOperation = "source-over";
                  ctx.font = "10px sans-serif";
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash([]);
                    ctx.lineDashOffset = 0;
                  }
                }
                function composeSMaskBackdrop(bytes, r0, g0, b0) {
                  const length = bytes.length;
                  for (let i = 3; i < length; i += 4) {
                    const alpha = bytes[i];
                    if (alpha === 0) {
                      bytes[i - 3] = r0;
                      bytes[i - 2] = g0;
                      bytes[i - 1] = b0;
                    } else if (alpha < 255) {
                      const alpha_ = 255 - alpha;
                      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                    }
                  }
                }
                function composeSMaskAlpha(maskData, layerData, transferMap) {
                  const length = maskData.length;
                  const scale = 1 / 255;
                  for (let i = 3; i < length; i += 4) {
                    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                    layerData[i] = layerData[i] * alpha * scale | 0;
                  }
                }
                function composeSMaskLuminosity(maskData, layerData, transferMap) {
                  const length = maskData.length;
                  for (let i = 3; i < length; i += 4) {
                    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                  }
                }
                function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                  const hasBackdrop = !!backdrop;
                  const r0 = hasBackdrop ? backdrop[0] : 0;
                  const g0 = hasBackdrop ? backdrop[1] : 0;
                  const b0 = hasBackdrop ? backdrop[2] : 0;
                  let composeFn;
                  if (subtype === "Luminosity") {
                    composeFn = composeSMaskLuminosity;
                  } else {
                    composeFn = composeSMaskAlpha;
                  }
                  const PIXELS_TO_PROCESS = 1048576;
                  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                  for (let row = 0; row < height; row += chunkSize) {
                    const chunkHeight = Math.min(chunkSize, height - row);
                    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                    if (hasBackdrop) {
                      composeSMaskBackdrop(maskData.data, r0, g0, b0);
                    }
                    composeFn(maskData.data, layerData.data, transferMap);
                    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                  }
                }
                function composeSMask(ctx, smask, layerCtx, layerBox) {
                  const layerOffsetX = layerBox[0];
                  const layerOffsetY = layerBox[1];
                  const layerWidth = layerBox[2] - layerOffsetX;
                  const layerHeight = layerBox[3] - layerOffsetY;
                  if (layerWidth === 0 || layerHeight === 0) {
                    return;
                  }
                  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                  ctx.save();
                  ctx.globalAlpha = 1;
                  ctx.globalCompositeOperation = "source-over";
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(layerCtx.canvas, 0, 0);
                  ctx.restore();
                }
                function getImageSmoothingEnabled(transform, interpolate) {
                  const scale = _util2.Util.singularValueDecompose2dScale(transform);
                  scale[0] = Math.fround(scale[0]);
                  scale[1] = Math.fround(scale[1]);
                  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                  if (interpolate !== void 0) {
                    return interpolate;
                  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                    return true;
                  }
                  return false;
                }
                const LINE_CAP_STYLES = ["butt", "round", "square"];
                const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                const NORMAL_CLIP = {};
                const EO_CLIP = {};
                class CanvasGraphics {
                  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                    this.ctx = canvasCtx;
                    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                    this.stateStack = [];
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.res = null;
                    this.xobjs = null;
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.canvasFactory = canvasFactory;
                    this.imageLayer = imageLayer;
                    this.groupStack = [];
                    this.processingType3 = null;
                    this.baseTransform = null;
                    this.baseTransformStack = [];
                    this.groupLevel = 0;
                    this.smaskStack = [];
                    this.smaskCounter = 0;
                    this.tempSMask = null;
                    this.suspendedCtx = null;
                    this.contentVisible = true;
                    this.markedContentStack = [];
                    this.optionalContentConfig = optionalContentConfig;
                    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                    this.cachedPatterns = /* @__PURE__ */ new Map();
                    this.annotationCanvasMap = annotationCanvasMap;
                    this.viewportScale = 1;
                    this.outputScaleX = 1;
                    this.outputScaleY = 1;
                    this.backgroundColor = (pageColors == null ? void 0 : pageColors.background) || null;
                    this.foregroundColor = (pageColors == null ? void 0 : pageColors.foreground) || null;
                    if (canvasCtx) {
                      addContextCurrentTransform(canvasCtx);
                    }
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                  }
                  getObject(data, fallback = null) {
                    if (typeof data === "string") {
                      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                    }
                    return fallback;
                  }
                  beginDrawing({
                    transform,
                    viewport,
                    transparency = false,
                    background = null
                  }) {
                    const width = this.ctx.canvas.width;
                    const height = this.ctx.canvas.height;
                    const defaultBackgroundColor = background || "#ffffff";
                    this.ctx.save();
                    if (this.foregroundColor && this.backgroundColor) {
                      this.ctx.fillStyle = this.foregroundColor;
                      const fg = this.foregroundColor = this.ctx.fillStyle;
                      this.ctx.fillStyle = this.backgroundColor;
                      const bg = this.backgroundColor = this.ctx.fillStyle;
                      let isValidDefaultBg = true;
                      let defaultBg = defaultBackgroundColor;
                      this.ctx.fillStyle = defaultBackgroundColor;
                      defaultBg = this.ctx.fillStyle;
                      isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                      if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                        this.foregroundColor = this.backgroundColor = null;
                      } else {
                        const cB = parseInt(defaultBg.slice(1), 16);
                        const rB = (cB && 16711680) >> 16;
                        const gB = (cB && 65280) >> 8;
                        const bB = cB && 255;
                        const newComp = (x) => {
                          x /= 255;
                          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                        };
                        const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                        this.selectColor = (r, g, b) => {
                          const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                          return Math.round(lumC) === lumB ? bg : fg;
                        };
                      }
                    }
                    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                    this.ctx.fillRect(0, 0, width, height);
                    this.ctx.restore();
                    if (transparency) {
                      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                      this.compositeCtx = this.ctx;
                      this.transparentCanvas = transparentCanvas.canvas;
                      this.ctx = transparentCanvas.context;
                      this.ctx.save();
                      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                    }
                    this.ctx.save();
                    resetCtxToDefault(this.ctx, this.foregroundColor);
                    if (transform) {
                      this.ctx.transform.apply(this.ctx, transform);
                      this.outputScaleX = transform[0];
                      this.outputScaleY = transform[0];
                    }
                    this.ctx.transform.apply(this.ctx, viewport.transform);
                    this.viewportScale = viewport.scale;
                    this.baseTransform = this.ctx.mozCurrentTransform.slice();
                    if (this.imageLayer) {
                      this.imageLayer.beginLayout();
                    }
                  }
                  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                    const argsArray = operatorList.argsArray;
                    const fnArray = operatorList.fnArray;
                    let i = executionStartIdx || 0;
                    const argsArrayLen = argsArray.length;
                    if (argsArrayLen === i) {
                      return i;
                    }
                    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                    let steps = 0;
                    const commonObjs = this.commonObjs;
                    const objs = this.objs;
                    let fnId;
                    while (true) {
                      if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                        stepper.breakIt(i, continueCallback);
                        return i;
                      }
                      fnId = fnArray[i];
                      if (fnId !== _util2.OPS.dependency) {
                        this[fnId].apply(this, argsArray[i]);
                      } else {
                        for (const depObjId of argsArray[i]) {
                          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                          if (!objsPool.has(depObjId)) {
                            objsPool.get(depObjId, continueCallback);
                            return i;
                          }
                        }
                      }
                      i++;
                      if (i === argsArrayLen) {
                        return i;
                      }
                      if (chunkOperations && ++steps > EXECUTION_STEPS) {
                        if (Date.now() > endTime) {
                          continueCallback();
                          return i;
                        }
                        steps = 0;
                      }
                    }
                  }
                  endDrawing() {
                    while (this.stateStack.length || this.inSMaskMode) {
                      this.restore();
                    }
                    this.ctx.restore();
                    if (this.transparentCanvas) {
                      this.ctx = this.compositeCtx;
                      this.ctx.save();
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.drawImage(this.transparentCanvas, 0, 0);
                      this.ctx.restore();
                      this.transparentCanvas = null;
                    }
                    this.cachedCanvases.clear();
                    this.cachedPatterns.clear();
                    for (const cache of this._cachedBitmapsMap.values()) {
                      for (const canvas of cache.values()) {
                        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                          canvas.width = canvas.height = 0;
                        }
                      }
                      cache.clear();
                    }
                    this._cachedBitmapsMap.clear();
                    if (this.imageLayer) {
                      this.imageLayer.endLayout();
                    }
                  }
                  _scaleImage(img, inverseTransform) {
                    const width = img.width;
                    const height = img.height;
                    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                    let paintWidth = width, paintHeight = height;
                    let tmpCanvasId = "prescale1";
                    let tmpCanvas, tmpCtx;
                    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                      let newWidth = paintWidth, newHeight = paintHeight;
                      if (widthScale > 2 && paintWidth > 1) {
                        newWidth = Math.ceil(paintWidth / 2);
                        widthScale /= paintWidth / newWidth;
                      }
                      if (heightScale > 2 && paintHeight > 1) {
                        newHeight = Math.ceil(paintHeight / 2);
                        heightScale /= paintHeight / newHeight;
                      }
                      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight, false);
                      tmpCtx = tmpCanvas.context;
                      tmpCtx.clearRect(0, 0, newWidth, newHeight);
                      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                      img = tmpCanvas.canvas;
                      paintWidth = newWidth;
                      paintHeight = newHeight;
                      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                    }
                    return {
                      img,
                      paintWidth,
                      paintHeight
                    };
                  }
                  _createMaskCanvas(img) {
                    const ctx = this.ctx;
                    const {
                      width,
                      height
                    } = img;
                    const fillColor = this.current.fillColor;
                    const isPatternFill = this.current.patternFill;
                    const currentTransform = ctx.mozCurrentTransform;
                    let cache, cacheKey, scaled, maskCanvas;
                    if ((img.bitmap || img.data) && img.count > 1) {
                      const mainKey = img.bitmap || img.data.buffer;
                      const withoutTranslation = currentTransform.slice(0, 4);
                      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                      cache = this._cachedBitmapsMap.get(mainKey);
                      if (!cache) {
                        cache = /* @__PURE__ */ new Map();
                        this._cachedBitmapsMap.set(mainKey, cache);
                      }
                      const cachedImage = cache.get(cacheKey);
                      if (cachedImage && !isPatternFill) {
                        const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                        const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                        return {
                          canvas: cachedImage,
                          offsetX: offsetX2,
                          offsetY: offsetY2
                        };
                      }
                      scaled = cachedImage;
                    }
                    if (!scaled) {
                      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
                      putBinaryImageMask(maskCanvas.context, img);
                    }
                    let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                    maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                    const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                    const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                    const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
                    const fillCtx = fillCanvas.context;
                    const offsetX = Math.min(cord1[0], cord2[0]);
                    const offsetY = Math.min(cord1[1], cord2[1]);
                    fillCtx.translate(-offsetX, -offsetY);
                    fillCtx.transform.apply(fillCtx, maskToCanvas);
                    if (!scaled) {
                      scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);
                      scaled = scaled.img;
                      if (cache && isPatternFill) {
                        cache.set(cacheKey, scaled);
                      }
                    }
                    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
                    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                    fillCtx.globalCompositeOperation = "source-in";
                    const inverse = _util2.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);
                    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                    fillCtx.fillRect(0, 0, width, height);
                    if (cache && !isPatternFill) {
                      this.cachedCanvases.delete("fillCanvas");
                      cache.set(cacheKey, fillCanvas.canvas);
                    }
                    return {
                      canvas: fillCanvas.canvas,
                      offsetX: Math.round(offsetX),
                      offsetY: Math.round(offsetY)
                    };
                  }
                  setLineWidth(width) {
                    if (width !== this.current.lineWidth) {
                      this._cachedScaleForStroking = null;
                    }
                    this.current.lineWidth = width;
                    this.ctx.lineWidth = width;
                  }
                  setLineCap(style) {
                    this.ctx.lineCap = LINE_CAP_STYLES[style];
                  }
                  setLineJoin(style) {
                    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                  }
                  setMiterLimit(limit) {
                    this.ctx.miterLimit = limit;
                  }
                  setDash(dashArray, dashPhase) {
                    const ctx = this.ctx;
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash(dashArray);
                      ctx.lineDashOffset = dashPhase;
                    }
                  }
                  setRenderingIntent(intent) {
                  }
                  setFlatness(flatness) {
                  }
                  setGState(states) {
                    for (let i = 0, ii = states.length; i < ii; i++) {
                      const state = states[i];
                      const key = state[0];
                      const value = state[1];
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value);
                          break;
                        case "FL":
                          this.setFlatness(value);
                          break;
                        case "Font":
                          this.setFont(value[0], value[1]);
                          break;
                        case "CA":
                          this.current.strokeAlpha = state[1];
                          break;
                        case "ca":
                          this.current.fillAlpha = state[1];
                          this.ctx.globalAlpha = state[1];
                          break;
                        case "BM":
                          this.ctx.globalCompositeOperation = value;
                          break;
                        case "SMask":
                          this.current.activeSMask = value ? this.tempSMask : null;
                          this.tempSMask = null;
                          this.checkSMaskState();
                          break;
                        case "TR":
                          this.current.transferMaps = value;
                      }
                    }
                  }
                  get inSMaskMode() {
                    return !!this.suspendedCtx;
                  }
                  checkSMaskState() {
                    const inSMaskMode = this.inSMaskMode;
                    if (this.current.activeSMask && !inSMaskMode) {
                      this.beginSMaskMode();
                    } else if (!this.current.activeSMask && inSMaskMode) {
                      this.endSMaskMode();
                    }
                  }
                  beginSMaskMode() {
                    if (this.inSMaskMode) {
                      throw new Error("beginSMaskMode called while already in smask mode");
                    }
                    const drawnWidth = this.ctx.canvas.width;
                    const drawnHeight = this.ctx.canvas.height;
                    const cacheId = "smaskGroupAt" + this.groupLevel;
                    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    this.suspendedCtx = this.ctx;
                    this.ctx = scratchCanvas.context;
                    const ctx = this.ctx;
                    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
                    copyCtxState(this.suspendedCtx, ctx);
                    mirrorContextOperations(ctx, this.suspendedCtx);
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  }
                  endSMaskMode() {
                    if (!this.inSMaskMode) {
                      throw new Error("endSMaskMode called while not in smask mode");
                    }
                    this.ctx._removeMirroring();
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.ctx = this.suspendedCtx;
                    this.suspendedCtx = null;
                  }
                  compose(dirtyBox) {
                    if (!this.current.activeSMask) {
                      return;
                    }
                    if (!dirtyBox) {
                      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                    } else {
                      dirtyBox[0] = Math.floor(dirtyBox[0]);
                      dirtyBox[1] = Math.floor(dirtyBox[1]);
                      dirtyBox[2] = Math.ceil(dirtyBox[2]);
                      dirtyBox[3] = Math.ceil(dirtyBox[3]);
                    }
                    const smask = this.current.activeSMask;
                    const suspendedCtx = this.suspendedCtx;
                    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                    this.ctx.restore();
                  }
                  save() {
                    if (this.inSMaskMode) {
                      copyCtxState(this.ctx, this.suspendedCtx);
                      this.suspendedCtx.save();
                    } else {
                      this.ctx.save();
                    }
                    const old = this.current;
                    this.stateStack.push(old);
                    this.current = old.clone();
                  }
                  restore() {
                    if (this.stateStack.length === 0 && this.inSMaskMode) {
                      this.endSMaskMode();
                    }
                    if (this.stateStack.length !== 0) {
                      this.current = this.stateStack.pop();
                      if (this.inSMaskMode) {
                        this.suspendedCtx.restore();
                        copyCtxState(this.suspendedCtx, this.ctx);
                      } else {
                        this.ctx.restore();
                      }
                      this.checkSMaskState();
                      this.pendingClip = null;
                      this._cachedScaleForStroking = null;
                      this._cachedGetSinglePixelWidth = null;
                    }
                  }
                  transform(a, b, c, d, e, f) {
                    this.ctx.transform(a, b, c, d, e, f);
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                  constructPath(ops, args, minMax) {
                    const ctx = this.ctx;
                    const current = this.current;
                    let x = current.x, y = current.y;
                    let startX, startY;
                    const currentTransform = ctx.mozCurrentTransform;
                    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                      switch (ops[i] | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          const width = args[j++];
                          const height = args[j++];
                          const xw = x + width;
                          const yh = y + height;
                          ctx.moveTo(x, y);
                          if (width === 0 || height === 0) {
                            ctx.lineTo(xw, yh);
                          } else {
                            ctx.lineTo(xw, y);
                            ctx.lineTo(xw, yh);
                            ctx.lineTo(x, yh);
                          }
                          if (!isScalingMatrix) {
                            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                          }
                          ctx.closePath();
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.moveTo(x, y);
                          if (!isScalingMatrix) {
                            current.updatePathMinMax(currentTransform, x, y);
                          }
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.lineTo(x, y);
                          if (!isScalingMatrix) {
                            current.updatePathMinMax(currentTransform, x, y);
                          }
                          break;
                        case _util2.OPS.curveTo:
                          startX = x;
                          startY = y;
                          x = args[j + 4];
                          y = args[j + 5];
                          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          startX = x;
                          startY = y;
                          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          startX = x;
                          startY = y;
                          x = args[j + 2];
                          y = args[j + 3];
                          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          ctx.closePath();
                          break;
                      }
                    }
                    if (isScalingMatrix) {
                      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                    }
                    current.setCurrentPoint(x, y);
                  }
                  closePath() {
                    this.ctx.closePath();
                  }
                  stroke(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    const ctx = this.ctx;
                    const strokeColor = this.current.strokeColor;
                    ctx.globalAlpha = this.current.strokeAlpha;
                    if (this.contentVisible) {
                      if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
                        ctx.save();
                        ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
                        this.rescaleAndStroke(false);
                        ctx.restore();
                      } else {
                        this.rescaleAndStroke(true);
                      }
                    }
                    if (consumePath) {
                      this.consumePath(this.current.getClippedPathBoundingBox());
                    }
                    ctx.globalAlpha = this.current.fillAlpha;
                  }
                  closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                  fill(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    const ctx = this.ctx;
                    const fillColor = this.current.fillColor;
                    const isPatternFill = this.current.patternFill;
                    let needRestore = false;
                    if (isPatternFill) {
                      ctx.save();
                      ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
                      needRestore = true;
                    }
                    const intersect = this.current.getClippedPathBoundingBox();
                    if (this.contentVisible && intersect !== null) {
                      if (this.pendingEOFill) {
                        ctx.fill("evenodd");
                        this.pendingEOFill = false;
                      } else {
                        ctx.fill();
                      }
                    }
                    if (needRestore) {
                      ctx.restore();
                    }
                    if (consumePath) {
                      this.consumePath(intersect);
                    }
                  }
                  eoFill() {
                    this.pendingEOFill = true;
                    this.fill();
                  }
                  fillStroke() {
                    this.fill(false);
                    this.stroke(false);
                    this.consumePath();
                  }
                  eoFillStroke() {
                    this.pendingEOFill = true;
                    this.fillStroke();
                  }
                  closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                  closeEOFillStroke() {
                    this.pendingEOFill = true;
                    this.closePath();
                    this.fillStroke();
                  }
                  endPath() {
                    this.consumePath();
                  }
                  clip() {
                    this.pendingClip = NORMAL_CLIP;
                  }
                  eoClip() {
                    this.pendingClip = EO_CLIP;
                  }
                  beginText() {
                    this.current.textMatrix = _util2.IDENTITY_MATRIX;
                    this.current.textMatrixScale = 1;
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }
                  endText() {
                    const paths = this.pendingTextPaths;
                    const ctx = this.ctx;
                    if (paths === void 0) {
                      ctx.beginPath();
                      return;
                    }
                    ctx.save();
                    ctx.beginPath();
                    for (let i = 0; i < paths.length; i++) {
                      const path = paths[i];
                      ctx.setTransform.apply(ctx, path.transform);
                      ctx.translate(path.x, path.y);
                      path.addToPath(ctx, path.fontSize);
                    }
                    ctx.restore();
                    ctx.clip();
                    ctx.beginPath();
                    delete this.pendingTextPaths;
                  }
                  setCharSpacing(spacing) {
                    this.current.charSpacing = spacing;
                  }
                  setWordSpacing(spacing) {
                    this.current.wordSpacing = spacing;
                  }
                  setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  }
                  setLeading(leading) {
                    this.current.leading = -leading;
                  }
                  setFont(fontRefName, size) {
                    const fontObj = this.commonObjs.get(fontRefName);
                    const current = this.current;
                    if (!fontObj) {
                      throw new Error(`Can't find font for ${fontRefName}`);
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                      (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                    }
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    this.current.font = fontObj;
                    this.current.fontSize = size;
                    if (fontObj.isType3Font) {
                      return;
                    }
                    const name = fontObj.loadedName || "sans-serif";
                    let bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    const italic = fontObj.italic ? "italic" : "normal";
                    const typeface = `"${name}", ${fontObj.fallbackName}`;
                    let browserFontSize = size;
                    if (size < MIN_FONT_SIZE) {
                      browserFontSize = MIN_FONT_SIZE;
                    } else if (size > MAX_FONT_SIZE) {
                      browserFontSize = MAX_FONT_SIZE;
                    }
                    this.current.fontSizeScale = size / browserFontSize;
                    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                  }
                  setTextRenderingMode(mode) {
                    this.current.textRenderingMode = mode;
                  }
                  setTextRise(rise) {
                    this.current.textRise = rise;
                  }
                  moveText(x, y) {
                    this.current.x = this.current.lineX += x;
                    this.current.y = this.current.lineY += y;
                  }
                  setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                  setTextMatrix(a, b, c, d, e, f) {
                    this.current.textMatrix = [a, b, c, d, e, f];
                    this.current.textMatrixScale = Math.hypot(a, b);
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }
                  nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                  paintChar(character, x, y, patternTransform) {
                    const ctx = this.ctx;
                    const current = this.current;
                    const font = current.font;
                    const textRenderingMode = current.textRenderingMode;
                    const fontSize = current.fontSize / current.fontSizeScale;
                    const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                    const patternFill = current.patternFill && !font.missingFile;
                    let addToPath;
                    if (font.disableFontFace || isAddToPathSet || patternFill) {
                      addToPath = font.getPathGenerator(this.commonObjs, character);
                    }
                    if (font.disableFontFace || patternFill) {
                      ctx.save();
                      ctx.translate(x, y);
                      ctx.beginPath();
                      addToPath(ctx, fontSize);
                      if (patternTransform) {
                        ctx.setTransform.apply(ctx, patternTransform);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fill();
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.stroke();
                      }
                      ctx.restore();
                    } else {
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fillText(character, x, y);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.strokeText(character, x, y);
                      }
                    }
                    if (isAddToPathSet) {
                      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                      paths.push({
                        transform: ctx.mozCurrentTransform,
                        x,
                        y,
                        fontSize,
                        addToPath
                      });
                    }
                  }
                  get isFontSubpixelAAEnabled() {
                    const {
                      context: ctx
                    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10, false);
                    ctx.scale(1.5, 1);
                    ctx.fillText("I", 0, 10);
                    const data = ctx.getImageData(0, 0, 10, 10).data;
                    let enabled = false;
                    for (let i = 3; i < data.length; i += 4) {
                      if (data[i] > 0 && data[i] < 255) {
                        enabled = true;
                        break;
                      }
                    }
                    return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                  }
                  showText(glyphs) {
                    const current = this.current;
                    const font = current.font;
                    if (font.isType3Font) {
                      return this.showType3Text(glyphs);
                    }
                    const fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return void 0;
                    }
                    const ctx = this.ctx;
                    const fontSizeScale = current.fontSizeScale;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const fontDirection = current.fontDirection;
                    const textHScale = current.textHScale * fontDirection;
                    const glyphsLength = glyphs.length;
                    const vertical = font.vertical;
                    const spacingDir = vertical ? 1 : -1;
                    const defaultVMetrics = font.defaultVMetrics;
                    const widthAdvanceScale = fontSize * current.fontMatrix[0];
                    const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                    ctx.save();
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y + current.textRise);
                    if (fontDirection > 0) {
                      ctx.scale(textHScale, -1);
                    } else {
                      ctx.scale(textHScale, 1);
                    }
                    let patternTransform;
                    if (current.patternFill) {
                      ctx.save();
                      const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
                      patternTransform = ctx.mozCurrentTransform;
                      ctx.restore();
                      ctx.fillStyle = pattern;
                    }
                    let lineWidth = current.lineWidth;
                    const scale = current.textMatrixScale;
                    if (scale === 0 || lineWidth === 0) {
                      const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        lineWidth = this.getSinglePixelWidth();
                      }
                    } else {
                      lineWidth /= scale;
                    }
                    if (fontSizeScale !== 1) {
                      ctx.scale(fontSizeScale, fontSizeScale);
                      lineWidth /= fontSizeScale;
                    }
                    ctx.lineWidth = lineWidth;
                    let x = 0, i;
                    for (i = 0; i < glyphsLength; ++i) {
                      const glyph = glyphs[i];
                      if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      let restoreNeeded = false;
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const character = glyph.fontChar;
                      const accent = glyph.accent;
                      let scaledX, scaledY;
                      let width = glyph.width;
                      if (vertical) {
                        const vmetric = glyph.vmetric || defaultVMetrics;
                        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                        const vy = vmetric[2] * widthAdvanceScale;
                        width = vmetric ? -vmetric[0] : width;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (font.remeasure && width > 0) {
                        const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                          const characterScaleX = width / measuredWidth;
                          restoreNeeded = true;
                          ctx.save();
                          ctx.scale(characterScaleX, 1);
                          scaledX /= characterScaleX;
                        } else if (width !== measuredWidth) {
                          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                        }
                      }
                      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                        if (simpleFillText && !accent) {
                          ctx.fillText(character, scaledX, scaledY);
                        } else {
                          this.paintChar(character, scaledX, scaledY, patternTransform);
                          if (accent) {
                            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                          }
                        }
                      }
                      let charWidth;
                      if (vertical) {
                        charWidth = width * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                      if (restoreNeeded) {
                        ctx.restore();
                      }
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    ctx.restore();
                    this.compose();
                    return void 0;
                  }
                  showType3Text(glyphs) {
                    const ctx = this.ctx;
                    const current = this.current;
                    const font = current.font;
                    const fontSize = current.fontSize;
                    const fontDirection = current.fontDirection;
                    const spacingDir = font.vertical ? 1 : -1;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const textHScale = current.textHScale * fontDirection;
                    const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    const glyphsLength = glyphs.length;
                    const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                    let i, glyph, width, spacingLength;
                    if (isTextInvisible || fontSize === 0) {
                      return;
                    }
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                    ctx.save();
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y);
                    ctx.scale(textHScale, fontDirection);
                    for (i = 0; i < glyphsLength; ++i) {
                      glyph = glyphs[i];
                      if (typeof glyph === "number") {
                        spacingLength = spacingDir * glyph * fontSize / 1e3;
                        this.ctx.translate(spacingLength, 0);
                        current.x += spacingLength * textHScale;
                        continue;
                      }
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const operatorList = font.charProcOperatorList[glyph.operatorListId];
                      if (!operatorList) {
                        (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                        continue;
                      }
                      if (this.contentVisible) {
                        this.processingType3 = glyph;
                        this.save();
                        ctx.scale(fontSize, fontSize);
                        ctx.transform.apply(ctx, fontMatrix);
                        this.executeOperatorList(operatorList);
                        this.restore();
                      }
                      const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                      width = transformed[0] * fontSize + spacing;
                      ctx.translate(width, 0);
                      current.x += width * textHScale;
                    }
                    ctx.restore();
                    this.processingType3 = null;
                  }
                  setCharWidth(xWidth, yWidth) {
                  }
                  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                    this.ctx.rect(llx, lly, urx - llx, ury - lly);
                    this.ctx.clip();
                    this.endPath();
                  }
                  getColorN_Pattern(IR) {
                    let pattern;
                    if (IR[0] === "TilingPattern") {
                      const color = IR[1];
                      const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                      const canvasGraphicsFactory = {
                        createCanvasGraphics: (ctx) => {
                          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                        }
                      };
                      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                    } else {
                      pattern = this._getPattern(IR[1], IR[2]);
                    }
                    return pattern;
                  }
                  setStrokeColorN() {
                    this.current.strokeColor = this.getColorN_Pattern(arguments);
                  }
                  setFillColorN() {
                    this.current.fillColor = this.getColorN_Pattern(arguments);
                    this.current.patternFill = true;
                  }
                  setStrokeRGBColor(r, g, b) {
                    var _a;
                    const color = ((_a = this.selectColor) == null ? void 0 : _a.call(this, r, g, b)) || _util2.Util.makeHexColor(r, g, b);
                    this.ctx.strokeStyle = color;
                    this.current.strokeColor = color;
                  }
                  setFillRGBColor(r, g, b) {
                    var _a;
                    const color = ((_a = this.selectColor) == null ? void 0 : _a.call(this, r, g, b)) || _util2.Util.makeHexColor(r, g, b);
                    this.ctx.fillStyle = color;
                    this.current.fillColor = color;
                    this.current.patternFill = false;
                  }
                  _getPattern(objId, matrix = null) {
                    let pattern;
                    if (this.cachedPatterns.has(objId)) {
                      pattern = this.cachedPatterns.get(objId);
                    } else {
                      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                      this.cachedPatterns.set(objId, pattern);
                    }
                    if (matrix) {
                      pattern.matrix = matrix;
                    }
                    return pattern;
                  }
                  shadingFill(objId) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const ctx = this.ctx;
                    this.save();
                    const pattern = this._getPattern(objId);
                    ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
                    const inv = ctx.mozCurrentTransformInverse;
                    if (inv) {
                      const canvas = ctx.canvas;
                      const width = canvas.width;
                      const height = canvas.height;
                      const bl = _util2.Util.applyTransform([0, 0], inv);
                      const br = _util2.Util.applyTransform([0, height], inv);
                      const ul = _util2.Util.applyTransform([width, 0], inv);
                      const ur = _util2.Util.applyTransform([width, height], inv);
                      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                    } else {
                      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                    }
                    this.compose(this.current.getClippedPathBoundingBox());
                    this.restore();
                  }
                  beginInlineImage() {
                    (0, _util2.unreachable)("Should not call beginInlineImage");
                  }
                  beginImageData() {
                    (0, _util2.unreachable)("Should not call beginImageData");
                  }
                  paintFormXObjectBegin(matrix, bbox) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.save();
                    this.baseTransformStack.push(this.baseTransform);
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform.apply(this, matrix);
                    }
                    this.baseTransform = this.ctx.mozCurrentTransform;
                    if (bbox) {
                      const width = bbox[2] - bbox[0];
                      const height = bbox[3] - bbox[1];
                      this.ctx.rect(bbox[0], bbox[1], width, height);
                      this.current.updateRectMinMax(this.ctx.mozCurrentTransform, bbox);
                      this.clip();
                      this.endPath();
                    }
                  }
                  paintFormXObjectEnd() {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.restore();
                    this.baseTransform = this.baseTransformStack.pop();
                  }
                  beginGroup(group) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.save();
                    if (this.inSMaskMode) {
                      this.endSMaskMode();
                      this.current.activeSMask = null;
                    }
                    const currentCtx = this.ctx;
                    if (!group.isolated) {
                      (0, _util2.info)("TODO: Support non-isolated groups.");
                    }
                    if (group.knockout) {
                      (0, _util2.warn)("Knockout groups not supported.");
                    }
                    const currentTransform = currentCtx.mozCurrentTransform;
                    if (group.matrix) {
                      currentCtx.transform.apply(currentCtx, group.matrix);
                    }
                    if (!group.bbox) {
                      throw new Error("Bounding box is required.");
                    }
                    let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                    bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                    const offsetX = Math.floor(bounds[0]);
                    const offsetY = Math.floor(bounds[1]);
                    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                    let scaleX = 1, scaleY = 1;
                    if (drawnWidth > MAX_GROUP_SIZE) {
                      scaleX = drawnWidth / MAX_GROUP_SIZE;
                      drawnWidth = MAX_GROUP_SIZE;
                    }
                    if (drawnHeight > MAX_GROUP_SIZE) {
                      scaleY = drawnHeight / MAX_GROUP_SIZE;
                      drawnHeight = MAX_GROUP_SIZE;
                    }
                    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                    let cacheId = "groupAt" + this.groupLevel;
                    if (group.smask) {
                      cacheId += "_smask_" + this.smaskCounter++ % 2;
                    }
                    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    const groupCtx = scratchCanvas.context;
                    groupCtx.scale(1 / scaleX, 1 / scaleY);
                    groupCtx.translate(-offsetX, -offsetY);
                    groupCtx.transform.apply(groupCtx, currentTransform);
                    if (group.smask) {
                      this.smaskStack.push({
                        canvas: scratchCanvas.canvas,
                        context: groupCtx,
                        offsetX,
                        offsetY,
                        scaleX,
                        scaleY,
                        subtype: group.smask.subtype,
                        backdrop: group.smask.backdrop,
                        transferMap: group.smask.transferMap || null,
                        startTransformInverse: null
                      });
                    } else {
                      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                      currentCtx.translate(offsetX, offsetY);
                      currentCtx.scale(scaleX, scaleY);
                      currentCtx.save();
                    }
                    copyCtxState(currentCtx, groupCtx);
                    this.ctx = groupCtx;
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                    this.groupStack.push(currentCtx);
                    this.groupLevel++;
                  }
                  endGroup(group) {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.groupLevel--;
                    const groupCtx = this.ctx;
                    const ctx = this.groupStack.pop();
                    this.ctx = ctx;
                    this.ctx.imageSmoothingEnabled = false;
                    if (group.smask) {
                      this.tempSMask = this.smaskStack.pop();
                      this.restore();
                    } else {
                      this.ctx.restore();
                      const currentMtx = this.ctx.mozCurrentTransform;
                      this.restore();
                      this.ctx.save();
                      this.ctx.setTransform.apply(this.ctx, currentMtx);
                      const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                      this.ctx.drawImage(groupCtx.canvas, 0, 0);
                      this.ctx.restore();
                      this.compose(dirtyBox);
                    }
                  }
                  beginAnnotations() {
                    this.save();
                    if (this.baseTransform) {
                      this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                    }
                  }
                  endAnnotations() {
                    this.restore();
                  }
                  beginAnnotation(id2, rect, transform, matrix, hasOwnCanvas) {
                    this.save();
                    if (Array.isArray(rect) && rect.length === 4) {
                      const width = rect[2] - rect[0];
                      const height = rect[3] - rect[1];
                      if (hasOwnCanvas && this.annotationCanvasMap) {
                        transform = transform.slice();
                        transform[4] -= rect[0];
                        transform[5] -= rect[1];
                        rect = rect.slice();
                        rect[0] = rect[1] = 0;
                        rect[2] = width;
                        rect[3] = height;
                        const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);
                        const {
                          viewportScale
                        } = this;
                        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                        const {
                          canvas,
                          context
                        } = this.annotationCanvas;
                        const viewportScaleFactorStr = `var(--zoom-factor) * ${_display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS}`;
                        canvas.style.width = `calc(${width}px * ${viewportScaleFactorStr})`;
                        canvas.style.height = `calc(${height}px * ${viewportScaleFactorStr})`;
                        this.annotationCanvasMap.set(id2, canvas);
                        this.annotationCanvas.savedCtx = this.ctx;
                        this.ctx = context;
                        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                        addContextCurrentTransform(this.ctx);
                        resetCtxToDefault(this.ctx, this.foregroundColor);
                      } else {
                        resetCtxToDefault(this.ctx, this.foregroundColor);
                        this.ctx.rect(rect[0], rect[1], width, height);
                        this.ctx.clip();
                        this.endPath();
                      }
                    }
                    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                    this.transform.apply(this, transform);
                    this.transform.apply(this, matrix);
                  }
                  endAnnotation() {
                    if (this.annotationCanvas) {
                      this.ctx = this.annotationCanvas.savedCtx;
                      delete this.annotationCanvas.savedCtx;
                      delete this.annotationCanvas;
                    }
                    this.restore();
                  }
                  paintImageMaskXObject(img) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const count = img.count;
                    img = this.getObject(img.data, img);
                    img.count = count;
                    const ctx = this.ctx;
                    const glyph = this.processingType3;
                    if (glyph) {
                      if (glyph.compiled === void 0) {
                        glyph.compiled = compileType3Glyph(img);
                      }
                      if (glyph.compiled) {
                        glyph.compiled(ctx);
                        return;
                      }
                    }
                    const mask = this._createMaskCanvas(img);
                    const maskCanvas = mask.canvas;
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                    ctx.restore();
                    this.compose();
                  }
                  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                    if (!this.contentVisible) {
                      return;
                    }
                    img = this.getObject(img.data, img);
                    const ctx = this.ctx;
                    ctx.save();
                    const currentTransform = ctx.mozCurrentTransform;
                    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                    const mask = this._createMaskCanvas(img);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    for (let i = 0, ii = positions.length; i < ii; i += 2) {
                      const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                      const [x, y] = _util2.Util.applyTransform([0, 0], trans);
                      ctx.drawImage(mask.canvas, x, y);
                    }
                    ctx.restore();
                    this.compose();
                  }
                  paintImageMaskXObjectGroup(images) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const ctx = this.ctx;
                    const fillColor = this.current.fillColor;
                    const isPatternFill = this.current.patternFill;
                    for (let i = 0, ii = images.length; i < ii; i++) {
                      const image = images[i];
                      const width = image.width, height = image.height;
                      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
                      const maskCtx = maskCanvas.context;
                      maskCtx.save();
                      putBinaryImageMask(maskCtx, image);
                      maskCtx.globalCompositeOperation = "source-in";
                      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
                      maskCtx.fillRect(0, 0, width, height);
                      maskCtx.restore();
                      ctx.save();
                      ctx.transform.apply(ctx, image.transform);
                      ctx.scale(1, -1);
                      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                      ctx.restore();
                    }
                    this.compose();
                  }
                  paintImageXObject(objId) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const imgData = this.getObject(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const imgData = this.getObject(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    const width = imgData.width;
                    const height = imgData.height;
                    const map = [];
                    for (let i = 0, ii = positions.length; i < ii; i += 2) {
                      map.push({
                        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                        x: 0,
                        y: 0,
                        w: width,
                        h: height
                      });
                    }
                    this.paintInlineImageXObjectGroup(imgData, map);
                  }
                  paintInlineImageXObject(imgData) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const width = imgData.width;
                    const height = imgData.height;
                    const ctx = this.ctx;
                    this.save();
                    ctx.scale(1 / width, -1 / height);
                    let imgToPaint;
                    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                      imgToPaint = imgData;
                    } else {
                      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height, false);
                      const tmpCtx = tmpCanvas.context;
                      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                      imgToPaint = tmpCanvas.canvas;
                    }
                    const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);
                    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
                    const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                    if (this.imageLayer) {
                      const position = this.getCanvasPosition(0, -height);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: rWidth,
                        height: rHeight
                      });
                    }
                    this.compose();
                    this.restore();
                  }
                  paintInlineImageXObjectGroup(imgData, map) {
                    if (!this.contentVisible) {
                      return;
                    }
                    const ctx = this.ctx;
                    const w = imgData.width;
                    const h = imgData.height;
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h, false);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    for (let i = 0, ii = map.length; i < ii; i++) {
                      const entry = map[i];
                      ctx.save();
                      ctx.transform.apply(ctx, entry.transform);
                      ctx.scale(1, -1);
                      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                      if (this.imageLayer) {
                        const position = this.getCanvasPosition(entry.x, entry.y);
                        this.imageLayer.appendImage({
                          imgData,
                          left: position[0],
                          top: position[1],
                          width: w,
                          height: h
                        });
                      }
                      ctx.restore();
                    }
                    this.compose();
                  }
                  paintSolidColorImageMask() {
                    if (!this.contentVisible) {
                      return;
                    }
                    this.ctx.fillRect(0, 0, 1, 1);
                    this.compose();
                  }
                  markPoint(tag) {
                  }
                  markPointProps(tag, properties) {
                  }
                  beginMarkedContent(tag) {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  beginMarkedContentProps(tag, properties) {
                    if (tag === "OC") {
                      this.markedContentStack.push({
                        visible: this.optionalContentConfig.isVisible(properties)
                      });
                    } else {
                      this.markedContentStack.push({
                        visible: true
                      });
                    }
                    this.contentVisible = this.isContentVisible();
                  }
                  endMarkedContent() {
                    this.markedContentStack.pop();
                    this.contentVisible = this.isContentVisible();
                  }
                  beginCompat() {
                  }
                  endCompat() {
                  }
                  consumePath(clipBox) {
                    const isEmpty = this.current.isEmptyClip();
                    if (this.pendingClip) {
                      this.current.updateClipFromPath();
                    }
                    if (!this.pendingClip) {
                      this.compose(clipBox);
                    }
                    const ctx = this.ctx;
                    if (this.pendingClip) {
                      if (!isEmpty) {
                        if (this.pendingClip === EO_CLIP) {
                          ctx.clip("evenodd");
                        } else {
                          ctx.clip();
                        }
                      }
                      this.pendingClip = null;
                    }
                    this.current.startNewPathAndClipBox(this.current.clipBox);
                    ctx.beginPath();
                  }
                  getSinglePixelWidth() {
                    if (!this._cachedGetSinglePixelWidth) {
                      const m = this.ctx.mozCurrentTransform;
                      if (m[1] === 0 && m[2] === 0) {
                        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                      } else {
                        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                        const normX = Math.hypot(m[0], m[2]);
                        const normY = Math.hypot(m[1], m[3]);
                        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                      }
                    }
                    return this._cachedGetSinglePixelWidth;
                  }
                  getScaleForStroking() {
                    if (!this._cachedScaleForStroking) {
                      const {
                        lineWidth
                      } = this.current;
                      const m = this.ctx.mozCurrentTransform;
                      let scaleX, scaleY;
                      if (m[1] === 0 && m[2] === 0) {
                        const normX = Math.abs(m[0]);
                        const normY = Math.abs(m[3]);
                        if (lineWidth === 0) {
                          scaleX = 1 / normX;
                          scaleY = 1 / normY;
                        } else {
                          const scaledXLineWidth = normX * lineWidth;
                          const scaledYLineWidth = normY * lineWidth;
                          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                        }
                      } else {
                        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                        const normX = Math.hypot(m[0], m[1]);
                        const normY = Math.hypot(m[2], m[3]);
                        if (lineWidth === 0) {
                          scaleX = normY / absDet;
                          scaleY = normX / absDet;
                        } else {
                          const baseArea = lineWidth * absDet;
                          scaleX = normY > baseArea ? normY / baseArea : 1;
                          scaleY = normX > baseArea ? normX / baseArea : 1;
                        }
                      }
                      this._cachedScaleForStroking = [scaleX, scaleY];
                    }
                    return this._cachedScaleForStroking;
                  }
                  rescaleAndStroke(saveRestore) {
                    const {
                      ctx
                    } = this;
                    const {
                      lineWidth
                    } = this.current;
                    const [scaleX, scaleY] = this.getScaleForStroking();
                    ctx.lineWidth = lineWidth || 1;
                    if (scaleX === 1 && scaleY === 1) {
                      ctx.stroke();
                      return;
                    }
                    let savedMatrix, savedDashes, savedDashOffset;
                    if (saveRestore) {
                      savedMatrix = ctx.mozCurrentTransform.slice();
                      savedDashes = ctx.getLineDash().slice();
                      savedDashOffset = ctx.lineDashOffset;
                    }
                    ctx.scale(scaleX, scaleY);
                    const scale = Math.max(scaleX, scaleY);
                    ctx.setLineDash(ctx.getLineDash().map((x) => x / scale));
                    ctx.lineDashOffset /= scale;
                    ctx.stroke();
                    if (saveRestore) {
                      ctx.setTransform(...savedMatrix);
                      ctx.setLineDash(savedDashes);
                      ctx.lineDashOffset = savedDashOffset;
                    }
                  }
                  getCanvasPosition(x, y) {
                    const transform = this.ctx.mozCurrentTransform;
                    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                  }
                  isContentVisible() {
                    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                      if (!this.markedContentStack[i].visible) {
                        return false;
                      }
                    }
                    return true;
                  }
                }
                exports2.CanvasGraphics = CanvasGraphics;
                for (const op in _util2.OPS) {
                  if (CanvasGraphics.prototype[op] !== void 0) {
                    CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                  }
                }
              },
              /* 11 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.TilingPattern = exports2.PathType = void 0;
                exports2.getShadingPattern = getShadingPattern;
                var _util2 = __w_pdfjs_require__2(1);
                var _is_node2 = __w_pdfjs_require__2(3);
                const PathType = {
                  FILL: "Fill",
                  STROKE: "Stroke",
                  SHADING: "Shading"
                };
                exports2.PathType = PathType;
                function applyBoundingBox(ctx, bbox) {
                  if (!bbox || _is_node2.isNodeJS) {
                    return;
                  }
                  const width = bbox[2] - bbox[0];
                  const height = bbox[3] - bbox[1];
                  const region = new Path2D();
                  region.rect(bbox[0], bbox[1], width, height);
                  ctx.clip(region);
                }
                class BaseShadingPattern {
                  constructor() {
                    if (this.constructor === BaseShadingPattern) {
                      (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                    }
                  }
                  getPattern() {
                    (0, _util2.unreachable)("Abstract method `getPattern` called.");
                  }
                }
                class RadialAxialShadingPattern extends BaseShadingPattern {
                  constructor(IR) {
                    super();
                    this._type = IR[1];
                    this._bbox = IR[2];
                    this._colorStops = IR[3];
                    this._p0 = IR[4];
                    this._p1 = IR[5];
                    this._r0 = IR[6];
                    this._r1 = IR[7];
                    this.matrix = null;
                  }
                  _createGradient(ctx) {
                    let grad;
                    if (this._type === "axial") {
                      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                    } else if (this._type === "radial") {
                      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                    }
                    for (const colorStop of this._colorStops) {
                      grad.addColorStop(colorStop[0], colorStop[1]);
                    }
                    return grad;
                  }
                  getPattern(ctx, owner, inverse, pathType) {
                    let pattern;
                    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
                      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                      const tmpCtx = tmpCanvas.context;
                      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                      tmpCtx.beginPath();
                      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                      inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);
                      if (this.matrix) {
                        tmpCtx.transform.apply(tmpCtx, this.matrix);
                      }
                      applyBoundingBox(tmpCtx, this._bbox);
                      tmpCtx.fillStyle = this._createGradient(tmpCtx);
                      tmpCtx.fill();
                      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                      const domMatrix = new DOMMatrix(inverse);
                      try {
                        pattern.setTransform(domMatrix);
                      } catch (ex) {
                        (0, _util2.warn)(`RadialAxialShadingPattern.getPattern: "${ex == null ? void 0 : ex.message}".`);
                      }
                    } else {
                      applyBoundingBox(ctx, this._bbox);
                      pattern = this._createGradient(ctx);
                    }
                    return pattern;
                  }
                }
                function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                  const coords = context.coords, colors = context.colors;
                  const bytes = data.data, rowSize = data.width * 4;
                  let tmp;
                  if (coords[p1 + 1] > coords[p2 + 1]) {
                    tmp = p1;
                    p1 = p2;
                    p2 = tmp;
                    tmp = c1;
                    c1 = c2;
                    c2 = tmp;
                  }
                  if (coords[p2 + 1] > coords[p3 + 1]) {
                    tmp = p2;
                    p2 = p3;
                    p3 = tmp;
                    tmp = c2;
                    c2 = c3;
                    c3 = tmp;
                  }
                  if (coords[p1 + 1] > coords[p2 + 1]) {
                    tmp = p1;
                    p1 = p2;
                    p2 = tmp;
                    tmp = c1;
                    c1 = c2;
                    c2 = tmp;
                  }
                  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                  if (y1 >= y3) {
                    return;
                  }
                  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                  const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                  const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                  const minY = Math.round(y1), maxY = Math.round(y3);
                  let xa, car, cag, cab;
                  let xb, cbr, cbg, cbb;
                  for (let y = minY; y <= maxY; y++) {
                    if (y < y2) {
                      let k2;
                      if (y < y1) {
                        k2 = 0;
                      } else {
                        k2 = (y1 - y) / (y1 - y2);
                      }
                      xa = x1 - (x1 - x2) * k2;
                      car = c1r - (c1r - c2r) * k2;
                      cag = c1g - (c1g - c2g) * k2;
                      cab = c1b - (c1b - c2b) * k2;
                    } else {
                      let k2;
                      if (y > y3) {
                        k2 = 1;
                      } else if (y2 === y3) {
                        k2 = 0;
                      } else {
                        k2 = (y2 - y) / (y2 - y3);
                      }
                      xa = x2 - (x2 - x3) * k2;
                      car = c2r - (c2r - c3r) * k2;
                      cag = c2g - (c2g - c3g) * k2;
                      cab = c2b - (c2b - c3b) * k2;
                    }
                    let k;
                    if (y < y1) {
                      k = 0;
                    } else if (y > y3) {
                      k = 1;
                    } else {
                      k = (y1 - y) / (y1 - y3);
                    }
                    xb = x1 - (x1 - x3) * k;
                    cbr = c1r - (c1r - c3r) * k;
                    cbg = c1g - (c1g - c3g) * k;
                    cbb = c1b - (c1b - c3b) * k;
                    const x1_ = Math.round(Math.min(xa, xb));
                    const x2_ = Math.round(Math.max(xa, xb));
                    let j = rowSize * y + x1_ * 4;
                    for (let x = x1_; x <= x2_; x++) {
                      k = (xa - x) / (xa - xb);
                      if (k < 0) {
                        k = 0;
                      } else if (k > 1) {
                        k = 1;
                      }
                      bytes[j++] = car - (car - cbr) * k | 0;
                      bytes[j++] = cag - (cag - cbg) * k | 0;
                      bytes[j++] = cab - (cab - cbb) * k | 0;
                      bytes[j++] = 255;
                    }
                  }
                }
                function drawFigure(data, figure, context) {
                  const ps = figure.coords;
                  const cs = figure.colors;
                  let i, ii;
                  switch (figure.type) {
                    case "lattice":
                      const verticesPerRow = figure.verticesPerRow;
                      const rows = Math.floor(ps.length / verticesPerRow) - 1;
                      const cols = verticesPerRow - 1;
                      for (i = 0; i < rows; i++) {
                        let q = i * verticesPerRow;
                        for (let j = 0; j < cols; j++, q++) {
                          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                        }
                      }
                      break;
                    case "triangles":
                      for (i = 0, ii = ps.length; i < ii; i += 3) {
                        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                      }
                      break;
                    default:
                      throw new Error("illegal figure");
                  }
                }
                class MeshShadingPattern extends BaseShadingPattern {
                  constructor(IR) {
                    super();
                    this._coords = IR[2];
                    this._colors = IR[3];
                    this._figures = IR[4];
                    this._bounds = IR[5];
                    this._bbox = IR[7];
                    this._background = IR[8];
                    this.matrix = null;
                  }
                  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                    const EXPECTED_SCALE = 1.1;
                    const MAX_PATTERN_SIZE = 3e3;
                    const BORDER_SIZE = 2;
                    const offsetX = Math.floor(this._bounds[0]);
                    const offsetY = Math.floor(this._bounds[1]);
                    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    const scaleX = boundsWidth / width;
                    const scaleY = boundsHeight / height;
                    const context = {
                      coords: this._coords,
                      colors: this._colors,
                      offsetX: -offsetX,
                      offsetY: -offsetY,
                      scaleX: 1 / scaleX,
                      scaleY: 1 / scaleY
                    };
                    const paddedWidth = width + BORDER_SIZE * 2;
                    const paddedHeight = height + BORDER_SIZE * 2;
                    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                    const tmpCtx = tmpCanvas.context;
                    const data = tmpCtx.createImageData(width, height);
                    if (backgroundColor) {
                      const bytes = data.data;
                      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                        bytes[i] = backgroundColor[0];
                        bytes[i + 1] = backgroundColor[1];
                        bytes[i + 2] = backgroundColor[2];
                        bytes[i + 3] = 255;
                      }
                    }
                    for (const figure of this._figures) {
                      drawFigure(data, figure, context);
                    }
                    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                    const canvas = tmpCanvas.canvas;
                    return {
                      canvas,
                      offsetX: offsetX - BORDER_SIZE * scaleX,
                      offsetY: offsetY - BORDER_SIZE * scaleY,
                      scaleX,
                      scaleY
                    };
                  }
                  getPattern(ctx, owner, inverse, pathType) {
                    applyBoundingBox(ctx, this._bbox);
                    let scale;
                    if (pathType === PathType.SHADING) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (this.matrix) {
                        const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                    if (pathType !== PathType.SHADING) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (this.matrix) {
                        ctx.transform.apply(ctx, this.matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                }
                class DummyShadingPattern extends BaseShadingPattern {
                  getPattern() {
                    return "hotpink";
                  }
                }
                function getShadingPattern(IR) {
                  switch (IR[0]) {
                    case "RadialAxial":
                      return new RadialAxialShadingPattern(IR);
                    case "Mesh":
                      return new MeshShadingPattern(IR);
                    case "Dummy":
                      return new DummyShadingPattern();
                  }
                  throw new Error(`Unknown IR type: ${IR[0]}`);
                }
                const PaintType = {
                  COLORED: 1,
                  UNCOLORED: 2
                };
                class TilingPattern {
                  static get MAX_PATTERN_SIZE() {
                    return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                  }
                  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                    this.operatorList = IR[2];
                    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                    this.bbox = IR[4];
                    this.xstep = IR[5];
                    this.ystep = IR[6];
                    this.paintType = IR[7];
                    this.tilingType = IR[8];
                    this.color = color;
                    this.ctx = ctx;
                    this.canvasGraphicsFactory = canvasGraphicsFactory;
                    this.baseTransform = baseTransform;
                  }
                  createPatternCanvas(owner) {
                    const operatorList = this.operatorList;
                    const bbox = this.bbox;
                    const xstep = this.xstep;
                    const ystep = this.ystep;
                    const paintType = this.paintType;
                    const tilingType = this.tilingType;
                    const color = this.color;
                    const canvasGraphicsFactory = this.canvasGraphicsFactory;
                    (0, _util2.info)("TilingType: " + tilingType);
                    const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                    const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                    const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                    const tmpCtx = tmpCanvas.context;
                    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                    graphics.groupLevel = owner.groupLevel;
                    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                    let adjustedX0 = x0;
                    let adjustedY0 = y0;
                    let adjustedX1 = x1;
                    let adjustedY1 = y1;
                    if (x0 < 0) {
                      adjustedX0 = 0;
                      adjustedX1 += Math.abs(x0);
                    }
                    if (y0 < 0) {
                      adjustedY0 = 0;
                      adjustedY1 += Math.abs(y0);
                    }
                    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                    tmpCtx.save();
                    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
                    graphics.executeOperatorList(operatorList);
                    graphics.endDrawing();
                    return {
                      canvas: tmpCanvas.canvas,
                      scaleX: dimx.scale,
                      scaleY: dimy.scale,
                      offsetX: adjustedX0,
                      offsetY: adjustedY0
                    };
                  }
                  getSizeAndScale(step, realOutputSize, scale) {
                    step = Math.abs(step);
                    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                    let size = Math.ceil(step * scale);
                    if (size >= maxSize) {
                      size = maxSize;
                    } else {
                      scale = size / step;
                    }
                    return {
                      scale,
                      size
                    };
                  }
                  clipBbox(graphics, x0, y0, x1, y1) {
                    const bboxWidth = x1 - x0;
                    const bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.current.updateRectMinMax(graphics.ctx.mozCurrentTransform, [x0, y0, x1, y1]);
                    graphics.clip();
                    graphics.endPath();
                  }
                  setFillAndStrokeStyleToContext(graphics, paintType, color) {
                    const context = graphics.ctx, current = graphics.current;
                    switch (paintType) {
                      case PaintType.COLORED:
                        const ctx = this.ctx;
                        context.fillStyle = ctx.fillStyle;
                        context.strokeStyle = ctx.strokeStyle;
                        current.fillColor = ctx.fillStyle;
                        current.strokeColor = ctx.strokeStyle;
                        break;
                      case PaintType.UNCOLORED:
                        const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                        context.fillStyle = cssColor;
                        context.strokeStyle = cssColor;
                        current.fillColor = cssColor;
                        current.strokeColor = cssColor;
                        break;
                      default:
                        throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                    }
                  }
                  getPattern(ctx, owner, inverse, pathType) {
                    let matrix = inverse;
                    if (pathType !== PathType.SHADING) {
                      matrix = _util2.Util.transform(matrix, owner.baseTransform);
                      if (this.matrix) {
                        matrix = _util2.Util.transform(matrix, this.matrix);
                      }
                    }
                    const temporaryPatternCanvas = this.createPatternCanvas(owner);
                    let domMatrix = new DOMMatrix(matrix);
                    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)(`TilingPattern.getPattern: "${ex == null ? void 0 : ex.message}".`);
                    }
                    return pattern;
                  }
                }
                exports2.TilingPattern = TilingPattern;
              },
              /* 12 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.applyMaskImageData = applyMaskImageData;
                var _util2 = __w_pdfjs_require__2(1);
                function applyMaskImageData({
                  src,
                  srcPos = 0,
                  dest,
                  destPos = 0,
                  width,
                  height,
                  inverseDecode = false
                }) {
                  const opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                  const widthInSource = width >> 3;
                  const widthRemainder = width & 7;
                  const srcLength = src.length;
                  dest = new Uint32Array(dest.buffer);
                  for (let i = 0; i < height; i++) {
                    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
                      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                    }
                    if (widthRemainder === 0) {
                      continue;
                    }
                    const elem = srcPos < srcLength ? src[srcPos++] : 255;
                    for (let j = 0; j < widthRemainder; j++) {
                      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                    }
                  }
                  return {
                    srcPos,
                    destPos
                  };
                }
              },
              /* 13 */
              /***/
              (__unused_webpack_module2, exports2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.GlobalWorkerOptions = void 0;
                const GlobalWorkerOptions2 = /* @__PURE__ */ Object.create(null);
                exports2.GlobalWorkerOptions = GlobalWorkerOptions2;
                GlobalWorkerOptions2.workerPort = GlobalWorkerOptions2.workerPort === void 0 ? null : GlobalWorkerOptions2.workerPort;
                GlobalWorkerOptions2.workerSrc = GlobalWorkerOptions2.workerSrc === void 0 ? "" : GlobalWorkerOptions2.workerSrc;
              },
              /* 14 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.MessageHandler = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                const CallbackKind = {
                  UNKNOWN: 0,
                  DATA: 1,
                  ERROR: 2
                };
                const StreamKind = {
                  UNKNOWN: 0,
                  CANCEL: 1,
                  CANCEL_COMPLETE: 2,
                  CLOSE: 3,
                  ENQUEUE: 4,
                  ERROR: 5,
                  PULL: 6,
                  PULL_COMPLETE: 7,
                  START_COMPLETE: 8
                };
                function wrapReason(reason) {
                  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                    (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                  }
                  switch (reason.name) {
                    case "AbortException":
                      return new _util2.AbortException(reason.message);
                    case "MissingPDFException":
                      return new _util2.MissingPDFException(reason.message);
                    case "PasswordException":
                      return new _util2.PasswordException(reason.message, reason.code);
                    case "UnexpectedResponseException":
                      return new _util2.UnexpectedResponseException(reason.message, reason.status);
                    case "UnknownErrorException":
                      return new _util2.UnknownErrorException(reason.message, reason.details);
                    default:
                      return new _util2.UnknownErrorException(reason.message, reason.toString());
                  }
                }
                class MessageHandler {
                  constructor(sourceName, targetName, comObj) {
                    this.sourceName = sourceName;
                    this.targetName = targetName;
                    this.comObj = comObj;
                    this.callbackId = 1;
                    this.streamId = 1;
                    this.streamSinks = /* @__PURE__ */ Object.create(null);
                    this.streamControllers = /* @__PURE__ */ Object.create(null);
                    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                    this.actionHandler = /* @__PURE__ */ Object.create(null);
                    this._onComObjOnMessage = (event) => {
                      const data = event.data;
                      if (data.targetName !== this.sourceName) {
                        return;
                      }
                      if (data.stream) {
                        this._processStreamMessage(data);
                        return;
                      }
                      if (data.callback) {
                        const callbackId = data.callbackId;
                        const capability = this.callbackCapabilities[callbackId];
                        if (!capability) {
                          throw new Error(`Cannot resolve callback ${callbackId}`);
                        }
                        delete this.callbackCapabilities[callbackId];
                        if (data.callback === CallbackKind.DATA) {
                          capability.resolve(data.data);
                        } else if (data.callback === CallbackKind.ERROR) {
                          capability.reject(wrapReason(data.reason));
                        } else {
                          throw new Error("Unexpected callback case");
                        }
                        return;
                      }
                      const action = this.actionHandler[data.action];
                      if (!action) {
                        throw new Error(`Unknown action from worker: ${data.action}`);
                      }
                      if (data.callbackId) {
                        const cbSourceName = this.sourceName;
                        const cbTargetName = data.sourceName;
                        new Promise(function(resolve) {
                          resolve(action(data.data));
                        }).then(function(result) {
                          comObj.postMessage({
                            sourceName: cbSourceName,
                            targetName: cbTargetName,
                            callback: CallbackKind.DATA,
                            callbackId: data.callbackId,
                            data: result
                          });
                        }, function(reason) {
                          comObj.postMessage({
                            sourceName: cbSourceName,
                            targetName: cbTargetName,
                            callback: CallbackKind.ERROR,
                            callbackId: data.callbackId,
                            reason: wrapReason(reason)
                          });
                        });
                        return;
                      }
                      if (data.streamId) {
                        this._createStreamSink(data);
                        return;
                      }
                      action(data.data);
                    };
                    comObj.addEventListener("message", this._onComObjOnMessage);
                  }
                  on(actionName, handler) {
                    const ah = this.actionHandler;
                    if (ah[actionName]) {
                      throw new Error(`There is already an actionName called "${actionName}"`);
                    }
                    ah[actionName] = handler;
                  }
                  send(actionName, data, transfers) {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      data
                    }, transfers);
                  }
                  sendWithPromise(actionName, data, transfers) {
                    const callbackId = this.callbackId++;
                    const capability = (0, _util2.createPromiseCapability)();
                    this.callbackCapabilities[callbackId] = capability;
                    try {
                      this.comObj.postMessage({
                        sourceName: this.sourceName,
                        targetName: this.targetName,
                        action: actionName,
                        callbackId,
                        data
                      }, transfers);
                    } catch (ex) {
                      capability.reject(ex);
                    }
                    return capability.promise;
                  }
                  sendWithStream(actionName, data, queueingStrategy, transfers) {
                    const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                    return new ReadableStream({
                      start: (controller) => {
                        const startCapability = (0, _util2.createPromiseCapability)();
                        this.streamControllers[streamId] = {
                          controller,
                          startCall: startCapability,
                          pullCall: null,
                          cancelCall: null,
                          isClosed: false
                        };
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          action: actionName,
                          streamId,
                          data,
                          desiredSize: controller.desiredSize
                        }, transfers);
                        return startCapability.promise;
                      },
                      pull: (controller) => {
                        const pullCapability = (0, _util2.createPromiseCapability)();
                        this.streamControllers[streamId].pullCall = pullCapability;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL,
                          streamId,
                          desiredSize: controller.desiredSize
                        });
                        return pullCapability.promise;
                      },
                      cancel: (reason) => {
                        (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                        const cancelCapability = (0, _util2.createPromiseCapability)();
                        this.streamControllers[streamId].cancelCall = cancelCapability;
                        this.streamControllers[streamId].isClosed = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL,
                          streamId,
                          reason: wrapReason(reason)
                        });
                        return cancelCapability.promise;
                      }
                    }, queueingStrategy);
                  }
                  _createStreamSink(data) {
                    const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                    const self2 = this, action = this.actionHandler[data.action];
                    const streamSink = {
                      enqueue(chunk, size = 1, transfers) {
                        if (this.isCancelled) {
                          return;
                        }
                        const lastDesiredSize = this.desiredSize;
                        this.desiredSize -= size;
                        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                          this.sinkCapability = (0, _util2.createPromiseCapability)();
                          this.ready = this.sinkCapability.promise;
                        }
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.ENQUEUE,
                          streamId,
                          chunk
                        }, transfers);
                      },
                      close() {
                        if (this.isCancelled) {
                          return;
                        }
                        this.isCancelled = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CLOSE,
                          streamId
                        });
                        delete self2.streamSinks[streamId];
                      },
                      error(reason) {
                        (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                        if (this.isCancelled) {
                          return;
                        }
                        this.isCancelled = true;
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.ERROR,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      },
                      sinkCapability: (0, _util2.createPromiseCapability)(),
                      onPull: null,
                      onCancel: null,
                      isCancelled: false,
                      desiredSize: data.desiredSize,
                      ready: null
                    };
                    streamSink.sinkCapability.resolve();
                    streamSink.ready = streamSink.sinkCapability.promise;
                    this.streamSinks[streamId] = streamSink;
                    new Promise(function(resolve) {
                      resolve(action(data.data, streamSink));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.START_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.START_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                  }
                  _processStreamMessage(data) {
                    const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                    const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                    switch (data.stream) {
                      case StreamKind.START_COMPLETE:
                        if (data.success) {
                          streamController.startCall.resolve();
                        } else {
                          streamController.startCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL_COMPLETE:
                        if (data.success) {
                          streamController.pullCall.resolve();
                        } else {
                          streamController.pullCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL:
                        if (!streamSink) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            success: true
                          });
                          break;
                        }
                        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                          streamSink.sinkCapability.resolve();
                        }
                        streamSink.desiredSize = data.desiredSize;
                        new Promise(function(resolve) {
                          resolve(streamSink.onPull && streamSink.onPull());
                        }).then(function() {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            success: true
                          });
                        }, function(reason) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.PULL_COMPLETE,
                            streamId,
                            reason: wrapReason(reason)
                          });
                        });
                        break;
                      case StreamKind.ENQUEUE:
                        (0, _util2.assert)(streamController, "enqueue should have stream controller");
                        if (streamController.isClosed) {
                          break;
                        }
                        streamController.controller.enqueue(data.chunk);
                        break;
                      case StreamKind.CLOSE:
                        (0, _util2.assert)(streamController, "close should have stream controller");
                        if (streamController.isClosed) {
                          break;
                        }
                        streamController.isClosed = true;
                        streamController.controller.close();
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.ERROR:
                        (0, _util2.assert)(streamController, "error should have stream controller");
                        streamController.controller.error(wrapReason(data.reason));
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.CANCEL_COMPLETE:
                        if (data.success) {
                          streamController.cancelCall.resolve();
                        } else {
                          streamController.cancelCall.reject(wrapReason(data.reason));
                        }
                        this._deleteStreamController(streamController, streamId);
                        break;
                      case StreamKind.CANCEL:
                        if (!streamSink) {
                          break;
                        }
                        new Promise(function(resolve) {
                          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                        }).then(function() {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.CANCEL_COMPLETE,
                            streamId,
                            success: true
                          });
                        }, function(reason) {
                          comObj.postMessage({
                            sourceName,
                            targetName,
                            stream: StreamKind.CANCEL_COMPLETE,
                            streamId,
                            reason: wrapReason(reason)
                          });
                        });
                        streamSink.sinkCapability.reject(wrapReason(data.reason));
                        streamSink.isCancelled = true;
                        delete this.streamSinks[streamId];
                        break;
                      default:
                        throw new Error("Unexpected stream case");
                    }
                  }
                  async _deleteStreamController(streamController, streamId) {
                    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                    delete this.streamControllers[streamId];
                  }
                  destroy() {
                    this.comObj.removeEventListener("message", this._onComObjOnMessage);
                  }
                }
                exports2.MessageHandler = MessageHandler;
              },
              /* 15 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                var _metadataMap, _data;
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.Metadata = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                class Metadata {
                  constructor({
                    parsedData,
                    rawData
                  }) {
                    __privateAdd(this, _metadataMap, void 0);
                    __privateAdd(this, _data, void 0);
                    __privateSet(this, _metadataMap, parsedData);
                    __privateSet(this, _data, rawData);
                  }
                  getRaw() {
                    return __privateGet(this, _data);
                  }
                  get(name) {
                    return __privateGet(this, _metadataMap).get(name) ?? null;
                  }
                  getAll() {
                    return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                  }
                  has(name) {
                    return __privateGet(this, _metadataMap).has(name);
                  }
                }
                _metadataMap = new WeakMap();
                _data = new WeakMap();
                exports2.Metadata = Metadata;
              },
              /* 16 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.OptionalContentConfig = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                class OptionalContentGroup {
                  constructor(name, intent) {
                    this.visible = true;
                    this.name = name;
                    this.intent = intent;
                  }
                }
                class OptionalContentConfig {
                  constructor(data) {
                    this.name = null;
                    this.creator = null;
                    this._order = null;
                    this._groups = /* @__PURE__ */ new Map();
                    if (data === null) {
                      return;
                    }
                    this.name = data.name;
                    this.creator = data.creator;
                    this._order = data.order;
                    for (const group of data.groups) {
                      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
                    }
                    if (data.baseState === "OFF") {
                      for (const group of this._groups) {
                        group.visible = false;
                      }
                    }
                    for (const on of data.on) {
                      this._groups.get(on).visible = true;
                    }
                    for (const off of data.off) {
                      this._groups.get(off).visible = false;
                    }
                  }
                  _evaluateVisibilityExpression(array) {
                    const length = array.length;
                    if (length < 2) {
                      return true;
                    }
                    const operator = array[0];
                    for (let i = 1; i < length; i++) {
                      const element = array[i];
                      let state;
                      if (Array.isArray(element)) {
                        state = this._evaluateVisibilityExpression(element);
                      } else if (this._groups.has(element)) {
                        state = this._groups.get(element).visible;
                      } else {
                        (0, _util2.warn)(`Optional content group not found: ${element}`);
                        return true;
                      }
                      switch (operator) {
                        case "And":
                          if (!state) {
                            return false;
                          }
                          break;
                        case "Or":
                          if (state) {
                            return true;
                          }
                          break;
                        case "Not":
                          return !state;
                        default:
                          return true;
                      }
                    }
                    return operator === "And";
                  }
                  isVisible(group) {
                    if (this._groups.size === 0) {
                      return true;
                    }
                    if (!group) {
                      (0, _util2.warn)("Optional content group not defined.");
                      return true;
                    }
                    if (group.type === "OCG") {
                      if (!this._groups.has(group.id)) {
                        (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                        return true;
                      }
                      return this._groups.get(group.id).visible;
                    } else if (group.type === "OCMD") {
                      if (group.expression) {
                        return this._evaluateVisibilityExpression(group.expression);
                      }
                      if (!group.policy || group.policy === "AnyOn") {
                        for (const id2 of group.ids) {
                          if (!this._groups.has(id2)) {
                            (0, _util2.warn)(`Optional content group not found: ${id2}`);
                            return true;
                          }
                          if (this._groups.get(id2).visible) {
                            return true;
                          }
                        }
                        return false;
                      } else if (group.policy === "AllOn") {
                        for (const id2 of group.ids) {
                          if (!this._groups.has(id2)) {
                            (0, _util2.warn)(`Optional content group not found: ${id2}`);
                            return true;
                          }
                          if (!this._groups.get(id2).visible) {
                            return false;
                          }
                        }
                        return true;
                      } else if (group.policy === "AnyOff") {
                        for (const id2 of group.ids) {
                          if (!this._groups.has(id2)) {
                            (0, _util2.warn)(`Optional content group not found: ${id2}`);
                            return true;
                          }
                          if (!this._groups.get(id2).visible) {
                            return true;
                          }
                        }
                        return false;
                      } else if (group.policy === "AllOff") {
                        for (const id2 of group.ids) {
                          if (!this._groups.has(id2)) {
                            (0, _util2.warn)(`Optional content group not found: ${id2}`);
                            return true;
                          }
                          if (this._groups.get(id2).visible) {
                            return false;
                          }
                        }
                        return true;
                      }
                      (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                      return true;
                    }
                    (0, _util2.warn)(`Unknown group type ${group.type}.`);
                    return true;
                  }
                  setVisibility(id2, visible = true) {
                    if (!this._groups.has(id2)) {
                      (0, _util2.warn)(`Optional content group not found: ${id2}`);
                      return;
                    }
                    this._groups.get(id2).visible = !!visible;
                  }
                  getOrder() {
                    if (!this._groups.size) {
                      return null;
                    }
                    if (this._order) {
                      return this._order.slice();
                    }
                    return Array.from(this._groups.keys());
                  }
                  getGroups() {
                    return this._groups.size > 0 ? (0, _util2.objectFromMap)(this._groups) : null;
                  }
                  getGroup(id2) {
                    return this._groups.get(id2) || null;
                  }
                }
                exports2.OptionalContentConfig = OptionalContentConfig;
              },
              /* 17 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.PDFDataTransportStream = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _display_utils2 = __w_pdfjs_require__2(5);
                class PDFDataTransportStream {
                  constructor(params, pdfDataRangeTransport) {
                    (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                    this._queuedChunks = [];
                    this._progressiveDone = params.progressiveDone || false;
                    this._contentDispositionFilename = params.contentDispositionFilename || null;
                    const initialData = params.initialData;
                    if ((initialData == null ? void 0 : initialData.length) > 0) {
                      const buffer = new Uint8Array(initialData).buffer;
                      this._queuedChunks.push(buffer);
                    }
                    this._pdfDataRangeTransport = pdfDataRangeTransport;
                    this._isStreamingSupported = !params.disableStream;
                    this._isRangeSupported = !params.disableRange;
                    this._contentLength = params.length;
                    this._fullRequestReader = null;
                    this._rangeReaders = [];
                    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                      this._onReceiveData({
                        begin,
                        chunk
                      });
                    });
                    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                      this._onProgress({
                        loaded,
                        total
                      });
                    });
                    this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                      this._onReceiveData({
                        chunk
                      });
                    });
                    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                      this._onProgressiveDone();
                    });
                    this._pdfDataRangeTransport.transportReady();
                  }
                  _onReceiveData(args) {
                    const buffer = new Uint8Array(args.chunk).buffer;
                    if (args.begin === void 0) {
                      if (this._fullRequestReader) {
                        this._fullRequestReader._enqueue(buffer);
                      } else {
                        this._queuedChunks.push(buffer);
                      }
                    } else {
                      const found = this._rangeReaders.some(function(rangeReader) {
                        if (rangeReader._begin !== args.begin) {
                          return false;
                        }
                        rangeReader._enqueue(buffer);
                        return true;
                      });
                      (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                    }
                  }
                  get _progressiveDataLength() {
                    var _a;
                    return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                  }
                  _onProgress(evt) {
                    if (evt.total === void 0) {
                      const firstReader = this._rangeReaders[0];
                      if (firstReader == null ? void 0 : firstReader.onProgress) {
                        firstReader.onProgress({
                          loaded: evt.loaded
                        });
                      }
                    } else {
                      const fullReader = this._fullRequestReader;
                      if (fullReader == null ? void 0 : fullReader.onProgress) {
                        fullReader.onProgress({
                          loaded: evt.loaded,
                          total: evt.total
                        });
                      }
                    }
                  }
                  _onProgressiveDone() {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.progressiveDone();
                    }
                    this._progressiveDone = true;
                  }
                  _removeRangeReader(reader) {
                    const i = this._rangeReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeReaders.splice(i, 1);
                    }
                  }
                  getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                    const queuedChunks = this._queuedChunks;
                    this._queuedChunks = null;
                    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                  }
                  getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                    this._pdfDataRangeTransport.requestDataRange(begin, end);
                    this._rangeReaders.push(reader);
                    return reader;
                  }
                  cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    for (const reader of this._rangeReaders.slice(0)) {
                      reader.cancel(reason);
                    }
                    this._pdfDataRangeTransport.abort();
                  }
                }
                exports2.PDFDataTransportStream = PDFDataTransportStream;
                class PDFDataTransportStreamReader {
                  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                    this._stream = stream;
                    this._done = progressiveDone || false;
                    this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                    this._queuedChunks = queuedChunks || [];
                    this._loaded = 0;
                    for (const chunk of this._queuedChunks) {
                      this._loaded += chunk.byteLength;
                    }
                    this._requests = [];
                    this._headersReady = Promise.resolve();
                    stream._fullRequestReader = this;
                    this.onProgress = null;
                  }
                  _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: chunk,
                        done: false
                      });
                    } else {
                      this._queuedChunks.push(chunk);
                    }
                    this._loaded += chunk.byteLength;
                  }
                  get headersReady() {
                    return this._headersReady;
                  }
                  get filename() {
                    return this._filename;
                  }
                  get isRangeSupported() {
                    return this._stream._isRangeSupported;
                  }
                  get isStreamingSupported() {
                    return this._stream._isStreamingSupported;
                  }
                  get contentLength() {
                    return this._stream._contentLength;
                  }
                  async read() {
                    if (this._queuedChunks.length > 0) {
                      const chunk = this._queuedChunks.shift();
                      return {
                        value: chunk,
                        done: false
                      };
                    }
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    const requestCapability = (0, _util2.createPromiseCapability)();
                    this._requests.push(requestCapability);
                    return requestCapability.promise;
                  }
                  cancel(reason) {
                    this._done = true;
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  progressiveDone() {
                    if (this._done) {
                      return;
                    }
                    this._done = true;
                  }
                }
                class PDFDataTransportStreamRangeReader {
                  constructor(stream, begin, end) {
                    this._stream = stream;
                    this._begin = begin;
                    this._end = end;
                    this._queuedChunk = null;
                    this._requests = [];
                    this._done = false;
                    this.onProgress = null;
                  }
                  _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length === 0) {
                      this._queuedChunk = chunk;
                    } else {
                      const requestsCapability = this._requests.shift();
                      requestsCapability.resolve({
                        value: chunk,
                        done: false
                      });
                      for (const requestCapability of this._requests) {
                        requestCapability.resolve({
                          value: void 0,
                          done: true
                        });
                      }
                      this._requests.length = 0;
                    }
                    this._done = true;
                    this._stream._removeRangeReader(this);
                  }
                  get isStreamingSupported() {
                    return false;
                  }
                  async read() {
                    if (this._queuedChunk) {
                      const chunk = this._queuedChunk;
                      this._queuedChunk = null;
                      return {
                        value: chunk,
                        done: false
                      };
                    }
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    const requestCapability = (0, _util2.createPromiseCapability)();
                    this._requests.push(requestCapability);
                    return requestCapability.promise;
                  }
                  cancel(reason) {
                    this._done = true;
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                    this._stream._removeRangeReader(this);
                  }
                }
              },
              /* 18 */
              /***/
              (__unused_webpack_module2, exports2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.XfaText = void 0;
                class XfaText {
                  static textContent(xfa) {
                    const items = [];
                    const output = {
                      items,
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    function walk(node) {
                      var _a;
                      if (!node) {
                        return;
                      }
                      let str = null;
                      const name = node.name;
                      if (name === "#text") {
                        str = node.value;
                      } else if (!XfaText.shouldBuildText(name)) {
                        return;
                      } else if ((_a = node == null ? void 0 : node.attributes) == null ? void 0 : _a.textContent) {
                        str = node.attributes.textContent;
                      } else if (node.value) {
                        str = node.value;
                      }
                      if (str !== null) {
                        items.push({
                          str
                        });
                      }
                      if (!node.children) {
                        return;
                      }
                      for (const child of node.children) {
                        walk(child);
                      }
                    }
                    walk(xfa);
                    return output;
                  }
                  static shouldBuildText(name) {
                    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                  }
                }
                exports2.XfaText = XfaText;
              },
              /* 19 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
                var _base_factory = __w_pdfjs_require__2(6);
                ;
                const fetchData = function(url) {
                  return new Promise((resolve, reject) => {
                    const fs = require_fs();
                    fs.readFile(url, (error, data) => {
                      if (error || !data) {
                        reject(new Error(error));
                        return;
                      }
                      resolve(new Uint8Array(data));
                    });
                  });
                };
                class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                  _createCanvas(width, height) {
                    const Canvas = require_canvas();
                    return Canvas.createCanvas(width, height);
                  }
                }
                exports2.NodeCanvasFactory = NodeCanvasFactory;
                class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                  _fetchData(url, compressionType) {
                    return fetchData(url).then((data) => {
                      return {
                        cMapData: data,
                        compressionType
                      };
                    });
                  }
                }
                exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
                class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                  _fetchData(url) {
                    return fetchData(url);
                  }
                }
                exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
              },
              /* 20 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                var _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.AnnotationLayer = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _display_utils2 = __w_pdfjs_require__2(5);
                var _annotation_storage2 = __w_pdfjs_require__2(8);
                var _scripting_utils = __w_pdfjs_require__2(21);
                var _xfa_layer = __w_pdfjs_require__2(22);
                const DEFAULT_TAB_INDEX = 1e3;
                const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
                function getRectDims(rect) {
                  return {
                    width: rect[2] - rect[0],
                    height: rect[3] - rect[1]
                  };
                }
                class AnnotationElementFactory {
                  static create(parameters) {
                    const subtype = parameters.data.annotationType;
                    switch (subtype) {
                      case _util2.AnnotationType.LINK:
                        return new LinkAnnotationElement(parameters);
                      case _util2.AnnotationType.TEXT:
                        return new TextAnnotationElement(parameters);
                      case _util2.AnnotationType.WIDGET:
                        const fieldType = parameters.data.fieldType;
                        switch (fieldType) {
                          case "Tx":
                            return new TextWidgetAnnotationElement(parameters);
                          case "Btn":
                            if (parameters.data.radioButton) {
                              return new RadioButtonWidgetAnnotationElement(parameters);
                            } else if (parameters.data.checkBox) {
                              return new CheckboxWidgetAnnotationElement(parameters);
                            }
                            return new PushButtonWidgetAnnotationElement(parameters);
                          case "Ch":
                            return new ChoiceWidgetAnnotationElement(parameters);
                        }
                        return new WidgetAnnotationElement(parameters);
                      case _util2.AnnotationType.POPUP:
                        return new PopupAnnotationElement(parameters);
                      case _util2.AnnotationType.FREETEXT:
                        return new FreeTextAnnotationElement(parameters);
                      case _util2.AnnotationType.LINE:
                        return new LineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUARE:
                        return new SquareAnnotationElement(parameters);
                      case _util2.AnnotationType.CIRCLE:
                        return new CircleAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYLINE:
                        return new PolylineAnnotationElement(parameters);
                      case _util2.AnnotationType.CARET:
                        return new CaretAnnotationElement(parameters);
                      case _util2.AnnotationType.INK:
                        return new InkAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYGON:
                        return new PolygonAnnotationElement(parameters);
                      case _util2.AnnotationType.HIGHLIGHT:
                        return new HighlightAnnotationElement(parameters);
                      case _util2.AnnotationType.UNDERLINE:
                        return new UnderlineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUIGGLY:
                        return new SquigglyAnnotationElement(parameters);
                      case _util2.AnnotationType.STRIKEOUT:
                        return new StrikeOutAnnotationElement(parameters);
                      case _util2.AnnotationType.STAMP:
                        return new StampAnnotationElement(parameters);
                      case _util2.AnnotationType.FILEATTACHMENT:
                        return new FileAttachmentAnnotationElement(parameters);
                      default:
                        return new AnnotationElement(parameters);
                    }
                  }
                }
                class AnnotationElement {
                  constructor(parameters, {
                    isRenderable = false,
                    ignoreBorder = false,
                    createQuadrilaterals = false
                  } = {}) {
                    this.isRenderable = isRenderable;
                    this.data = parameters.data;
                    this.layer = parameters.layer;
                    this.page = parameters.page;
                    this.viewport = parameters.viewport;
                    this.linkService = parameters.linkService;
                    this.downloadManager = parameters.downloadManager;
                    this.imageResourcesPath = parameters.imageResourcesPath;
                    this.renderForms = parameters.renderForms;
                    this.svgFactory = parameters.svgFactory;
                    this.annotationStorage = parameters.annotationStorage;
                    this.enableScripting = parameters.enableScripting;
                    this.hasJSActions = parameters.hasJSActions;
                    this._fieldObjects = parameters.fieldObjects;
                    this._mouseState = parameters.mouseState;
                    if (isRenderable) {
                      this.container = this._createContainer(ignoreBorder);
                    }
                    if (createQuadrilaterals) {
                      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                    }
                  }
                  _createContainer(ignoreBorder = false) {
                    const data = this.data, page = this.page, viewport = this.viewport;
                    const container = document.createElement("section");
                    let {
                      width,
                      height
                    } = getRectDims(data.rect);
                    container.setAttribute("data-annotation-id", data.id);
                    const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                    if (data.hasOwnCanvas) {
                      const transform = viewport.transform.slice();
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale(transform);
                      width = Math.ceil(width * scaleX);
                      height = Math.ceil(height * scaleY);
                      rect[0] *= scaleX;
                      rect[1] *= scaleY;
                      for (let i = 0; i < 4; i++) {
                        transform[i] = Math.sign(transform[i]);
                      }
                      container.style.transform = `matrix(${transform.join(",")})`;
                    } else {
                      container.style.transform = `matrix(${viewport.transform.join(",")})`;
                    }
                    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;
                    if (!ignoreBorder && data.borderStyle.width > 0) {
                      container.style.borderWidth = `${data.borderStyle.width}px`;
                      if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                        width -= 2 * data.borderStyle.width;
                        height -= 2 * data.borderStyle.width;
                      }
                      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                      const verticalRadius = data.borderStyle.verticalCornerRadius;
                      if (horizontalRadius > 0 || verticalRadius > 0) {
                        const radius = `${horizontalRadius}px / ${verticalRadius}px`;
                        container.style.borderRadius = radius;
                      }
                      switch (data.borderStyle.style) {
                        case _util2.AnnotationBorderStyleType.SOLID:
                          container.style.borderStyle = "solid";
                          break;
                        case _util2.AnnotationBorderStyleType.DASHED:
                          container.style.borderStyle = "dashed";
                          break;
                        case _util2.AnnotationBorderStyleType.BEVELED:
                          (0, _util2.warn)("Unimplemented border style: beveled");
                          break;
                        case _util2.AnnotationBorderStyleType.INSET:
                          (0, _util2.warn)("Unimplemented border style: inset");
                          break;
                        case _util2.AnnotationBorderStyleType.UNDERLINE:
                          container.style.borderBottomStyle = "solid";
                          break;
                        default:
                          break;
                      }
                      const borderColor = data.borderColor || data.color || null;
                      if (borderColor) {
                        container.style.borderColor = _util2.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                      } else {
                        container.style.borderWidth = 0;
                      }
                    }
                    container.style.left = `${rect[0]}px`;
                    container.style.top = `${rect[1]}px`;
                    if (data.hasOwnCanvas) {
                      container.style.width = container.style.height = "auto";
                    } else {
                      container.style.width = `${width}px`;
                      container.style.height = `${height}px`;
                    }
                    return container;
                  }
                  get _commonActions() {
                    const setColor = (jsName, styleName, event) => {
                      const color = event.detail[jsName];
                      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                    };
                    return (0, _util2.shadow)(this, "_commonActions", {
                      display: (event) => {
                        const hidden = event.detail.display % 2 === 1;
                        event.target.style.visibility = hidden ? "hidden" : "visible";
                        this.annotationStorage.setValue(this.data.id, {
                          hidden,
                          print: event.detail.display === 0 || event.detail.display === 3
                        });
                      },
                      print: (event) => {
                        this.annotationStorage.setValue(this.data.id, {
                          print: event.detail.print
                        });
                      },
                      hidden: (event) => {
                        event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
                        this.annotationStorage.setValue(this.data.id, {
                          hidden: event.detail.hidden
                        });
                      },
                      focus: (event) => {
                        setTimeout(() => event.target.focus({
                          preventScroll: false
                        }), 0);
                      },
                      userName: (event) => {
                        event.target.title = event.detail.userName;
                      },
                      readonly: (event) => {
                        if (event.detail.readonly) {
                          event.target.setAttribute("readonly", "");
                        } else {
                          event.target.removeAttribute("readonly");
                        }
                      },
                      required: (event) => {
                        if (event.detail.required) {
                          event.target.setAttribute("required", "");
                        } else {
                          event.target.removeAttribute("required");
                        }
                      },
                      bgColor: (event) => {
                        setColor("bgColor", "backgroundColor", event);
                      },
                      fillColor: (event) => {
                        setColor("fillColor", "backgroundColor", event);
                      },
                      fgColor: (event) => {
                        setColor("fgColor", "color", event);
                      },
                      textColor: (event) => {
                        setColor("textColor", "color", event);
                      },
                      borderColor: (event) => {
                        setColor("borderColor", "borderColor", event);
                      },
                      strokeColor: (event) => {
                        setColor("strokeColor", "borderColor", event);
                      }
                    });
                  }
                  _dispatchEventFromSandbox(actions, jsEvent) {
                    const commonActions = this._commonActions;
                    for (const name of Object.keys(jsEvent.detail)) {
                      const action = actions[name] || commonActions[name];
                      if (action) {
                        action(jsEvent);
                      }
                    }
                  }
                  _setDefaultPropertiesFromJS(element) {
                    if (!this.enableScripting) {
                      return;
                    }
                    const storedData = this.annotationStorage.getRawValue(this.data.id);
                    if (!storedData) {
                      return;
                    }
                    const commonActions = this._commonActions;
                    for (const [actionName, detail] of Object.entries(storedData)) {
                      const action = commonActions[actionName];
                      if (action) {
                        action({
                          detail,
                          target: element
                        });
                        delete storedData[actionName];
                      }
                    }
                  }
                  _createQuadrilaterals(ignoreBorder = false) {
                    if (!this.data.quadPoints) {
                      return null;
                    }
                    const quadrilaterals = [];
                    const savedRect = this.data.rect;
                    for (const quadPoint of this.data.quadPoints) {
                      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                      quadrilaterals.push(this._createContainer(ignoreBorder));
                    }
                    this.data.rect = savedRect;
                    return quadrilaterals;
                  }
                  _createPopup(trigger, data) {
                    let container = this.container;
                    if (this.quadrilaterals) {
                      trigger = trigger || this.quadrilaterals;
                      container = this.quadrilaterals[0];
                    }
                    if (!trigger) {
                      trigger = document.createElement("div");
                      trigger.style.height = container.style.height;
                      trigger.style.width = container.style.width;
                      container.appendChild(trigger);
                    }
                    const popupElement = new PopupElement({
                      container,
                      trigger,
                      color: data.color,
                      titleObj: data.titleObj,
                      modificationDate: data.modificationDate,
                      contentsObj: data.contentsObj,
                      richText: data.richText,
                      hideWrapper: true
                    });
                    const popup = popupElement.render();
                    popup.style.left = container.style.width;
                    container.appendChild(popup);
                  }
                  _renderQuadrilaterals(className) {
                    for (const quadrilateral of this.quadrilaterals) {
                      quadrilateral.className = className;
                    }
                    return this.quadrilaterals;
                  }
                  render() {
                    (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                  }
                  _getElementsByName(name, skipId = null) {
                    const fields = [];
                    if (this._fieldObjects) {
                      const fieldObj = this._fieldObjects[name];
                      if (fieldObj) {
                        for (const {
                          page,
                          id: id2,
                          exportValues
                        } of fieldObj) {
                          if (page === -1) {
                            continue;
                          }
                          if (id2 === skipId) {
                            continue;
                          }
                          const exportValue = typeof exportValues === "string" ? exportValues : null;
                          const domElement = document.getElementById(id2);
                          if (domElement && !GetElementsByNameSet.has(domElement)) {
                            (0, _util2.warn)(`_getElementsByName - element not allowed: ${id2}`);
                            continue;
                          }
                          fields.push({
                            id: id2,
                            exportValue,
                            domElement
                          });
                        }
                      }
                      return fields;
                    }
                    for (const domElement of document.getElementsByName(name)) {
                      const {
                        id: id2,
                        exportValue
                      } = domElement;
                      if (id2 === skipId) {
                        continue;
                      }
                      if (!GetElementsByNameSet.has(domElement)) {
                        continue;
                      }
                      fields.push({
                        id: id2,
                        exportValue,
                        domElement
                      });
                    }
                    return fields;
                  }
                  static get platform() {
                    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                    return (0, _util2.shadow)(this, "platform", {
                      isWin: platform.includes("Win"),
                      isMac: platform.includes("Mac")
                    });
                  }
                }
                class LinkAnnotationElement extends AnnotationElement {
                  constructor(parameters, options = null) {
                    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
                      createQuadrilaterals: true
                    });
                  }
                  render() {
                    const {
                      data,
                      linkService
                    } = this;
                    const link = document.createElement("a");
                    if (data.url) {
                      linkService.addLinkAttributes(link, data.url, data.newWindow);
                    } else if (data.action) {
                      this._bindNamedAction(link, data.action);
                    } else if (data.dest) {
                      this._bindLink(link, data.dest);
                    } else {
                      let hasClickAction = false;
                      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                        hasClickAction = true;
                        this._bindJSAction(link, data);
                      }
                      if (data.resetForm) {
                        this._bindResetFormAction(link, data.resetForm);
                      } else if (!hasClickAction) {
                        this._bindLink(link, "");
                      }
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index2) => {
                        const linkElement = index2 === 0 ? link : link.cloneNode();
                        quadrilateral.appendChild(linkElement);
                        return quadrilateral;
                      });
                    }
                    this.container.className = "linkAnnotation";
                    this.container.appendChild(link);
                    return this.container;
                  }
                  _bindLink(link, destination) {
                    link.href = this.linkService.getDestinationHash(destination);
                    link.onclick = () => {
                      if (destination) {
                        this.linkService.goToDestination(destination);
                      }
                      return false;
                    };
                    if (destination || destination === "") {
                      link.className = "internalLink";
                    }
                  }
                  _bindNamedAction(link, action) {
                    link.href = this.linkService.getAnchorUrl("");
                    link.onclick = () => {
                      this.linkService.executeNamedAction(action);
                      return false;
                    };
                    link.className = "internalLink";
                  }
                  _bindJSAction(link, data) {
                    link.href = this.linkService.getAnchorUrl("");
                    const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                    for (const name of Object.keys(data.actions)) {
                      const jsName = map.get(name);
                      if (!jsName) {
                        continue;
                      }
                      link[jsName] = () => {
                        var _a;
                        (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: data.id,
                            name
                          }
                        });
                        return false;
                      };
                    }
                    if (!link.onclick) {
                      link.onclick = () => false;
                    }
                    link.className = "internalLink";
                  }
                  _bindResetFormAction(link, resetForm) {
                    const otherClickAction = link.onclick;
                    if (!otherClickAction) {
                      link.href = this.linkService.getAnchorUrl("");
                    }
                    link.className = "internalLink";
                    if (!this._fieldObjects) {
                      (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                      if (!otherClickAction) {
                        link.onclick = () => false;
                      }
                      return;
                    }
                    link.onclick = () => {
                      var _a;
                      if (otherClickAction) {
                        otherClickAction();
                      }
                      const {
                        fields: resetFormFields,
                        refs: resetFormRefs,
                        include
                      } = resetForm;
                      const allFields = [];
                      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                        const fieldIds = new Set(resetFormRefs);
                        for (const fieldName of resetFormFields) {
                          const fields = this._fieldObjects[fieldName] || [];
                          for (const {
                            id: id2
                          } of fields) {
                            fieldIds.add(id2);
                          }
                        }
                        for (const fields of Object.values(this._fieldObjects)) {
                          for (const field of fields) {
                            if (fieldIds.has(field.id) === include) {
                              allFields.push(field);
                            }
                          }
                        }
                      } else {
                        for (const fields of Object.values(this._fieldObjects)) {
                          allFields.push(...fields);
                        }
                      }
                      const storage = this.annotationStorage;
                      const allIds = [];
                      for (const field of allFields) {
                        const {
                          id: id2
                        } = field;
                        allIds.push(id2);
                        switch (field.type) {
                          case "text": {
                            const value = field.defaultValue || "";
                            storage.setValue(id2, {
                              value
                            });
                            break;
                          }
                          case "checkbox":
                          case "radiobutton": {
                            const value = field.defaultValue === field.exportValues;
                            storage.setValue(id2, {
                              value
                            });
                            break;
                          }
                          case "combobox":
                          case "listbox": {
                            const value = field.defaultValue || "";
                            storage.setValue(id2, {
                              value
                            });
                            break;
                          }
                          default:
                            continue;
                        }
                        const domElement = document.getElementById(id2);
                        if (!domElement || !GetElementsByNameSet.has(domElement)) {
                          continue;
                        }
                        domElement.dispatchEvent(new Event("resetform"));
                      }
                      if (this.enableScripting) {
                        (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: "app",
                            ids: allIds,
                            name: "ResetForm"
                          }
                        });
                      }
                      return false;
                    };
                  }
                }
                class TextAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable
                    });
                  }
                  render() {
                    this.container.className = "textAnnotation";
                    const image = document.createElement("img");
                    image.style.height = this.container.style.height;
                    image.style.width = this.container.style.width;
                    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                    image.alt = "[{{type}} Annotation]";
                    image.dataset.l10nId = "text_annotation_type";
                    image.dataset.l10nArgs = JSON.stringify({
                      type: this.data.name
                    });
                    if (!this.data.hasPopup) {
                      this._createPopup(image, this.data);
                    }
                    this.container.appendChild(image);
                    return this.container;
                  }
                }
                class WidgetAnnotationElement extends AnnotationElement {
                  render() {
                    if (this.data.alternativeText) {
                      this.container.title = this.data.alternativeText;
                    }
                    return this.container;
                  }
                  _getKeyModifier(event) {
                    const {
                      isWin,
                      isMac
                    } = AnnotationElement.platform;
                    return isWin && event.ctrlKey || isMac && event.metaKey;
                  }
                  _setEventListener(element, baseName, eventName, valueGetter) {
                    if (baseName.includes("mouse")) {
                      element.addEventListener(baseName, (event) => {
                        var _a;
                        (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: this.data.id,
                            name: eventName,
                            value: valueGetter(event),
                            shift: event.shiftKey,
                            modifier: this._getKeyModifier(event)
                          }
                        });
                      });
                    } else {
                      element.addEventListener(baseName, (event) => {
                        var _a;
                        (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: this.data.id,
                            name: eventName,
                            value: valueGetter(event)
                          }
                        });
                      });
                    }
                  }
                  _setEventListeners(element, names, getter) {
                    var _a;
                    for (const [baseName, eventName] of names) {
                      if (eventName === "Action" || ((_a = this.data.actions) == null ? void 0 : _a[eventName])) {
                        this._setEventListener(element, baseName, eventName, getter);
                      }
                    }
                  }
                  _setBackgroundColor(element) {
                    const color = this.data.backgroundColor || null;
                    element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                  }
                }
                class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                  constructor(parameters) {
                    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                    super(parameters, {
                      isRenderable
                    });
                  }
                  setPropertyOnSiblings(base, key, value, keyInStorage) {
                    const storage = this.annotationStorage;
                    for (const element of this._getElementsByName(base.name, base.id)) {
                      if (element.domElement) {
                        element.domElement[key] = value;
                      }
                      storage.setValue(element.id, {
                        [keyInStorage]: value
                      });
                    }
                  }
                  render() {
                    var _a;
                    const storage = this.annotationStorage;
                    const id2 = this.data.id;
                    this.container.className = "textWidgetAnnotation";
                    let element = null;
                    if (this.renderForms) {
                      const storedData = storage.getValue(id2, {
                        value: this.data.fieldValue
                      });
                      const textContent = storedData.formattedValue || storedData.value || "";
                      const elementData = {
                        userValue: null,
                        formattedValue: null,
                        valueOnFocus: ""
                      };
                      if (this.data.multiLine) {
                        element = document.createElement("textarea");
                        element.textContent = textContent;
                      } else {
                        element = document.createElement("input");
                        element.type = "text";
                        element.setAttribute("value", textContent);
                      }
                      GetElementsByNameSet.add(element);
                      element.disabled = this.data.readOnly;
                      element.name = this.data.fieldName;
                      element.tabIndex = DEFAULT_TAB_INDEX;
                      elementData.userValue = textContent;
                      element.setAttribute("id", id2);
                      element.addEventListener("input", (event) => {
                        storage.setValue(id2, {
                          value: event.target.value
                        });
                        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                      });
                      element.addEventListener("resetform", (event) => {
                        const defaultValue = this.data.defaultFieldValue ?? "";
                        element.value = elementData.userValue = defaultValue;
                        elementData.formattedValue = null;
                      });
                      let blurListener = (event) => {
                        const {
                          formattedValue
                        } = elementData;
                        if (formattedValue !== null && formattedValue !== void 0) {
                          event.target.value = formattedValue;
                        }
                        event.target.scrollLeft = 0;
                      };
                      if (this.enableScripting && this.hasJSActions) {
                        element.addEventListener("focus", (event) => {
                          if (elementData.userValue) {
                            event.target.value = elementData.userValue;
                          }
                          elementData.valueOnFocus = event.target.value;
                        });
                        element.addEventListener("updatefromsandbox", (jsEvent) => {
                          const actions = {
                            value(event) {
                              elementData.userValue = event.detail.value ?? "";
                              storage.setValue(id2, {
                                value: elementData.userValue.toString()
                              });
                              event.target.value = elementData.userValue;
                            },
                            formattedValue(event) {
                              const {
                                formattedValue
                              } = event.detail;
                              elementData.formattedValue = formattedValue;
                              if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                                event.target.value = formattedValue;
                              }
                              storage.setValue(id2, {
                                formattedValue
                              });
                            },
                            selRange(event) {
                              event.target.setSelectionRange(...event.detail.selRange);
                            }
                          };
                          this._dispatchEventFromSandbox(actions, jsEvent);
                        });
                        element.addEventListener("keydown", (event) => {
                          var _a2;
                          let commitKey = -1;
                          if (event.key === "Escape") {
                            commitKey = 0;
                          } else if (event.key === "Enter") {
                            commitKey = 2;
                          } else if (event.key === "Tab") {
                            commitKey = 3;
                          }
                          if (commitKey === -1) {
                            return;
                          }
                          const {
                            value
                          } = event.target;
                          if (elementData.valueOnFocus === value) {
                            return;
                          }
                          elementData.userValue = value;
                          (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: id2,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        });
                        const _blurListener = blurListener;
                        blurListener = null;
                        element.addEventListener("blur", (event) => {
                          var _a2;
                          const {
                            value
                          } = event.target;
                          elementData.userValue = value;
                          if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
                            (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id: id2,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: event.target.selectionStart,
                                selEnd: event.target.selectionEnd
                              }
                            });
                          }
                          _blurListener(event);
                        });
                        if ((_a = this.data.actions) == null ? void 0 : _a.Keystroke) {
                          element.addEventListener("beforeinput", (event) => {
                            var _a2;
                            const {
                              data,
                              target
                            } = event;
                            const {
                              value,
                              selectionStart,
                              selectionEnd
                            } = target;
                            let selStart = selectionStart, selEnd = selectionEnd;
                            switch (event.inputType) {
                              case "deleteWordBackward": {
                                const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                                if (match) {
                                  selStart -= match[0].length;
                                }
                                break;
                              }
                              case "deleteWordForward": {
                                const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                                if (match) {
                                  selEnd += match[0].length;
                                }
                                break;
                              }
                              case "deleteContentBackward":
                                if (selectionStart === selectionEnd) {
                                  selStart -= 1;
                                }
                                break;
                              case "deleteContentForward":
                                if (selectionStart === selectionEnd) {
                                  selEnd += 1;
                                }
                                break;
                            }
                            event.preventDefault();
                            (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id: id2,
                                name: "Keystroke",
                                value,
                                change: data || "",
                                willCommit: false,
                                selStart,
                                selEnd
                              }
                            });
                          });
                        }
                        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                      }
                      if (blurListener) {
                        element.addEventListener("blur", blurListener);
                      }
                      if (this.data.maxLen !== null) {
                        element.maxLength = this.data.maxLen;
                      }
                      if (this.data.comb) {
                        const fieldWidth = this.data.rect[2] - this.data.rect[0];
                        const combWidth = fieldWidth / this.data.maxLen;
                        element.classList.add("comb");
                        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
                      }
                    } else {
                      element = document.createElement("div");
                      element.textContent = this.data.fieldValue;
                      element.style.verticalAlign = "middle";
                      element.style.display = "table-cell";
                    }
                    this._setTextStyle(element);
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                  _setTextStyle(element) {
                    const TEXT_ALIGNMENT = ["left", "center", "right"];
                    const {
                      fontSize,
                      fontColor
                    } = this.data.defaultAppearanceData;
                    const style = element.style;
                    if (fontSize) {
                      style.fontSize = `${fontSize}px`;
                    }
                    style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                    if (this.data.textAlignment !== null) {
                      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                    }
                  }
                }
                class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                  constructor(parameters) {
                    super(parameters, {
                      isRenderable: parameters.renderForms
                    });
                  }
                  render() {
                    const storage = this.annotationStorage;
                    const data = this.data;
                    const id2 = data.id;
                    let value = storage.getValue(id2, {
                      value: data.exportValue === data.fieldValue
                    }).value;
                    if (typeof value === "string") {
                      value = value !== "Off";
                      storage.setValue(id2, {
                        value
                      });
                    }
                    this.container.className = "buttonWidgetAnnotation checkBox";
                    const element = document.createElement("input");
                    GetElementsByNameSet.add(element);
                    element.disabled = data.readOnly;
                    element.type = "checkbox";
                    element.name = data.fieldName;
                    if (value) {
                      element.setAttribute("checked", true);
                    }
                    element.setAttribute("id", id2);
                    element.setAttribute("exportValue", data.exportValue);
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    element.addEventListener("change", (event) => {
                      const {
                        name,
                        checked
                      } = event.target;
                      for (const checkbox of this._getElementsByName(name, id2)) {
                        const curChecked = checked && checkbox.exportValue === data.exportValue;
                        if (checkbox.domElement) {
                          checkbox.domElement.checked = curChecked;
                        }
                        storage.setValue(checkbox.id, {
                          value: curChecked
                        });
                      }
                      storage.setValue(id2, {
                        value: checked
                      });
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = data.defaultFieldValue || "Off";
                      event.target.checked = defaultValue === data.exportValue;
                    });
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            event.target.checked = event.detail.value !== "Off";
                            storage.setValue(id2, {
                              value: event.target.checked
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                    }
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                }
                class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                  constructor(parameters) {
                    super(parameters, {
                      isRenderable: parameters.renderForms
                    });
                  }
                  render() {
                    this.container.className = "buttonWidgetAnnotation radioButton";
                    const storage = this.annotationStorage;
                    const data = this.data;
                    const id2 = data.id;
                    let value = storage.getValue(id2, {
                      value: data.fieldValue === data.buttonValue
                    }).value;
                    if (typeof value === "string") {
                      value = value !== data.buttonValue;
                      storage.setValue(id2, {
                        value
                      });
                    }
                    const element = document.createElement("input");
                    GetElementsByNameSet.add(element);
                    element.disabled = data.readOnly;
                    element.type = "radio";
                    element.name = data.fieldName;
                    if (value) {
                      element.setAttribute("checked", true);
                    }
                    element.setAttribute("id", id2);
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    element.addEventListener("change", (event) => {
                      const {
                        name,
                        checked
                      } = event.target;
                      for (const radio of this._getElementsByName(name, id2)) {
                        storage.setValue(radio.id, {
                          value: false
                        });
                      }
                      storage.setValue(id2, {
                        value: checked
                      });
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = data.defaultFieldValue;
                      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                    });
                    if (this.enableScripting && this.hasJSActions) {
                      const pdfButtonValue = data.buttonValue;
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value: (event) => {
                            const checked = pdfButtonValue === event.detail.value;
                            for (const radio of this._getElementsByName(event.target.name)) {
                              const curChecked = checked && radio.id === id2;
                              if (radio.domElement) {
                                radio.domElement.checked = curChecked;
                              }
                              storage.setValue(radio.id, {
                                value: curChecked
                              });
                            }
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                    }
                    this._setBackgroundColor(element);
                    this._setDefaultPropertiesFromJS(element);
                    this.container.appendChild(element);
                    return this.container;
                  }
                }
                class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                  constructor(parameters) {
                    super(parameters, {
                      ignoreBorder: parameters.data.hasAppearance
                    });
                  }
                  render() {
                    const container = super.render();
                    container.className = "buttonWidgetAnnotation pushButton";
                    if (this.data.alternativeText) {
                      container.title = this.data.alternativeText;
                    }
                    this._setDefaultPropertiesFromJS(container);
                    return container;
                  }
                }
                class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                  constructor(parameters) {
                    super(parameters, {
                      isRenderable: parameters.renderForms
                    });
                  }
                  render() {
                    this.container.className = "choiceWidgetAnnotation";
                    const storage = this.annotationStorage;
                    const id2 = this.data.id;
                    const storedData = storage.getValue(id2, {
                      value: this.data.fieldValue
                    });
                    let {
                      fontSize
                    } = this.data.defaultAppearanceData;
                    if (!fontSize) {
                      fontSize = 9;
                    }
                    const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;
                    const selectElement = document.createElement("select");
                    GetElementsByNameSet.add(selectElement);
                    selectElement.disabled = this.data.readOnly;
                    selectElement.name = this.data.fieldName;
                    selectElement.setAttribute("id", id2);
                    selectElement.tabIndex = DEFAULT_TAB_INDEX;
                    selectElement.style.fontSize = `${fontSize}px`;
                    if (!this.data.combo) {
                      selectElement.size = this.data.options.length;
                      if (this.data.multiSelect) {
                        selectElement.multiple = true;
                      }
                    }
                    selectElement.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue;
                      for (const option of selectElement.options) {
                        option.selected = option.value === defaultValue;
                      }
                    });
                    for (const option of this.data.options) {
                      const optionElement = document.createElement("option");
                      optionElement.textContent = option.displayValue;
                      optionElement.value = option.exportValue;
                      if (this.data.combo) {
                        optionElement.style.fontSize = fontSizeStyle;
                      }
                      if (storedData.value.includes(option.exportValue)) {
                        optionElement.setAttribute("selected", true);
                      }
                      selectElement.appendChild(optionElement);
                    }
                    const getValue = (event, isExport) => {
                      const name = isExport ? "value" : "textContent";
                      const options = event.target.options;
                      if (!event.target.multiple) {
                        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                      }
                      return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                    };
                    const getItems = (event) => {
                      const options = event.target.options;
                      return Array.prototype.map.call(options, (option) => {
                        return {
                          displayValue: option.textContent,
                          exportValue: option.value
                        };
                      });
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            const value = event.detail.value;
                            const values = new Set(Array.isArray(value) ? value : [value]);
                            for (const option of selectElement.options) {
                              option.selected = values.has(option.value);
                            }
                            storage.setValue(id2, {
                              value: getValue(event, true)
                            });
                          },
                          multipleSelection(event) {
                            selectElement.multiple = true;
                          },
                          remove(event) {
                            const options = selectElement.options;
                            const index2 = event.detail.remove;
                            options[index2].selected = false;
                            selectElement.remove(index2);
                            if (options.length > 0) {
                              const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                              if (i === -1) {
                                options[0].selected = true;
                              }
                            }
                            storage.setValue(id2, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          clear(event) {
                            while (selectElement.length !== 0) {
                              selectElement.remove(0);
                            }
                            storage.setValue(id2, {
                              value: null,
                              items: []
                            });
                          },
                          insert(event) {
                            const {
                              index: index2,
                              displayValue,
                              exportValue
                            } = event.detail.insert;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.insertBefore(optionElement, selectElement.children[index2]);
                            storage.setValue(id2, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          items(event) {
                            const {
                              items
                            } = event.detail;
                            while (selectElement.length !== 0) {
                              selectElement.remove(0);
                            }
                            for (const item of items) {
                              const {
                                displayValue,
                                exportValue
                              } = item;
                              const optionElement = document.createElement("option");
                              optionElement.textContent = displayValue;
                              optionElement.value = exportValue;
                              selectElement.appendChild(optionElement);
                            }
                            if (selectElement.options.length > 0) {
                              selectElement.options[0].selected = true;
                            }
                            storage.setValue(id2, {
                              value: getValue(event, true),
                              items: getItems(event)
                            });
                          },
                          indices(event) {
                            const indices = new Set(event.detail.indices);
                            for (const option of event.target.options) {
                              option.selected = indices.has(option.index);
                            }
                            storage.setValue(id2, {
                              value: getValue(event, true)
                            });
                          },
                          editable(event) {
                            event.target.disabled = !event.detail.editable;
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      selectElement.addEventListener("input", (event) => {
                        var _a;
                        const exportValue = getValue(event, true);
                        const value = getValue(event, false);
                        storage.setValue(id2, {
                          value: exportValue
                        });
                        (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: id2,
                            name: "Keystroke",
                            value,
                            changeEx: exportValue,
                            willCommit: true,
                            commitKey: 1,
                            keyDown: false
                          }
                        });
                      });
                      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                    } else {
                      selectElement.addEventListener("input", function(event) {
                        storage.setValue(id2, {
                          value: getValue(event, true)
                        });
                      });
                    }
                    this._setBackgroundColor(selectElement);
                    this._setDefaultPropertiesFromJS(selectElement);
                    this.container.appendChild(selectElement);
                    return this.container;
                  }
                }
                class PopupAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable
                    });
                  }
                  render() {
                    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                    this.container.className = "popupAnnotation";
                    if (IGNORE_TYPES.includes(this.data.parentType)) {
                      return this.container;
                    }
                    const selector2 = `[data-annotation-id="${this.data.parentId}"]`;
                    const parentElements = this.layer.querySelectorAll(selector2);
                    if (parentElements.length === 0) {
                      return this.container;
                    }
                    const popup = new PopupElement({
                      container: this.container,
                      trigger: Array.from(parentElements),
                      color: this.data.color,
                      titleObj: this.data.titleObj,
                      modificationDate: this.data.modificationDate,
                      contentsObj: this.data.contentsObj,
                      richText: this.data.richText
                    });
                    const page = this.page;
                    const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                    const popupTop = rect[1];
                    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
                    this.container.style.left = `${popupLeft}px`;
                    this.container.style.top = `${popupTop}px`;
                    this.container.appendChild(popup.render());
                    return this.container;
                  }
                }
                class PopupElement {
                  constructor(parameters) {
                    this.container = parameters.container;
                    this.trigger = parameters.trigger;
                    this.color = parameters.color;
                    this.titleObj = parameters.titleObj;
                    this.modificationDate = parameters.modificationDate;
                    this.contentsObj = parameters.contentsObj;
                    this.richText = parameters.richText;
                    this.hideWrapper = parameters.hideWrapper || false;
                    this.pinned = false;
                  }
                  render() {
                    var _a, _b;
                    const BACKGROUND_ENLIGHT = 0.7;
                    const wrapper = document.createElement("div");
                    wrapper.className = "popupWrapper";
                    this.hideElement = this.hideWrapper ? wrapper : this.container;
                    this.hideElement.hidden = true;
                    const popup = document.createElement("div");
                    popup.className = "popup";
                    const color = this.color;
                    if (color) {
                      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                      popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                    }
                    const title = document.createElement("h1");
                    title.dir = this.titleObj.dir;
                    title.textContent = this.titleObj.str;
                    popup.appendChild(title);
                    const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                    if (dateObject) {
                      const modificationDate = document.createElement("span");
                      modificationDate.className = "popupDate";
                      modificationDate.textContent = "{{date}}, {{time}}";
                      modificationDate.dataset.l10nId = "annotation_date_string";
                      modificationDate.dataset.l10nArgs = JSON.stringify({
                        date: dateObject.toLocaleDateString(),
                        time: dateObject.toLocaleTimeString()
                      });
                      popup.appendChild(modificationDate);
                    }
                    if (((_a = this.richText) == null ? void 0 : _a.str) && (!((_b = this.contentsObj) == null ? void 0 : _b.str) || this.contentsObj.str === this.richText.str)) {
                      _xfa_layer.XfaLayer.render({
                        xfaHtml: this.richText.html,
                        intent: "richText",
                        div: popup
                      });
                      popup.lastChild.className = "richText popupContent";
                    } else {
                      const contents = this._formatContents(this.contentsObj);
                      popup.appendChild(contents);
                    }
                    if (!Array.isArray(this.trigger)) {
                      this.trigger = [this.trigger];
                    }
                    for (const element of this.trigger) {
                      element.addEventListener("click", this._toggle.bind(this));
                      element.addEventListener("mouseover", this._show.bind(this, false));
                      element.addEventListener("mouseout", this._hide.bind(this, false));
                    }
                    popup.addEventListener("click", this._hide.bind(this, true));
                    wrapper.appendChild(popup);
                    return wrapper;
                  }
                  _formatContents({
                    str,
                    dir
                  }) {
                    const p = document.createElement("p");
                    p.className = "popupContent";
                    p.dir = dir;
                    const lines = str.split(/(?:\r\n?|\n)/);
                    for (let i = 0, ii = lines.length; i < ii; ++i) {
                      const line = lines[i];
                      p.appendChild(document.createTextNode(line));
                      if (i < ii - 1) {
                        p.appendChild(document.createElement("br"));
                      }
                    }
                    return p;
                  }
                  _toggle() {
                    if (this.pinned) {
                      this._hide(true);
                    } else {
                      this._show(true);
                    }
                  }
                  _show(pin = false) {
                    if (pin) {
                      this.pinned = true;
                    }
                    if (this.hideElement.hidden) {
                      this.hideElement.hidden = false;
                      this.container.style.zIndex += 1;
                    }
                  }
                  _hide(unpin = true) {
                    if (unpin) {
                      this.pinned = false;
                    }
                    if (!this.hideElement.hidden && !this.pinned) {
                      this.hideElement.hidden = true;
                      this.container.style.zIndex -= 1;
                    }
                  }
                }
                class FreeTextAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "freeTextAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }
                class LineAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "lineAnnotation";
                    const data = this.data;
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    const svg = this.svgFactory.create(width, height);
                    const line = this.svgFactory.createElement("svg:line");
                    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                    line.setAttribute("stroke-width", data.borderStyle.width || 1);
                    line.setAttribute("stroke", "transparent");
                    line.setAttribute("fill", "transparent");
                    svg.appendChild(line);
                    this.container.append(svg);
                    this._createPopup(line, data);
                    return this.container;
                  }
                }
                class SquareAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "squareAnnotation";
                    const data = this.data;
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    const svg = this.svgFactory.create(width, height);
                    const borderWidth = data.borderStyle.width;
                    const square = this.svgFactory.createElement("svg:rect");
                    square.setAttribute("x", borderWidth / 2);
                    square.setAttribute("y", borderWidth / 2);
                    square.setAttribute("width", width - borderWidth);
                    square.setAttribute("height", height - borderWidth);
                    square.setAttribute("stroke-width", borderWidth || 1);
                    square.setAttribute("stroke", "transparent");
                    square.setAttribute("fill", "transparent");
                    svg.appendChild(square);
                    this.container.append(svg);
                    this._createPopup(square, data);
                    return this.container;
                  }
                }
                class CircleAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "circleAnnotation";
                    const data = this.data;
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    const svg = this.svgFactory.create(width, height);
                    const borderWidth = data.borderStyle.width;
                    const circle = this.svgFactory.createElement("svg:ellipse");
                    circle.setAttribute("cx", width / 2);
                    circle.setAttribute("cy", height / 2);
                    circle.setAttribute("rx", width / 2 - borderWidth / 2);
                    circle.setAttribute("ry", height / 2 - borderWidth / 2);
                    circle.setAttribute("stroke-width", borderWidth || 1);
                    circle.setAttribute("stroke", "transparent");
                    circle.setAttribute("fill", "transparent");
                    svg.appendChild(circle);
                    this.container.append(svg);
                    this._createPopup(circle, data);
                    return this.container;
                  }
                }
                class PolylineAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                    this.containerClassName = "polylineAnnotation";
                    this.svgElementName = "svg:polyline";
                  }
                  render() {
                    this.container.className = this.containerClassName;
                    const data = this.data;
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    const svg = this.svgFactory.create(width, height);
                    let points = [];
                    for (const coordinate of data.vertices) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(x + "," + y);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    svg.appendChild(polyline);
                    this.container.append(svg);
                    this._createPopup(polyline, data);
                    return this.container;
                  }
                }
                class PolygonAnnotationElement extends PolylineAnnotationElement {
                  constructor(parameters) {
                    super(parameters);
                    this.containerClassName = "polygonAnnotation";
                    this.svgElementName = "svg:polygon";
                  }
                }
                class CaretAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "caretAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }
                class InkAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                    this.containerClassName = "inkAnnotation";
                    this.svgElementName = "svg:polyline";
                  }
                  render() {
                    this.container.className = this.containerClassName;
                    const data = this.data;
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    const svg = this.svgFactory.create(width, height);
                    for (const inkList of data.inkLists) {
                      let points = [];
                      for (const coordinate of inkList) {
                        const x = coordinate.x - data.rect[0];
                        const y = data.rect[3] - coordinate.y;
                        points.push(`${x},${y}`);
                      }
                      points = points.join(" ");
                      const polyline = this.svgFactory.createElement(this.svgElementName);
                      polyline.setAttribute("points", points);
                      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                      polyline.setAttribute("stroke", "transparent");
                      polyline.setAttribute("fill", "transparent");
                      this._createPopup(polyline, data);
                      svg.appendChild(polyline);
                    }
                    this.container.append(svg);
                    return this.container;
                  }
                }
                class HighlightAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true,
                      createQuadrilaterals: true
                    });
                  }
                  render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("highlightAnnotation");
                    }
                    this.container.className = "highlightAnnotation";
                    return this.container;
                  }
                }
                class UnderlineAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true,
                      createQuadrilaterals: true
                    });
                  }
                  render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("underlineAnnotation");
                    }
                    this.container.className = "underlineAnnotation";
                    return this.container;
                  }
                }
                class SquigglyAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true,
                      createQuadrilaterals: true
                    });
                  }
                  render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("squigglyAnnotation");
                    }
                    this.container.className = "squigglyAnnotation";
                    return this.container;
                  }
                }
                class StrikeOutAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true,
                      createQuadrilaterals: true
                    });
                  }
                  render() {
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    if (this.quadrilaterals) {
                      return this._renderQuadrilaterals("strikeoutAnnotation");
                    }
                    this.container.className = "strikeoutAnnotation";
                    return this.container;
                  }
                }
                class StampAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a, _b, _c;
                    const isRenderable = !!(parameters.data.hasPopup || ((_a = parameters.data.titleObj) == null ? void 0 : _a.str) || ((_b = parameters.data.contentsObj) == null ? void 0 : _b.str) || ((_c = parameters.data.richText) == null ? void 0 : _c.str));
                    super(parameters, {
                      isRenderable,
                      ignoreBorder: true
                    });
                  }
                  render() {
                    this.container.className = "stampAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(null, this.data);
                    }
                    return this.container;
                  }
                }
                class FileAttachmentAnnotationElement extends AnnotationElement {
                  constructor(parameters) {
                    var _a;
                    super(parameters, {
                      isRenderable: true
                    });
                    const {
                      filename,
                      content
                    } = this.data.file;
                    this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                    this.content = content;
                    (_a = this.linkService.eventBus) == null ? void 0 : _a.dispatch("fileattachmentannotation", {
                      source: this,
                      filename,
                      content
                    });
                  }
                  render() {
                    var _a, _b;
                    this.container.className = "fileAttachmentAnnotation";
                    const trigger = document.createElement("div");
                    trigger.style.height = this.container.style.height;
                    trigger.style.width = this.container.style.width;
                    trigger.addEventListener("dblclick", this._download.bind(this));
                    if (!this.data.hasPopup && (((_a = this.data.titleObj) == null ? void 0 : _a.str) || ((_b = this.data.contentsObj) == null ? void 0 : _b.str) || this.data.richText)) {
                      this._createPopup(trigger, this.data);
                    }
                    this.container.appendChild(trigger);
                    return this.container;
                  }
                  _download() {
                    var _a;
                    (_a = this.downloadManager) == null ? void 0 : _a.openOrDownloadData(this.container, this.content, this.filename);
                  }
                }
                class AnnotationLayer {
                  static render(parameters) {
                    const sortedAnnotations = [], popupAnnotations = [];
                    for (const data of parameters.annotations) {
                      if (!data) {
                        continue;
                      }
                      const {
                        width,
                        height
                      } = getRectDims(data.rect);
                      if (width <= 0 || height <= 0) {
                        continue;
                      }
                      if (data.annotationType === _util2.AnnotationType.POPUP) {
                        popupAnnotations.push(data);
                        continue;
                      }
                      sortedAnnotations.push(data);
                    }
                    if (popupAnnotations.length) {
                      sortedAnnotations.push(...popupAnnotations);
                    }
                    const div = parameters.div;
                    for (const data of sortedAnnotations) {
                      const element = AnnotationElementFactory.create({
                        data,
                        layer: div,
                        page: parameters.page,
                        viewport: parameters.viewport,
                        linkService: parameters.linkService,
                        downloadManager: parameters.downloadManager,
                        imageResourcesPath: parameters.imageResourcesPath || "",
                        renderForms: parameters.renderForms !== false,
                        svgFactory: new _display_utils2.DOMSVGFactory(),
                        annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                        enableScripting: parameters.enableScripting,
                        hasJSActions: parameters.hasJSActions,
                        fieldObjects: parameters.fieldObjects,
                        mouseState: parameters.mouseState || {
                          isDown: false
                        }
                      });
                      if (element.isRenderable) {
                        const rendered = element.render();
                        if (data.hidden) {
                          rendered.style.visibility = "hidden";
                        }
                        if (Array.isArray(rendered)) {
                          for (const renderedElement of rendered) {
                            div.appendChild(renderedElement);
                          }
                        } else {
                          if (element instanceof PopupAnnotationElement) {
                            div.prepend(rendered);
                          } else {
                            div.appendChild(rendered);
                          }
                        }
                      }
                    }
                    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div, parameters.annotationCanvasMap);
                  }
                  static update(parameters) {
                    const {
                      page,
                      viewport,
                      annotations,
                      annotationCanvasMap,
                      div
                    } = parameters;
                    const transform = viewport.transform;
                    const matrix = `matrix(${transform.join(",")})`;
                    let scale, ownMatrix;
                    for (const data of annotations) {
                      const elements = div.querySelectorAll(`[data-annotation-id="${data.id}"]`);
                      if (elements) {
                        for (const element of elements) {
                          if (data.hasOwnCanvas) {
                            const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                            if (!ownMatrix) {
                              scale = Math.abs(transform[0] || transform[1]);
                              const ownTransform = transform.slice();
                              for (let i = 0; i < 4; i++) {
                                ownTransform[i] = Math.sign(ownTransform[i]);
                              }
                              ownMatrix = `matrix(${ownTransform.join(",")})`;
                            }
                            const left = rect[0] * scale;
                            const top = rect[1] * scale;
                            element.style.left = `${left}px`;
                            element.style.top = `${top}px`;
                            element.style.transformOrigin = `${-left}px ${-top}px`;
                            element.style.transform = ownMatrix;
                          } else {
                            element.style.transform = matrix;
                          }
                        }
                      }
                    }
                    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div, annotationCanvasMap);
                    div.hidden = false;
                  }
                }
                _setAnnotationCanvasMap = new WeakSet();
                setAnnotationCanvasMap_fn = function(div, annotationCanvasMap) {
                  if (!annotationCanvasMap) {
                    return;
                  }
                  for (const [id2, canvas] of annotationCanvasMap) {
                    const element = div.querySelector(`[data-annotation-id="${id2}"]`);
                    if (!element) {
                      continue;
                    }
                    const {
                      firstChild
                    } = element;
                    if (firstChild.nodeName === "CANVAS") {
                      element.replaceChild(canvas, firstChild);
                    } else {
                      element.insertBefore(canvas, firstChild);
                    }
                  }
                  annotationCanvasMap.clear();
                };
                __privateAdd(AnnotationLayer, _setAnnotationCanvasMap);
                exports2.AnnotationLayer = AnnotationLayer;
              },
              /* 21 */
              /***/
              (__unused_webpack_module2, exports2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.ColorConverters = void 0;
                function makeColorComp(n) {
                  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
                }
                class ColorConverters {
                  static CMYK_G([c, y, m, k]) {
                    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                  }
                  static G_CMYK([g]) {
                    return ["CMYK", 0, 0, 0, 1 - g];
                  }
                  static G_RGB([g]) {
                    return ["RGB", g, g, g];
                  }
                  static G_HTML([g]) {
                    const G = makeColorComp(g);
                    return `#${G}${G}${G}`;
                  }
                  static RGB_G([r, g, b]) {
                    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                  }
                  static RGB_HTML([r, g, b]) {
                    const R = makeColorComp(r);
                    const G = makeColorComp(g);
                    const B = makeColorComp(b);
                    return `#${R}${G}${B}`;
                  }
                  static T_HTML() {
                    return "#00000000";
                  }
                  static CMYK_RGB([c, y, m, k]) {
                    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                  }
                  static CMYK_HTML(components) {
                    return this.RGB_HTML(this.CMYK_RGB(components));
                  }
                  static RGB_CMYK([r, g, b]) {
                    const c = 1 - r;
                    const m = 1 - g;
                    const y = 1 - b;
                    const k = Math.min(c, m, y);
                    return ["CMYK", c, m, y, k];
                  }
                }
                exports2.ColorConverters = ColorConverters;
              },
              /* 22 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.XfaLayer = void 0;
                var _xfa_text2 = __w_pdfjs_require__2(18);
                class XfaLayer {
                  static setupStorage(html, id2, element, storage, intent) {
                    const storedData = storage.getValue(id2, {
                      value: null
                    });
                    switch (element.name) {
                      case "textarea":
                        if (storedData.value !== null) {
                          html.textContent = storedData.value;
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id2, {
                            value: event.target.value
                          });
                        });
                        break;
                      case "input":
                        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                          if (storedData.value === element.attributes.xfaOn) {
                            html.setAttribute("checked", true);
                          } else if (storedData.value === element.attributes.xfaOff) {
                            html.removeAttribute("checked");
                          }
                          if (intent === "print") {
                            break;
                          }
                          html.addEventListener("change", (event) => {
                            storage.setValue(id2, {
                              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                            });
                          });
                        } else {
                          if (storedData.value !== null) {
                            html.setAttribute("value", storedData.value);
                          }
                          if (intent === "print") {
                            break;
                          }
                          html.addEventListener("input", (event) => {
                            storage.setValue(id2, {
                              value: event.target.value
                            });
                          });
                        }
                        break;
                      case "select":
                        if (storedData.value !== null) {
                          for (const option of element.children) {
                            if (option.attributes.value === storedData.value) {
                              option.attributes.selected = true;
                            }
                          }
                        }
                        html.addEventListener("input", (event) => {
                          const options = event.target.options;
                          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                          storage.setValue(id2, {
                            value
                          });
                        });
                        break;
                    }
                  }
                  static setAttributes({
                    html,
                    element,
                    storage = null,
                    intent,
                    linkService
                  }) {
                    const {
                      attributes
                    } = element;
                    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                    if (attributes.type === "radio") {
                      attributes.name = `${attributes.name}-${intent}`;
                    }
                    for (const [key, value] of Object.entries(attributes)) {
                      if (value === null || value === void 0 || key === "dataId") {
                        continue;
                      }
                      if (key !== "style") {
                        if (key === "textContent") {
                          html.textContent = value;
                        } else if (key === "class") {
                          if (value.length) {
                            html.setAttribute(key, value.join(" "));
                          }
                        } else {
                          if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
                            continue;
                          }
                          html.setAttribute(key, value);
                        }
                      } else {
                        Object.assign(html.style, value);
                      }
                    }
                    if (isHTMLAnchorElement) {
                      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                    }
                    if (storage && attributes.dataId) {
                      this.setupStorage(html, attributes.dataId, element, storage);
                    }
                  }
                  static render(parameters) {
                    var _a;
                    const storage = parameters.annotationStorage;
                    const linkService = parameters.linkService;
                    const root = parameters.xfaHtml;
                    const intent = parameters.intent || "display";
                    const rootHtml = document.createElement(root.name);
                    if (root.attributes) {
                      this.setAttributes({
                        html: rootHtml,
                        element: root,
                        intent,
                        linkService
                      });
                    }
                    const stack = [[root, -1, rootHtml]];
                    const rootDiv = parameters.div;
                    rootDiv.appendChild(rootHtml);
                    if (parameters.viewport) {
                      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                      rootDiv.style.transform = transform;
                    }
                    if (intent !== "richText") {
                      rootDiv.setAttribute("class", "xfaLayer xfaFont");
                    }
                    const textDivs = [];
                    while (stack.length > 0) {
                      const [parent, i, html] = stack[stack.length - 1];
                      if (i + 1 === parent.children.length) {
                        stack.pop();
                        continue;
                      }
                      const child = parent.children[++stack[stack.length - 1][1]];
                      if (child === null) {
                        continue;
                      }
                      const {
                        name
                      } = child;
                      if (name === "#text") {
                        const node = document.createTextNode(child.value);
                        textDivs.push(node);
                        html.appendChild(node);
                        continue;
                      }
                      let childHtml;
                      if ((_a = child == null ? void 0 : child.attributes) == null ? void 0 : _a.xmlns) {
                        childHtml = document.createElementNS(child.attributes.xmlns, name);
                      } else {
                        childHtml = document.createElement(name);
                      }
                      html.appendChild(childHtml);
                      if (child.attributes) {
                        this.setAttributes({
                          html: childHtml,
                          element: child,
                          storage,
                          intent,
                          linkService
                        });
                      }
                      if (child.children && child.children.length > 0) {
                        stack.push([child, -1, childHtml]);
                      } else if (child.value) {
                        const node = document.createTextNode(child.value);
                        if (_xfa_text2.XfaText.shouldBuildText(name)) {
                          textDivs.push(node);
                        }
                        childHtml.appendChild(node);
                      }
                    }
                    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                      el.setAttribute("readOnly", true);
                    }
                    return {
                      textDivs
                    };
                  }
                  static update(parameters) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    parameters.div.style.transform = transform;
                    parameters.div.hidden = false;
                  }
                }
                exports2.XfaLayer = XfaLayer;
              },
              /* 23 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.renderTextLayer = renderTextLayer;
                var _util2 = __w_pdfjs_require__2(1);
                const MAX_TEXT_DIVS_TO_RENDER = 1e5;
                const DEFAULT_FONT_SIZE = 30;
                const DEFAULT_FONT_ASCENT = 0.8;
                const ascentCache = /* @__PURE__ */ new Map();
                const AllWhitespaceRegexp = /^\s+$/g;
                function getAscent(fontFamily, ctx) {
                  const cachedAscent = ascentCache.get(fontFamily);
                  if (cachedAscent) {
                    return cachedAscent;
                  }
                  ctx.save();
                  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                  const metrics = ctx.measureText("");
                  let ascent = metrics.fontBoundingBoxAscent;
                  let descent = Math.abs(metrics.fontBoundingBoxDescent);
                  if (ascent) {
                    ctx.restore();
                    const ratio = ascent / (ascent + descent);
                    ascentCache.set(fontFamily, ratio);
                    return ratio;
                  }
                  ctx.strokeStyle = "red";
                  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                  ctx.strokeText("g", 0, 0);
                  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                  descent = 0;
                  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                    if (pixels[i] > 0) {
                      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                      break;
                    }
                  }
                  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                  ascent = 0;
                  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                    if (pixels[i] > 0) {
                      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                      break;
                    }
                  }
                  ctx.restore();
                  if (ascent) {
                    const ratio = ascent / (ascent + descent);
                    ascentCache.set(fontFamily, ratio);
                    return ratio;
                  }
                  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                  return DEFAULT_FONT_ASCENT;
                }
                function appendText(task, geom, styles, ctx) {
                  const textDiv = document.createElement("span");
                  const textDivProperties = task._enhanceTextSelection ? {
                    angle: 0,
                    canvasWidth: 0,
                    hasText: geom.str !== "",
                    hasEOL: geom.hasEOL,
                    originalTransform: null,
                    paddingBottom: 0,
                    paddingLeft: 0,
                    paddingRight: 0,
                    paddingTop: 0,
                    scale: 1
                  } : {
                    angle: 0,
                    canvasWidth: 0,
                    hasText: geom.str !== "",
                    hasEOL: geom.hasEOL
                  };
                  task._textDivs.push(textDiv);
                  const tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                  let angle = Math.atan2(tx[1], tx[0]);
                  const style = styles[geom.fontName];
                  if (style.vertical) {
                    angle += Math.PI / 2;
                  }
                  const fontHeight = Math.hypot(tx[2], tx[3]);
                  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                  let left, top;
                  if (angle === 0) {
                    left = tx[4];
                    top = tx[5] - fontAscent;
                  } else {
                    left = tx[4] + fontAscent * Math.sin(angle);
                    top = tx[5] - fontAscent * Math.cos(angle);
                  }
                  textDiv.style.left = `${left}px`;
                  textDiv.style.top = `${top}px`;
                  textDiv.style.fontSize = `${fontHeight}px`;
                  textDiv.style.fontFamily = style.fontFamily;
                  textDiv.setAttribute("role", "presentation");
                  textDiv.textContent = geom.str;
                  textDiv.dir = geom.dir;
                  if (task._fontInspectorEnabled) {
                    textDiv.dataset.fontName = geom.fontName;
                  }
                  if (angle !== 0) {
                    textDivProperties.angle = angle * (180 / Math.PI);
                  }
                  let shouldScaleText = false;
                  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
                    shouldScaleText = true;
                  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                    const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                      shouldScaleText = true;
                    }
                  }
                  if (shouldScaleText) {
                    if (style.vertical) {
                      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                    } else {
                      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                    }
                  }
                  task._textDivProperties.set(textDiv, textDivProperties);
                  if (task._textContentStream) {
                    task._layoutText(textDiv);
                  }
                  if (task._enhanceTextSelection && textDivProperties.hasText) {
                    let angleCos = 1, angleSin = 0;
                    if (angle !== 0) {
                      angleCos = Math.cos(angle);
                      angleSin = Math.sin(angle);
                    }
                    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                    const divHeight = fontHeight;
                    let m, b;
                    if (angle !== 0) {
                      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                      b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                    } else {
                      b = [left, top, left + divWidth, top + divHeight];
                    }
                    task._bounds.push({
                      left: b[0],
                      top: b[1],
                      right: b[2],
                      bottom: b[3],
                      div: textDiv,
                      size: [divWidth, divHeight],
                      m
                    });
                  }
                }
                function render(task) {
                  if (task._canceled) {
                    return;
                  }
                  const textDivs = task._textDivs;
                  const capability = task._capability;
                  const textDivsLength = textDivs.length;
                  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                    task._renderingDone = true;
                    capability.resolve();
                    return;
                  }
                  if (!task._textContentStream) {
                    for (let i = 0; i < textDivsLength; i++) {
                      task._layoutText(textDivs[i]);
                    }
                  }
                  task._renderingDone = true;
                  capability.resolve();
                }
                function findPositiveMin(ts, offset, count) {
                  let result = 0;
                  for (let i = 0; i < count; i++) {
                    const t = ts[offset++];
                    if (t > 0) {
                      result = result ? Math.min(t, result) : t;
                    }
                  }
                  return result;
                }
                function expand(task) {
                  const bounds = task._bounds;
                  const viewport = task._viewport;
                  const expanded = expandBounds(viewport.width, viewport.height, bounds);
                  for (let i = 0; i < expanded.length; i++) {
                    const div = bounds[i].div;
                    const divProperties = task._textDivProperties.get(div);
                    if (divProperties.angle === 0) {
                      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                      divProperties.paddingTop = bounds[i].top - expanded[i].top;
                      divProperties.paddingRight = expanded[i].right - bounds[i].right;
                      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                      task._textDivProperties.set(div, divProperties);
                      continue;
                    }
                    const e = expanded[i], b = bounds[i];
                    const m = b.m, c = m[0], s = m[1];
                    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                    const ts = new Float64Array(64);
                    for (let j = 0, jj = points.length; j < jj; j++) {
                      const t = _util2.Util.applyTransform(points[j], m);
                      ts[j + 0] = c && (e.left - t[0]) / c;
                      ts[j + 4] = s && (e.top - t[1]) / s;
                      ts[j + 8] = c && (e.right - t[0]) / c;
                      ts[j + 12] = s && (e.bottom - t[1]) / s;
                      ts[j + 16] = s && (e.left - t[0]) / -s;
                      ts[j + 20] = c && (e.top - t[1]) / c;
                      ts[j + 24] = s && (e.right - t[0]) / -s;
                      ts[j + 28] = c && (e.bottom - t[1]) / c;
                      ts[j + 32] = c && (e.left - t[0]) / -c;
                      ts[j + 36] = s && (e.top - t[1]) / -s;
                      ts[j + 40] = c && (e.right - t[0]) / -c;
                      ts[j + 44] = s && (e.bottom - t[1]) / -s;
                      ts[j + 48] = s && (e.left - t[0]) / s;
                      ts[j + 52] = c && (e.top - t[1]) / -c;
                      ts[j + 56] = s && (e.right - t[0]) / s;
                      ts[j + 60] = c && (e.bottom - t[1]) / -c;
                    }
                    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                    task._textDivProperties.set(div, divProperties);
                  }
                }
                function expandBounds(width, height, boxes) {
                  const bounds = boxes.map(function(box, i) {
                    return {
                      x1: box.left,
                      y1: box.top,
                      x2: box.right,
                      y2: box.bottom,
                      index: i,
                      x1New: void 0,
                      x2New: void 0
                    };
                  });
                  expandBoundsLTR(width, bounds);
                  const expanded = new Array(boxes.length);
                  for (const b of bounds) {
                    const i = b.index;
                    expanded[i] = {
                      left: b.x1New,
                      top: 0,
                      right: b.x2New,
                      bottom: 0
                    };
                  }
                  boxes.map(function(box, i) {
                    const e = expanded[i], b = bounds[i];
                    b.x1 = box.top;
                    b.y1 = width - e.right;
                    b.x2 = box.bottom;
                    b.y2 = width - e.left;
                    b.index = i;
                    b.x1New = void 0;
                    b.x2New = void 0;
                  });
                  expandBoundsLTR(height, bounds);
                  for (const b of bounds) {
                    const i = b.index;
                    expanded[i].top = b.x1New;
                    expanded[i].bottom = b.x2New;
                  }
                  return expanded;
                }
                function expandBoundsLTR(width, bounds) {
                  bounds.sort(function(a, b) {
                    return a.x1 - b.x1 || a.index - b.index;
                  });
                  const fakeBoundary = {
                    x1: -Infinity,
                    y1: -Infinity,
                    x2: 0,
                    y2: Infinity,
                    index: -1,
                    x1New: 0,
                    x2New: 0
                  };
                  const horizon = [{
                    start: -Infinity,
                    end: Infinity,
                    boundary: fakeBoundary
                  }];
                  for (const boundary of bounds) {
                    let i = 0;
                    while (i < horizon.length && horizon[i].end <= boundary.y1) {
                      i++;
                    }
                    let j = horizon.length - 1;
                    while (j >= 0 && horizon[j].start >= boundary.y2) {
                      j--;
                    }
                    let horizonPart, affectedBoundary;
                    let q, k, maxXNew = -Infinity;
                    for (q = i; q <= j; q++) {
                      horizonPart = horizon[q];
                      affectedBoundary = horizonPart.boundary;
                      let xNew;
                      if (affectedBoundary.x2 > boundary.x1) {
                        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                      } else if (affectedBoundary.x2New === void 0) {
                        xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                      } else {
                        xNew = affectedBoundary.x2New;
                      }
                      if (xNew > maxXNew) {
                        maxXNew = xNew;
                      }
                    }
                    boundary.x1New = maxXNew;
                    for (q = i; q <= j; q++) {
                      horizonPart = horizon[q];
                      affectedBoundary = horizonPart.boundary;
                      if (affectedBoundary.x2New === void 0) {
                        if (affectedBoundary.x2 > boundary.x1) {
                          if (affectedBoundary.index > boundary.index) {
                            affectedBoundary.x2New = affectedBoundary.x2;
                          }
                        } else {
                          affectedBoundary.x2New = maxXNew;
                        }
                      } else if (affectedBoundary.x2New > maxXNew) {
                        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                      }
                    }
                    const changedHorizon = [];
                    let lastBoundary = null;
                    for (q = i; q <= j; q++) {
                      horizonPart = horizon[q];
                      affectedBoundary = horizonPart.boundary;
                      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                      if (lastBoundary === useBoundary) {
                        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                      } else {
                        changedHorizon.push({
                          start: horizonPart.start,
                          end: horizonPart.end,
                          boundary: useBoundary
                        });
                        lastBoundary = useBoundary;
                      }
                    }
                    if (horizon[i].start < boundary.y1) {
                      changedHorizon[0].start = boundary.y1;
                      changedHorizon.unshift({
                        start: horizon[i].start,
                        end: boundary.y1,
                        boundary: horizon[i].boundary
                      });
                    }
                    if (boundary.y2 < horizon[j].end) {
                      changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                      changedHorizon.push({
                        start: boundary.y2,
                        end: horizon[j].end,
                        boundary: horizon[j].boundary
                      });
                    }
                    for (q = i; q <= j; q++) {
                      horizonPart = horizon[q];
                      affectedBoundary = horizonPart.boundary;
                      if (affectedBoundary.x2New !== void 0) {
                        continue;
                      }
                      let used = false;
                      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                        used = horizon[k].boundary === affectedBoundary;
                      }
                      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                        used = horizon[k].boundary === affectedBoundary;
                      }
                      for (k = 0; !used && k < changedHorizon.length; k++) {
                        used = changedHorizon[k].boundary === affectedBoundary;
                      }
                      if (!used) {
                        affectedBoundary.x2New = maxXNew;
                      }
                    }
                    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                  }
                  for (const horizonPart of horizon) {
                    const affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                    }
                  }
                }
                class TextLayerRenderTask {
                  constructor({
                    textContent,
                    textContentStream,
                    container,
                    viewport,
                    textDivs,
                    textContentItemsStr,
                    enhanceTextSelection
                  }) {
                    var _a;
                    this._textContent = textContent;
                    this._textContentStream = textContentStream;
                    this._container = container;
                    this._document = container.ownerDocument;
                    this._viewport = viewport;
                    this._textDivs = textDivs || [];
                    this._textContentItemsStr = textContentItemsStr || [];
                    this._enhanceTextSelection = !!enhanceTextSelection;
                    this._fontInspectorEnabled = !!((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled);
                    this._reader = null;
                    this._layoutTextLastFontSize = null;
                    this._layoutTextLastFontFamily = null;
                    this._layoutTextCtx = null;
                    this._textDivProperties = /* @__PURE__ */ new WeakMap();
                    this._renderingDone = false;
                    this._canceled = false;
                    this._capability = (0, _util2.createPromiseCapability)();
                    this._renderTimer = null;
                    this._bounds = [];
                    this._capability.promise.finally(() => {
                      if (!this._enhanceTextSelection) {
                        this._textDivProperties = null;
                      }
                      if (this._layoutTextCtx) {
                        this._layoutTextCtx.canvas.width = 0;
                        this._layoutTextCtx.canvas.height = 0;
                        this._layoutTextCtx = null;
                      }
                    }).catch(() => {
                    });
                  }
                  get promise() {
                    return this._capability.promise;
                  }
                  cancel() {
                    this._canceled = true;
                    if (this._reader) {
                      this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                      });
                      this._reader = null;
                    }
                    if (this._renderTimer !== null) {
                      clearTimeout(this._renderTimer);
                      this._renderTimer = null;
                    }
                    this._capability.reject(new Error("TextLayer task cancelled."));
                  }
                  _processItems(items, styleCache) {
                    for (let i = 0, len = items.length; i < len; i++) {
                      if (items[i].str === void 0) {
                        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                          const parent = this._container;
                          this._container = document.createElement("span");
                          this._container.classList.add("markedContent");
                          if (items[i].id !== null) {
                            this._container.setAttribute("id", `${items[i].id}`);
                          }
                          parent.appendChild(this._container);
                        } else if (items[i].type === "endMarkedContent") {
                          this._container = this._container.parentNode;
                        }
                        continue;
                      }
                      this._textContentItemsStr.push(items[i].str);
                      appendText(this, items[i], styleCache, this._layoutTextCtx);
                    }
                  }
                  _layoutText(textDiv) {
                    const textDivProperties = this._textDivProperties.get(textDiv);
                    let transform = "";
                    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                      const {
                        fontSize,
                        fontFamily
                      } = textDiv.style;
                      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
                        this._layoutTextLastFontSize = fontSize;
                        this._layoutTextLastFontFamily = fontFamily;
                      }
                      const {
                        width
                      } = this._layoutTextCtx.measureText(textDiv.textContent);
                      if (width > 0) {
                        const scale = textDivProperties.canvasWidth / width;
                        if (this._enhanceTextSelection) {
                          textDivProperties.scale = scale;
                        }
                        transform = `scaleX(${scale})`;
                      }
                    }
                    if (textDivProperties.angle !== 0) {
                      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                    }
                    if (transform.length > 0) {
                      if (this._enhanceTextSelection) {
                        textDivProperties.originalTransform = transform;
                      }
                      textDiv.style.transform = transform;
                    }
                    if (textDivProperties.hasText) {
                      this._container.appendChild(textDiv);
                    }
                    if (textDivProperties.hasEOL) {
                      const br = document.createElement("br");
                      br.setAttribute("role", "presentation");
                      this._container.appendChild(br);
                    }
                  }
                  _render(timeout = 0) {
                    const capability = (0, _util2.createPromiseCapability)();
                    let styleCache = /* @__PURE__ */ Object.create(null);
                    const canvas = this._document.createElement("canvas");
                    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                    this._layoutTextCtx = canvas.getContext("2d", {
                      alpha: false
                    });
                    if (this._textContent) {
                      const textItems = this._textContent.items;
                      const textStyles = this._textContent.styles;
                      this._processItems(textItems, textStyles);
                      capability.resolve();
                    } else if (this._textContentStream) {
                      const pump = () => {
                        this._reader.read().then(({
                          value,
                          done
                        }) => {
                          if (done) {
                            capability.resolve();
                            return;
                          }
                          Object.assign(styleCache, value.styles);
                          this._processItems(value.items, styleCache);
                          pump();
                        }, capability.reject);
                      };
                      this._reader = this._textContentStream.getReader();
                      pump();
                    } else {
                      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                    }
                    capability.promise.then(() => {
                      styleCache = null;
                      if (!timeout) {
                        render(this);
                      } else {
                        this._renderTimer = setTimeout(() => {
                          render(this);
                          this._renderTimer = null;
                        }, timeout);
                      }
                    }, this._capability.reject);
                  }
                  expandTextDivs(expandDivs = false) {
                    if (!this._enhanceTextSelection || !this._renderingDone) {
                      return;
                    }
                    if (this._bounds !== null) {
                      expand(this);
                      this._bounds = null;
                    }
                    const transformBuf = [], paddingBuf = [];
                    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                      const div = this._textDivs[i];
                      const divProps = this._textDivProperties.get(div);
                      if (!divProps.hasText) {
                        continue;
                      }
                      if (expandDivs) {
                        transformBuf.length = 0;
                        paddingBuf.length = 0;
                        if (divProps.originalTransform) {
                          transformBuf.push(divProps.originalTransform);
                        }
                        if (divProps.paddingTop > 0) {
                          paddingBuf.push(`${divProps.paddingTop}px`);
                          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingRight > 0) {
                          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingBottom > 0) {
                          paddingBuf.push(`${divProps.paddingBottom}px`);
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingLeft > 0) {
                          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                        } else {
                          paddingBuf.push(0);
                        }
                        div.style.padding = paddingBuf.join(" ");
                        if (transformBuf.length) {
                          div.style.transform = transformBuf.join(" ");
                        }
                      } else {
                        div.style.padding = null;
                        div.style.transform = divProps.originalTransform;
                      }
                    }
                  }
                }
                function renderTextLayer(renderParameters) {
                  const task = new TextLayerRenderTask({
                    textContent: renderParameters.textContent,
                    textContentStream: renderParameters.textContentStream,
                    container: renderParameters.container,
                    viewport: renderParameters.viewport,
                    textDivs: renderParameters.textDivs,
                    textContentItemsStr: renderParameters.textContentItemsStr,
                    enhanceTextSelection: renderParameters.enhanceTextSelection
                  });
                  task._render(renderParameters.timeout);
                  return task;
                }
              },
              /* 24 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.SVGGraphics = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _display_utils2 = __w_pdfjs_require__2(5);
                var _is_node2 = __w_pdfjs_require__2(3);
                let SVGGraphics = class {
                  constructor() {
                    (0, _util2.unreachable)("Not implemented: SVGGraphics");
                  }
                };
                exports2.SVGGraphics = SVGGraphics;
                {
                  let opListToTree = function(opList) {
                    let opTree = [];
                    const tmp = [];
                    for (const opListElement of opList) {
                      if (opListElement.fn === "save") {
                        opTree.push({
                          fnId: 92,
                          fn: "group",
                          items: []
                        });
                        tmp.push(opTree);
                        opTree = opTree[opTree.length - 1].items;
                        continue;
                      }
                      if (opListElement.fn === "restore") {
                        opTree = tmp.pop();
                      } else {
                        opTree.push(opListElement);
                      }
                    }
                    return opTree;
                  }, pf = function(value) {
                    if (Number.isInteger(value)) {
                      return value.toString();
                    }
                    const s = value.toFixed(10);
                    let i = s.length - 1;
                    if (s[i] !== "0") {
                      return s;
                    }
                    do {
                      i--;
                    } while (s[i] === "0");
                    return s.substring(0, s[i] === "." ? i : i + 1);
                  }, pm = function(m) {
                    if (m[4] === 0 && m[5] === 0) {
                      if (m[1] === 0 && m[2] === 0) {
                        if (m[0] === 1 && m[3] === 1) {
                          return "";
                        }
                        return `scale(${pf(m[0])} ${pf(m[3])})`;
                      }
                      if (m[0] === m[3] && m[1] === -m[2]) {
                        const a = Math.acos(m[0]) * 180 / Math.PI;
                        return `rotate(${pf(a)})`;
                      }
                    } else {
                      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                        return `translate(${pf(m[4])} ${pf(m[5])})`;
                      }
                    }
                    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
                  };
                  const SVG_DEFAULTS = {
                    fontStyle: "normal",
                    fontWeight: "normal",
                    fillColor: "#000000"
                  };
                  const XML_NS = "http://www.w3.org/XML/1998/namespace";
                  const XLINK_NS = "http://www.w3.org/1999/xlink";
                  const LINE_CAP_STYLES = ["butt", "round", "square"];
                  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                  const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                    if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                      return URL.createObjectURL(new Blob([data], {
                        type: contentType
                      }));
                    }
                    const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    let buffer = `data:${contentType};base64,`;
                    for (let i = 0, ii = data.length; i < ii; i += 3) {
                      const b1 = data[i] & 255;
                      const b2 = data[i + 1] & 255;
                      const b3 = data[i + 2] & 255;
                      const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                      const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                      const d4 = i + 2 < ii ? b3 & 63 : 64;
                      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                    }
                    return buffer;
                  };
                  const convertImgDataToPng = function() {
                    const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                    const CHUNK_WRAPPER_SIZE = 12;
                    const crcTable = new Int32Array(256);
                    for (let i = 0; i < 256; i++) {
                      let c = i;
                      for (let h = 0; h < 8; h++) {
                        if (c & 1) {
                          c = 3988292384 ^ c >> 1 & 2147483647;
                        } else {
                          c = c >> 1 & 2147483647;
                        }
                      }
                      crcTable[i] = c;
                    }
                    function crc32(data, start, end) {
                      let crc = -1;
                      for (let i = start; i < end; i++) {
                        const a = (crc ^ data[i]) & 255;
                        const b = crcTable[a];
                        crc = crc >>> 8 ^ b;
                      }
                      return crc ^ -1;
                    }
                    function writePngChunk(type, body, data, offset) {
                      let p = offset;
                      const len = body.length;
                      data[p] = len >> 24 & 255;
                      data[p + 1] = len >> 16 & 255;
                      data[p + 2] = len >> 8 & 255;
                      data[p + 3] = len & 255;
                      p += 4;
                      data[p] = type.charCodeAt(0) & 255;
                      data[p + 1] = type.charCodeAt(1) & 255;
                      data[p + 2] = type.charCodeAt(2) & 255;
                      data[p + 3] = type.charCodeAt(3) & 255;
                      p += 4;
                      data.set(body, p);
                      p += body.length;
                      const crc = crc32(data, offset + 4, p);
                      data[p] = crc >> 24 & 255;
                      data[p + 1] = crc >> 16 & 255;
                      data[p + 2] = crc >> 8 & 255;
                      data[p + 3] = crc & 255;
                    }
                    function adler32(data, start, end) {
                      let a = 1;
                      let b = 0;
                      for (let i = start; i < end; ++i) {
                        a = (a + (data[i] & 255)) % 65521;
                        b = (b + a) % 65521;
                      }
                      return b << 16 | a;
                    }
                    function deflateSync(literals) {
                      if (!_is_node2.isNodeJS) {
                        return deflateSyncUncompressed(literals);
                      }
                      try {
                        let input;
                        if (parseInt(process.versions.node) >= 8) {
                          input = literals;
                        } else {
                          input = Buffer.from(literals);
                        }
                        const output = require_zlib().deflateSync(input, {
                          level: 9
                        });
                        return output instanceof Uint8Array ? output : new Uint8Array(output);
                      } catch (e) {
                        (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                      }
                      return deflateSyncUncompressed(literals);
                    }
                    function deflateSyncUncompressed(literals) {
                      let len = literals.length;
                      const maxBlockLength = 65535;
                      const deflateBlocks = Math.ceil(len / maxBlockLength);
                      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                      let pi = 0;
                      idat[pi++] = 120;
                      idat[pi++] = 156;
                      let pos = 0;
                      while (len > maxBlockLength) {
                        idat[pi++] = 0;
                        idat[pi++] = 255;
                        idat[pi++] = 255;
                        idat[pi++] = 0;
                        idat[pi++] = 0;
                        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                        pi += maxBlockLength;
                        pos += maxBlockLength;
                        len -= maxBlockLength;
                      }
                      idat[pi++] = 1;
                      idat[pi++] = len & 255;
                      idat[pi++] = len >> 8 & 255;
                      idat[pi++] = ~len & 65535 & 255;
                      idat[pi++] = (~len & 65535) >> 8 & 255;
                      idat.set(literals.subarray(pos), pi);
                      pi += literals.length - pos;
                      const adler = adler32(literals, 0, literals.length);
                      idat[pi++] = adler >> 24 & 255;
                      idat[pi++] = adler >> 16 & 255;
                      idat[pi++] = adler >> 8 & 255;
                      idat[pi++] = adler & 255;
                      return idat;
                    }
                    function encode(imgData, kind, forceDataSchema, isMask) {
                      const width = imgData.width;
                      const height = imgData.height;
                      let bitDepth, colorType, lineSize;
                      const bytes = imgData.data;
                      switch (kind) {
                        case _util2.ImageKind.GRAYSCALE_1BPP:
                          colorType = 0;
                          bitDepth = 1;
                          lineSize = width + 7 >> 3;
                          break;
                        case _util2.ImageKind.RGB_24BPP:
                          colorType = 2;
                          bitDepth = 8;
                          lineSize = width * 3;
                          break;
                        case _util2.ImageKind.RGBA_32BPP:
                          colorType = 6;
                          bitDepth = 8;
                          lineSize = width * 4;
                          break;
                        default:
                          throw new Error("invalid format");
                      }
                      const literals = new Uint8Array((1 + lineSize) * height);
                      let offsetLiterals = 0, offsetBytes = 0;
                      for (let y = 0; y < height; ++y) {
                        literals[offsetLiterals++] = 0;
                        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                        offsetBytes += lineSize;
                        offsetLiterals += lineSize;
                      }
                      if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                        offsetLiterals = 0;
                        for (let y = 0; y < height; y++) {
                          offsetLiterals++;
                          for (let i = 0; i < lineSize; i++) {
                            literals[offsetLiterals++] ^= 255;
                          }
                        }
                      }
                      const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                      const idat = deflateSync(literals);
                      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                      const data = new Uint8Array(pngLength);
                      let offset = 0;
                      data.set(PNG_HEADER, offset);
                      offset += PNG_HEADER.length;
                      writePngChunk("IHDR", ihdr, data, offset);
                      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                      writePngChunk("IDATA", idat, data, offset);
                      offset += CHUNK_WRAPPER_SIZE + idat.length;
                      writePngChunk("IEND", new Uint8Array(0), data, offset);
                      return createObjectURL(data, "image/png", forceDataSchema);
                    }
                    return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                      const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                      return encode(imgData, kind, forceDataSchema, isMask);
                    };
                  }();
                  class SVGExtraState {
                    constructor() {
                      this.fontSizeScale = 1;
                      this.fontWeight = SVG_DEFAULTS.fontWeight;
                      this.fontSize = 0;
                      this.textMatrix = _util2.IDENTITY_MATRIX;
                      this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                      this.leading = 0;
                      this.textRenderingMode = _util2.TextRenderingMode.FILL;
                      this.textMatrixScale = 1;
                      this.x = 0;
                      this.y = 0;
                      this.lineX = 0;
                      this.lineY = 0;
                      this.charSpacing = 0;
                      this.wordSpacing = 0;
                      this.textHScale = 1;
                      this.textRise = 0;
                      this.fillColor = SVG_DEFAULTS.fillColor;
                      this.strokeColor = "#000000";
                      this.fillAlpha = 1;
                      this.strokeAlpha = 1;
                      this.lineWidth = 1;
                      this.lineJoin = "";
                      this.lineCap = "";
                      this.miterLimit = 0;
                      this.dashArray = [];
                      this.dashPhase = 0;
                      this.dependencies = [];
                      this.activeClipUrl = null;
                      this.clipGroup = null;
                      this.maskId = "";
                    }
                    clone() {
                      return Object.create(this);
                    }
                    setCurrentPoint(x, y) {
                      this.x = x;
                      this.y = y;
                    }
                  }
                  let clipCount = 0;
                  let maskCount = 0;
                  let shadingCount = 0;
                  exports2.SVGGraphics = SVGGraphics = class {
                    constructor(commonObjs, objs, forceDataSchema = false) {
                      this.svgFactory = new _display_utils2.DOMSVGFactory();
                      this.current = new SVGExtraState();
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.transformStack = [];
                      this.extraStack = [];
                      this.commonObjs = commonObjs;
                      this.objs = objs;
                      this.pendingClip = null;
                      this.pendingEOFill = false;
                      this.embedFonts = false;
                      this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                      this.cssStyle = null;
                      this.forceDataSchema = !!forceDataSchema;
                      this._operatorIdMapping = [];
                      for (const op in _util2.OPS) {
                        this._operatorIdMapping[_util2.OPS[op]] = op;
                      }
                    }
                    save() {
                      this.transformStack.push(this.transformMatrix);
                      const old = this.current;
                      this.extraStack.push(old);
                      this.current = old.clone();
                    }
                    restore() {
                      this.transformMatrix = this.transformStack.pop();
                      this.current = this.extraStack.pop();
                      this.pendingClip = null;
                      this.tgrp = null;
                    }
                    group(items) {
                      this.save();
                      this.executeOpTree(items);
                      this.restore();
                    }
                    loadDependencies(operatorList) {
                      const fnArray = operatorList.fnArray;
                      const argsArray = operatorList.argsArray;
                      for (let i = 0, ii = fnArray.length; i < ii; i++) {
                        if (fnArray[i] !== _util2.OPS.dependency) {
                          continue;
                        }
                        for (const obj of argsArray[i]) {
                          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                          const promise = new Promise((resolve) => {
                            objsPool.get(obj, resolve);
                          });
                          this.current.dependencies.push(promise);
                        }
                      }
                      return Promise.all(this.current.dependencies);
                    }
                    transform(a, b, c, d, e, f) {
                      const transformMatrix = [a, b, c, d, e, f];
                      this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                      this.tgrp = null;
                    }
                    getSVG(operatorList, viewport) {
                      this.viewport = viewport;
                      const svgElement = this._initialize(viewport);
                      return this.loadDependencies(operatorList).then(() => {
                        this.transformMatrix = _util2.IDENTITY_MATRIX;
                        this.executeOpTree(this.convertOpList(operatorList));
                        return svgElement;
                      });
                    }
                    convertOpList(operatorList) {
                      const operatorIdMapping = this._operatorIdMapping;
                      const argsArray = operatorList.argsArray;
                      const fnArray = operatorList.fnArray;
                      const opList = [];
                      for (let i = 0, ii = fnArray.length; i < ii; i++) {
                        const fnId = fnArray[i];
                        opList.push({
                          fnId,
                          fn: operatorIdMapping[fnId],
                          args: argsArray[i]
                        });
                      }
                      return opListToTree(opList);
                    }
                    executeOpTree(opTree) {
                      for (const opTreeElement of opTree) {
                        const fn = opTreeElement.fn;
                        const fnId = opTreeElement.fnId;
                        const args = opTreeElement.args;
                        switch (fnId | 0) {
                          case _util2.OPS.beginText:
                            this.beginText();
                            break;
                          case _util2.OPS.dependency:
                            break;
                          case _util2.OPS.setLeading:
                            this.setLeading(args);
                            break;
                          case _util2.OPS.setLeadingMoveText:
                            this.setLeadingMoveText(args[0], args[1]);
                            break;
                          case _util2.OPS.setFont:
                            this.setFont(args);
                            break;
                          case _util2.OPS.showText:
                            this.showText(args[0]);
                            break;
                          case _util2.OPS.showSpacedText:
                            this.showText(args[0]);
                            break;
                          case _util2.OPS.endText:
                            this.endText();
                            break;
                          case _util2.OPS.moveText:
                            this.moveText(args[0], args[1]);
                            break;
                          case _util2.OPS.setCharSpacing:
                            this.setCharSpacing(args[0]);
                            break;
                          case _util2.OPS.setWordSpacing:
                            this.setWordSpacing(args[0]);
                            break;
                          case _util2.OPS.setHScale:
                            this.setHScale(args[0]);
                            break;
                          case _util2.OPS.setTextMatrix:
                            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                            break;
                          case _util2.OPS.setTextRise:
                            this.setTextRise(args[0]);
                            break;
                          case _util2.OPS.setTextRenderingMode:
                            this.setTextRenderingMode(args[0]);
                            break;
                          case _util2.OPS.setLineWidth:
                            this.setLineWidth(args[0]);
                            break;
                          case _util2.OPS.setLineJoin:
                            this.setLineJoin(args[0]);
                            break;
                          case _util2.OPS.setLineCap:
                            this.setLineCap(args[0]);
                            break;
                          case _util2.OPS.setMiterLimit:
                            this.setMiterLimit(args[0]);
                            break;
                          case _util2.OPS.setFillRGBColor:
                            this.setFillRGBColor(args[0], args[1], args[2]);
                            break;
                          case _util2.OPS.setStrokeRGBColor:
                            this.setStrokeRGBColor(args[0], args[1], args[2]);
                            break;
                          case _util2.OPS.setStrokeColorN:
                            this.setStrokeColorN(args);
                            break;
                          case _util2.OPS.setFillColorN:
                            this.setFillColorN(args);
                            break;
                          case _util2.OPS.shadingFill:
                            this.shadingFill(args[0]);
                            break;
                          case _util2.OPS.setDash:
                            this.setDash(args[0], args[1]);
                            break;
                          case _util2.OPS.setRenderingIntent:
                            this.setRenderingIntent(args[0]);
                            break;
                          case _util2.OPS.setFlatness:
                            this.setFlatness(args[0]);
                            break;
                          case _util2.OPS.setGState:
                            this.setGState(args[0]);
                            break;
                          case _util2.OPS.fill:
                            this.fill();
                            break;
                          case _util2.OPS.eoFill:
                            this.eoFill();
                            break;
                          case _util2.OPS.stroke:
                            this.stroke();
                            break;
                          case _util2.OPS.fillStroke:
                            this.fillStroke();
                            break;
                          case _util2.OPS.eoFillStroke:
                            this.eoFillStroke();
                            break;
                          case _util2.OPS.clip:
                            this.clip("nonzero");
                            break;
                          case _util2.OPS.eoClip:
                            this.clip("evenodd");
                            break;
                          case _util2.OPS.paintSolidColorImageMask:
                            this.paintSolidColorImageMask();
                            break;
                          case _util2.OPS.paintImageXObject:
                            this.paintImageXObject(args[0]);
                            break;
                          case _util2.OPS.paintInlineImageXObject:
                            this.paintInlineImageXObject(args[0]);
                            break;
                          case _util2.OPS.paintImageMaskXObject:
                            this.paintImageMaskXObject(args[0]);
                            break;
                          case _util2.OPS.paintFormXObjectBegin:
                            this.paintFormXObjectBegin(args[0], args[1]);
                            break;
                          case _util2.OPS.paintFormXObjectEnd:
                            this.paintFormXObjectEnd();
                            break;
                          case _util2.OPS.closePath:
                            this.closePath();
                            break;
                          case _util2.OPS.closeStroke:
                            this.closeStroke();
                            break;
                          case _util2.OPS.closeFillStroke:
                            this.closeFillStroke();
                            break;
                          case _util2.OPS.closeEOFillStroke:
                            this.closeEOFillStroke();
                            break;
                          case _util2.OPS.nextLine:
                            this.nextLine();
                            break;
                          case _util2.OPS.transform:
                            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                            break;
                          case _util2.OPS.constructPath:
                            this.constructPath(args[0], args[1]);
                            break;
                          case _util2.OPS.endPath:
                            this.endPath();
                            break;
                          case 92:
                            this.group(opTreeElement.items);
                            break;
                          default:
                            (0, _util2.warn)(`Unimplemented operator ${fn}`);
                            break;
                        }
                      }
                    }
                    setWordSpacing(wordSpacing) {
                      this.current.wordSpacing = wordSpacing;
                    }
                    setCharSpacing(charSpacing) {
                      this.current.charSpacing = charSpacing;
                    }
                    nextLine() {
                      this.moveText(0, this.current.leading);
                    }
                    setTextMatrix(a, b, c, d, e, f) {
                      const current = this.current;
                      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                      current.textMatrixScale = Math.hypot(a, b);
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.xcoords = [];
                      current.ycoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtElement.appendChild(current.tspan);
                    }
                    beginText() {
                      const current = this.current;
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.textMatrix = _util2.IDENTITY_MATRIX;
                      current.lineMatrix = _util2.IDENTITY_MATRIX;
                      current.textMatrixScale = 1;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtgrp = this.svgFactory.createElement("svg:g");
                      current.xcoords = [];
                      current.ycoords = [];
                    }
                    moveText(x, y) {
                      const current = this.current;
                      current.x = current.lineX += x;
                      current.y = current.lineY += y;
                      current.xcoords = [];
                      current.ycoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    showText(glyphs) {
                      const current = this.current;
                      const font = current.font;
                      const fontSize = current.fontSize;
                      if (fontSize === 0) {
                        return;
                      }
                      const fontSizeScale = current.fontSizeScale;
                      const charSpacing = current.charSpacing;
                      const wordSpacing = current.wordSpacing;
                      const fontDirection = current.fontDirection;
                      const textHScale = current.textHScale * fontDirection;
                      const vertical = font.vertical;
                      const spacingDir = vertical ? 1 : -1;
                      const defaultVMetrics = font.defaultVMetrics;
                      const widthAdvanceScale = fontSize * current.fontMatrix[0];
                      let x = 0;
                      for (const glyph of glyphs) {
                        if (glyph === null) {
                          x += fontDirection * wordSpacing;
                          continue;
                        } else if (typeof glyph === "number") {
                          x += spacingDir * glyph * fontSize / 1e3;
                          continue;
                        }
                        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                        const character = glyph.fontChar;
                        let scaledX, scaledY;
                        let width = glyph.width;
                        if (vertical) {
                          let vx;
                          const vmetric = glyph.vmetric || defaultVMetrics;
                          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                          vx = -vx * widthAdvanceScale;
                          const vy = vmetric[2] * widthAdvanceScale;
                          width = vmetric ? -vmetric[0] : width;
                          scaledX = vx / fontSizeScale;
                          scaledY = (x + vy) / fontSizeScale;
                        } else {
                          scaledX = x / fontSizeScale;
                          scaledY = 0;
                        }
                        if (glyph.isInFont || font.missingFile) {
                          current.xcoords.push(current.x + scaledX);
                          if (vertical) {
                            current.ycoords.push(-current.y + scaledY);
                          }
                          current.tspan.textContent += character;
                        } else {
                        }
                        let charWidth;
                        if (vertical) {
                          charWidth = width * widthAdvanceScale - spacing * fontDirection;
                        } else {
                          charWidth = width * widthAdvanceScale + spacing * fontDirection;
                        }
                        x += charWidth;
                      }
                      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                      if (vertical) {
                        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                      } else {
                        current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      }
                      if (vertical) {
                        current.y -= x;
                      } else {
                        current.x += x * textHScale;
                      }
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                      }
                      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                      }
                      const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                          current.tspan.setAttributeNS(null, "fill", current.fillColor);
                        }
                        if (current.fillAlpha < 1) {
                          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        }
                      } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                        current.tspan.setAttributeNS(null, "fill", "transparent");
                      } else {
                        current.tspan.setAttributeNS(null, "fill", "none");
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        const lineWidthScale = 1 / (current.textMatrixScale || 1);
                        this._setStrokeAttributes(current.tspan, lineWidthScale);
                      }
                      let textMatrix = current.textMatrix;
                      if (current.textRise !== 0) {
                        textMatrix = textMatrix.slice();
                        textMatrix[5] += current.textRise;
                      }
                      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                      current.txtElement.appendChild(current.tspan);
                      current.txtgrp.appendChild(current.txtElement);
                      this._ensureTransformGroup().appendChild(current.txtElement);
                    }
                    setLeadingMoveText(x, y) {
                      this.setLeading(-y);
                      this.moveText(x, y);
                    }
                    addFontStyle(fontObj) {
                      if (!fontObj.data) {
                        throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                      }
                      if (!this.cssStyle) {
                        this.cssStyle = this.svgFactory.createElement("svg:style");
                        this.cssStyle.setAttributeNS(null, "type", "text/css");
                        this.defs.appendChild(this.cssStyle);
                      }
                      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                    }
                    setFont(details) {
                      const current = this.current;
                      const fontObj = this.commonObjs.get(details[0]);
                      let size = details[1];
                      current.font = fontObj;
                      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                        this.addFontStyle(fontObj);
                        this.embeddedFonts[fontObj.loadedName] = fontObj;
                      }
                      current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                      let bold = "normal";
                      if (fontObj.black) {
                        bold = "900";
                      } else if (fontObj.bold) {
                        bold = "bold";
                      }
                      const italic = fontObj.italic ? "italic" : "normal";
                      if (size < 0) {
                        size = -size;
                        current.fontDirection = -1;
                      } else {
                        current.fontDirection = 1;
                      }
                      current.fontSize = size;
                      current.fontFamily = fontObj.loadedName;
                      current.fontWeight = bold;
                      current.fontStyle = italic;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.xcoords = [];
                      current.ycoords = [];
                    }
                    endText() {
                      var _a;
                      const current = this.current;
                      if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && ((_a = current.txtElement) == null ? void 0 : _a.hasChildNodes())) {
                        current.element = current.txtElement;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    }
                    setLineWidth(width) {
                      if (width > 0) {
                        this.current.lineWidth = width;
                      }
                    }
                    setLineCap(style) {
                      this.current.lineCap = LINE_CAP_STYLES[style];
                    }
                    setLineJoin(style) {
                      this.current.lineJoin = LINE_JOIN_STYLES[style];
                    }
                    setMiterLimit(limit) {
                      this.current.miterLimit = limit;
                    }
                    setStrokeAlpha(strokeAlpha) {
                      this.current.strokeAlpha = strokeAlpha;
                    }
                    setStrokeRGBColor(r, g, b) {
                      this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                    }
                    setFillAlpha(fillAlpha) {
                      this.current.fillAlpha = fillAlpha;
                    }
                    setFillRGBColor(r, g, b) {
                      this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                      this.current.tspan = this.svgFactory.createElement("svg:tspan");
                      this.current.xcoords = [];
                      this.current.ycoords = [];
                    }
                    setStrokeColorN(args) {
                      this.current.strokeColor = this._makeColorN_Pattern(args);
                    }
                    setFillColorN(args) {
                      this.current.fillColor = this._makeColorN_Pattern(args);
                    }
                    shadingFill(args) {
                      const width = this.viewport.width;
                      const height = this.viewport.height;
                      const inv = _util2.Util.inverseTransform(this.transformMatrix);
                      const bl = _util2.Util.applyTransform([0, 0], inv);
                      const br = _util2.Util.applyTransform([0, height], inv);
                      const ul = _util2.Util.applyTransform([width, 0], inv);
                      const ur = _util2.Util.applyTransform([width, height], inv);
                      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      const rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", x0);
                      rect.setAttributeNS(null, "y", y0);
                      rect.setAttributeNS(null, "width", x1 - x0);
                      rect.setAttributeNS(null, "height", y1 - y0);
                      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                      if (this.current.fillAlpha < 1) {
                        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                      }
                      this._ensureTransformGroup().appendChild(rect);
                    }
                    _makeColorN_Pattern(args) {
                      if (args[0] === "TilingPattern") {
                        return this._makeTilingPattern(args);
                      }
                      return this._makeShadingPattern(args);
                    }
                    _makeTilingPattern(args) {
                      const color = args[1];
                      const operatorList = args[2];
                      const matrix = args[3] || _util2.IDENTITY_MATRIX;
                      const [x0, y0, x1, y1] = args[4];
                      const xstep = args[5];
                      const ystep = args[6];
                      const paintType = args[7];
                      const tilingId = `shading${shadingCount++}`;
                      const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                      const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                      const txstep = xstep * xscale;
                      const tystep = ystep * yscale;
                      const tiling = this.svgFactory.createElement("svg:pattern");
                      tiling.setAttributeNS(null, "id", tilingId);
                      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                      tiling.setAttributeNS(null, "width", txstep);
                      tiling.setAttributeNS(null, "height", tystep);
                      tiling.setAttributeNS(null, "x", `${tx0}`);
                      tiling.setAttributeNS(null, "y", `${ty0}`);
                      const svg = this.svg;
                      const transformMatrix = this.transformMatrix;
                      const fillColor = this.current.fillColor;
                      const strokeColor = this.current.strokeColor;
                      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                      this.svg = bbox;
                      this.transformMatrix = matrix;
                      if (paintType === 2) {
                        const cssColor = _util2.Util.makeHexColor(...color);
                        this.current.fillColor = cssColor;
                        this.current.strokeColor = cssColor;
                      }
                      this.executeOpTree(this.convertOpList(operatorList));
                      this.svg = svg;
                      this.transformMatrix = transformMatrix;
                      this.current.fillColor = fillColor;
                      this.current.strokeColor = strokeColor;
                      tiling.appendChild(bbox.childNodes[0]);
                      this.defs.appendChild(tiling);
                      return `url(#${tilingId})`;
                    }
                    _makeShadingPattern(args) {
                      if (typeof args === "string") {
                        args = this.objs.get(args);
                      }
                      switch (args[0]) {
                        case "RadialAxial":
                          const shadingId = `shading${shadingCount++}`;
                          const colorStops = args[3];
                          let gradient;
                          switch (args[1]) {
                            case "axial":
                              const point0 = args[4];
                              const point1 = args[5];
                              gradient = this.svgFactory.createElement("svg:linearGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "x1", point0[0]);
                              gradient.setAttributeNS(null, "y1", point0[1]);
                              gradient.setAttributeNS(null, "x2", point1[0]);
                              gradient.setAttributeNS(null, "y2", point1[1]);
                              break;
                            case "radial":
                              const focalPoint = args[4];
                              const circlePoint = args[5];
                              const focalRadius = args[6];
                              const circleRadius = args[7];
                              gradient = this.svgFactory.createElement("svg:radialGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "cx", circlePoint[0]);
                              gradient.setAttributeNS(null, "cy", circlePoint[1]);
                              gradient.setAttributeNS(null, "r", circleRadius);
                              gradient.setAttributeNS(null, "fx", focalPoint[0]);
                              gradient.setAttributeNS(null, "fy", focalPoint[1]);
                              gradient.setAttributeNS(null, "fr", focalRadius);
                              break;
                            default:
                              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                          }
                          for (const colorStop of colorStops) {
                            const stop = this.svgFactory.createElement("svg:stop");
                            stop.setAttributeNS(null, "offset", colorStop[0]);
                            stop.setAttributeNS(null, "stop-color", colorStop[1]);
                            gradient.appendChild(stop);
                          }
                          this.defs.appendChild(gradient);
                          return `url(#${shadingId})`;
                        case "Mesh":
                          (0, _util2.warn)("Unimplemented pattern Mesh");
                          return null;
                        case "Dummy":
                          return "hotpink";
                        default:
                          throw new Error(`Unknown IR type: ${args[0]}`);
                      }
                    }
                    setDash(dashArray, dashPhase) {
                      this.current.dashArray = dashArray;
                      this.current.dashPhase = dashPhase;
                    }
                    constructPath(ops, args) {
                      const current = this.current;
                      let x = current.x, y = current.y;
                      let d = [];
                      let j = 0;
                      for (const op of ops) {
                        switch (op | 0) {
                          case _util2.OPS.rectangle:
                            x = args[j++];
                            y = args[j++];
                            const width = args[j++];
                            const height = args[j++];
                            const xw = x + width;
                            const yh = y + height;
                            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                            break;
                          case _util2.OPS.moveTo:
                            x = args[j++];
                            y = args[j++];
                            d.push("M", pf(x), pf(y));
                            break;
                          case _util2.OPS.lineTo:
                            x = args[j++];
                            y = args[j++];
                            d.push("L", pf(x), pf(y));
                            break;
                          case _util2.OPS.curveTo:
                            x = args[j + 4];
                            y = args[j + 5];
                            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                            j += 6;
                            break;
                          case _util2.OPS.curveTo2:
                            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                            x = args[j + 2];
                            y = args[j + 3];
                            j += 4;
                            break;
                          case _util2.OPS.curveTo3:
                            x = args[j + 2];
                            y = args[j + 3];
                            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                            j += 4;
                            break;
                          case _util2.OPS.closePath:
                            d.push("Z");
                            break;
                        }
                      }
                      d = d.join(" ");
                      if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                        d = current.path.getAttributeNS(null, "d") + d;
                      } else {
                        current.path = this.svgFactory.createElement("svg:path");
                        this._ensureTransformGroup().appendChild(current.path);
                      }
                      current.path.setAttributeNS(null, "d", d);
                      current.path.setAttributeNS(null, "fill", "none");
                      current.element = current.path;
                      current.setCurrentPoint(x, y);
                    }
                    endPath() {
                      const current = this.current;
                      current.path = null;
                      if (!this.pendingClip) {
                        return;
                      }
                      if (!current.element) {
                        this.pendingClip = null;
                        return;
                      }
                      const clipId = `clippath${clipCount++}`;
                      const clipPath = this.svgFactory.createElement("svg:clipPath");
                      clipPath.setAttributeNS(null, "id", clipId);
                      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      const clipElement = current.element.cloneNode(true);
                      if (this.pendingClip === "evenodd") {
                        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                      } else {
                        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                      }
                      this.pendingClip = null;
                      clipPath.appendChild(clipElement);
                      this.defs.appendChild(clipPath);
                      if (current.activeClipUrl) {
                        current.clipGroup = null;
                        for (const prev of this.extraStack) {
                          prev.clipGroup = null;
                        }
                        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                      }
                      current.activeClipUrl = `url(#${clipId})`;
                      this.tgrp = null;
                    }
                    clip(type) {
                      this.pendingClip = type;
                    }
                    closePath() {
                      const current = this.current;
                      if (current.path) {
                        const d = `${current.path.getAttributeNS(null, "d")}Z`;
                        current.path.setAttributeNS(null, "d", d);
                      }
                    }
                    setLeading(leading) {
                      this.current.leading = -leading;
                    }
                    setTextRise(textRise) {
                      this.current.textRise = textRise;
                    }
                    setTextRenderingMode(textRenderingMode) {
                      this.current.textRenderingMode = textRenderingMode;
                    }
                    setHScale(scale) {
                      this.current.textHScale = scale / 100;
                    }
                    setRenderingIntent(intent) {
                    }
                    setFlatness(flatness) {
                    }
                    setGState(states) {
                      for (const [key, value] of states) {
                        switch (key) {
                          case "LW":
                            this.setLineWidth(value);
                            break;
                          case "LC":
                            this.setLineCap(value);
                            break;
                          case "LJ":
                            this.setLineJoin(value);
                            break;
                          case "ML":
                            this.setMiterLimit(value);
                            break;
                          case "D":
                            this.setDash(value[0], value[1]);
                            break;
                          case "RI":
                            this.setRenderingIntent(value);
                            break;
                          case "FL":
                            this.setFlatness(value);
                            break;
                          case "Font":
                            this.setFont(value);
                            break;
                          case "CA":
                            this.setStrokeAlpha(value);
                            break;
                          case "ca":
                            this.setFillAlpha(value);
                            break;
                          default:
                            (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                            break;
                        }
                      }
                    }
                    fill() {
                      const current = this.current;
                      if (current.element) {
                        current.element.setAttributeNS(null, "fill", current.fillColor);
                        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        this.endPath();
                      }
                    }
                    stroke() {
                      const current = this.current;
                      if (current.element) {
                        this._setStrokeAttributes(current.element);
                        current.element.setAttributeNS(null, "fill", "none");
                        this.endPath();
                      }
                    }
                    _setStrokeAttributes(element, lineWidthScale = 1) {
                      const current = this.current;
                      let dashArray = current.dashArray;
                      if (lineWidthScale !== 1 && dashArray.length > 0) {
                        dashArray = dashArray.map(function(value) {
                          return lineWidthScale * value;
                        });
                      }
                      element.setAttributeNS(null, "stroke", current.strokeColor);
                      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                    }
                    eoFill() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fill();
                    }
                    fillStroke() {
                      this.stroke();
                      this.fill();
                    }
                    eoFillStroke() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fillStroke();
                    }
                    closeStroke() {
                      this.closePath();
                      this.stroke();
                    }
                    closeFillStroke() {
                      this.closePath();
                      this.fillStroke();
                    }
                    closeEOFillStroke() {
                      this.closePath();
                      this.eoFillStroke();
                    }
                    paintSolidColorImageMask() {
                      const rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", "1px");
                      rect.setAttributeNS(null, "height", "1px");
                      rect.setAttributeNS(null, "fill", this.current.fillColor);
                      this._ensureTransformGroup().appendChild(rect);
                    }
                    paintImageXObject(objId) {
                      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                      if (!imgData) {
                        (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                        return;
                      }
                      this.paintInlineImageXObject(imgData);
                    }
                    paintInlineImageXObject(imgData, mask) {
                      const width = imgData.width;
                      const height = imgData.height;
                      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                      const cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", "0");
                      cliprect.setAttributeNS(null, "y", "0");
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      const imgEl = this.svgFactory.createElement("svg:image");
                      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                      imgEl.setAttributeNS(null, "x", "0");
                      imgEl.setAttributeNS(null, "y", pf(-height));
                      imgEl.setAttributeNS(null, "width", pf(width) + "px");
                      imgEl.setAttributeNS(null, "height", pf(height) + "px");
                      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                      if (mask) {
                        mask.appendChild(imgEl);
                      } else {
                        this._ensureTransformGroup().appendChild(imgEl);
                      }
                    }
                    paintImageMaskXObject(imgData) {
                      const current = this.current;
                      const width = imgData.width;
                      const height = imgData.height;
                      const fillColor = current.fillColor;
                      current.maskId = `mask${maskCount++}`;
                      const mask = this.svgFactory.createElement("svg:mask");
                      mask.setAttributeNS(null, "id", current.maskId);
                      const rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", pf(width));
                      rect.setAttributeNS(null, "height", pf(height));
                      rect.setAttributeNS(null, "fill", fillColor);
                      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                      this.defs.appendChild(mask);
                      this._ensureTransformGroup().appendChild(rect);
                      this.paintInlineImageXObject(imgData, mask);
                    }
                    paintFormXObjectBegin(matrix, bbox) {
                      if (Array.isArray(matrix) && matrix.length === 6) {
                        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                      }
                      if (bbox) {
                        const width = bbox[2] - bbox[0];
                        const height = bbox[3] - bbox[1];
                        const cliprect = this.svgFactory.createElement("svg:rect");
                        cliprect.setAttributeNS(null, "x", bbox[0]);
                        cliprect.setAttributeNS(null, "y", bbox[1]);
                        cliprect.setAttributeNS(null, "width", pf(width));
                        cliprect.setAttributeNS(null, "height", pf(height));
                        this.current.element = cliprect;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    }
                    paintFormXObjectEnd() {
                    }
                    _initialize(viewport) {
                      const svg = this.svgFactory.create(viewport.width, viewport.height);
                      const definitions = this.svgFactory.createElement("svg:defs");
                      svg.appendChild(definitions);
                      this.defs = definitions;
                      const rootGroup = this.svgFactory.createElement("svg:g");
                      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                      svg.appendChild(rootGroup);
                      this.svg = rootGroup;
                      return svg;
                    }
                    _ensureClipGroup() {
                      if (!this.current.clipGroup) {
                        const clipGroup = this.svgFactory.createElement("svg:g");
                        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                        this.svg.appendChild(clipGroup);
                        this.current.clipGroup = clipGroup;
                      }
                      return this.current.clipGroup;
                    }
                    _ensureTransformGroup() {
                      if (!this.tgrp) {
                        this.tgrp = this.svgFactory.createElement("svg:g");
                        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                        if (this.current.activeClipUrl) {
                          this._ensureClipGroup().appendChild(this.tgrp);
                        } else {
                          this.svg.appendChild(this.tgrp);
                        }
                      }
                      return this.tgrp;
                    }
                  };
                }
              },
              /* 25 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.PDFNodeStream = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(26);
                ;
                const fs = require_fs();
                const http = require_http();
                const https = require_https();
                const url = require_url();
                const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
                function parseUrl(sourceUrl) {
                  const parsedUrl = url.parse(sourceUrl);
                  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                    return parsedUrl;
                  }
                  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                    return url.parse(`file:///${sourceUrl}`);
                  }
                  if (!parsedUrl.host) {
                    parsedUrl.protocol = "file:";
                  }
                  return parsedUrl;
                }
                class PDFNodeStream {
                  constructor(source) {
                    this.source = source;
                    this.url = parseUrl(source.url);
                    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                    this.isFsUrl = this.url.protocol === "file:";
                    this.httpHeaders = this.isHttp && source.httpHeaders || {};
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  get _progressiveDataLength() {
                    var _a;
                    return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                  }
                  getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                    return this._fullRequestReader;
                  }
                  getRangeReader(start, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                    this._rangeRequestReaders.push(rangeReader);
                    return rangeReader;
                  }
                  cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    for (const reader of this._rangeRequestReaders.slice(0)) {
                      reader.cancel(reason);
                    }
                  }
                }
                exports2.PDFNodeStream = PDFNodeStream;
                class BaseFullReader {
                  constructor(stream) {
                    this._url = stream.url;
                    this._done = false;
                    this._storedError = null;
                    this.onProgress = null;
                    const source = stream.source;
                    this._contentLength = source.length;
                    this._loaded = 0;
                    this._filename = null;
                    this._disableRange = source.disableRange || false;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    this._isStreamingSupported = !source.disableStream;
                    this._isRangeSupported = !source.disableRange;
                    this._readableStream = null;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    this._headersCapability = (0, _util2.createPromiseCapability)();
                  }
                  get headersReady() {
                    return this._headersCapability.promise;
                  }
                  get filename() {
                    return this._filename;
                  }
                  get contentLength() {
                    return this._contentLength;
                  }
                  get isRangeSupported() {
                    return this._isRangeSupported;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  async read() {
                    await this._readCapability.promise;
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    if (this._storedError) {
                      throw this._storedError;
                    }
                    const chunk = this._readableStream.read();
                    if (chunk === null) {
                      this._readCapability = (0, _util2.createPromiseCapability)();
                      return this.read();
                    }
                    this._loaded += chunk.length;
                    if (this.onProgress) {
                      this.onProgress({
                        loaded: this._loaded,
                        total: this._contentLength
                      });
                    }
                    const buffer = new Uint8Array(chunk).buffer;
                    return {
                      value: buffer,
                      done: false
                    };
                  }
                  cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  }
                  _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  }
                  _setReadableStream(readableStream) {
                    this._readableStream = readableStream;
                    readableStream.on("readable", () => {
                      this._readCapability.resolve();
                    });
                    readableStream.on("end", () => {
                      readableStream.destroy();
                      this._done = true;
                      this._readCapability.resolve();
                    });
                    readableStream.on("error", (reason) => {
                      this._error(reason);
                    });
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this._error(new _util2.AbortException("streaming is disabled"));
                    }
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  }
                }
                class BaseRangeReader {
                  constructor(stream) {
                    this._url = stream.url;
                    this._done = false;
                    this._storedError = null;
                    this.onProgress = null;
                    this._loaded = 0;
                    this._readableStream = null;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    const source = stream.source;
                    this._isStreamingSupported = !source.disableStream;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  async read() {
                    await this._readCapability.promise;
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    if (this._storedError) {
                      throw this._storedError;
                    }
                    const chunk = this._readableStream.read();
                    if (chunk === null) {
                      this._readCapability = (0, _util2.createPromiseCapability)();
                      return this.read();
                    }
                    this._loaded += chunk.length;
                    if (this.onProgress) {
                      this.onProgress({
                        loaded: this._loaded
                      });
                    }
                    const buffer = new Uint8Array(chunk).buffer;
                    return {
                      value: buffer,
                      done: false
                    };
                  }
                  cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  }
                  _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  }
                  _setReadableStream(readableStream) {
                    this._readableStream = readableStream;
                    readableStream.on("readable", () => {
                      this._readCapability.resolve();
                    });
                    readableStream.on("end", () => {
                      readableStream.destroy();
                      this._done = true;
                      this._readCapability.resolve();
                    });
                    readableStream.on("error", (reason) => {
                      this._error(reason);
                    });
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  }
                }
                function createRequestOptions(parsedUrl, headers) {
                  return {
                    protocol: parsedUrl.protocol,
                    auth: parsedUrl.auth,
                    host: parsedUrl.hostname,
                    port: parsedUrl.port,
                    path: parsedUrl.path,
                    method: "GET",
                    headers
                  };
                }
                class PDFNodeStreamFullReader extends BaseFullReader {
                  constructor(stream) {
                    super(stream);
                    const handleResponse = (response) => {
                      if (response.statusCode === 404) {
                        const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                        this._storedError = error;
                        this._headersCapability.reject(error);
                        return;
                      }
                      this._headersCapability.resolve();
                      this._setReadableStream(response);
                      const getResponseHeader = (name) => {
                        return this._readableStream.headers[name.toLowerCase()];
                      };
                      const {
                        allowRangeRequests,
                        suggestedLength
                      } = (0, _network_utils.validateRangeRequestCapabilities)({
                        getResponseHeader,
                        isHttp: stream.isHttp,
                        rangeChunkSize: this._rangeChunkSize,
                        disableRange: this._disableRange
                      });
                      this._isRangeSupported = allowRangeRequests;
                      this._contentLength = suggestedLength || this._contentLength;
                      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    };
                    this._request = null;
                    if (this._url.protocol === "http:") {
                      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                    } else {
                      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                    }
                    this._request.on("error", (reason) => {
                      this._storedError = reason;
                      this._headersCapability.reject(reason);
                    });
                    this._request.end();
                  }
                }
                class PDFNodeStreamRangeReader extends BaseRangeReader {
                  constructor(stream, start, end) {
                    super(stream);
                    this._httpHeaders = {};
                    for (const property in stream.httpHeaders) {
                      const value = stream.httpHeaders[property];
                      if (typeof value === "undefined") {
                        continue;
                      }
                      this._httpHeaders[property] = value;
                    }
                    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                    const handleResponse = (response) => {
                      if (response.statusCode === 404) {
                        const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                        this._storedError = error;
                        return;
                      }
                      this._setReadableStream(response);
                    };
                    this._request = null;
                    if (this._url.protocol === "http:") {
                      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                    } else {
                      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                    }
                    this._request.on("error", (reason) => {
                      this._storedError = reason;
                    });
                    this._request.end();
                  }
                }
                class PDFNodeStreamFsFullReader extends BaseFullReader {
                  constructor(stream) {
                    super(stream);
                    let path = decodeURIComponent(this._url.path);
                    if (fileUriRegex.test(this._url.href)) {
                      path = path.replace(/^\//, "");
                    }
                    fs.lstat(path, (error, stat) => {
                      if (error) {
                        if (error.code === "ENOENT") {
                          error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                        }
                        this._storedError = error;
                        this._headersCapability.reject(error);
                        return;
                      }
                      this._contentLength = stat.size;
                      this._setReadableStream(fs.createReadStream(path));
                      this._headersCapability.resolve();
                    });
                  }
                }
                class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                  constructor(stream, start, end) {
                    super(stream);
                    let path = decodeURIComponent(this._url.path);
                    if (fileUriRegex.test(this._url.href)) {
                      path = path.replace(/^\//, "");
                    }
                    this._setReadableStream(fs.createReadStream(path, {
                      start,
                      end: end - 1
                    }));
                  }
                }
              },
              /* 26 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.createResponseStatusError = createResponseStatusError;
                exports2.extractFilenameFromHeader = extractFilenameFromHeader;
                exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
                exports2.validateResponseStatus = validateResponseStatus;
                var _util2 = __w_pdfjs_require__2(1);
                var _content_disposition = __w_pdfjs_require__2(27);
                var _display_utils2 = __w_pdfjs_require__2(5);
                function validateRangeRequestCapabilities({
                  getResponseHeader,
                  isHttp,
                  rangeChunkSize,
                  disableRange
                }) {
                  const returnValues = {
                    allowRangeRequests: false,
                    suggestedLength: void 0
                  };
                  const length = parseInt(getResponseHeader("Content-Length"), 10);
                  if (!Number.isInteger(length)) {
                    return returnValues;
                  }
                  returnValues.suggestedLength = length;
                  if (length <= 2 * rangeChunkSize) {
                    return returnValues;
                  }
                  if (disableRange || !isHttp) {
                    return returnValues;
                  }
                  if (getResponseHeader("Accept-Ranges") !== "bytes") {
                    return returnValues;
                  }
                  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                  if (contentEncoding !== "identity") {
                    return returnValues;
                  }
                  returnValues.allowRangeRequests = true;
                  return returnValues;
                }
                function extractFilenameFromHeader(getResponseHeader) {
                  const contentDisposition = getResponseHeader("Content-Disposition");
                  if (contentDisposition) {
                    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                    if (filename.includes("%")) {
                      try {
                        filename = decodeURIComponent(filename);
                      } catch (ex) {
                      }
                    }
                    if ((0, _display_utils2.isPdfFile)(filename)) {
                      return filename;
                    }
                  }
                  return null;
                }
                function createResponseStatusError(status, url) {
                  if (status === 404 || status === 0 && url.startsWith("file:")) {
                    return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                  }
                  return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
                }
                function validateResponseStatus(status) {
                  return status === 200 || status === 206;
                }
              },
              /* 27 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
                var _util2 = __w_pdfjs_require__2(1);
                function getFilenameFromContentDispositionHeader(contentDisposition) {
                  let needsEncodingFixup = true;
                  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                  if (tmp) {
                    tmp = tmp[1];
                    let filename = rfc2616unquote(tmp);
                    filename = unescape(filename);
                    filename = rfc5987decode(filename);
                    filename = rfc2047decode(filename);
                    return fixupEncoding(filename);
                  }
                  tmp = rfc2231getparam(contentDisposition);
                  if (tmp) {
                    const filename = rfc2047decode(tmp);
                    return fixupEncoding(filename);
                  }
                  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                  if (tmp) {
                    tmp = tmp[1];
                    let filename = rfc2616unquote(tmp);
                    filename = rfc2047decode(filename);
                    return fixupEncoding(filename);
                  }
                  function toParamRegExp(attributePattern, flags) {
                    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                  }
                  function textdecode(encoding, value) {
                    if (encoding) {
                      if (!/^[\x00-\xFF]+$/.test(value)) {
                        return value;
                      }
                      try {
                        const decoder = new TextDecoder(encoding, {
                          fatal: true
                        });
                        const buffer = (0, _util2.stringToBytes)(value);
                        value = decoder.decode(buffer);
                        needsEncodingFixup = false;
                      } catch (e) {
                      }
                    }
                    return value;
                  }
                  function fixupEncoding(value) {
                    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                      value = textdecode("utf-8", value);
                      if (needsEncodingFixup) {
                        value = textdecode("iso-8859-1", value);
                      }
                    }
                    return value;
                  }
                  function rfc2231getparam(contentDispositionStr) {
                    const matches = [];
                    let match;
                    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                    while ((match = iter.exec(contentDispositionStr)) !== null) {
                      let [, n, quot, part] = match;
                      n = parseInt(n, 10);
                      if (n in matches) {
                        if (n === 0) {
                          break;
                        }
                        continue;
                      }
                      matches[n] = [quot, part];
                    }
                    const parts = [];
                    for (let n = 0; n < matches.length; ++n) {
                      if (!(n in matches)) {
                        break;
                      }
                      let [quot, part] = matches[n];
                      part = rfc2616unquote(part);
                      if (quot) {
                        part = unescape(part);
                        if (n === 0) {
                          part = rfc5987decode(part);
                        }
                      }
                      parts.push(part);
                    }
                    return parts.join("");
                  }
                  function rfc2616unquote(value) {
                    if (value.startsWith('"')) {
                      const parts = value.slice(1).split('\\"');
                      for (let i = 0; i < parts.length; ++i) {
                        const quotindex = parts[i].indexOf('"');
                        if (quotindex !== -1) {
                          parts[i] = parts[i].slice(0, quotindex);
                          parts.length = i + 1;
                        }
                        parts[i] = parts[i].replace(/\\(.)/g, "$1");
                      }
                      value = parts.join('"');
                    }
                    return value;
                  }
                  function rfc5987decode(extvalue) {
                    const encodingend = extvalue.indexOf("'");
                    if (encodingend === -1) {
                      return extvalue;
                    }
                    const encoding = extvalue.slice(0, encodingend);
                    const langvalue = extvalue.slice(encodingend + 1);
                    const value = langvalue.replace(/^[^']*'/, "");
                    return textdecode(encoding, value);
                  }
                  function rfc2047decode(value) {
                    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                      return value;
                    }
                    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                      if (encoding === "q" || encoding === "Q") {
                        text = text.replace(/_/g, " ");
                        text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                          return String.fromCharCode(parseInt(hex, 16));
                        });
                        return textdecode(charset, text);
                      }
                      try {
                        text = atob(text);
                      } catch (e) {
                      }
                      return textdecode(charset, text);
                    });
                  }
                  return "";
                }
              },
              /* 28 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.PDFNetworkStream = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(26);
                ;
                const OK_RESPONSE = 200;
                const PARTIAL_CONTENT_RESPONSE = 206;
                function getArrayBuffer(xhr) {
                  const data = xhr.response;
                  if (typeof data !== "string") {
                    return data;
                  }
                  const array = (0, _util2.stringToBytes)(data);
                  return array.buffer;
                }
                class NetworkManager {
                  constructor(url, args = {}) {
                    this.url = url;
                    this.isHttp = /^https?:/i.test(url);
                    this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                    this.withCredentials = args.withCredentials || false;
                    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                      return new XMLHttpRequest();
                    };
                    this.currXhrId = 0;
                    this.pendingRequests = /* @__PURE__ */ Object.create(null);
                  }
                  requestRange(begin, end, listeners) {
                    const args = {
                      begin,
                      end
                    };
                    for (const prop in listeners) {
                      args[prop] = listeners[prop];
                    }
                    return this.request(args);
                  }
                  requestFull(listeners) {
                    return this.request(listeners);
                  }
                  request(args) {
                    const xhr = this.getXhr();
                    const xhrId = this.currXhrId++;
                    const pendingRequest = this.pendingRequests[xhrId] = {
                      xhr
                    };
                    xhr.open("GET", this.url);
                    xhr.withCredentials = this.withCredentials;
                    for (const property in this.httpHeaders) {
                      const value = this.httpHeaders[property];
                      if (typeof value === "undefined") {
                        continue;
                      }
                      xhr.setRequestHeader(property, value);
                    }
                    if (this.isHttp && "begin" in args && "end" in args) {
                      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                    } else {
                      pendingRequest.expectedStatus = OK_RESPONSE;
                    }
                    xhr.responseType = "arraybuffer";
                    if (args.onError) {
                      xhr.onerror = function(evt) {
                        args.onError(xhr.status);
                      };
                    }
                    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                    xhr.onprogress = this.onProgress.bind(this, xhrId);
                    pendingRequest.onHeadersReceived = args.onHeadersReceived;
                    pendingRequest.onDone = args.onDone;
                    pendingRequest.onError = args.onError;
                    pendingRequest.onProgress = args.onProgress;
                    xhr.send(null);
                    return xhrId;
                  }
                  onProgress(xhrId, evt) {
                    var _a;
                    const pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    (_a = pendingRequest.onProgress) == null ? void 0 : _a.call(pendingRequest, evt);
                  }
                  onStateChange(xhrId, evt) {
                    var _a, _b, _c;
                    const pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    const xhr = pendingRequest.xhr;
                    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                      pendingRequest.onHeadersReceived();
                      delete pendingRequest.onHeadersReceived;
                    }
                    if (xhr.readyState !== 4) {
                      return;
                    }
                    if (!(xhrId in this.pendingRequests)) {
                      return;
                    }
                    delete this.pendingRequests[xhrId];
                    if (xhr.status === 0 && this.isHttp) {
                      (_a = pendingRequest.onError) == null ? void 0 : _a.call(pendingRequest, xhr.status);
                      return;
                    }
                    const xhrStatus = xhr.status || OK_RESPONSE;
                    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                      (_b = pendingRequest.onError) == null ? void 0 : _b.call(pendingRequest, xhr.status);
                      return;
                    }
                    const chunk = getArrayBuffer(xhr);
                    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                      const rangeHeader = xhr.getResponseHeader("Content-Range");
                      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                      pendingRequest.onDone({
                        begin: parseInt(matches[1], 10),
                        chunk
                      });
                    } else if (chunk) {
                      pendingRequest.onDone({
                        begin: 0,
                        chunk
                      });
                    } else {
                      (_c = pendingRequest.onError) == null ? void 0 : _c.call(pendingRequest, xhr.status);
                    }
                  }
                  getRequestXhr(xhrId) {
                    return this.pendingRequests[xhrId].xhr;
                  }
                  isPendingRequest(xhrId) {
                    return xhrId in this.pendingRequests;
                  }
                  abortRequest(xhrId) {
                    const xhr = this.pendingRequests[xhrId].xhr;
                    delete this.pendingRequests[xhrId];
                    xhr.abort();
                  }
                }
                class PDFNetworkStream {
                  constructor(source) {
                    this._source = source;
                    this._manager = new NetworkManager(source.url, {
                      httpHeaders: source.httpHeaders,
                      withCredentials: source.withCredentials
                    });
                    this._rangeChunkSize = source.rangeChunkSize;
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  _onRangeRequestReaderClosed(reader) {
                    const i = this._rangeRequestReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeRequestReaders.splice(i, 1);
                    }
                  }
                  getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                    return this._fullRequestReader;
                  }
                  getRangeReader(begin, end) {
                    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  }
                  cancelAllRequests(reason) {
                    var _a;
                    (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(reason);
                    for (const reader of this._rangeRequestReaders.slice(0)) {
                      reader.cancel(reason);
                    }
                  }
                }
                exports2.PDFNetworkStream = PDFNetworkStream;
                class PDFNetworkStreamFullRequestReader {
                  constructor(manager, source) {
                    this._manager = manager;
                    const args = {
                      onHeadersReceived: this._onHeadersReceived.bind(this),
                      onDone: this._onDone.bind(this),
                      onError: this._onError.bind(this),
                      onProgress: this._onProgress.bind(this)
                    };
                    this._url = source.url;
                    this._fullRequestId = manager.requestFull(args);
                    this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                    this._disableRange = source.disableRange || false;
                    this._contentLength = source.length;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    this._isStreamingSupported = false;
                    this._isRangeSupported = false;
                    this._cachedChunks = [];
                    this._requests = [];
                    this._done = false;
                    this._storedError = void 0;
                    this._filename = null;
                    this.onProgress = null;
                  }
                  _onHeadersReceived() {
                    const fullRequestXhrId = this._fullRequestId;
                    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                    const getResponseHeader = (name) => {
                      return fullRequestXhr.getResponseHeader(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._manager.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    if (allowRangeRequests) {
                      this._isRangeSupported = true;
                    }
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (this._isRangeSupported) {
                      this._manager.abortRequest(fullRequestXhrId);
                    }
                    this._headersReceivedCapability.resolve();
                  }
                  _onDone(data) {
                    if (data) {
                      if (this._requests.length > 0) {
                        const requestCapability = this._requests.shift();
                        requestCapability.resolve({
                          value: data.chunk,
                          done: false
                        });
                      } else {
                        this._cachedChunks.push(data.chunk);
                      }
                    }
                    this._done = true;
                    if (this._cachedChunks.length > 0) {
                      return;
                    }
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  _onError(status) {
                    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                    this._headersReceivedCapability.reject(this._storedError);
                    for (const requestCapability of this._requests) {
                      requestCapability.reject(this._storedError);
                    }
                    this._requests.length = 0;
                    this._cachedChunks.length = 0;
                  }
                  _onProgress(evt) {
                    var _a;
                    (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                      loaded: evt.loaded,
                      total: evt.lengthComputable ? evt.total : this._contentLength
                    });
                  }
                  get filename() {
                    return this._filename;
                  }
                  get isRangeSupported() {
                    return this._isRangeSupported;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  get contentLength() {
                    return this._contentLength;
                  }
                  get headersReady() {
                    return this._headersReceivedCapability.promise;
                  }
                  async read() {
                    if (this._storedError) {
                      throw this._storedError;
                    }
                    if (this._cachedChunks.length > 0) {
                      const chunk = this._cachedChunks.shift();
                      return {
                        value: chunk,
                        done: false
                      };
                    }
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    const requestCapability = (0, _util2.createPromiseCapability)();
                    this._requests.push(requestCapability);
                    return requestCapability.promise;
                  }
                  cancel(reason) {
                    this._done = true;
                    this._headersReceivedCapability.reject(reason);
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                    if (this._manager.isPendingRequest(this._fullRequestId)) {
                      this._manager.abortRequest(this._fullRequestId);
                    }
                    this._fullRequestReader = null;
                  }
                }
                class PDFNetworkStreamRangeRequestReader {
                  constructor(manager, begin, end) {
                    this._manager = manager;
                    const args = {
                      onDone: this._onDone.bind(this),
                      onError: this._onError.bind(this),
                      onProgress: this._onProgress.bind(this)
                    };
                    this._url = manager.url;
                    this._requestId = manager.requestRange(begin, end, args);
                    this._requests = [];
                    this._queuedChunk = null;
                    this._done = false;
                    this._storedError = void 0;
                    this.onProgress = null;
                    this.onClosed = null;
                  }
                  _close() {
                    var _a;
                    (_a = this.onClosed) == null ? void 0 : _a.call(this, this);
                  }
                  _onDone(data) {
                    const chunk = data.chunk;
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: chunk,
                        done: false
                      });
                    } else {
                      this._queuedChunk = chunk;
                    }
                    this._done = true;
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                    this._close();
                  }
                  _onError(status) {
                    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                    for (const requestCapability of this._requests) {
                      requestCapability.reject(this._storedError);
                    }
                    this._requests.length = 0;
                    this._queuedChunk = null;
                  }
                  _onProgress(evt) {
                    var _a;
                    if (!this.isStreamingSupported) {
                      (_a = this.onProgress) == null ? void 0 : _a.call(this, {
                        loaded: evt.loaded
                      });
                    }
                  }
                  get isStreamingSupported() {
                    return false;
                  }
                  async read() {
                    if (this._storedError) {
                      throw this._storedError;
                    }
                    if (this._queuedChunk !== null) {
                      const chunk = this._queuedChunk;
                      this._queuedChunk = null;
                      return {
                        value: chunk,
                        done: false
                      };
                    }
                    if (this._done) {
                      return {
                        value: void 0,
                        done: true
                      };
                    }
                    const requestCapability = (0, _util2.createPromiseCapability)();
                    this._requests.push(requestCapability);
                    return requestCapability.promise;
                  }
                  cancel(reason) {
                    this._done = true;
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                    if (this._manager.isPendingRequest(this._requestId)) {
                      this._manager.abortRequest(this._requestId);
                    }
                    this._close();
                  }
                }
              },
              /* 29 */
              /***/
              (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2.PDFFetchStream = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(26);
                ;
                function createFetchOptions(headers, withCredentials, abortController) {
                  return {
                    method: "GET",
                    headers,
                    signal: abortController == null ? void 0 : abortController.signal,
                    mode: "cors",
                    credentials: withCredentials ? "include" : "same-origin",
                    redirect: "follow"
                  };
                }
                function createHeaders(httpHeaders) {
                  const headers = new Headers();
                  for (const property in httpHeaders) {
                    const value = httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    headers.append(property, value);
                  }
                  return headers;
                }
                class PDFFetchStream {
                  constructor(source) {
                    this.source = source;
                    this.isHttp = /^https?:/i.test(source.url);
                    this.httpHeaders = this.isHttp && source.httpHeaders || {};
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  get _progressiveDataLength() {
                    var _a;
                    return ((_a = this._fullRequestReader) == null ? void 0 : _a._loaded) ?? 0;
                  }
                  getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                    this._fullRequestReader = new PDFFetchStreamReader(this);
                    return this._fullRequestReader;
                  }
                  getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    const reader = new PDFFetchStreamRangeReader(this, begin, end);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  }
                  cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    for (const reader of this._rangeRequestReaders.slice(0)) {
                      reader.cancel(reason);
                    }
                  }
                }
                exports2.PDFFetchStream = PDFFetchStream;
                class PDFFetchStreamReader {
                  constructor(stream) {
                    this._stream = stream;
                    this._reader = null;
                    this._loaded = 0;
                    this._filename = null;
                    const source = stream.source;
                    this._withCredentials = source.withCredentials || false;
                    this._contentLength = source.length;
                    this._headersCapability = (0, _util2.createPromiseCapability)();
                    this._disableRange = source.disableRange || false;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    if (typeof AbortController !== "undefined") {
                      this._abortController = new AbortController();
                    }
                    this._isStreamingSupported = !source.disableStream;
                    this._isRangeSupported = !source.disableRange;
                    this._headers = createHeaders(this._stream.httpHeaders);
                    const url = source.url;
                    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                        throw (0, _network_utils.createResponseStatusError)(response.status, url);
                      }
                      this._reader = response.body.getReader();
                      this._headersCapability.resolve();
                      const getResponseHeader = (name) => {
                        return response.headers.get(name);
                      };
                      const {
                        allowRangeRequests,
                        suggestedLength
                      } = (0, _network_utils.validateRangeRequestCapabilities)({
                        getResponseHeader,
                        isHttp: this._stream.isHttp,
                        rangeChunkSize: this._rangeChunkSize,
                        disableRange: this._disableRange
                      });
                      this._isRangeSupported = allowRangeRequests;
                      this._contentLength = suggestedLength || this._contentLength;
                      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                      if (!this._isStreamingSupported && this._isRangeSupported) {
                        this.cancel(new _util2.AbortException("Streaming is disabled."));
                      }
                    }).catch(this._headersCapability.reject);
                    this.onProgress = null;
                  }
                  get headersReady() {
                    return this._headersCapability.promise;
                  }
                  get filename() {
                    return this._filename;
                  }
                  get contentLength() {
                    return this._contentLength;
                  }
                  get isRangeSupported() {
                    return this._isRangeSupported;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  async read() {
                    await this._headersCapability.promise;
                    const {
                      value,
                      done
                    } = await this._reader.read();
                    if (done) {
                      return {
                        value,
                        done
                      };
                    }
                    this._loaded += value.byteLength;
                    if (this.onProgress) {
                      this.onProgress({
                        loaded: this._loaded,
                        total: this._contentLength
                      });
                    }
                    const buffer = new Uint8Array(value).buffer;
                    return {
                      value: buffer,
                      done: false
                    };
                  }
                  cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  }
                }
                class PDFFetchStreamRangeReader {
                  constructor(stream, begin, end) {
                    this._stream = stream;
                    this._reader = null;
                    this._loaded = 0;
                    const source = stream.source;
                    this._withCredentials = source.withCredentials || false;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    this._isStreamingSupported = !source.disableStream;
                    if (typeof AbortController !== "undefined") {
                      this._abortController = new AbortController();
                    }
                    this._headers = createHeaders(this._stream.httpHeaders);
                    this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                    const url = source.url;
                    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                        throw (0, _network_utils.createResponseStatusError)(response.status, url);
                      }
                      this._readCapability.resolve();
                      this._reader = response.body.getReader();
                    }).catch(this._readCapability.reject);
                    this.onProgress = null;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  async read() {
                    await this._readCapability.promise;
                    const {
                      value,
                      done
                    } = await this._reader.read();
                    if (done) {
                      return {
                        value,
                        done
                      };
                    }
                    this._loaded += value.byteLength;
                    if (this.onProgress) {
                      this.onProgress({
                        loaded: this._loaded
                      });
                    }
                    const buffer = new Uint8Array(value).buffer;
                    return {
                      value: buffer,
                      done: false
                    };
                  }
                  cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  }
                }
              }
              /******/
            ];
            var __webpack_module_cache__ = {};
            function __w_pdfjs_require__(moduleId) {
              var cachedModule = __webpack_module_cache__[moduleId];
              if (cachedModule !== void 0) {
                return cachedModule.exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                // no module.id needed
                /******/
                // no module.loaded needed
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
              return module2.exports;
            }
            var __webpack_exports__ = {};
            (() => {
              var exports2 = __webpack_exports__;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              Object.defineProperty(exports2, "AnnotationLayer", {
                enumerable: true,
                get: function() {
                  return _annotation_layer.AnnotationLayer;
                }
              });
              Object.defineProperty(exports2, "AnnotationMode", {
                enumerable: true,
                get: function() {
                  return _util2.AnnotationMode;
                }
              });
              Object.defineProperty(exports2, "CMapCompressionType", {
                enumerable: true,
                get: function() {
                  return _util2.CMapCompressionType;
                }
              });
              Object.defineProperty(exports2, "GlobalWorkerOptions", {
                enumerable: true,
                get: function() {
                  return _worker_options2.GlobalWorkerOptions;
                }
              });
              Object.defineProperty(exports2, "InvalidPDFException", {
                enumerable: true,
                get: function() {
                  return _util2.InvalidPDFException;
                }
              });
              Object.defineProperty(exports2, "LoopbackPort", {
                enumerable: true,
                get: function() {
                  return _api.LoopbackPort;
                }
              });
              Object.defineProperty(exports2, "MissingPDFException", {
                enumerable: true,
                get: function() {
                  return _util2.MissingPDFException;
                }
              });
              Object.defineProperty(exports2, "OPS", {
                enumerable: true,
                get: function() {
                  return _util2.OPS;
                }
              });
              Object.defineProperty(exports2, "PDFDataRangeTransport", {
                enumerable: true,
                get: function() {
                  return _api.PDFDataRangeTransport;
                }
              });
              Object.defineProperty(exports2, "PDFDateString", {
                enumerable: true,
                get: function() {
                  return _display_utils2.PDFDateString;
                }
              });
              Object.defineProperty(exports2, "PDFWorker", {
                enumerable: true,
                get: function() {
                  return _api.PDFWorker;
                }
              });
              Object.defineProperty(exports2, "PasswordResponses", {
                enumerable: true,
                get: function() {
                  return _util2.PasswordResponses;
                }
              });
              Object.defineProperty(exports2, "PermissionFlag", {
                enumerable: true,
                get: function() {
                  return _util2.PermissionFlag;
                }
              });
              Object.defineProperty(exports2, "PixelsPerInch", {
                enumerable: true,
                get: function() {
                  return _display_utils2.PixelsPerInch;
                }
              });
              Object.defineProperty(exports2, "RenderingCancelledException", {
                enumerable: true,
                get: function() {
                  return _display_utils2.RenderingCancelledException;
                }
              });
              Object.defineProperty(exports2, "SVGGraphics", {
                enumerable: true,
                get: function() {
                  return _svg.SVGGraphics;
                }
              });
              Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
                enumerable: true,
                get: function() {
                  return _util2.UNSUPPORTED_FEATURES;
                }
              });
              Object.defineProperty(exports2, "UnexpectedResponseException", {
                enumerable: true,
                get: function() {
                  return _util2.UnexpectedResponseException;
                }
              });
              Object.defineProperty(exports2, "Util", {
                enumerable: true,
                get: function() {
                  return _util2.Util;
                }
              });
              Object.defineProperty(exports2, "VerbosityLevel", {
                enumerable: true,
                get: function() {
                  return _util2.VerbosityLevel;
                }
              });
              Object.defineProperty(exports2, "XfaLayer", {
                enumerable: true,
                get: function() {
                  return _xfa_layer.XfaLayer;
                }
              });
              Object.defineProperty(exports2, "build", {
                enumerable: true,
                get: function() {
                  return _api.build;
                }
              });
              Object.defineProperty(exports2, "createPromiseCapability", {
                enumerable: true,
                get: function() {
                  return _util2.createPromiseCapability;
                }
              });
              Object.defineProperty(exports2, "createValidAbsoluteUrl", {
                enumerable: true,
                get: function() {
                  return _util2.createValidAbsoluteUrl;
                }
              });
              Object.defineProperty(exports2, "getDocument", {
                enumerable: true,
                get: function() {
                  return _api.getDocument;
                }
              });
              Object.defineProperty(exports2, "getFilenameFromUrl", {
                enumerable: true,
                get: function() {
                  return _display_utils2.getFilenameFromUrl;
                }
              });
              Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
                enumerable: true,
                get: function() {
                  return _display_utils2.getPdfFilenameFromUrl;
                }
              });
              Object.defineProperty(exports2, "getXfaPageViewport", {
                enumerable: true,
                get: function() {
                  return _display_utils2.getXfaPageViewport;
                }
              });
              Object.defineProperty(exports2, "isPdfFile", {
                enumerable: true,
                get: function() {
                  return _display_utils2.isPdfFile;
                }
              });
              Object.defineProperty(exports2, "loadScript", {
                enumerable: true,
                get: function() {
                  return _display_utils2.loadScript;
                }
              });
              Object.defineProperty(exports2, "renderTextLayer", {
                enumerable: true,
                get: function() {
                  return _text_layer.renderTextLayer;
                }
              });
              Object.defineProperty(exports2, "shadow", {
                enumerable: true,
                get: function() {
                  return _util2.shadow;
                }
              });
              Object.defineProperty(exports2, "version", {
                enumerable: true,
                get: function() {
                  return _api.version;
                }
              });
              var _util2 = __w_pdfjs_require__(1);
              var _api = __w_pdfjs_require__(4);
              var _display_utils2 = __w_pdfjs_require__(5);
              var _annotation_layer = __w_pdfjs_require__(20);
              var _worker_options2 = __w_pdfjs_require__(13);
              var _is_node2 = __w_pdfjs_require__(3);
              var _text_layer = __w_pdfjs_require__(23);
              var _svg = __w_pdfjs_require__(24);
              var _xfa_layer = __w_pdfjs_require__(22);
              const pdfjsVersion = "2.14.305";
              const pdfjsBuild = "eaaa8b4ad";
              {
                if (_is_node2.isNodeJS) {
                  const {
                    PDFNodeStream
                  } = __w_pdfjs_require__(25);
                  (0, _api.setPDFNetworkStreamFactory)((params) => {
                    return new PDFNodeStream(params);
                  });
                } else {
                  const {
                    PDFNetworkStream
                  } = __w_pdfjs_require__(28);
                  const {
                    PDFFetchStream
                  } = __w_pdfjs_require__(29);
                  (0, _api.setPDFNetworkStreamFactory)((params) => {
                    if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                      return new PDFFetchStream(params);
                    }
                    return new PDFNetworkStream(params);
                  });
                }
              }
            })();
            return __webpack_exports__;
          })()
        );
      });
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Link: () => Link,
    default: () => src_default,
    load: () => load
  });
  init_polyfills();

  // src/reader.ts
  init_polyfills();

  // src/model/Publication.ts
  init_polyfills();
  var import_publication = __toESM(require_publication());
  var import_ta_json_x2 = __toESM(require_cjs());

  // src/utils/JsonUtil.ts
  init_polyfills();
  var import_ta_json_x = __toESM(require_cjs());
  function TaJsonDeserialize(json, type) {
    return import_ta_json_x.TaJson.deserialize(json, type);
  }

  // src/model/Publication.ts
  var Publication = class extends import_publication.Publication {
    /**
     * Initialize a publication from a manifest URL
     */
    static async fromUrl(url, requestConfig) {
      const response = await fetch(url.href, requestConfig);
      const manifestJSON = await response.json();
      let publication = TaJsonDeserialize(manifestJSON, Publication);
      publication.manifestUrl = url;
      return publication;
    }
    get readingOrder() {
      return this.Spine ?? [];
    }
    get resources() {
      return this.Resources ?? [];
    }
    get tableOfContents() {
      var _a, _b;
      if (((_a = this.sample) == null ? void 0 : _a.isSampleRead) && ((_b = this.positions) == null ? void 0 : _b.length) > 0) {
        return this.limitedTOC();
      }
      return this.TOC || [];
    }
    limitedTOC() {
      var _a;
      function disableChildren(item) {
        for (let index2 = 0; index2 < item.Children.length; index2++) {
          let child = item.Children[index2];
          child.Href = void 0;
          if (child.Children) {
            disableChildren(child);
          }
        }
      }
      let toc = (_a = this.TOC) == null ? void 0 : _a.map((item) => {
        var _a2, _b;
        if (item.Href) {
          const positions = this.positionsByHref(this.getRelativeHref(item.Href));
          if ((positions == null ? void 0 : positions.length) > 0) {
            const locator = positions[0];
            let progress = Math.round(
              (locator.locations.totalProgression ? locator.locations.totalProgression : 0) * 100
            );
            if ((_a2 = this.sample) == null ? void 0 : _a2.limit) {
              let valid = progress <= ((_b = this.sample) == null ? void 0 : _b.limit);
              if (!valid) {
                item.Href = void 0;
                if (item.Children) {
                  disableChildren(item);
                }
              }
            }
          }
        }
        return item;
      });
      return toc || [];
    }
    get landmarks() {
      return this.Landmarks;
    }
    get pageList() {
      return this.PageList;
    }
    get isFixedLayout() {
      var _a;
      return ((_a = this.Metadata.Rendition) == null ? void 0 : _a.Layout) === "fixed";
    }
    get isReflowable() {
      return !this.isFixedLayout;
    }
    get layout() {
      return this.isFixedLayout ? "fixed" : "reflowable";
    }
    get hasMediaOverlays() {
      return this.readingOrder ? this.readingOrder.filter((el) => {
        var _a;
        return (_a = el.Properties) == null ? void 0 : _a.MediaOverlay;
      }).length > 0 : false;
    }
    getStartLink() {
      if (this.readingOrder !== void 0 && this.readingOrder.length > 0) {
        return this.readingOrder[0];
      }
      return void 0;
    }
    getPreviousSpineItem(href) {
      const index2 = this.getSpineIndex(href);
      if (index2 !== void 0 && this.readingOrder !== void 0 && index2 > 0) {
        return this.readingOrder[index2 - 1];
      }
      return void 0;
    }
    getNextSpineItem(href) {
      const index2 = this.getSpineIndex(href);
      if (index2 !== void 0 && this.readingOrder !== void 0 && index2 < this.readingOrder.length - 1) {
        return this.readingOrder[index2 + 1];
      }
      return void 0;
    }
    getSpineItem(href) {
      const index2 = this.getSpineIndex(href);
      if (index2 !== void 0 && this.readingOrder !== void 0) {
        return this.readingOrder[index2];
      }
      return void 0;
    }
    getSpineIndex(href) {
      var _a;
      return (_a = this.readingOrder) == null ? void 0 : _a.findIndex(
        (item) => item.Href && this.getAbsoluteHref(item.Href) === href
      );
    }
    getAbsoluteHref(href) {
      return new URL(href, this.manifestUrl.href).href;
    }
    getRelativeHref(href) {
      const manifest = this.manifestUrl.href.replace("/manifest.json", "");
      let h = href.replace(manifest, "");
      if (h.indexOf("#") > 0) {
        h = h.slice(0, h.indexOf("#"));
      }
      if (h.charAt(0) === "/") {
        h = h.substring(1);
      }
      return h;
    }
    getTOCItemAbsolute(href) {
      const absolute = this.getAbsoluteHref(href);
      const findItem = (href2, links) => {
        for (let index2 = 0; index2 < links.length; index2++) {
          const item = links[index2];
          if (item.Href) {
            const hrefAbsolute = item.Href.indexOf("#") !== -1 ? item.Href.slice(0, item.Href.indexOf("#")) : item.Href;
            const itemUrl = this.getAbsoluteHref(hrefAbsolute);
            if (itemUrl === href2) {
              return item;
            }
          }
          if (item.Children) {
            const childItem = findItem(href2, item.Children);
            if (childItem !== void 0) {
              return childItem;
            }
          }
        }
        return void 0;
      };
      let link = findItem(absolute, this.tableOfContents);
      if (link === void 0 && this.readingOrder !== void 0) {
        link = findItem(absolute, this.readingOrder);
      }
      return link;
    }
    getTOCItem(href) {
      const findItem = (href2, links) => {
        for (let index2 = 0; index2 < links.length; index2++) {
          const item = links[index2];
          if (item.Href) {
            const itemUrl = this.getAbsoluteHref(item.Href);
            if (itemUrl === href2) {
              return item;
            }
          }
          if (item.Children) {
            const childItem = findItem(href2, item.Children);
            if (childItem !== void 0) {
              return childItem;
            }
          }
        }
        return void 0;
      };
      let link = findItem(href, this.tableOfContents);
      if (link === void 0 && this.readingOrder !== void 0) {
        link = findItem(href, this.readingOrder);
      }
      if (link === void 0) {
        if (href.indexOf("#") !== -1) {
          const newResource = href.slice(0, href.indexOf("#"));
          link = findItem(newResource, this.tableOfContents);
          if (link === void 0 && this.readingOrder !== void 0) {
            link = findItem(newResource, this.readingOrder);
          }
        }
      }
      return link;
    }
    /**
     * positionsByHref
     */
    positionsByHref(href) {
      var _a;
      const decodedHref = decodeURI(href) ?? "";
      return (_a = this.positions) == null ? void 0 : _a.filter((p) => decodedHref.includes(p.href));
    }
    /**
     * Fetches the contents to build up the positions manually,
     * at least for fluid layout pubs
     */
    async autoGeneratePositions(requestConfig, getContentBytesLength = fetchContentBytesLength) {
      let startPosition = 0;
      let totalContentLength = 0;
      const positions = [];
      if (this.readingOrder !== void 0) {
        for (const link of this.readingOrder) {
          if (this.isFixedLayout) {
            const locator = {
              href: link.Href,
              locations: {
                progression: 0,
                position: startPosition + 1
              },
              type: link.TypeLink
            };
            positions.push(locator);
            startPosition = startPosition + 1;
          } else {
            let href = this.getAbsoluteHref(link.Href);
            let length = await getContentBytesLength(href, requestConfig);
            link.contentLength = length;
            totalContentLength += length;
            let positionLength = 1024;
            let positionCount = Math.max(1, Math.ceil(length / positionLength));
            for (let position = 0; position < positionCount; position++) {
              const locator = {
                href: link.Href,
                locations: {
                  progression: position / positionCount,
                  position: startPosition + (position + 1)
                },
                type: link.TypeLink
              };
              positions.push(locator);
            }
            startPosition = startPosition + positionCount;
          }
        }
      }
      var totalweight = 0;
      if (this.isReflowable && this.readingOrder !== void 0) {
        for (const link of this.readingOrder) {
          if (!link.contentLength) {
            console.error("Link is missing contentLength", link);
            return;
          }
          link.contentWeight = 100 / totalContentLength * link.contentLength;
          totalweight = totalweight + link.contentWeight;
        }
      }
      for (const locator of positions) {
        const resource = positions.filter(
          (el) => el.href === decodeURI(locator.href)
        );
        const positionIndex = Math.ceil(
          (locator.locations.progression ? locator.locations.progression : 0) * (resource.length - 1)
        );
        if (locator.locations.position) {
          locator.locations.totalProgression = (locator.locations.position - 1) / positions.length;
        }
        locator.locations.remainingPositions = Math.abs(
          positionIndex - (resource.length - 1)
        );
        if (locator.locations.position) {
          locator.locations.totalRemainingPositions = Math.abs(
            locator.locations.position - 1 - (positions.length - 1)
          );
        }
      }
      this.positions = positions;
    }
    /**
     * Fetches the positions from a given service href
     */
    async fetchPositionsFromService(href, requestConfig) {
      const result = await fetch(href, requestConfig);
      const content = await result.json();
      this.positions = content.positions;
    }
    /**
     * Fetches weights from a given service href
     */
    async fetchWeightsFromService(href, requestConfig) {
      if (this.isFixedLayout) {
        console.warn(
          "Not fetching weights from service for fixed layout publication."
        );
        return;
      }
      const result = await fetch(href, requestConfig);
      const weights = await result.json();
      if (this.readingOrder !== void 0) {
        this.readingOrder.forEach((link) => {
          link.contentWeight = weights[link.Href];
        });
      }
    }
  };
  Publication = __decorateClass([
    (0, import_ta_json_x2.JsonObject)()
  ], Publication);
  var fetchContentBytesLength = async (href, requestConfig) => {
    const r = await fetch(href, requestConfig);
    const b = await r.blob();
    return b.size;
  };

  // src/model/user-settings/UserSettings.ts
  init_polyfills();

  // src/model/user-settings/UserProperties.ts
  init_polyfills();
  var UserProperty = class {
    json() {
      return JSON.stringify(this);
    }
  };
  var Stringable = class extends UserProperty {
    constructor(value, ref, name) {
      super();
      this.value = value;
      this.ref = ref;
      this.name = name;
    }
    toString() {
      return this.value;
    }
  };
  var JSONable = class extends UserProperty {
    constructor(value, ref, name) {
      super();
      this.value = value;
      this.ref = ref;
      this.name = name;
    }
    toString() {
      return this.value;
    }
    toJson() {
      return JSON.parse(this.value);
    }
  };
  var Enumerable = class extends UserProperty {
    constructor(value, values, ref, name) {
      super();
      this.value = value;
      this.values = values;
      this.ref = ref;
      this.name = name;
    }
    toString() {
      return this.values[this.value];
    }
  };
  var Incremental = class extends UserProperty {
    constructor(value, min, max, step, suffix, ref, name) {
      super();
      this.countDecimals = function(value) {
        if (value % 1 !== 0)
          return value.toString().split(".")[1].length;
        return 1;
      };
      this.value = value;
      this.min = min;
      this.max = max;
      this.step = step;
      this.suffix = suffix;
      this.ref = ref;
      this.name = name;
    }
    toString() {
      return this.value.toString() + this.suffix;
    }
    increment() {
      const dec = this.countDecimals(this.max);
      if (parseFloat(this.value.toFixed(dec)) < this.max) {
        this.value = parseFloat(this.value.toFixed(dec)) + this.step;
      }
    }
    decrement() {
      const dec = this.countDecimals(this.min);
      if (parseFloat(this.value.toFixed(dec)) > this.min) {
        this.value = parseFloat(this.value.toFixed(dec)) - this.step;
      }
    }
  };
  var Switchable = class extends UserProperty {
    constructor(onValue, offValue, value, ref, name) {
      super();
      this.value = value;
      this.onValue = onValue;
      this.offValue = offValue;
      this.ref = ref;
      this.name = name;
    }
    toString() {
      return this.value ? this.onValue : this.offValue;
    }
    switch() {
      this.value = !this.value;
    }
  };
  var UserProperties = class {
    constructor() {
      this.properties = [];
    }
    addIncremental(nValue, min, max, step, suffix, ref, key) {
      this.properties.push(
        new Incremental(nValue, min, max, step, suffix, ref, key)
      );
    }
    addStringable(nValue, ref, key) {
      this.properties.push(new Stringable(nValue, ref, key));
    }
    addJSONable(nValue, ref, key) {
      this.properties.push(new JSONable(nValue, ref, key));
    }
    addSwitchable(onValue, offValue, on, ref, key) {
      this.properties.push(new Switchable(onValue, offValue, on, ref, key));
    }
    addEnumerable(index2, values, ref, key) {
      this.properties.push(new Enumerable(index2, values, ref, key));
    }
    getByRef(ref) {
      let result = this.properties.filter((el) => el.ref === ref);
      if (result.length > 0) {
        return result[0];
      }
      return null;
    }
    getByKey(key) {
      let result = this.properties.filter((el) => el.key === key);
      if (result.length > 0) {
        return result[0];
      }
      return null;
    }
  };

  // src/model/user-settings/ReadiumCSS.ts
  init_polyfills();
  var _ReadiumCSS = class _ReadiumCSS {
  };
  _ReadiumCSS.FONT_SIZE_REF = "fontSize";
  _ReadiumCSS.FONT_FAMILY_REF = "fontFamily";
  _ReadiumCSS.FONT_OVERRIDE_REF = "fontOverride";
  _ReadiumCSS.APPEARANCE_REF = "appearance";
  _ReadiumCSS.SCROLL_REF = "scroll";
  // static readonly PUBLISHER_DEFAULT_REF = "advancedSettings";
  _ReadiumCSS.TEXT_ALIGNMENT_REF = "textAlign";
  _ReadiumCSS.COLUMN_COUNT_REF = "colCount";
  _ReadiumCSS.WORD_SPACING_REF = "wordSpacing";
  _ReadiumCSS.LETTER_SPACING_REF = "letterSpacing";
  _ReadiumCSS.PAGE_MARGINS_REF = "pageMargins";
  _ReadiumCSS.LINE_HEIGHT_REF = "lineHeight";
  _ReadiumCSS.FONT_SIZE_KEY = "--USER__" + _ReadiumCSS.FONT_SIZE_REF;
  _ReadiumCSS.FONT_FAMILY_KEY = "--USER__" + _ReadiumCSS.FONT_FAMILY_REF;
  _ReadiumCSS.FONT_OVERRIDE_KEY = "--USER__" + _ReadiumCSS.FONT_OVERRIDE_REF;
  _ReadiumCSS.APPEARANCE_KEY = "--USER__" + _ReadiumCSS.APPEARANCE_REF;
  _ReadiumCSS.SCROLL_KEY = "--USER__" + _ReadiumCSS.SCROLL_REF;
  // static readonly PUBLISHER_DEFAULT_KEY =
  //   "--USER__" + ReadiumCSS.PUBLISHER_DEFAULT_REF;
  _ReadiumCSS.TEXT_ALIGNMENT_KEY = "--USER__" + _ReadiumCSS.TEXT_ALIGNMENT_REF;
  _ReadiumCSS.COLUMN_COUNT_KEY = "--USER__" + _ReadiumCSS.COLUMN_COUNT_REF;
  _ReadiumCSS.WORD_SPACING_KEY = "--USER__" + _ReadiumCSS.WORD_SPACING_REF;
  _ReadiumCSS.LETTER_SPACING_KEY = "--USER__" + _ReadiumCSS.LETTER_SPACING_REF;
  _ReadiumCSS.PAGE_MARGINS_KEY = "--USER__" + _ReadiumCSS.PAGE_MARGINS_REF;
  _ReadiumCSS.LINE_HEIGHT_KEY = "--USER__" + _ReadiumCSS.LINE_HEIGHT_REF;
  var ReadiumCSS = _ReadiumCSS;

  // src/utils/HTMLUtilities.ts
  init_polyfills();
  function findElement(parentElement, selector2) {
    return parentElement.querySelector(selector2);
  }
  function findRequiredElement(parentElement, selector2) {
    const element = findElement(parentElement, selector2);
    if (element && element instanceof HTMLElement) {
      return element;
    } else {
      throw new Error("required element " + selector2 + " not found");
    }
  }
  function findIframeElement(parentElement, selector2) {
    if (parentElement === null) {
      throw new Error("parent element is null");
    } else {
      return parentElement.querySelector(selector2);
    }
  }
  function findRequiredIframeElement(parentElement, selector2) {
    const element = findIframeElement(parentElement, selector2);
    if (!element) {
      throw new Error("required element " + selector2 + " not found in iframe");
    } else {
      return element;
    }
  }
  function setAttr(element, attr, value) {
    element.setAttribute(attr, value);
  }

  // src/utils/EventHandler.ts
  init_polyfills();

  // src/modules/search/Popup.ts
  init_polyfills();
  var import_sanitize_html = __toESM(require_sanitize_html());
  var Popup = class {
    constructor(navigator2) {
      this.getScrollingElement = (doc) => {
        if (doc.scrollingElement) {
          return doc.scrollingElement;
        }
        return doc.body;
      };
      this.navigator = navigator2;
    }
    async handleFootnote(link, event) {
      var _a, _b;
      const href = link.getAttribute("href");
      if (href && href.indexOf("#") > 0) {
        let getAbsoluteHref = function(href2) {
          const currentUrl = document.location.href;
          return new URL(href2, currentUrl).href;
        };
        const id2 = href.substring(href.indexOf("#") + 1);
        let absolute = getAbsoluteHref(href);
        if (absolute) {
          absolute = absolute.substring(0, absolute.indexOf("#"));
          event.preventDefault();
          event.stopPropagation();
          if ((_a = this.navigator.api) == null ? void 0 : _a.getContent) {
            await ((_b = this.navigator.api) == null ? void 0 : _b.getContent(href).then((content) => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(content, "text/html");
              const element = doc.querySelector("#" + id2);
              if (element) {
                event.preventDefault();
                event.stopPropagation();
                this.showPopup(element, event);
              }
            }));
          } else {
            await fetch(absolute, this.navigator.requestConfig).then((r) => r.text()).then(async (data) => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(data, "text/html");
              const element = doc.querySelector("#" + id2);
              if (element) {
                event.preventDefault();
                event.stopPropagation();
                this.showPopup(element, event);
              }
            });
          }
        }
      }
    }
    async hidePopover() {
      var _a, _b;
      let footnote = (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.getElementById("d2-popover");
      if (footnote) {
        (_b = footnote.parentElement) == null ? void 0 : _b.removeChild(footnote);
      }
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      wrapper.style.overflow = "auto";
    }
    async showPopover(link, event) {
      var _a, _b, _c, _d, _e, _f;
      const href = link.getAttribute("href");
      const src = link.getAttribute("src");
      function getAbsoluteHref(href2) {
        const currentUrl = document.location.href;
        return new URL(href2, currentUrl).href;
      }
      if (href) {
        let absolute = getAbsoluteHref(href);
        if (absolute) {
          event.preventDefault();
          event.stopPropagation();
          let popover = (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.getElementById(
            "d2-popover"
          );
          if (popover) {
            (_b = popover.parentElement) == null ? void 0 : _b.removeChild(popover);
          }
          const d2popover = document.createElement("div");
          d2popover.id = "d2-popover";
          d2popover.className = "d2-popover is-active";
          const wrapper = findRequiredElement(
            document,
            "#iframe-wrapper"
          );
          wrapper.style.overflow = "hidden";
          d2popover.style.top = wrapper.scrollTop + "px";
          d2popover.style.height = wrapper.clientHeight * 0.9 + "px";
          const d2wrapper = document.createElement("div");
          d2wrapper.className = "d2-popover-wrapper";
          d2popover.appendChild(d2wrapper);
          const d2content = document.createElement("div");
          d2content.className = "d2-popover-content";
          d2wrapper.appendChild(d2content);
          if ((_c = this.navigator.api) == null ? void 0 : _c.getContent) {
            await ((_d = this.navigator.api) == null ? void 0 : _d.getContent(href).then((content) => {
              d2content.innerHTML = content;
              let doc = this.navigator.iframes[0].contentDocument;
              if (doc) {
                doc.body.appendChild(d2popover);
              }
            }));
          } else {
            await fetch(absolute, this.navigator.requestConfig).then((r) => r.text()).then(async (data) => {
              d2content.innerHTML = data;
              let doc = this.navigator.iframes[0].contentDocument;
              if (doc) {
                doc.body.appendChild(d2popover);
              }
            });
          }
          let win = this.navigator.iframes[0].contentWindow;
          if (!win) {
            return;
          }
          let self2 = this;
          win.addEventListener(
            "click",
            function(ev) {
              if (event.target !== ev.target) {
                if (d2popover.parentElement) {
                  self2.hidePopover();
                  ev.stopImmediatePropagation();
                }
              }
            },
            {
              once: true,
              capture: true
            }
          );
        }
      } else if (src) {
        let absolute = getAbsoluteHref(src);
        if (absolute) {
          event.preventDefault();
          event.stopPropagation();
          let popover = (_e = this.navigator.iframes[0].contentDocument) == null ? void 0 : _e.getElementById(
            "d2-popover"
          );
          if (popover) {
            (_f = popover.parentElement) == null ? void 0 : _f.removeChild(popover);
          }
          const d2popover = document.createElement("div");
          d2popover.id = "d2-popover";
          d2popover.className = "d2-popover is-active";
          const wrapper = findRequiredElement(
            document,
            "#iframe-wrapper"
          );
          wrapper.style.overflow = "hidden";
          d2popover.style.top = wrapper.scrollTop + "px";
          d2popover.style.height = wrapper.clientHeight * 0.9 + "px";
          const d2wrapper = document.createElement("div");
          d2wrapper.className = "d2-popover-wrapper";
          d2popover.appendChild(d2wrapper);
          const d2content = document.createElement("img");
          d2content.className = "d2-popover-content";
          d2wrapper.appendChild(d2content);
          d2content.src = src;
          let doc = this.navigator.iframes[0].contentDocument;
          if (doc) {
            doc.body.appendChild(d2popover);
          }
          let win = this.navigator.iframes[0].contentWindow;
          if (!win) {
            return;
          }
          let self2 = this;
          win.addEventListener(
            "click",
            function(ev) {
              if (event.target !== ev.target) {
                if (d2popover.parentElement) {
                  self2.hidePopover();
                  ev.stopImmediatePropagation();
                }
              }
            },
            {
              once: true,
              capture: true
            }
          );
        }
      }
    }
    showPopup(element, event) {
      var _a, _b, _c;
      let footnote = (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.getElementById("d2-popup");
      if (footnote) {
        (_b = footnote.parentElement) == null ? void 0 : _b.removeChild(footnote);
      }
      const d2popup = document.createElement("aside");
      d2popup.id = "d2-popup";
      d2popup.className = "d2-popup is-active";
      const d2wrapper = document.createElement("div");
      d2wrapper.className = "d2-popup-wrapper";
      d2popup.appendChild(d2wrapper);
      const d2content = document.createElement("div");
      d2content.className = "d2-popup-content";
      d2wrapper.appendChild(d2content);
      const p = document.createElement("p");
      d2content.appendChild(p);
      if (typeof element === "string") {
        p.innerHTML = element;
      } else {
        p.innerHTML = (0, import_sanitize_html.default)(element.innerHTML, {
          allowedTags: [],
          allowedAttributes: {}
        });
      }
      const paginated = (_c = this.navigator.view) == null ? void 0 : _c.isPaginated();
      let doc = this.navigator.iframes[0].contentDocument;
      if (!doc) {
        return;
      }
      const scrollElement = this.getScrollingElement(doc);
      const xOffset = paginated ? scrollElement.scrollLeft : 0;
      const yOffset = paginated ? scrollElement.scrollTop : 0;
      const left = event.x + xOffset;
      const top = event.y + yOffset;
      d2popup.style.top = top + "px";
      if (paginated) {
        d2popup.style.left = left + "px";
      }
      doc.body.appendChild(d2popup);
      let win = this.navigator.iframes[0].contentWindow;
      if (!win) {
        return;
      }
      win.onclick = function(ev) {
        if (event.target !== ev.target) {
          if (d2popup.parentElement) {
            d2popup.style.display = "none";
            d2popup.parentElement.removeChild(d2popup);
            if (win) {
              win.onclick = null;
            }
          }
        }
      };
    }
  };

  // src/utils/EventHandler.ts
  var import_loglevel = __toESM(require_loglevel());
  function addEventListenerOptional(element, eventType, eventListener) {
    if (element) {
      element.addEventListener(eventType, eventListener, true);
    }
  }
  function removeEventListenerOptional(element, eventType, eventListener) {
    if (element) {
      element.removeEventListener(eventType, eventListener, true);
    }
  }
  var EventHandler = class {
    constructor(navigator2) {
      this.onInternalLink = () => {
      };
      this.onClickThrough = () => {
      };
      this.checkForLink = (event) => {
        let nextElement = event.target;
        while (nextElement && nextElement.tagName.toLowerCase() !== "body") {
          if (nextElement.tagName.toLowerCase() === "a" && nextElement.href) {
            return nextElement;
          } else {
            nextElement = nextElement.parentElement;
          }
        }
        return null;
      };
      this.linkInPublication = (readingOrder, clickedHref) => readingOrder.some((link) => {
        var _a;
        return !((_a = link.Rel) == null ? void 0 : _a.includes("external")) && this.navigator.publication.getRelativeHref(clickedHref).includes(link.Href);
      });
      /**
       *
       * This function checks the user clicked link inside the iframe
       * against the readingOrder list, it is an internal link if found.
       *
       */
      this.isReadingOrderInternal = (clickedLink) => {
        import_loglevel.default.log("clickedLink: ", clickedLink);
        const isEpubInternal = this.linkInPublication(
          this.navigator.publication.readingOrder,
          clickedLink.href
        );
        return isEpubInternal;
      };
      this.isResourceInternal = (clickedLink) => {
        import_loglevel.default.log("clickedLink: ", clickedLink);
        const isEpubInternal = this.linkInPublication(
          this.navigator.publication.resources,
          clickedLink.href
        );
        return isEpubInternal;
      };
      this.handleLinks = async (event) => {
        import_loglevel.default.log("R2 Click Handler");
        const link = this.checkForLink(event);
        if (link) {
          const isSameOrigin = window.location.protocol === link.protocol && window.location.port === link.port && window.location.hostname === link.hostname;
          const isEpubInternal = this.isReadingOrderInternal(link);
          const isResourceInternal = this.isResourceInternal(link);
          if (!isResourceInternal) {
            await this.popup.hidePopover();
          }
          const isInternal = link.href.indexOf("#");
          if (!isEpubInternal && !isResourceInternal) {
            window.open(link.href, link.target ?? "_blank");
            event.preventDefault();
            event.stopPropagation();
          } else {
            event.target.href = link.href;
            if ((isSameOrigin || isEpubInternal) && isInternal !== -1) {
              const link2 = event.target;
              if (link2) {
                const attribute = link2.getAttribute("epub:type") === "noteref";
                if (attribute) {
                  await this.popup.handleFootnote(link2, event);
                } else if (isResourceInternal && !isEpubInternal) {
                  await this.popup.showPopover(link2, event);
                } else {
                  this.onInternalLink(event);
                }
              } else {
                this.onInternalLink(event);
              }
            } else if ((isSameOrigin || isEpubInternal) && isInternal === -1) {
              this.onInternalLink(event);
            }
          }
        } else {
          this.onClickThrough(event);
        }
      };
      this.navigator = navigator2;
      this.popup = new Popup(this.navigator);
    }
    setupEvents(element) {
      if (element !== null) {
        element.addEventListener(
          "dblclick",
          async (event) => {
            let htmlElement = event.target;
            if (event.target && htmlElement.tagName.toLowerCase() === "img") {
              await this.popup.showPopover(htmlElement, event);
            }
          },
          true
        );
        element.addEventListener("click", this.handleLinks.bind(this), true);
      } else {
        throw "cannot setup events for null";
      }
    }
  };

  // src/views/ReflowableBookView.ts
  init_polyfills();

  // src/utils/BrowserUtilities.ts
  init_polyfills();
  function getWidth() {
    const wrapper = findRequiredElement(
      document,
      "#iframe-wrapper"
    );
    return wrapper.clientWidth;
  }
  function getHeight() {
    const wrapper = findRequiredElement(
      document,
      "#iframe-wrapper"
    );
    return wrapper.clientHeight;
  }

  // src/views/ReflowableBookView.ts
  var import_debounce = __toESM(require_debounce());
  var ReflowableBookView = class {
    constructor(store) {
      this.layout = "reflowable";
      this.USERSETTINGS = "userSetting";
      this.sideMargin = 20;
      this.height = 0;
      this.attributes = { margin: 0 };
      // paginated functions
      this.hasFixedScrollWidth = false;
      this.store = store;
      if (this.scrollMode) {
        this.name = "readium-scroll-on";
        this.label = "Scrolling";
      } else {
        this.name = "readium-scroll-off";
        this.label = "Paginated";
      }
    }
    setMode(scroll) {
      var _a;
      this.scrollMode = scroll;
      if (scroll) {
        this.name = "readium-scroll-on";
        this.label = "Scrolling";
        let doc = this.iframe.contentDocument;
        if (doc) {
          const head = findIframeElement(
            doc,
            "head"
          );
          if (head) {
            const viewport = findElement(
              head,
              "meta[name=viewport]"
            );
            if (viewport) {
              viewport.remove();
            }
          }
          const html = findIframeElement(
            doc,
            "html"
          );
          if (html) {
            html.style.setProperty("--USER__scroll", "readium-scroll-on");
          }
        }
        this.setSize();
        this.setIframeHeight(this.iframe);
      } else {
        this.height = getHeight() - 40 - this.attributes.margin;
        this.name = "readium-scroll-off";
        this.label = "Paginated";
        this.checkForFixedScrollWidth();
        let doc = this.iframe.contentDocument;
        if (doc) {
          const html = findIframeElement(
            doc,
            "html"
          );
          if (html) {
            html.style.setProperty("--USER__scroll", "readium-scroll-off");
          }
        }
        this.setSize();
      }
      if (this.navigator.rights.enableContentProtection) {
        (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate();
      }
    }
    start() {
      if (this.scrollMode) {
        let doc = this.iframe.contentDocument;
        if (doc) {
          const head = findIframeElement(
            doc,
            "head"
          );
          if (head) {
            const viewport = findElement(
              head,
              "meta[name=viewport]"
            );
            if (viewport) {
              viewport.remove();
            }
          }
        }
        this.setSize();
        this.setIframeHeight(this.iframe);
      } else {
        this.iframe.height = "0";
        this.iframe.width = "0";
        this.setSize();
        const viewportElement = document.createElement("meta");
        viewportElement.name = "viewport";
        viewportElement.content = "width=device-width, initial-scale=1, maximum-scale=1";
        this.checkForFixedScrollWidth();
      }
    }
    stop() {
      this.iframe.height = "0";
      this.iframe.width = "0";
      let doc = this.iframe.contentDocument;
      if (doc) {
        const body = findIframeElement(
          this.iframe.contentDocument,
          "body"
        );
        const images = Array.prototype.slice.call(body.querySelectorAll("img"));
        for (const image of images) {
          image.style.maxWidth = "";
        }
      }
    }
    getCurrentPosition() {
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (this.scrollMode) {
        return wrapper.scrollTop / this.scrollingElement.scrollHeight;
      } else {
        const width = this.getColumnWidth();
        const leftWidth = this.getLeftColumnsWidth();
        const rightWidth = this.getRightColumnsWidth();
        const totalWidth = leftWidth + width + rightWidth;
        return leftWidth / totalWidth;
      }
    }
    goToProgression(position) {
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (this.scrollMode) {
        wrapper.scrollTop = this.scrollingElement.scrollHeight * position;
      } else {
        const width = this.getColumnWidth();
        const leftWidth = this.getLeftColumnsWidth();
        const rightWidth = this.getRightColumnsWidth();
        const totalWidth = leftWidth + width + rightWidth;
        const newLeftWidth = position * totalWidth;
        let roundedLeftWidth = Math.round(newLeftWidth / width) * width;
        if (roundedLeftWidth >= totalWidth) {
          roundedLeftWidth = roundedLeftWidth - width;
        }
        this.setLeftColumnsWidth(roundedLeftWidth);
      }
    }
    goToCssSelector(cssSelector, relative) {
      let doc = this.iframe.contentDocument;
      if (doc) {
        let element = doc.querySelector(cssSelector);
        this.goToElement(element, relative);
      }
    }
    goToFragment(fragment, relative) {
      let doc = this.iframe.contentDocument;
      if (doc) {
        const element = doc.getElementById(fragment);
        this.goToElement(element, relative);
      }
    }
    snap(element, _relative) {
      var _a;
      if (element) {
        if (this.scrollMode) {
        } else {
          const originalHeight = element.style.height;
          element.style.height = "0";
          const width = this.getColumnWidth();
          const left = this.getLeftColumnsWidth() + element.getBoundingClientRect().left;
          let roundedLeftWidth = Math.floor(left / width) * width;
          element.style.height = originalHeight;
          this.setLeftColumnsWidth(roundedLeftWidth);
          if (this.navigator.rights.enableContentProtection) {
            (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(0);
          }
        }
      }
    }
    goToElement(element, relative) {
      var _a;
      if (this.scrollMode) {
        if (element) {
          element.scrollIntoView({ block: "center" });
        }
      } else {
        if (element) {
          const originalHeight = element.style.height;
          element.style.height = "0";
          const left = element.getBoundingClientRect().left;
          const width = this.getColumnWidth();
          const diff = this.scrollingElement.scrollLeft - width;
          let roundedLeftWidth = Math.ceil(left / width) * width + diff;
          if (relative) {
            const origin = this.getLeftColumnsWidth();
            roundedLeftWidth = Math.ceil(left / width) * width + origin;
          }
          element.style.height = originalHeight;
          this.setLeftColumnsWidth(roundedLeftWidth);
          if (this.navigator.rights.enableContentProtection) {
            (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(200);
          }
        }
      }
    }
    // at top in scroll mode
    atStart() {
      if (this.scrollMode) {
        const wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        return wrapper.scrollTop === 0;
      } else {
        const leftWidth = this.getLeftColumnsWidth();
        return leftWidth <= 0;
      }
    }
    // at bottom in scroll mode
    atEnd() {
      if (this.scrollMode) {
        const wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        return Math.ceil(this.scrollingElement.scrollHeight - wrapper.scrollTop) - 1 <= getHeight();
      } else {
        const rightWidth = Math.floor(this.getRightColumnsWidth());
        return rightWidth <= 0 || Math.ceil(this.getCurrentPage()) === this.getPageCount();
      }
    }
    goToPreviousPage() {
      var _a;
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (this.scrollMode) {
        const leftHeight = wrapper.scrollTop;
        const height = this.getScreenHeight() - 40;
        const offset = leftHeight - height;
        if (offset >= 0) {
          wrapper.scrollTop = offset;
        } else {
          wrapper.scrollTop = 0;
        }
      } else {
        const leftWidth = this.getLeftColumnsWidth();
        const width = this.getColumnWidth();
        const offset = leftWidth - width;
        if (offset >= 0) {
          this.setLeftColumnsWidth(offset);
        } else {
          this.setLeftColumnsWidth(0);
        }
        this.navigator.checkResourcePosition();
      }
      if (this.navigator.rights.enableContentProtection) {
        (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate();
      }
    }
    goToNextPage() {
      var _a;
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (this.scrollMode) {
        const leftHeight = wrapper.scrollTop;
        const height = this.getScreenHeight() - 40;
        const scrollHeight = this.scrollingElement.scrollHeight;
        const offset = leftHeight + height;
        if (offset < scrollHeight) {
          wrapper.scrollTop = offset;
        } else {
          wrapper.scrollTop = scrollHeight;
        }
      } else {
        const leftWidth = this.getLeftColumnsWidth();
        const width = this.getColumnWidth();
        const scrollWidth = this.scrollWidth;
        const offset = leftWidth + width;
        if (offset < scrollWidth) {
          this.setLeftColumnsWidth(offset);
        } else {
          this.setLeftColumnsWidth(scrollWidth);
        }
        this.navigator.checkResourcePosition();
      }
      if (this.navigator.rights.enableContentProtection) {
        (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate();
      }
    }
    // doesn't exist in scroll mode
    getCurrentPage() {
      if (this.scrollMode) {
        return 0;
      } else {
        return this.getCurrentPosition() * this.getPageCount() + 1;
      }
    }
    // doesn't exist in scroll mode
    getPageCount() {
      if (this.scrollMode) {
        return 0;
      } else {
        const width = this.getColumnWidth();
        return this.scrollWidth / width;
      }
    }
    isPaginated() {
      if (this.iframe) {
        let doc = this.iframe.contentDocument;
        if (doc) {
          const html = findIframeElement(
            doc,
            "html"
          );
          if (html) {
            const scroll = "readium-scroll-on" === html.style.getPropertyValue("--USER__scroll");
            return !scroll;
          }
        }
      }
      return !this.scrollMode;
    }
    isScrollMode() {
      if (this.iframe) {
        let doc = this.iframe.contentDocument;
        if (doc) {
          const html = findIframeElement(
            doc,
            "html"
          );
          if (html) {
            return "readium-scroll-on" === html.style.getPropertyValue("--USER__scroll");
          }
        }
      }
      return this.scrollMode;
    }
    async getProperty(name) {
      let array = await this.store.get(this.USERSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        properties = properties.filter((el) => el.name === name);
        if (properties.length === 0) {
          return null;
        }
        return properties[0];
      }
      return null;
    }
    // scrolling functions
    getScreenHeight() {
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      return wrapper.clientHeight;
    }
    setIframeHeight(iframe) {
      let d = (0, import_debounce.debounce)((iframe2) => {
        if (iframe2) {
          let body = iframe2.contentWindow.document.body, html = iframe2.contentWindow.document.documentElement;
          let height = Math.max(
            body == null ? void 0 : body.scrollHeight,
            body == null ? void 0 : body.offsetHeight,
            html == null ? void 0 : html.clientHeight,
            html == null ? void 0 : html.scrollHeight,
            html == null ? void 0 : html.offsetHeight
          );
          if (height) {
            const minHeight = getHeight() - this.attributes.margin;
            iframe2.height = Math.max(minHeight, height) + "px";
          }
        }
      }, 200);
      d(iframe);
    }
    checkForFixedScrollWidth() {
      let doc = this.iframe.contentDocument;
      if (doc) {
        const body = findIframeElement(doc, "body");
        const originalScrollWidth = body == null ? void 0 : body.scrollWidth;
        this.hasFixedScrollWidth = (body == null ? void 0 : body.scrollWidth) === originalScrollWidth;
      }
    }
    setSize() {
      var _a, _b;
      this.iframe.width = getWidth() + "px";
      if (!this.scrollMode) {
        let doc = this.iframe.contentDocument;
        if (doc && doc.documentElement) {
          doc.documentElement.style.height = this.height + "px";
        }
        this.iframe.height = this.height + "px";
      } else {
        let html = (_b = (_a = this.iframe.contentWindow) == null ? void 0 : _a.document) == null ? void 0 : _b.documentElement;
        this.iframe.height = (html == null ? void 0 : html.offsetHeight) + "px";
      }
    }
    // TODO: if we changed the following functions to handle screen size (height and width) we can use it for both paginated and reflowable.
    // For example: getColumnWidth would be renamed to something that gives us either the offsetWidth when in paginated mode and the offsetHeight when in scroll mode. etc.
    // Since theses are the only 4 functions right now that are specifically used for paginated mode but gives us nothing for scroll mode, it would make sense to make them more universal
    /** Returns the total width of the columns that are currently
       positioned to the left of the iframe viewport. */
    getLeftColumnsWidth() {
      return Math.ceil(this.scrollingElement.scrollLeft);
    }
    /** Returns the total width of the columns that are currently
       positioned to the right of the iframe viewport. */
    getRightColumnsWidth() {
      const width = this.getColumnWidth();
      let rightWidth = this.scrollWidth - width;
      if (this.hasFixedScrollWidth) {
        const leftWidth = this.getLeftColumnsWidth();
        rightWidth = Math.max(0, rightWidth - leftWidth);
      }
      return rightWidth;
    }
    /** Returns the width of one column. */
    getColumnWidth() {
      return this.scrollingElement.clientWidth;
    }
    /** Shifts the columns so that the specified width is positioned
       to the left of the iframe viewport. */
    setLeftColumnsWidth(width) {
      this.scrollingElement.scrollLeft = width;
    }
    get scrollingElement() {
      var _a, _b, _c, _d;
      if ((_a = this.iframe.contentDocument) == null ? void 0 : _a.scrollingElement) {
        return (_b = this.iframe.contentDocument) == null ? void 0 : _b.scrollingElement;
      } else if ((_c = this.iframe.contentDocument) == null ? void 0 : _c.body) {
        return (_d = this.iframe.contentDocument) == null ? void 0 : _d.body;
      } else {
        return document.createElement("body");
      }
    }
    get scrollWidth() {
      var _a;
      const scrollWidth = (_a = this.scrollingElement) == null ? void 0 : _a.scrollWidth;
      const width = this.getColumnWidth();
      const pages = Math.ceil(scrollWidth / width);
      return pages * width;
    }
  };

  // src/views/FixedBookView.ts
  init_polyfills();
  var FixedBookView = class {
    constructor() {
      this.layout = "fixed";
      this.sideMargin = 20;
      this.height = 0;
      this.attributes = { margin: 0 };
    }
    start() {
    }
    stop() {
    }
    getCurrentPosition() {
      return 0;
    }
    getScreenHeight() {
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      return wrapper.clientHeight;
    }
    goToProgression(_position) {
    }
    goToCssSelector(_cssSelector, _relative) {
    }
    goToFragment(_fragment, _relative) {
    }
    snap(_element, _relative) {
    }
    getCurrentPage() {
      return 0;
    }
    getPageCount() {
      return 1;
    }
    setSize() {
    }
    isPaginated() {
      return true;
    }
    isScrollMode() {
      return false;
    }
    atEnd() {
      return true;
    }
    atStart() {
      return true;
    }
  };

  // src/model/user-settings/UserSettings.ts
  var import_loglevel2 = __toESM(require_loglevel());
  var _UserSettings = class _UserSettings {
    constructor(store, headerMenu, api, injectables, layout) {
      this.USERSETTINGS = "userSetting";
      this.fontSize = 100;
      this.fontOverride = false;
      this.fontFamily = 0;
      this.appearance = 0;
      this.verticalScroll = true;
      //Advanced settings
      // publisherDefaults = true;
      this.textAlignment = 0;
      this.columnCount = 0;
      this.wordSpacing = 0;
      this.letterSpacing = 0;
      this.pageMargins = 2;
      this.lineHeight = 1;
      this.settingsChangeCallback = () => {
      };
      this.settingsColumnsChangeCallback = () => {
      };
      this.viewChangeCallback = () => {
      };
      var _a;
      this.store = store;
      this.view = layout === "fixed" ? new FixedBookView() : new ReflowableBookView(this.store);
      this.headerMenu = headerMenu;
      this.api = api;
      this.injectables = injectables;
      (_a = this.injectables) == null ? void 0 : _a.forEach((injectable) => {
        if (injectable.type === "style") {
          if (injectable.fontFamily) {
            this.addFont(injectable.fontFamily);
          }
          if (injectable.appearance) {
            this.addAppearance(injectable.appearance);
          }
        }
      });
    }
    async isPaginated() {
      let scroll = await this.getPropertyAndFallback(
        "verticalScroll",
        ReadiumCSS.SCROLL_KEY
      );
      return !scroll;
    }
    async isScrollMode() {
      return !await this.isPaginated();
    }
    static async create(config2) {
      const settings = new this(
        config2.store,
        config2.headerMenu,
        config2.api,
        config2.injectables,
        config2.layout
      );
      await settings.initialise();
      if (config2.initialUserSettings) {
        if (!settings.userProperties) {
          settings.userProperties = settings.getUserSettings();
        }
        let initialUserSettings = config2.initialUserSettings;
        if (initialUserSettings.verticalScroll !== void 0) {
          settings.verticalScroll = this.parseScrollSetting(
            initialUserSettings.verticalScroll
          );
          let prop = settings.userProperties.getByRef(ReadiumCSS.SCROLL_REF);
          if (prop) {
            prop.value = settings.verticalScroll;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.verticalScroll);
        }
        if (initialUserSettings.appearance) {
          settings.appearance = _UserSettings.parseAppearanceSetting(
            initialUserSettings.appearance
          );
          let prop = settings.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF);
          if (prop) {
            prop.value = settings.appearance;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.appearance);
        }
        if (initialUserSettings.fontSize) {
          settings.fontSize = initialUserSettings.fontSize;
          let prop = settings.userProperties.getByRef(ReadiumCSS.FONT_SIZE_REF);
          if (prop) {
            prop.value = settings.fontSize;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.fontSize);
        }
        if (initialUserSettings.fontFamily) {
          settings.fontFamily = _UserSettings.fontFamilyValues.findIndex(
            (el) => el === initialUserSettings.fontFamily
          );
          let prop = settings.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF);
          if (prop) {
            prop.value = settings.fontFamily;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.fontFamily);
          if (settings.fontFamily !== 0) {
            settings.fontOverride = true;
          }
        }
        if (initialUserSettings.textAlignment) {
          settings.textAlignment = _UserSettings.textAlignmentValues.findIndex(
            (el) => el === initialUserSettings.textAlignment
          );
          let prop = settings.userProperties.getByRef(
            ReadiumCSS.TEXT_ALIGNMENT_REF
          );
          if (prop) {
            prop.value = settings.textAlignment;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.textAlignment);
        }
        if (initialUserSettings.columnCount) {
          settings.columnCount = _UserSettings.columnCountValues.findIndex(
            (el) => el === initialUserSettings.columnCount
          );
          let prop = settings.userProperties.getByRef(
            ReadiumCSS.COLUMN_COUNT_REF
          );
          if (prop) {
            prop.value = settings.columnCount;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.columnCount);
        }
        if (initialUserSettings.wordSpacing) {
          settings.wordSpacing = initialUserSettings.wordSpacing;
          let prop = settings.userProperties.getByRef(
            ReadiumCSS.WORD_SPACING_REF
          );
          if (prop) {
            prop.value = settings.wordSpacing;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.wordSpacing);
        }
        if (initialUserSettings.letterSpacing) {
          settings.letterSpacing = initialUserSettings.letterSpacing;
          let prop = settings.userProperties.getByRef(
            ReadiumCSS.LETTER_SPACING_REF
          );
          if (prop) {
            prop.value = settings.letterSpacing;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.letterSpacing);
        }
        if (initialUserSettings.pageMargins) {
          settings.pageMargins = initialUserSettings.pageMargins;
          let prop = settings.userProperties.getByRef(
            ReadiumCSS.PAGE_MARGINS_REF
          );
          if (prop) {
            prop.value = settings.pageMargins;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.pageMargins);
        }
        if (initialUserSettings.lineHeight) {
          settings.lineHeight = initialUserSettings.lineHeight;
          let prop = settings.userProperties.getByRef(ReadiumCSS.LINE_HEIGHT_REF);
          if (prop) {
            prop.value = settings.lineHeight;
            await settings.saveProperty(prop);
          }
          import_loglevel2.default.log(settings.lineHeight);
        }
        settings.userProperties = settings.getUserSettings();
        await settings.initialise();
      }
      await settings.initializeSelections();
      return new Promise((resolve) => resolve(settings));
    }
    stop() {
      import_loglevel2.default.log("book settings stop");
    }
    async initialise() {
      this.appearance = await this.getPropertyAndFallback(
        "appearance",
        ReadiumCSS.APPEARANCE_KEY
      );
      this.verticalScroll = await this.getPropertyAndFallback(
        "verticalScroll",
        ReadiumCSS.SCROLL_KEY
      );
      this.fontFamily = await this.getPropertyAndFallback(
        "fontFamily",
        ReadiumCSS.FONT_FAMILY_KEY
      );
      if (this.fontFamily !== 0) {
        this.fontOverride = true;
      }
      this.textAlignment = await this.getPropertyAndFallback(
        "textAlignment",
        ReadiumCSS.TEXT_ALIGNMENT_KEY
      );
      this.columnCount = await this.getPropertyAndFallback(
        "columnCount",
        ReadiumCSS.COLUMN_COUNT_KEY
      );
      this.fontSize = await this.getPropertyAndFallback(
        "fontSize",
        ReadiumCSS.FONT_SIZE_KEY
      );
      this.wordSpacing = await this.getPropertyAndFallback(
        "wordSpacing",
        ReadiumCSS.WORD_SPACING_KEY
      );
      this.letterSpacing = await this.getPropertyAndFallback(
        "letterSpacing",
        ReadiumCSS.LETTER_SPACING_KEY
      );
      this.pageMargins = await this.getPropertyAndFallback(
        "pageMargins",
        ReadiumCSS.PAGE_MARGINS_KEY
      );
      this.lineHeight = await this.getPropertyAndFallback(
        "lineHeight",
        ReadiumCSS.LINE_HEIGHT_KEY
      );
      this.userProperties = this.getUserSettings();
    }
    async reset() {
      this.appearance = 0;
      this.verticalScroll = true;
      this.fontSize = 100;
      this.fontOverride = false;
      this.fontFamily = 0;
      this.textAlignment = 0;
      this.columnCount = 0;
      this.wordSpacing = 0;
      this.letterSpacing = 0;
      this.pageMargins = 2;
      this.lineHeight = 1;
      this.userProperties = this.getUserSettings();
      let doc = this.iframe.contentDocument;
      if (doc) {
        const html = findIframeElement(
          doc,
          "html"
        );
        if (html) {
          const rootElement = findElement(document, "#root") || document.documentElement;
          const body = findElement(html, "body");
          html.style.removeProperty(ReadiumCSS.FONT_SIZE_KEY);
          html.style.removeProperty(ReadiumCSS.WORD_SPACING_KEY);
          html.style.removeProperty(ReadiumCSS.LETTER_SPACING_KEY);
          html.style.removeProperty(ReadiumCSS.COLUMN_COUNT_KEY);
          html.style.removeProperty(ReadiumCSS.TEXT_ALIGNMENT_KEY);
          html.style.removeProperty(ReadiumCSS.LINE_HEIGHT_KEY);
          html.style.removeProperty(ReadiumCSS.PAGE_MARGINS_KEY);
          html.style.removeProperty(ReadiumCSS.APPEARANCE_KEY);
          if (rootElement)
            setAttr(rootElement, "data-viewer-theme", "day");
          if (body)
            setAttr(body, "data-viewer-theme", "day");
          html.style.removeProperty(ReadiumCSS.FONT_FAMILY_KEY);
          setAttr(html, "data-viewer-font", "publisher");
          html.style.setProperty(
            ReadiumCSS.FONT_OVERRIDE_KEY,
            "readium-font-off"
          );
        }
      }
    }
    // TODO not really needed
    async initializeSelections() {
      if (this.headerMenu)
        this.settingsView = findElement(
          this.headerMenu,
          "#container-view-settings"
        );
    }
    async applyProperties() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
      this.userProperties = this.getUserSettings();
      let doc = this.iframe.contentDocument;
      if (doc) {
        const html = findIframeElement(
          doc,
          "html"
        );
        if (html) {
          const rootElement = findElement(document, "#root") || document.documentElement;
          const body = findElement(html, "body");
          if ((_a = this.view) == null ? void 0 : _a.navigator.publication.isReflowable) {
            if (await this.getProperty(ReadiumCSS.FONT_SIZE_KEY)) {
              html.style.setProperty(
                ReadiumCSS.FONT_SIZE_KEY,
                ((_b = this.userProperties.getByRef(ReadiumCSS.FONT_SIZE_REF)) == null ? void 0 : _b.toString()) ?? null
              );
            }
            if (await this.getProperty(ReadiumCSS.WORD_SPACING_KEY)) {
              html.style.setProperty(
                ReadiumCSS.WORD_SPACING_KEY,
                ((_c = this.userProperties.getByRef(ReadiumCSS.WORD_SPACING_REF)) == null ? void 0 : _c.toString()) ?? null
              );
            }
            if (await this.getProperty(ReadiumCSS.LETTER_SPACING_KEY)) {
              html.style.setProperty(
                ReadiumCSS.LETTER_SPACING_KEY,
                ((_d = this.userProperties.getByRef(ReadiumCSS.LETTER_SPACING_REF)) == null ? void 0 : _d.toString()) ?? null
              );
            }
          }
          if (await this.getProperty(ReadiumCSS.COLUMN_COUNT_KEY)) {
            html.style.setProperty(
              ReadiumCSS.COLUMN_COUNT_KEY,
              ((_e = this.userProperties.getByRef(ReadiumCSS.COLUMN_COUNT_REF)) == null ? void 0 : _e.toString()) ?? null
            );
          }
          if ((_f = this.view) == null ? void 0 : _f.navigator.publication.isReflowable) {
            if (await this.getProperty(ReadiumCSS.TEXT_ALIGNMENT_KEY)) {
              if (((_g = this.userProperties.getByRef(ReadiumCSS.TEXT_ALIGNMENT_REF)) == null ? void 0 : _g.toString()) === "auto") {
                html.style.removeProperty(ReadiumCSS.TEXT_ALIGNMENT_KEY);
              } else {
                html.style.setProperty(
                  ReadiumCSS.TEXT_ALIGNMENT_KEY,
                  ((_h = this.userProperties.getByRef(ReadiumCSS.TEXT_ALIGNMENT_REF)) == null ? void 0 : _h.toString()) ?? null
                );
              }
            }
            if (await this.getProperty(ReadiumCSS.LINE_HEIGHT_KEY)) {
              html.style.setProperty(
                ReadiumCSS.LINE_HEIGHT_KEY,
                ((_i = this.userProperties.getByRef(ReadiumCSS.LINE_HEIGHT_REF)) == null ? void 0 : _i.toString()) ?? null
              );
            }
            if (await this.getProperty(ReadiumCSS.PAGE_MARGINS_KEY)) {
              html.style.setProperty(
                ReadiumCSS.PAGE_MARGINS_KEY,
                ((_j = this.userProperties.getByRef(ReadiumCSS.PAGE_MARGINS_REF)) == null ? void 0 : _j.toString()) ?? null
              );
            }
          }
          if (await this.getProperty(ReadiumCSS.APPEARANCE_KEY)) {
            html.style.setProperty(
              ReadiumCSS.APPEARANCE_KEY,
              ((_k = this.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _k.toString()) ?? null
            );
            if (((_l = this.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _l.value) === 0) {
              if (rootElement)
                setAttr(rootElement, "data-viewer-theme", "day");
              if (body)
                setAttr(body, "data-viewer-theme", "day");
            } else if (((_m = this.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _m.value) === 1) {
              if (rootElement)
                setAttr(rootElement, "data-viewer-theme", "sepia");
              if (body)
                setAttr(body, "data-viewer-theme", "sepia");
            } else if (((_n = this.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _n.value) === 2) {
              if (rootElement)
                setAttr(rootElement, "data-viewer-theme", "night");
              if (body)
                setAttr(body, "data-viewer-theme", "night");
            }
          } else {
            html.style.setProperty(
              ReadiumCSS.APPEARANCE_KEY,
              ((_o = this.userProperties.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _o.toString()) ?? null
            );
            if (rootElement)
              setAttr(rootElement, "data-viewer-theme", "day");
            if (body)
              setAttr(body, "data-viewer-theme", "day");
          }
          if ((_p = this.view) == null ? void 0 : _p.navigator.publication.isReflowable) {
            if (await this.getProperty(ReadiumCSS.FONT_FAMILY_KEY)) {
              html.style.setProperty(
                ReadiumCSS.FONT_FAMILY_KEY,
                ((_q = this.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _q.toString()) ?? null
              );
              if (((_r = this.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _r.value) === 0) {
                setAttr(html, "data-viewer-font", "publisher");
                html.style.setProperty(
                  ReadiumCSS.FONT_OVERRIDE_KEY,
                  "readium-font-off"
                );
              } else if (((_s = this.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _s.value) === 1) {
                setAttr(html, "data-viewer-font", "serif");
                html.style.setProperty(
                  ReadiumCSS.FONT_OVERRIDE_KEY,
                  "readium-font-on"
                );
              } else if (((_t = this.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _t.value) === 2) {
                setAttr(html, "data-viewer-font", "sans");
                html.style.setProperty(
                  ReadiumCSS.FONT_OVERRIDE_KEY,
                  "readium-font-on"
                );
              } else {
                let prop = this.userProperties.getByRef(
                  ReadiumCSS.FONT_FAMILY_REF
                );
                if (prop) {
                  setAttr(
                    html,
                    "data-viewer-font",
                    prop.toString()
                  );
                }
                html.style.setProperty(
                  ReadiumCSS.FONT_OVERRIDE_KEY,
                  "readium-font-on"
                );
              }
            } else {
              html.style.setProperty(
                ReadiumCSS.FONT_FAMILY_KEY,
                ((_u = this.userProperties.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _u.toString()) ?? null
              );
              setAttr(html, "data-viewer-font", "publisher");
              html.style.setProperty(
                ReadiumCSS.FONT_OVERRIDE_KEY,
                "readium-font-off"
              );
            }
            if (await this.getProperty(ReadiumCSS.SCROLL_KEY)) {
              if (((_v = this.userProperties.getByRef(ReadiumCSS.SCROLL_REF)) == null ? void 0 : _v.value) === true) {
                html.style.setProperty("--USER__scroll", "readium-scroll-on");
              } else {
                html.style.setProperty("--USER__scroll", "readium-scroll-off");
              }
            } else {
              html.style.setProperty("--USER__scroll", "readium-scroll-on");
            }
            html.style.setProperty(
              "--USER__advancedSettings",
              "readium-advanced-on"
            );
            this.isScrollMode().then((scroll) => {
              var _a2, _b2;
              (_b2 = (_a2 = this.view) == null ? void 0 : _a2.setMode) == null ? void 0 : _b2.call(_a2, scroll);
            });
          }
        }
      }
    }
    setIframe(iframe) {
      this.iframe = iframe;
      if (this.view) {
        this.view.iframe = iframe;
      }
      if (this.settingsView)
        _UserSettings.renderControls(this.settingsView);
    }
    static renderControls(element) {
      addEventListenerOptional(
        findElement(element, "ul"),
        "click",
        (event) => {
          event.stopPropagation();
        }
      );
    }
    onSettingsChange(callback) {
      this.settingsChangeCallback = callback;
    }
    onColumnSettingsChange(callback) {
      this.settingsColumnsChangeCallback = callback;
    }
    onViewChange(callback) {
      this.viewChangeCallback = callback;
    }
    async storeProperty(property) {
      await this.updateUserSettings();
      await this.saveProperty(property);
    }
    addAppearance(appearance) {
      if (!_UserSettings.appearanceValues.includes(appearance)) {
        _UserSettings.appearanceValues.push(appearance);
      }
    }
    initAddedAppearance() {
      this.applyProperties();
    }
    addFont(fontFamily) {
      if (!_UserSettings.fontFamilyValues.includes(fontFamily)) {
        _UserSettings.fontFamilyValues.push(fontFamily);
      }
    }
    initAddedFont() {
      this.applyProperties();
    }
    async updateUserSettings() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
      let userSettings = {
        fontFamily: _UserSettings.fontFamilyValues[await ((_b = (_a = this.userProperties) == null ? void 0 : _a.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _b.value)],
        fontSize: (_d = (_c = this.userProperties) == null ? void 0 : _c.getByRef(ReadiumCSS.FONT_SIZE_REF)) == null ? void 0 : _d.value,
        appearance: _UserSettings.appearanceValues[await ((_f = (_e = this.userProperties) == null ? void 0 : _e.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _f.value)],
        textAlignment: _UserSettings.textAlignmentValues[await ((_h = (_g = this.userProperties) == null ? void 0 : _g.getByRef(ReadiumCSS.TEXT_ALIGNMENT_REF)) == null ? void 0 : _h.value)],
        columnCount: _UserSettings.columnCountValues[await ((_j = (_i = this.userProperties) == null ? void 0 : _i.getByRef(ReadiumCSS.COLUMN_COUNT_REF)) == null ? void 0 : _j.value)],
        wordSpacing: (_l = (_k = this.userProperties) == null ? void 0 : _k.getByRef(ReadiumCSS.WORD_SPACING_REF)) == null ? void 0 : _l.value,
        letterSpacing: (_n = (_m = this.userProperties) == null ? void 0 : _m.getByRef(
          ReadiumCSS.LETTER_SPACING_REF
        )) == null ? void 0 : _n.value,
        // publisherDefault: this.userProperties.getByRef(
        //   ReadiumCSS.PUBLISHER_DEFAULT_REF
        // ).value,
        verticalScroll: (_p = (_o = this.userProperties) == null ? void 0 : _o.getByRef(ReadiumCSS.SCROLL_REF)) == null ? void 0 : _p.value
      };
      if ((_q = this.api) == null ? void 0 : _q.updateSettings) {
        (_r = this.api) == null ? void 0 : _r.updateSettings(userSettings).then((_) => {
          import_loglevel2.default.log("api updated user settings", JSON.stringify(userSettings));
        });
      }
    }
    getUserSettings() {
      let userProperties = new UserProperties();
      userProperties.addSwitchable(
        "readium-font-on",
        "readium-font-off",
        this.fontOverride,
        ReadiumCSS.FONT_OVERRIDE_REF,
        ReadiumCSS.FONT_OVERRIDE_KEY
      );
      userProperties.addEnumerable(
        this.columnCount,
        _UserSettings.columnCountValues,
        ReadiumCSS.COLUMN_COUNT_REF,
        ReadiumCSS.COLUMN_COUNT_KEY
      );
      userProperties.addEnumerable(
        this.appearance,
        _UserSettings.appearanceValues,
        ReadiumCSS.APPEARANCE_REF,
        ReadiumCSS.APPEARANCE_KEY
      );
      userProperties.addIncremental(
        this.pageMargins,
        0.5,
        4,
        0.25,
        "",
        ReadiumCSS.PAGE_MARGINS_REF,
        ReadiumCSS.PAGE_MARGINS_KEY
      );
      userProperties.addEnumerable(
        this.textAlignment,
        _UserSettings.textAlignmentValues,
        ReadiumCSS.TEXT_ALIGNMENT_REF,
        ReadiumCSS.TEXT_ALIGNMENT_KEY
      );
      userProperties.addEnumerable(
        this.fontFamily,
        _UserSettings.fontFamilyValues,
        ReadiumCSS.FONT_FAMILY_REF,
        ReadiumCSS.FONT_FAMILY_KEY
      );
      userProperties.addIncremental(
        this.fontSize,
        100,
        300,
        25,
        "%",
        ReadiumCSS.FONT_SIZE_REF,
        ReadiumCSS.FONT_SIZE_KEY
      );
      userProperties.addIncremental(
        this.lineHeight,
        1,
        2,
        0.25,
        "em",
        ReadiumCSS.LINE_HEIGHT_REF,
        ReadiumCSS.LINE_HEIGHT_KEY
      );
      userProperties.addIncremental(
        this.wordSpacing,
        0,
        1,
        0.25,
        "rem",
        ReadiumCSS.WORD_SPACING_REF,
        ReadiumCSS.WORD_SPACING_KEY
      );
      userProperties.addIncremental(
        this.letterSpacing,
        0,
        0.5,
        0.0625,
        "em",
        ReadiumCSS.LETTER_SPACING_REF,
        ReadiumCSS.LETTER_SPACING_KEY
      );
      userProperties.addSwitchable(
        "readium-scroll-on",
        "readium-scroll-off",
        this.verticalScroll,
        ReadiumCSS.SCROLL_REF,
        ReadiumCSS.SCROLL_KEY
      );
      return userProperties;
    }
    async saveProperty(property) {
      let savedProperties = await this.store.get(this.USERSETTINGS);
      if (savedProperties) {
        let array = JSON.parse(savedProperties);
        array = array.filter((el) => el.name !== property.name);
        if (property.value !== void 0) {
          array.push(property);
        }
        await this.store.set(this.USERSETTINGS, JSON.stringify(array));
      } else {
        let array = [];
        array.push(property);
        await this.store.set(this.USERSETTINGS, JSON.stringify(array));
      }
      return new Promise((resolve) => resolve(property));
    }
    async getProperty(name) {
      let array = await this.store.get(this.USERSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        properties = properties.filter((el) => el.name === name);
        if (properties.length === 0) {
          return null;
        }
        return properties[0];
      }
      return null;
    }
    /**
     * If the property doesn't exist in the store, will fall back to the value on this
     */
    async getPropertyAndFallback(name, key) {
      var _a;
      return ((_a = await this.getProperty(key)) == null ? void 0 : _a.value) ?? this[name];
    }
    async resetUserSettings() {
      await this.store.remove(this.USERSETTINGS);
      await this.reset();
      this.settingsChangeCallback();
    }
    get currentSettings() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return {
        appearance: _UserSettings.appearanceValues[(_b = (_a = this.userProperties) == null ? void 0 : _a.getByRef(ReadiumCSS.APPEARANCE_REF)) == null ? void 0 : _b.value],
        //readium-default-on, readium-night-on, readium-sepia-on
        fontFamily: _UserSettings.fontFamilyValues[(_d = (_c = this.userProperties) == null ? void 0 : _c.getByRef(ReadiumCSS.FONT_FAMILY_REF)) == null ? void 0 : _d.value],
        //Original, serif, sans-serif
        textAlignment: _UserSettings.textAlignmentValues[(_f = (_e = this.userProperties) == null ? void 0 : _e.getByRef(ReadiumCSS.TEXT_ALIGNMENT_REF)) == null ? void 0 : _f.value],
        //"auto", "justify", "start"
        columnCount: _UserSettings.columnCountValues[(_h = (_g = this.userProperties) == null ? void 0 : _g.getByRef(ReadiumCSS.COLUMN_COUNT_REF)) == null ? void 0 : _h.value],
        // "auto", "1", "2"
        verticalScroll: this.verticalScroll,
        fontSize: this.fontSize,
        wordSpacing: this.wordSpacing,
        letterSpacing: this.letterSpacing,
        pageMargins: this.pageMargins,
        lineHeight: this.lineHeight
      };
    }
    async applyUserSettings(userSettings) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      if (userSettings.appearance) {
        this.appearance = _UserSettings.parseAppearanceSetting(
          userSettings.appearance
        );
        let prop = (_a = this.userProperties) == null ? void 0 : _a.getByRef(ReadiumCSS.APPEARANCE_REF);
        if (prop) {
          prop.value = this.appearance;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.fontSize) {
        this.fontSize = userSettings.fontSize;
        let prop = (_b = this.userProperties) == null ? void 0 : _b.getByRef(ReadiumCSS.FONT_SIZE_REF);
        if (prop) {
          prop.value = this.fontSize;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.fontFamily) {
        this.fontFamily = _UserSettings.fontFamilyValues.findIndex(
          (el) => el === userSettings.fontFamily
        );
        let prop = (_c = this.userProperties) == null ? void 0 : _c.getByRef(ReadiumCSS.FONT_FAMILY_REF);
        if (prop) {
          prop.value = this.fontFamily;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.letterSpacing) {
        this.letterSpacing = userSettings.letterSpacing;
        let prop = (_d = this.userProperties) == null ? void 0 : _d.getByRef(ReadiumCSS.LETTER_SPACING_REF);
        if (prop) {
          prop.value = this.letterSpacing;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.wordSpacing) {
        this.wordSpacing = userSettings.wordSpacing;
        let prop = (_e = this.userProperties) == null ? void 0 : _e.getByRef(ReadiumCSS.WORD_SPACING_REF);
        if (prop) {
          prop.value = this.wordSpacing;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.columnCount) {
        this.columnCount = _UserSettings.columnCountValues.findIndex(
          (el) => el === userSettings.columnCount
        );
        let prop = (_f = this.userProperties) == null ? void 0 : _f.getByRef(ReadiumCSS.COLUMN_COUNT_REF);
        if (prop) {
          prop.value = this.columnCount;
          await this.storeProperty(prop);
        }
        this.settingsColumnsChangeCallback();
      }
      if (userSettings.textAlignment) {
        this.textAlignment = _UserSettings.textAlignmentValues.findIndex(
          (el) => el === userSettings.textAlignment
        );
        let prop = (_g = this.userProperties) == null ? void 0 : _g.getByRef(ReadiumCSS.TEXT_ALIGNMENT_REF);
        if (prop) {
          prop.value = this.textAlignment;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.lineHeight) {
        this.lineHeight = userSettings.lineHeight;
        let prop = (_h = this.userProperties) == null ? void 0 : _h.getByRef(ReadiumCSS.LINE_HEIGHT_REF);
        if (prop) {
          prop.value = this.lineHeight;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.pageMargins) {
        this.pageMargins = userSettings.pageMargins;
        let prop = (_i = this.userProperties) == null ? void 0 : _i.getByRef(ReadiumCSS.PAGE_MARGINS_REF);
        if (prop) {
          prop.value = this.pageMargins;
          await this.storeProperty(prop);
        }
      }
      if (userSettings.verticalScroll !== void 0) {
        const position = (_j = this.view) == null ? void 0 : _j.getCurrentPosition();
        this.verticalScroll = _UserSettings.parseScrollSetting(
          userSettings.verticalScroll
        );
        let prop = (_k = this.userProperties) == null ? void 0 : _k.getByRef(ReadiumCSS.SCROLL_REF);
        if (prop) {
          prop.value = this.verticalScroll;
          await this.saveProperty(prop);
        }
        (_m = (_l = this.view) == null ? void 0 : _l.setMode) == null ? void 0 : _m.call(_l, this.verticalScroll);
        if (position) {
          (_n = this.view) == null ? void 0 : _n.goToProgression(position);
        }
        this.viewChangeCallback();
      }
      await this.applyProperties();
      this.settingsChangeCallback();
    }
    /**
     * Parses a scroll setting from a variety of inputs to a simple boolean
     */
    static parseScrollSetting(inputSetting) {
      switch (inputSetting) {
        case true:
        case "scroll":
        case "readium-scroll-on":
          return true;
        case false:
        case "paginated":
        case "readium-scroll-off":
          return false;
        default:
          return false;
      }
    }
    static parseAppearanceSetting(inputSetting) {
      let a;
      if (inputSetting === "day" || inputSetting === "readium-default-on") {
        a = _UserSettings.appearanceValues[0];
      } else if (inputSetting === "sepia" || inputSetting === "readium-sepia-on") {
        a = _UserSettings.appearanceValues[1];
      } else if (inputSetting === "night" || inputSetting === "readium-night-on") {
        a = _UserSettings.appearanceValues[2];
      } else {
        a = inputSetting;
      }
      return _UserSettings.appearanceValues.findIndex((el) => el === a);
    }
    async scroll(scroll) {
      var _a, _b, _c, _d, _e;
      const position = (_a = this.view) == null ? void 0 : _a.getCurrentPosition();
      this.verticalScroll = scroll;
      let prop = (_b = this.userProperties) == null ? void 0 : _b.getByRef(ReadiumCSS.SCROLL_REF);
      if (prop) {
        prop.value = this.verticalScroll;
        await this.saveProperty(prop);
      }
      await this.applyProperties();
      (_d = (_c = this.view) == null ? void 0 : _c.setMode) == null ? void 0 : _d.call(_c, this.verticalScroll);
      if (position) {
        (_e = this.view) == null ? void 0 : _e.goToProgression(position);
      }
      this.viewChangeCallback();
    }
    async increase(incremental) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      if (incremental === "fontSize") {
        ((_a = this.userProperties) == null ? void 0 : _a.getByRef(ReadiumCSS.FONT_SIZE_REF)).increment();
        this.fontSize = (_c = (_b = this.userProperties) == null ? void 0 : _b.getByRef(ReadiumCSS.FONT_SIZE_REF)) == null ? void 0 : _c.value;
        let prop = (_d = this.userProperties) == null ? void 0 : _d.getByRef(ReadiumCSS.FONT_SIZE_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "letterSpacing") {
        ((_e = this.userProperties) == null ? void 0 : _e.getByRef(
          ReadiumCSS.LETTER_SPACING_REF
        )).increment();
        this.letterSpacing = (_g = (_f = this.userProperties) == null ? void 0 : _f.getByRef(
          ReadiumCSS.LETTER_SPACING_REF
        )) == null ? void 0 : _g.value;
        let prop = (_h = this.userProperties) == null ? void 0 : _h.getByRef(ReadiumCSS.LETTER_SPACING_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "wordSpacing") {
        ((_i = this.userProperties) == null ? void 0 : _i.getByRef(
          ReadiumCSS.WORD_SPACING_REF
        )).increment();
        this.wordSpacing = (_k = (_j = this.userProperties) == null ? void 0 : _j.getByRef(
          ReadiumCSS.WORD_SPACING_REF
        )) == null ? void 0 : _k.value;
        let prop = (_l = this.userProperties) == null ? void 0 : _l.getByRef(ReadiumCSS.WORD_SPACING_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "lineHeight") {
        ((_m = this.userProperties) == null ? void 0 : _m.getByRef(ReadiumCSS.LINE_HEIGHT_REF)).increment();
        this.lineHeight = (_o = (_n = this.userProperties) == null ? void 0 : _n.getByRef(
          ReadiumCSS.LINE_HEIGHT_REF
        )) == null ? void 0 : _o.value;
        let prop = (_p = this.userProperties) == null ? void 0 : _p.getByRef(ReadiumCSS.LINE_HEIGHT_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      }
      await this.applyProperties();
      this.settingsChangeCallback();
    }
    async decrease(incremental) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      if (incremental === "fontSize") {
        ((_a = this.userProperties) == null ? void 0 : _a.getByRef(ReadiumCSS.FONT_SIZE_REF)).decrement();
        this.fontSize = (_c = (_b = this.userProperties) == null ? void 0 : _b.getByRef(ReadiumCSS.FONT_SIZE_REF)) == null ? void 0 : _c.value;
        let prop = (_d = this.userProperties) == null ? void 0 : _d.getByRef(ReadiumCSS.FONT_SIZE_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "letterSpacing") {
        ((_e = this.userProperties) == null ? void 0 : _e.getByRef(
          ReadiumCSS.LETTER_SPACING_REF
        )).decrement();
        this.letterSpacing = (_g = (_f = this.userProperties) == null ? void 0 : _f.getByRef(
          ReadiumCSS.LETTER_SPACING_REF
        )) == null ? void 0 : _g.value;
        let prop = (_h = this.userProperties) == null ? void 0 : _h.getByRef(ReadiumCSS.LETTER_SPACING_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "wordSpacing") {
        ((_i = this.userProperties) == null ? void 0 : _i.getByRef(
          ReadiumCSS.WORD_SPACING_REF
        )).decrement();
        this.wordSpacing = (_k = (_j = this.userProperties) == null ? void 0 : _j.getByRef(
          ReadiumCSS.WORD_SPACING_REF
        )) == null ? void 0 : _k.value;
        let prop = (_l = this.userProperties) == null ? void 0 : _l.getByRef(ReadiumCSS.WORD_SPACING_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      } else if (incremental === "lineHeight") {
        ((_m = this.userProperties) == null ? void 0 : _m.getByRef(ReadiumCSS.LINE_HEIGHT_REF)).decrement();
        this.wordSpacing = (_o = (_n = this.userProperties) == null ? void 0 : _n.getByRef(
          ReadiumCSS.LINE_HEIGHT_REF
        )) == null ? void 0 : _o.value;
        let prop = (_p = this.userProperties) == null ? void 0 : _p.getByRef(ReadiumCSS.LINE_HEIGHT_REF);
        if (prop) {
          await this.storeProperty(prop);
        }
      }
      await this.applyProperties();
      this.settingsChangeCallback();
    }
    // async publisher(on): Promise<void> {
    //   this.userProperties.getByRef(ReadiumCSS.PUBLISHER_DEFAULT_REF).value = on;
    //   this.storeProperty(
    //     this.userProperties.getByRef(ReadiumCSS.PUBLISHER_DEFAULT_REF)
    //   );
    //   this.applyProperties();
    // }
  };
  _UserSettings.appearanceValues = [
    "readium-default-on",
    "readium-sepia-on",
    "readium-night-on"
  ];
  _UserSettings.fontFamilyValues = ["Original", "serif", "sans-serif"];
  _UserSettings.textAlignmentValues = ["auto", "justify", "start"];
  _UserSettings.columnCountValues = ["auto", "1", "2"];
  var UserSettings = _UserSettings;

  // src/modules/AnnotationModule.ts
  init_polyfills();

  // src/store/Annotator.ts
  init_polyfills();

  // src/modules/highlight/TextHighlighter.ts
  init_polyfills();

  // node_modules/jscrypto/es6/SHA256.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/algorithm/Hasher.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/algorithm/BufferedBlockAlgorithm.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/Word32Array.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/encoder/Hex.js
  init_polyfills();
  var Hex = {
    /**
     * Converts a word array to a hex string.
     *
     * @param {Word32Array} w An array of 32-bit words.
     * @return {string} The hex string.
     * @example
     *   var hexString = Hex.stringify(new Word32Array([0x293892], 6));
     */
    stringify(w) {
      const nSig = w.nSigBytes;
      const words = w.words;
      const hexChars = [];
      for (let i = 0; i < nSig; i++) {
        const byte = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        hexChars.push((byte >>> 4).toString(16));
        hexChars.push((byte & 15).toString(16));
      }
      return hexChars.join("");
    },
    /**
     * Converts a hex string to a word array.
     *
     * @param {string} hexStr The hex string.
     * @return {Word32Array} The word array.
     * @example
     *   var wordArray = Hex.parse(hexString);
     */
    parse(hexStr) {
      const Len = hexStr.length;
      if (Len % 2 !== 0) {
        throw new Error("Hex string count must be even");
      } else if (!/^[a-fA-F0-9]+$/.test(hexStr)) {
        throw new Error(`Invalid Hex string: ${hexStr}`);
      }
      const words = [];
      for (let i = 0; i < Len; i += 2) {
        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
      }
      return new Word32Array(words, Len / 2);
    }
  };

  // node_modules/jscrypto/es6/lib/random.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/browser.js
  init_polyfills();
  var ua = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var IEVer = (() => {
    let ver = parseInt((/msie (\d+)/.exec(ua) || [])[1], 10);
    if (isNaN(ver)) {
      ver = parseInt((/trident\/.*; rv:(\d+)/.exec(ua) || [])[1], 10);
      if (isNaN(ver)) {
        return false;
      }
      return ver;
    }
    return ver;
  })();
  function isIE(op, ver) {
    if (IEVer === false)
      return false;
    if (!ver)
      return true;
    if (op === "<")
      return IEVer < ver;
    if (op === "<=")
      return IEVer <= ver;
    if (op === ">")
      return IEVer > ver;
    if (op === ">=")
      return IEVer >= ver;
    if (op === "=")
      return IEVer === ver;
    return IEVer === ver;
  }

  // node_modules/jscrypto/es6/lib/random.js
  function makeRandFunction() {
    if (typeof window !== "undefined") {
      const c = window.crypto || window.msCrypto;
      if (!c) {
        if (isIE("<", 11)) {
          console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser");
          return function rand() {
            return Math.floor(Math.random() * 512) % 256;
          };
        }
        throw new Error("Crypto module not found");
      }
      return function rand() {
        return c.getRandomValues(new Uint32Array(1))[0];
      };
    } else if (typeof globalThis !== "undefined" && globalThis.crypto) {
      return function rand() {
        return globalThis.crypto.randomBytes(4).readInt32LE();
      };
    } else if (typeof __require === "function") {
      return function rand() {
        return __non_webpack_require__("crypto").randomBytes(4).readInt32LE();
      };
    }
    throw new Error("Unable to find crypto module");
  }
  var random = makeRandFunction();

  // node_modules/jscrypto/es6/lib/Word32Array.js
  var Word32Array = class _Word32Array {
    /**
     * Initializes a newly created word array.
     *
     * ByteArray Support thanks to
     * https://github.com/entronad/crypto-es/blob/master/lib/core.js
     * MIT License Copyright(c) LIN Chen
     *
     * @param {Array} words (Optional) An array of 32-bit words.
     * @param {number} nSignificantBytes (Optional) The number of significant bytes in the words.
     * @example
     *   var words = new Word32Array();
     *   var words = new Word32Array([0x00010203, 0x04050607]);
     *   var words = new Word32Array([0x00010203, 0x04050607], 6);
     *   // Cloning wordArray can be done like below.
     *   var clone = (new Word32Array([0x00010203, 0x04050607])).clone();
     *   // or
     *   var clone = new Word32Array(new Word32Array([0x00010203, 0x04050607]));
     */
    constructor(words, nSignificantBytes) {
      if (Array.isArray(words) || !words) {
        this._words = Array.isArray(words) ? words : [];
        this._nSignificantBytes = typeof nSignificantBytes === "number" ? nSignificantBytes : this._words.length * 4;
        return;
      } else if (words instanceof _Word32Array) {
        this._words = words.words.slice();
        this._nSignificantBytes = words.nSigBytes;
        return;
      }
      let uint8Array;
      try {
        if (words instanceof ArrayBuffer) {
          uint8Array = new Uint8Array(words);
        } else if (words instanceof Uint8Array || words instanceof Int8Array || words instanceof Uint8ClampedArray || words instanceof Int16Array || words instanceof Uint16Array || words instanceof Int32Array || words instanceof Uint32Array || words instanceof Float32Array || words instanceof Float64Array) {
          uint8Array = new Uint8Array(words.buffer, words.byteOffset, words.byteLength);
        }
      } catch (e) {
        throw new Error("Invalid argument");
      }
      if (!uint8Array) {
        throw new Error("Invalid argument");
      }
      const byteLen = uint8Array.byteLength;
      const w = [];
      for (let i = 0; i < byteLen; i++) {
        w[i >>> 2] |= uint8Array[i] << 24 - i % 4 * 8;
      }
      this._words = w;
      this._nSignificantBytes = byteLen;
    }
    get nSigBytes() {
      return this._nSignificantBytes;
    }
    /**
     * Set significant bytes
     * @param {number} n - significant bytes
     */
    set nSigBytes(n) {
      this._nSignificantBytes = n;
    }
    /**
     * Get raw reference of internal words.
     * Modification of this raw array will affect internal words.
     */
    get words() {
      return this._words;
    }
    /**
     * Converts this word array to a string.
     *
     * @param {IEncoder?} encoder The encoding strategy to use. Default: CryptoJS.enc.Hex
     * @return {string} The stringified word array.
     * @example
     *   var string = wordArray + '';
     *   var string = wordArray.toString();
     *   var string = wordArray.toString(Utf8);
     */
    toString(encoder) {
      if (!encoder) {
        return Hex.stringify(this);
      }
      return encoder.stringify(this);
    }
    /**
     * Converts this 32bit word array to Uint8Array
     *
     * @return {Uint8Array} Unsigned int 8bit array
     * @example
     *   var word = new Word32Array([0x00102030]);
     *   var uint8 = word.toUint8Array(); // Uint8Array(4) [ 0, 16, 32, 48 ]
     */
    toUint8Array() {
      const words = this._words;
      const nB = this._nSignificantBytes;
      const uint8Array = new Uint8Array(nB);
      for (let i = 0; i < nB; i++) {
        uint8Array[i] = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      }
      return uint8Array;
    }
    /**
     * Concatenates a word array to this word array.
     *
     * @param {Word32Array} w The word array to append.
     * @return {Word32Array} This word array.
     * @example
     *   wordArray1.concat(wordArray2);
     */
    concat(w) {
      const words = w.words.slice();
      const N = w.nSigBytes;
      this.clamp();
      if (this._nSignificantBytes % 4) {
        for (let i = 0; i < N; i++) {
          const b = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
          this._words[this._nSignificantBytes + i >>> 2] |= b << 24 - (this._nSignificantBytes + i) % 4 * 8;
        }
      } else {
        for (let i = 0; i < N; i += 4) {
          this._words[this._nSignificantBytes + i >>> 2] = words[i >>> 2];
        }
      }
      this._nSignificantBytes += N;
      return this;
    }
    /**
     * Removes insignificant bits.
     *
     * @example
     *   wordArray.clamp();
     */
    clamp() {
      const n = this._nSignificantBytes;
      this._words[n >>> 2] &= 4294967295 << 32 - n % 4 * 8;
      this._words.length = Math.ceil(n / 4);
    }
    /**
     * Creates a copy of this word array.
     *
     * @return {Word32Array} The clone.
     * @example
     *   var clone = word32Array.clone();
     */
    clone() {
      return new _Word32Array(this._words.slice(), this._nSignificantBytes);
    }
    /**
     * Creates a word array filled with random bytes.
     *
     * @param {number} nBytes The number of random bytes to generate.
     * @return {Word32Array} The random word array.
     * @static
     * @example
     *   var wordArray = Word32Array.random(16);
     */
    static random(nBytes) {
      const words = [];
      for (let i = 0; i < nBytes; i += 4) {
        words.push(random());
      }
      return new _Word32Array(words, nBytes);
    }
  };

  // node_modules/jscrypto/es6/lib/encoder/Utf8.js
  init_polyfills();

  // node_modules/jscrypto/es6/lib/encoder/Latin1.js
  init_polyfills();
  var Latin1 = {
    /**
     * Converts a word array to a Latin1 string.
     *
     * @param {Word32Array} w An array of 32-bit words.
     * @return {string} The Latin1 string.
     * @example
     *   var latin1String = Latin1.stringify(new Word32Array([0x293892], 6));
     */
    stringify(w) {
      const nSig = w.nSigBytes;
      const words = w.words;
      const latin1Chars = [];
      for (let i = 0; i < nSig; i++) {
        const byte = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        latin1Chars.push(String.fromCharCode(byte));
      }
      return latin1Chars.join("");
    },
    /**
     * Converts a latin1 string to a word array.
     *
     * @param {string} latin1Str The latin1 string.
     * @return {Word32Array} The word array.
     * @example
     *   var wordArray = Latin1.parse(latin1Str);
     */
    parse(latin1Str) {
      const Len = latin1Str.length;
      const words = [];
      for (let i = 0; i < Len; i++) {
        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
      }
      return new Word32Array(words, Len);
    }
  };

  // node_modules/jscrypto/es6/lib/encoder/Utf8.js
  var Utf8 = {
    /**
     * Converts a word array to a UTF-8 string.
     *
     * @param {Word32Array} w An array of 32-bit words.
     * @return {string} The UTF-8 string.
     * @example
     *   var utf8String = Utf8.stringify(new Word32Array([0x293892]));
     */
    stringify(w) {
      try {
        return decodeURIComponent(escape(Latin1.stringify(w)));
      } catch (e) {
        throw new Error("Malformed UTF-8 data");
      }
    },
    /**
     * Converts a UTF-8 string to a word array.
     *
     * @param {string} utf8Str The UTF-8 string.
     * @return {Word32Array} The word array.
     * @example
     *   var wordArray = Utf8.parse(utf8Str);
     */
    parse(utf8Str) {
      return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
    }
  };

  // node_modules/jscrypto/es6/lib/algorithm/BufferedBlockAlgorithm.js
  var BufferedBlockAlgorithm = class {
    constructor(props) {
      this._minBufferSize = 0;
      this._blockSize = 0;
      this._props = props;
      this._data = props && typeof props.data !== "undefined" ? props.data.clone() : new Word32Array();
      this._nBytes = props && typeof props.nBytes === "number" ? props.nBytes : 0;
    }
    get blockSize() {
      return this._blockSize;
    }
    /**
     * Resets this block algorithm's data buffer to its initial state.
     *
     * @example
     *   bufferedBlockAlgorithm.reset();
     */
    reset(data, nBytes) {
      this._data = typeof data !== "undefined" ? data.clone() : new Word32Array();
      this._nBytes = typeof nBytes === "number" ? nBytes : 0;
    }
    /**
     * Adds new data to this block algorithm's buffer.
     *
     * @param {Word32Array|string} data The data to append. Strings are converted to a WordArray using UTF-8.
     * @example
     *   bufferedBlockAlgorithm.append('data');
     *   bufferedBlockAlgorithm.append(wordArray);
     */
    _append(data) {
      const d = typeof data === "string" ? Utf8.parse(data) : data;
      this._data.concat(d);
      this._nBytes += d.nSigBytes;
    }
    /**
     * Processes available data blocks.
     * This method invokes doProcessBlock(offset), which must be implemented by a concrete subtype.
     *
     * @param {boolean?} doFlush Whether all blocks and partial blocks should be processed.
     * @return {Word32Array} The processed data.
     * @example
     *   var processedData = bufferedBlockAlgorithm.process();
     *   var processedData = bufferedBlockAlgorithm.process(!!'flush');
     */
    _process(doFlush) {
      let processedWords;
      const words = this._data.words;
      const nSigBytes = this._data.nSigBytes;
      const blockSize = this._blockSize;
      const blockSizeByte = this._blockSize * 4;
      let nBlocksReady = nSigBytes / blockSizeByte;
      if (doFlush) {
        nBlocksReady = Math.ceil(nBlocksReady);
      } else {
        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
      }
      const nWordsReady = nBlocksReady * blockSize;
      const nBytesReady = Math.min(nWordsReady * 4, nSigBytes);
      if (nWordsReady) {
        for (let offset = 0; offset < nWordsReady; offset += blockSize) {
          this._doProcessBlock(words, offset);
        }
        processedWords = words.splice(0, nWordsReady);
        this._data.nSigBytes -= nBytesReady;
      }
      return new Word32Array(processedWords, nBytesReady);
    }
    /**
     * @abstract
     */
    _doProcessBlock(words, offset) {
      throw new Error("Not implemented");
    }
  };

  // node_modules/jscrypto/es6/lib/algorithm/Hasher.js
  var Hasher = class extends BufferedBlockAlgorithm {
    constructor(props) {
      super(props);
      this._blockSize = 512 / 32;
      this._props = props;
      if (props && typeof props.blockSize === "number") {
        this._blockSize = props.blockSize;
      }
      this.reset(props ? props.data : void 0, props ? props.nBytes : void 0);
    }
    get blockSize() {
      return this._blockSize;
    }
    /**
     * Resets this hasher to its initial state.
     *
     * @example
     *   hasher.reset();
     */
    reset(data, nBytes) {
      super.reset.call(this, data, nBytes);
      this._doReset();
    }
    /**
     * Updates this hasher with a message.
     *
     * @param {Word32Array|string} messageUpdate The message to append.
     * @return {Hasher} This hasher.
     * @example
     *   hasher.update('message');
     *   hasher.update(wordArray);
     */
    update(messageUpdate) {
      this._append(messageUpdate);
      this._process();
      return this;
    }
    /**
     * Finalizes the hash computation.
     * Note that the finalize operation is effectively a destructive, read-once operation.
     *
     * @param {Word32Array|string?} messageUpdate (Optional) A final message update.
     * @return {Word32Array} The hash.
     * @example
     *   var hash = hasher.finalize();
     *   var hash = hasher.finalize('message');
     *   var hash = hasher.finalize(wordArray);
     */
    finalize(messageUpdate) {
      if (messageUpdate) {
        this._append(messageUpdate);
      }
      return this._doFinalize();
    }
    /**
     * @abstract
     */
    _doReset() {
      throw new Error("Not implemented");
    }
    /**
     * @abstract
     */
    _doFinalize() {
      throw new Error("Not implemented");
    }
  };

  // node_modules/jscrypto/es6/SHA256.js
  var H = [];
  var K = [];
  function isPrime(n) {
    const sqrtN = Math.sqrt(n);
    for (let factor = 2; factor <= sqrtN; factor++) {
      if (!(n % factor)) {
        return false;
      }
    }
    return true;
  }
  function getFractionalBits(n) {
    return (n - (n | 0)) * 4294967296 | 0;
  }
  (function computeRoundConstants() {
    let n = 2;
    let nPrime = 0;
    while (nPrime < 64) {
      if (isPrime(n)) {
        if (nPrime < 8) {
          H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
        }
        K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
        nPrime++;
      }
      n++;
    }
  })();
  var W = [];
  var SHA256 = class _SHA256 extends Hasher {
    constructor(props) {
      super(props);
      this._hash = new Word32Array(H.slice(0));
      this._props = props;
      if (props && typeof props.hash !== "undefined") {
        this._hash = props.hash.clone();
      }
    }
    _doReset() {
      this._hash = new Word32Array(H.slice(0));
    }
    _doProcessBlock(words, offset) {
      const _H = this._hash.words;
      let a = _H[0];
      let b = _H[1];
      let c = _H[2];
      let d = _H[3];
      let e = _H[4];
      let f = _H[5];
      let g = _H[6];
      let h = _H[7];
      for (let i = 0; i < 64; i++) {
        if (i < 16) {
          W[i] = words[offset + i] | 0;
        } else {
          const gamma0x = W[i - 15];
          const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
          const gamma1x = W[i - 2];
          const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
        }
        const ch = e & f ^ ~e & g;
        const maj = a & b ^ a & c ^ b & c;
        const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
        const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
        const t1 = h + sigma1 + ch + K[i] + W[i];
        const t2 = sigma0 + maj;
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      _H[0] = _H[0] + a | 0;
      _H[1] = _H[1] + b | 0;
      _H[2] = _H[2] + c | 0;
      _H[3] = _H[3] + d | 0;
      _H[4] = _H[4] + e | 0;
      _H[5] = _H[5] + f | 0;
      _H[6] = _H[6] + g | 0;
      _H[7] = _H[7] + h | 0;
    }
    _doFinalize() {
      const words = this._data.words;
      const nBitsTotal = this._nBytes * 8;
      const nBitsLeft = this._data.nSigBytes * 8;
      words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
      words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
      words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
      this._data.nSigBytes = words.length * 4;
      this._process();
      return this._hash;
    }
    clone() {
      const props = { hash: this._hash, blockSize: this._blockSize, data: this._data, nBytes: this._nBytes };
      return new _SHA256(props);
    }
    static hash(message, props) {
      return new _SHA256(props).finalize(message);
    }
  };

  // src/modules/highlight/TextHighlighter.ts
  var import_debounce2 = __toESM(require_debounce());

  // src/modules/highlight/common/highlight.ts
  init_polyfills();

  // src/modules/highlight/common/rect-utils.ts
  init_polyfills();
  var import_loglevel3 = __toESM(require_loglevel());
  function getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {
    const rangeClientRects = range.getClientRects();
    return getClientRectsNoOverlap_(
      rangeClientRects,
      doNotMergeHorizontallyAlignedRects
    );
  }
  function getClientRectsNoOverlap_(clientRects, doNotMergeHorizontallyAlignedRects) {
    const tolerance = 1;
    const originalRects = [];
    for (const rangeClientRect of clientRects) {
      originalRects.push({
        bottom: rangeClientRect.bottom,
        height: rangeClientRect.height,
        left: rangeClientRect.left,
        right: rangeClientRect.right,
        top: rangeClientRect.top,
        width: rangeClientRect.width
      });
    }
    const mergedRects = mergeTouchingRects(
      originalRects,
      tolerance,
      doNotMergeHorizontallyAlignedRects
    );
    const noContainedRects = removeContainedRects(mergedRects, tolerance);
    const newRects = replaceOverlappingRects(noContainedRects);
    const minArea = 2 * 2;
    for (let j = newRects.length - 1; j >= 0; j--) {
      const rect = newRects[j];
      const bigEnough = rect.width * rect.height > minArea;
      if (!bigEnough) {
        if (newRects.length > 1) {
          import_loglevel3.default.log("CLIENT RECT: remove small");
          newRects.splice(j, 1);
        } else {
          import_loglevel3.default.log("CLIENT RECT: remove small, but keep otherwise empty!");
          break;
        }
      }
    }
    checkOverlaps(newRects);
    import_loglevel3.default.log(
      `CLIENT RECT: reduced ${originalRects.length} --> ${newRects.length}`
    );
    return newRects;
  }
  function almostEqual(a, b, tolerance) {
    return Math.abs(a - b) <= tolerance;
  }
  function rectIntersect(rect1, rect2) {
    const maxLeft = Math.max(rect1.left, rect2.left);
    const minRight = Math.min(rect1.right, rect2.right);
    const maxTop = Math.max(rect1.top, rect2.top);
    const minBottom = Math.min(rect1.bottom, rect2.bottom);
    return {
      bottom: minBottom,
      height: Math.max(0, minBottom - maxTop),
      left: maxLeft,
      right: minRight,
      top: maxTop,
      width: Math.max(0, minRight - maxLeft)
    };
  }
  function rectSubtract(rect1, rect2) {
    const rectIntersected = rectIntersect(rect2, rect1);
    if (rectIntersected.height === 0 || rectIntersected.width === 0) {
      return [rect1];
    }
    const rects = [];
    {
      const rectA = {
        bottom: rect1.bottom,
        height: 0,
        left: rect1.left,
        right: rectIntersected.left,
        top: rect1.top,
        width: 0
      };
      rectA.width = rectA.right - rectA.left;
      rectA.height = rectA.bottom - rectA.top;
      if (rectA.height !== 0 && rectA.width !== 0) {
        rects.push(rectA);
      }
    }
    {
      const rectB = {
        bottom: rectIntersected.top,
        height: 0,
        left: rectIntersected.left,
        right: rectIntersected.right,
        top: rect1.top,
        width: 0
      };
      rectB.width = rectB.right - rectB.left;
      rectB.height = rectB.bottom - rectB.top;
      if (rectB.height !== 0 && rectB.width !== 0) {
        rects.push(rectB);
      }
    }
    {
      const rectC = {
        bottom: rect1.bottom,
        height: 0,
        left: rectIntersected.left,
        right: rectIntersected.right,
        top: rectIntersected.bottom,
        width: 0
      };
      rectC.width = rectC.right - rectC.left;
      rectC.height = rectC.bottom - rectC.top;
      if (rectC.height !== 0 && rectC.width !== 0) {
        rects.push(rectC);
      }
    }
    {
      const rectD = {
        bottom: rect1.bottom,
        height: 0,
        left: rectIntersected.right,
        right: rect1.right,
        top: rect1.top,
        width: 0
      };
      rectD.width = rectD.right - rectD.left;
      rectD.height = rectD.bottom - rectD.top;
      if (rectD.height !== 0 && rectD.width !== 0) {
        rects.push(rectD);
      }
    }
    return rects;
  }
  function rectContainsPoint(rect, x, y, tolerance) {
    return (rect.left < x || almostEqual(rect.left, x, tolerance)) && (rect.right > x || almostEqual(rect.right, x, tolerance)) && (rect.top < y || almostEqual(rect.top, y, tolerance)) && (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));
  }
  function rectContains(rect1, rect2, tolerance) {
    return rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) && // top left corner
    rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) && // top right corner
    rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) && // bottom left corner
    rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance);
  }
  function getBoundingRect(rect1, rect2) {
    const left = Math.min(rect1.left, rect2.left);
    const right = Math.max(rect1.right, rect2.right);
    const top = Math.min(rect1.top, rect2.top);
    const bottom = Math.max(rect1.bottom, rect2.bottom);
    return {
      bottom,
      height: bottom - top,
      left,
      right,
      top,
      width: right - left
    };
  }
  function rectsTouchOrOverlap(rect1, rect2, tolerance) {
    return (rect1.left < rect2.right || tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance)) && (rect2.left < rect1.right || tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance)) && (rect1.top < rect2.bottom || tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance)) && (rect2.top < rect1.bottom || tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance));
  }
  function mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {
    for (let i = 0; i < rects.length; i++) {
      for (let j = i + 1; j < rects.length; j++) {
        const rect1 = rects[i];
        const rect2 = rects[j];
        if (rect1 === rect2) {
          import_loglevel3.default.log("mergeTouchingRects rect1 === rect2 ??!");
          continue;
        }
        const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) && almostEqual(rect1.bottom, rect2.bottom, tolerance);
        const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) && almostEqual(rect1.right, rect2.right, tolerance);
        const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;
        const aligned = rectsLineUpHorizontally && horizontalAllowed || rectsLineUpVertically && !rectsLineUpHorizontally;
        const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);
        if (canMerge) {
          import_loglevel3.default.log(
            `CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`
          );
          const newRects = rects.filter((rect) => {
            return rect !== rect1 && rect !== rect2;
          });
          const replacementClientRect = getBoundingRect(rect1, rect2);
          newRects.push(replacementClientRect);
          return mergeTouchingRects(
            newRects,
            tolerance,
            doNotMergeHorizontallyAlignedRects
          );
        }
      }
    }
    return rects;
  }
  function replaceOverlappingRects(rects) {
    for (let i = 0; i < rects.length; i++) {
      for (let j = i + 1; j < rects.length; j++) {
        const rect1 = rects[i];
        const rect2 = rects[j];
        if (rect1 === rect2) {
          import_loglevel3.default.log("replaceOverlappingRects rect1 === rect2 ??!");
          continue;
        }
        if (rectsTouchOrOverlap(rect1, rect2, -1)) {
          let toAdd = [];
          let toRemove;
          let toPreserve;
          const subtractRects1 = rectSubtract(rect1, rect2);
          if (subtractRects1.length === 1) {
            toAdd = subtractRects1;
            toRemove = rect1;
            toPreserve = rect2;
          } else {
            const subtractRects2 = rectSubtract(rect2, rect1);
            if (subtractRects1.length < subtractRects2.length) {
              toAdd = subtractRects1;
              toRemove = rect1;
              toPreserve = rect2;
            } else {
              toAdd = subtractRects2;
              toRemove = rect2;
              toPreserve = rect1;
            }
          }
          const toCheck = [];
          toCheck.push(toPreserve);
          Array.prototype.push.apply(toCheck, toAdd);
          checkOverlaps(toCheck);
          import_loglevel3.default.log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);
          const newRects = rects.filter((rect) => {
            return rect !== toRemove;
          });
          Array.prototype.push.apply(newRects, toAdd);
          return replaceOverlappingRects(newRects);
        }
      }
    }
    return rects;
  }
  function getRectOverlapX(rect1, rect2) {
    return Math.max(
      0,
      Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left)
    );
  }
  function getRectOverlapY(rect1, rect2) {
    return Math.max(
      0,
      Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top)
    );
  }
  function removeContainedRects(rects, tolerance) {
    const rectsToKeep = new Set(rects);
    for (const rect of rects) {
      const bigEnough = rect.width > 1 && rect.height > 1;
      if (!bigEnough) {
        import_loglevel3.default.log("CLIENT RECT: remove tiny");
        rectsToKeep.delete(rect);
        continue;
      }
      for (const possiblyContainingRect of rects) {
        if (rect === possiblyContainingRect) {
          continue;
        }
        if (!rectsToKeep.has(possiblyContainingRect)) {
          continue;
        }
        if (rectContains(possiblyContainingRect, rect, tolerance)) {
          import_loglevel3.default.log("CLIENT RECT: remove contained");
          rectsToKeep.delete(rect);
          break;
        }
      }
    }
    return Array.from(rectsToKeep);
  }
  function checkOverlaps(rects) {
    const stillOverlappingRects = [];
    for (const rect1 of rects) {
      for (const rect2 of rects) {
        if (rect1 === rect2) {
          continue;
        }
        const has1 = stillOverlappingRects.indexOf(rect1) >= 0;
        const has2 = stillOverlappingRects.indexOf(rect2) >= 0;
        if (!has1 || !has2) {
          if (rectsTouchOrOverlap(rect1, rect2, -1)) {
            if (!has1) {
              stillOverlappingRects.push(rect1);
            }
            if (!has2) {
              stillOverlappingRects.push(rect2);
            }
            import_loglevel3.default.log("CLIENT RECT: overlap ---");
            import_loglevel3.default.log(
              `#1 TOP:${rect1.top} BOTTOM:${rect1.bottom} LEFT:${rect1.left} RIGHT:${rect1.right} WIDTH:${rect1.width} HEIGHT:${rect1.height}`
            );
            import_loglevel3.default.log(
              `#2 TOP:${rect2.top} BOTTOM:${rect2.bottom} LEFT:${rect2.left} RIGHT:${rect2.right} WIDTH:${rect2.width} HEIGHT:${rect2.height}`
            );
            const xOverlap = getRectOverlapX(rect1, rect2);
            import_loglevel3.default.log(`xOverlap: ${xOverlap}`);
            const yOverlap = getRectOverlapY(rect1, rect2);
            import_loglevel3.default.log(`yOverlap: ${yOverlap}`);
          }
        }
      }
    }
    if (stillOverlappingRects.length) {
      import_loglevel3.default.log(`CLIENT RECT: overlaps ${stillOverlappingRects.length}`);
    }
  }

  // src/modules/highlight/renderer/iframe/selection.ts
  init_polyfills();
  var import_loglevel4 = __toESM(require_loglevel());
  function getCurrentSelectionInfo(win, getCssSelector) {
    const selection = win ? win.getSelection() : null;
    if (!selection) {
      return void 0;
    }
    if (selection.isCollapsed) {
      import_loglevel4.default.log("^^^ SELECTION COLLAPSED.");
      return void 0;
    }
    const rawText = selection.toString();
    const cleanText = rawText.trim().replace(/\n/g, " ").replace(/\s\s+/g, " ");
    if (cleanText.length === 0) {
      import_loglevel4.default.log("^^^ SELECTION TEXT EMPTY.");
      return void 0;
    }
    if (!selection.anchorNode || !selection.focusNode) {
      return void 0;
    }
    const r = selection.rangeCount === 1 ? selection.getRangeAt(0) : createOrderedRange(
      selection.anchorNode,
      selection.anchorOffset,
      selection.focusNode,
      selection.focusOffset
    );
    if (!r || r.collapsed) {
      import_loglevel4.default.log("$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!");
      return void 0;
    }
    const range = normalizeRange(r);
    if (range.startContainer !== r.startContainer) {
      import_loglevel4.default.log(
        ">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: startContainer"
      );
      import_loglevel4.default.log(range.startContainer);
      import_loglevel4.default.log(r.startContainer);
    }
    if (range.startOffset !== r.startOffset) {
      import_loglevel4.default.log(
        ">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: startOffset"
      );
      import_loglevel4.default.log(`${range.startOffset} !== ${r.startOffset}`);
    }
    if (range.endContainer !== r.endContainer) {
      import_loglevel4.default.log(
        ">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: endContainer"
      );
      import_loglevel4.default.log(range.endContainer);
      import_loglevel4.default.log(r.endContainer);
    }
    if (range.endOffset !== r.endOffset) {
      import_loglevel4.default.log(
        ">>>>>>>>>>>>>>>>>>>>>>> SELECTION RANGE NORMALIZE diff: endOffset"
      );
      import_loglevel4.default.log(`${range.endOffset} !== ${r.endOffset}`);
    }
    const rangeInfo = convertRange(range, getCssSelector);
    if (!rangeInfo) {
      import_loglevel4.default.log("^^^ SELECTION RANGE INFO FAIL?!");
      return void 0;
    }
    return { rangeInfo, cleanText, rawText, range };
  }
  function createOrderedRange(startNode, startOffset, endNode, endOffset) {
    try {
      const range = new Range();
      range.setStart(startNode, startOffset);
      range.setEnd(endNode, endOffset);
      if (!range.collapsed) {
        import_loglevel4.default.log(">>> createOrderedRange RANGE OK");
        return range;
      }
      import_loglevel4.default.log(">>> createOrderedRange COLLAPSED ... RANGE REVERSE?");
      const rangeReverse = new Range();
      rangeReverse.setStart(endNode, endOffset);
      rangeReverse.setEnd(startNode, startOffset);
      if (!rangeReverse.collapsed) {
        import_loglevel4.default.log(">>> createOrderedRange RANGE REVERSE OK.");
        return range;
      }
      import_loglevel4.default.log(">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!");
      return void 0;
    } catch (err) {
      console.warn(err.message);
      return void 0;
    }
  }
  function convertRange(range, getCssSelector) {
    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;
    const startContainerElement = startIsElement ? range.startContainer : range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE ? range.startContainer.parentNode : void 0;
    if (!startContainerElement) {
      return void 0;
    }
    const startContainerChildTextNodeIndex = startIsElement ? -1 : Array.from(startContainerElement.childNodes).indexOf(
      range.startContainer
    );
    if (startContainerChildTextNodeIndex < -1) {
      return void 0;
    }
    const startContainerElementCssSelector = getCssSelector(
      startContainerElement
    );
    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;
    const endContainerElement = endIsElement ? range.endContainer : range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE ? range.endContainer.parentNode : void 0;
    if (!endContainerElement) {
      return void 0;
    }
    const endContainerChildTextNodeIndex = endIsElement ? -1 : Array.from(endContainerElement.childNodes).indexOf(
      range.endContainer
    );
    if (endContainerChildTextNodeIndex < -1) {
      return void 0;
    }
    const endContainerElementCssSelector = getCssSelector(endContainerElement);
    const commonElementAncestor = getCommonAncestorElement(
      range.startContainer,
      range.endContainer
    );
    if (!commonElementAncestor) {
      import_loglevel4.default.log("^^^ NO RANGE COMMON ANCESTOR?!");
      return void 0;
    }
    if (range.commonAncestorContainer) {
      const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ? range.commonAncestorContainer : range.commonAncestorContainer.parentNode;
      if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {
        if (commonElementAncestor !== rangeCommonAncestorElement) {
          import_loglevel4.default.log(">>>>>> COMMON ANCESTOR CONTAINER DIFF??!");
          import_loglevel4.default.log(getCssSelector(commonElementAncestor));
          import_loglevel4.default.log(getCssSelector(rangeCommonAncestorElement));
        }
      }
    }
    if (endContainerElementCssSelector && startContainerElementCssSelector) {
      return {
        endContainerChildTextNodeIndex,
        endContainerElementCssSelector,
        endOffset: range.endOffset,
        startContainerChildTextNodeIndex,
        startContainerElementCssSelector,
        startOffset: range.startOffset
      };
    } else {
      return void 0;
    }
  }
  function convertRangeInfo(documant, rangeInfo) {
    const startElement = documant.querySelector(
      rangeInfo.startContainerElementCssSelector
    );
    if (!startElement) {
      import_loglevel4.default.log("^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!");
      return void 0;
    }
    let startContainer = startElement;
    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {
      if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {
        import_loglevel4.default.log(
          "^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!"
        );
        return void 0;
      }
      startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];
      if (startContainer.nodeType !== Node.TEXT_NODE) {
        import_loglevel4.default.log(
          "^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!"
        );
        return void 0;
      }
    }
    const endElement = documant.querySelector(
      rangeInfo.endContainerElementCssSelector
    );
    if (!endElement) {
      import_loglevel4.default.log("^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!");
      return void 0;
    }
    let endContainer = endElement;
    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {
      if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {
        import_loglevel4.default.log(
          "^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!"
        );
        return void 0;
      }
      endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];
      if (endContainer.nodeType !== Node.TEXT_NODE) {
        import_loglevel4.default.log(
          "^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!"
        );
        return void 0;
      }
    }
    return createOrderedRange(
      startContainer,
      rangeInfo.startOffset,
      endContainer,
      rangeInfo.endOffset
    );
  }
  function getCommonAncestorElement(node1, node2) {
    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {
      return node1;
    }
    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {
      return node1;
    }
    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {
      return node2;
    }
    const node1ElementAncestorChain = [];
    let parent = node1.parentNode;
    while (parent && parent.nodeType === Node.ELEMENT_NODE) {
      node1ElementAncestorChain.push(parent);
      parent = parent.parentNode;
    }
    const node2ElementAncestorChain = [];
    parent = node2.parentNode;
    while (parent && parent.nodeType === Node.ELEMENT_NODE) {
      node2ElementAncestorChain.push(parent);
      parent = parent.parentNode;
    }
    let commonAncestor = node1ElementAncestorChain.find(
      (node1ElementAncestor) => {
        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;
      }
    );
    if (!commonAncestor) {
      commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {
        return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;
      });
    }
    return commonAncestor;
  }
  function normalizeRange(r) {
    const range = r.cloneRange();
    let sc = range.startContainer;
    let so = range.startOffset;
    let ec = range.endContainer;
    let eo = range.endOffset;
    if (sc.childNodes.length && so > 0) {
      sc = lastLeaf(sc.childNodes[so - 1]);
      so = sc.length || 0;
    }
    if (eo < ec.childNodes.length) {
      ec = firstLeaf(ec.childNodes[eo]);
      eo = 0;
    }
    let start = firstLeaf(sc);
    let end = lastLeaf(ec);
    function isLeafNodeInRange(node) {
      if (node.childNodes.length) {
        return false;
      }
      const length = node.length || 0;
      if (node === sc && so === length) {
        return false;
      }
      return !(node === ec && eo === 0);
    }
    while (start && !isLeafNodeInRange(start) && start !== end) {
      start = documentForward(start);
    }
    if (start === sc) {
      range.setStart(sc, so);
    } else if (start !== null) {
      if (start.nodeType === 3) {
        range.setStart(start, 0);
      } else {
        range.setStartBefore(start);
      }
    }
    while (end && !isLeafNodeInRange(end) && end !== start) {
      end = documentReverse(end);
    }
    if (end === ec) {
      range.setEnd(ec, eo);
    } else if (end !== null) {
      if (end.nodeType === 3) {
        range.setEnd(end, end.length);
      } else {
        range.setEndAfter(end);
      }
    }
    return range;
  }
  function documentForward(node) {
    if (node.firstChild) {
      return node.firstChild;
    }
    let n = node;
    while (!n.nextSibling) {
      n = n.parentNode;
      if (!n) {
        return null;
      }
    }
    return n.nextSibling;
  }
  function documentReverse(node) {
    if (node.lastChild) {
      return node.lastChild;
    }
    let n = node;
    while (!n.previousSibling) {
      n = n.parentNode;
      if (!n) {
        return null;
      }
    }
    return n.previousSibling;
  }
  function firstLeaf(node) {
    while (node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function lastLeaf(node) {
    while (node.lastChild) {
      node = node.lastChild;
    }
    return node;
  }

  // src/modules/highlight/renderer/common/cssselector2.ts
  init_polyfills();
  var import_cssesc = __toESM(require_cssesc());
  var config;
  var rootDocument;
  function uniqueCssSelector(input, doc, options) {
    if (input.nodeType !== Node.ELEMENT_NODE) {
      throw new Error(`Can't generate CSS selector for non-element node type.`);
    }
    if ("html" === input.tagName.toLowerCase()) {
      return input.tagName.toLowerCase();
    }
    const defaults = {
      className: (_name) => true,
      idName: (_name) => true,
      optimizedMinLength: 2,
      root: doc.body,
      seedMinLength: 1,
      tagName: (_name) => true,
      threshold: 1e3
    };
    config = { ...defaults, ...options };
    rootDocument = findRootDocument(config.root, defaults);
    let path = bottomUpSearch(
      input,
      0 /* All */,
      () => bottomUpSearch(input, 1 /* Two */, () => bottomUpSearch(input, 2 /* One */))
    );
    if (path) {
      const optimized = sort(optimize(path, input));
      if (optimized.length > 0) {
        path = optimized[0];
      }
      return selector(path);
    } else {
      throw new Error(`Selector was not found.`);
    }
  }
  function findRootDocument(rootNode, defaults) {
    if (rootNode.nodeType === Node.DOCUMENT_NODE) {
      return rootNode;
    }
    if (rootNode === defaults.root) {
      return rootNode.ownerDocument;
    }
    return rootNode;
  }
  function bottomUpSearch(input, limit, fallback) {
    let path = null;
    const stack = [];
    let current = input;
    let i = 0;
    while (current && current !== config.root.parentElement) {
      let level = maybe(id(current)) || maybe(...classNames(current)) || maybe(tagName(current)) || [any()];
      const nth = index(current);
      if (limit === 0 /* All */) {
        if (nth) {
          level = level.concat(
            level.filter(dispensableNth).map((node) => nthChild(node, nth))
          );
        }
      } else if (limit === 1 /* Two */) {
        level = level.slice(0, 1);
        if (nth) {
          level = level.concat(
            level.filter(dispensableNth).map((node) => nthChild(node, nth))
          );
        }
      } else if (limit === 2 /* One */) {
        const [node] = level = level.slice(0, 1);
        if (nth && dispensableNth(node)) {
          level = [nthChild(node, nth)];
        }
      }
      for (const node of level) {
        node.level = i;
      }
      stack.push(level);
      if (stack.length >= config.seedMinLength) {
        path = findUniquePath(stack, fallback);
        if (path) {
          break;
        }
      }
      current = current.parentElement;
      i++;
    }
    if (!path) {
      path = findUniquePath(stack, fallback);
    }
    return path;
  }
  function findUniquePath(stack, fallback) {
    const paths = sort(combinations(stack));
    if (paths.length > config.threshold) {
      return fallback ? fallback() : null;
    }
    for (const candidate of paths) {
      if (unique(candidate)) {
        return candidate;
      }
    }
    return null;
  }
  function selector(path) {
    let node = path[0];
    let query = node.name;
    for (let i = 1; i < path.length; i++) {
      const level = path[i].level || 0;
      if (node.level === level - 1) {
        query = `${path[i].name} > ${query}`;
      } else {
        query = `${path[i].name} ${query}`;
      }
      node = path[i];
    }
    return query;
  }
  function penalty(path) {
    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);
  }
  function unique(path) {
    switch (rootDocument.querySelectorAll(selector(path)).length) {
      case 0:
        throw new Error(
          `Can't select any node with this selector: ${selector(path)}`
        );
      case 1:
        return true;
      default:
        return false;
    }
  }
  function id(input) {
    const elementId = input.getAttribute("id");
    if (elementId && config.idName(elementId)) {
      return {
        name: "#" + (0, import_cssesc.default)(elementId, { isIdentifier: true }),
        penalty: 0
      };
    }
    return null;
  }
  function classNames(input) {
    const names = Array.from(input.classList).filter(config.className);
    return names.map(
      (name) => ({
        name: "." + (0, import_cssesc.default)(name, { isIdentifier: true }),
        penalty: 1
      })
    );
  }
  function tagName(input) {
    const name = input.tagName.toLowerCase();
    if (config.tagName(name)) {
      return {
        name,
        penalty: 2
      };
    }
    return null;
  }
  function any() {
    return {
      name: "*",
      penalty: 3
    };
  }
  function index(input) {
    const parent = input.parentNode;
    if (!parent) {
      return null;
    }
    let child = parent.firstChild;
    if (!child) {
      return null;
    }
    let i = 0;
    while (child) {
      if (child.nodeType === Node.ELEMENT_NODE) {
        i++;
      }
      if (child === input) {
        break;
      }
      child = child.nextSibling;
    }
    return i;
  }
  function nthChild(node, i) {
    return {
      name: node.name + `:nth-child(${i})`,
      penalty: node.penalty + 1
    };
  }
  function dispensableNth(node) {
    return node.name !== "html" && !node.name.startsWith("#");
  }
  function maybe(...level) {
    const list = level.filter(notEmpty);
    if (list.length > 0) {
      return list;
    }
    return null;
  }
  function notEmpty(value) {
    return value !== null && value !== void 0;
  }
  function* combinations(stack, path = []) {
    if (stack.length > 0) {
      for (const node of stack[0]) {
        yield* combinations(stack.slice(1, stack.length), path.concat(node));
      }
    } else {
      yield path;
    }
  }
  function sort(paths) {
    return Array.from(paths).sort((a, b) => penalty(a) - penalty(b));
  }
  function* optimize(path, input) {
    if (path.length > 2 && path.length > config.optimizedMinLength) {
      for (let i = 1; i < path.length - 1; i++) {
        const newPath = [...path];
        newPath.splice(i, 1);
        if (unique(newPath) && same(newPath, input)) {
          yield newPath;
          yield* optimize(newPath, input);
        }
      }
    }
  }
  function same(path, input) {
    return rootDocument.querySelector(selector(path)) === input;
  }

  // src/model/Locator.ts
  init_polyfills();

  // src/utils/IconLib.ts
  init_polyfills();
  var WIDTH_ATTR = 24;
  var HEIGHT_ATTR = 24;
  var VIEWBOX_ATTR = `0 0 24 24`;
  var iconTemplate = (id2, title, path, classAttr = `icon`) => `<svg xmlns="http://www.w3.org/2000/svg" width="${WIDTH_ATTR}" height="${HEIGHT_ATTR}" viewBox="${VIEWBOX_ATTR}" preserveAspectRatio="xMidYMid meet" role="img" class="${classAttr}" aria-labelledBy="${id2}">
  <title id="${id2}">${title}</title>
  ${path}
</svg>`;
  var iconTemplateWithViewBox = (id2, title, path, viewBox, classAttr = `icon`) => `<svg xmlns="http://www.w3.org/2000/svg" width="${WIDTH_ATTR}" height="${WIDTH_ATTR}" viewBox="${viewBox}" preserveAspectRatio="xMidYMid meet" role="img" class="${classAttr}" aria-labelledBy="${id2}">
  <title id="${id2}">${title}</title>
  ${path}
</svg>`;
  var iconTemplateColored = (id2, title, path, classAttr = `icon`, size, fill) => `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="${VIEWBOX_ATTR}" style="fill:${fill}" preserveAspectRatio="xMidYMid meet" role="img" class="${classAttr}" aria-labelledBy="${id2}">
  <title id="${id2}">${title}</title>
  ${path}
</svg>`;
  var icons = {
    error: iconTemplate(
      `error-icon`,
      `Warning`,
      `<path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>`
    ),
    home: `<path d="M12 5.69l5 4.5V18h-2v-6H9v6H7v-7.81l5-4.5M12 3L2 12h3v8h6v-6h2v6h6v-8h3L12 3z"/>`,
    expand: iconTemplate(
      `expand-icon`,
      `Enter fullscreen`,
      `<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`,
      `icon active-icon`
    ),
    loading: iconTemplateWithViewBox(
      `loading-icon`,
      `Loading`,
      `<path fill="#BBBBBB" d="M145,241.6c-53.3,0-96.6-43.2-96.6-96.6c0-53.3,43.2-96.6,96.6-96.6c53.3,0,96.6,43.2,96.6,96.6 c0,26.7-10.8,50.9-28.3,68.3l7.6,7.6c19.4-19.4,31.5-46.3,31.5-75.9c0-59.3-48-107.3-107.3-107.3S37.7,85.7,37.7,145 c0,59.3,48,107.3,107.3,107.3V241.6z"/>`,
      "0 0 290 290"
    ),
    next: iconTemplate(
      `next-icon`,
      `Next Chapter`,
      `<path d="M6.49 20.13l1.77 1.77 9.9-9.9-9.9-9.9-1.77 1.77L14.62 12l-8.13 8.13z"/>`
    ),
    previous: iconTemplate(
      `previous-icon`,
      `Previous Chapter`,
      `<path d="M17.51 3.87L15.73 2.1 5.84 12l9.9 9.9 1.77-1.77L9.38 12l8.13-8.13z"/>`
    ),
    settings: iconTemplate(
      `settings-icon`,
      `Settings`,
      `<path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.09-.16-.26-.25-.44-.25-.06 0-.12.01-.17.03l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.06-.02-.12-.03-.18-.03-.17 0-.34.09-.43.25l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.09.16.26.25.44.25.06 0 .12-.01.17-.03l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.06.02.12.03.18.03.17 0 .34-.09.43-.25l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-1.98-1.71c.04.31.05.52.05.73 0 .21-.02.43-.05.73l-.14 1.13.89.7 1.08.84-.7 1.21-1.27-.51-1.04-.42-.9.68c-.43.32-.84.56-1.25.73l-1.06.43-.16 1.13-.2 1.35h-1.4l-.19-1.35-.16-1.13-1.06-.43c-.43-.18-.83-.41-1.23-.71l-.91-.7-1.06.43-1.27.51-.7-1.21 1.08-.84.89-.7-.14-1.13c-.03-.31-.05-.54-.05-.74s.02-.43.05-.73l.14-1.13-.89-.7-1.08-.84.7-1.21 1.27.51 1.04.42.9-.68c.43-.32.84-.56 1.25-.73l1.06-.43.16-1.13.2-1.35h1.39l.19 1.35.16 1.13 1.06.43c.43.18.83.41 1.23.71l.91.7 1.06-.43 1.27-.51.7 1.21-1.07.85-.89.7.14 1.13zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>`,
      `icon open`
    ),
    toc: iconTemplate(
      `toc-icon`,
      `Table of Contents`,
      `<path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"/>`,
      `icon open`
    ),
    bookmarks: iconTemplate(
      `toc-icon`,
      `Bookmarks`,
      `<path d="M4,6H2v16h16v-2H4V6z"/><path d="M22,2H6v16h16V2z M20,12l-2.5-1.5L15,12V4h5V12z"/>`,
      `icon open`
    ),
    bookmark: iconTemplate(
      `toc-icon`,
      `Bookmark`,
      `<path d="M19,3H5v18l7-3l7,3V3z"/>`,
      `icon open`
    ),
    delete: iconTemplate(
      `delete-icon`,
      `Delete`,
      `<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>`,
      `icon open`
    ),
    close: iconTemplate(
      `close-icon`,
      `Close`,
      `<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>`,
      `icon open`
    ),
    text: iconTemplate(
      `text-icon`,
      `Text`,
      `<path d="M5 4v3h5.5v12h3V7H19V4z"/>`,
      `icon open`
    ),
    speak: iconTemplate(
      `speak-icon`,
      `Speak`,
      `<circle cx="9" cy="9" r="4"/><path d="M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4zm7.76-9.64l-1.68 1.69c.84 1.18.84 2.71 0 3.89l1.68 1.69c2.02-2.02 2.02-5.07 0-7.27zM20.07 2l-1.63 1.63c2.77 3.02 2.77 7.56 0 10.74L20.07 16c3.9-3.89 3.91-9.95 0-14z"/><path d="M0 0h24v24H0z" fill="none"/>`,
      `icon open`
    ),
    note: iconTemplate(
      `note-icon`,
      `Note`,
      `<polygon points="17.71 24.66 22.3 20.07 17.71 20.07 17.71 24.66" fill="none"/><path d="M22.42.07H5.58A3.28,3.28,0,0,0,2.29,3.35V24.79a3.28,3.28,0,0,0,3.29,3.28H16.71a1,1,0,0,0,.71-.29l8-8a1,1,0,0,0,.29-.71V3.35A3.28,3.28,0,0,0,22.42.07Zm-8.17,15h-7v-2h7Zm-7-6v-2h13v2ZM16.5,25.86v-6a1,1,0,0,1,1-1h6Z" />`,
      `icon open`
    ),
    highlight: iconTemplate(
      `highlight-icon`,
      `Highlight`,
      `<path d="M27.71,7.78,21.12,1.19a1,1,0,0,0-1.38,0L4.32,15A1,1,0,0,0,4,15.7a1,1,0,0,0,.3.73c1.22,1.22,1.2,2.37,0,3.62a1,1,0,0,0,0,1.41l3.2,3.2a1,1,0,0,0,1.41,0c1.28-1.28,2.36-1.29,3.62,0a1,1,0,0,0,1.45,0L27.74,9.16A1,1,0,0,0,27.71,7.78Z" /><path d="M3.09,22.59l-2.8,2.8a1,1,0,0,0-.21,1.09A1,1,0,0,0,1,27.1H4.6a1,1,0,0,0,.71-.29l1-1Z" />`,
      `icon open`
    )
  };

  // src/modules/highlight/TextHighlighter.ts
  var lodash = __toESM(require_lodash());
  var import_loglevel5 = __toESM(require_loglevel());
  var HighlightContainer = /* @__PURE__ */ ((HighlightContainer2) => {
    HighlightContainer2["R2_ID_HIGHLIGHTS_CONTAINER"] = "R2_ID_HIGHLIGHTS_CONTAINER";
    HighlightContainer2["R2_ID_BOOKMAKRS_CONTAINER"] = "R2_ID_BOOKMAKRS_CONTAINER";
    HighlightContainer2["R2_ID_READALOUD_CONTAINER"] = "R2_ID_READALOUD_CONTAINER";
    HighlightContainer2["R2_ID_PAGEBREAK_CONTAINER"] = "R2_ID_PAGEBREAK_CONTAINER";
    HighlightContainer2["R2_ID_SEARCH_CONTAINER"] = "R2_ID_SEARCH_CONTAINER";
    HighlightContainer2["R2_ID_DEFINITIONS_CONTAINER"] = "R2_ID_DEFINITIONS_CONTAINER";
    HighlightContainer2["R2_ID_LINEFOCUS_CONTAINER"] = "R2_ID_LINEFOCUS_CONTAINER";
    HighlightContainer2["R2_ID_GUTTER_RIGHT_CONTAINER"] = "R2_ID_GUTTER_RIGHT_CONTAINER";
    return HighlightContainer2;
  })(HighlightContainer || {});
  var CLASS_HIGHLIGHT_CONTAINER = "R2_CLASS_HIGHLIGHT_CONTAINER";
  var CLASS_HIGHLIGHT_BOUNDING_AREA = "R2_CLASS_HIGHLIGHT_BOUNDING_AREA";
  var CLASS_HIGHLIGHT_AREA = "R2_CLASS_HIGHLIGHT_AREA";
  var CLASS_HIGHLIGHT_ICON = "R2_CLASS_HIGHLIGHT_ICON";
  var DEFAULT_BACKGROUND_COLOR_OPACITY = 0.5;
  var ALT_BACKGROUND_COLOR_OPACITY = 0.75;
  var DEFAULT_BACKGROUND_COLOR = {
    blue: 100,
    green: 50,
    red: 230
  };
  var _highlights = [];
  var DATA_ATTR = "data-highlighted";
  var TIMESTAMP_ATTR = "data-timestamp";
  var NODE_TYPE = {
    ELEMENT_NODE: 1,
    TEXT_NODE: 3
  };
  var _blacklistIdClassForCssSelectors = [
    "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */,
    "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */,
    "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */,
    "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */,
    "R2_ID_BOOKMAKRS_CONTAINER" /* R2_ID_BOOKMAKRS_CONTAINER */,
    "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */,
    "R2_ID_LINEFOCUS_CONTAINER" /* R2_ID_LINEFOCUS_CONTAINER */,
    "R2_ID_GUTTER_RIGHT_CONTAINER" /* R2_ID_GUTTER_RIGHT_CONTAINER */,
    CLASS_HIGHLIGHT_CONTAINER,
    CLASS_HIGHLIGHT_AREA,
    CLASS_HIGHLIGHT_BOUNDING_AREA
  ];
  var lastMouseDownX = -1;
  var lastMouseDownY = -1;
  var TextHighlighter = class _TextHighlighter {
    constructor(layerSettings, properties, hasEventListener, options, api) {
      this.lastSelectedHighlight = void 0;
      this.activeAnnotationMarkerId = void 0;
      this.showTool = (0, import_debounce2.debounce)(
        (b) => {
          if (!this.isAndroid()) {
            this.snapSelectionToWord(b);
          }
          this.toolboxShow();
        },
        navigator.userAgent.toLowerCase().indexOf("firefox") > -1 ? 200 : 100
      );
      this.isSelectionMenuOpen = false;
      this.selectionMenuOpened = (0, import_debounce2.debounce)(() => {
        var _a, _b;
        if (!this.isSelectionMenuOpen) {
          this.isSelectionMenuOpen = true;
          if ((_a = this.api) == null ? void 0 : _a.selectionMenuOpen)
            (_b = this.api) == null ? void 0 : _b.selectionMenuOpen();
          this.navigator.emit("toolbox.opened", "opened");
        }
      }, 100);
      this.selectionMenuClosed = (0, import_debounce2.debounce)(() => {
        var _a, _b;
        if (this.isSelectionMenuOpen) {
          this.isSelectionMenuOpen = false;
          if ((_a = this.api) == null ? void 0 : _a.selectionMenuClose)
            (_b = this.api) == null ? void 0 : _b.selectionMenuClose();
          this.navigator.emit("toolbox.closed", "closed");
        }
      }, 100);
      this.selection = (0, import_debounce2.debounce)((text, selection) => {
        var _a, _b;
        if ((_a = this.api) == null ? void 0 : _a.selection)
          (_b = this.api) == null ? void 0 : _b.selection(text, selection);
      }, 100);
      this.getScrollingElement = (doc) => {
        if (doc == null ? void 0 : doc.scrollingElement) {
          return doc == null ? void 0 : doc.scrollingElement;
        } else if (doc == null ? void 0 : doc.body) {
          return doc == null ? void 0 : doc.body;
        } else {
          return document.createElement("body");
        }
      };
      this.layerSettings = layerSettings;
      this.properties = properties;
      if (this.properties.menuPosition === void 0) {
        this.properties.menuPosition = "inline" /* INLINE */;
      }
      this.api = api;
      this.hasEventListener = hasEventListener;
      this.options = this.defaults(options, {
        color: "#fce300",
        highlightedClass: "highlighted",
        contextClass: "highlighter-context",
        onBeforeHighlight: function() {
          return true;
        },
        onAfterHighlight: function() {
        }
      });
    }
    static async create(config2) {
      const module2 = new this(
        config2.layerSettings,
        config2,
        false,
        {},
        config2.api
      );
      return new Promise((resolve) => resolve(module2));
    }
    async initialize() {
      var _a;
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        this.dom(doc.body).addClass(this.options.contextClass);
      }
      this.bindEvents(
        (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.body,
        this,
        this.hasEventListener
      );
      this.initializeToolbox();
      lastMouseDownX = -1;
      lastMouseDownY = -1;
      let self2 = this;
      async function unselect() {
        if (self2.lastSelectedHighlight === void 0) {
        } else {
          self2.lastSelectedHighlight = void 0;
        }
      }
      setTimeout(async () => {
        var _a2;
        let doc2 = this.navigator.iframes[0].contentDocument;
        if (doc2) {
          await ((_a2 = doc2.body) == null ? void 0 : _a2.addEventListener("click", unselect));
        }
      }, 100);
    }
    /**
     * Returns true if elements a i b have the same color.
     * @param {Node} a
     * @param {Node} b
     * @returns {boolean}
     */
    haveSameColor(a, b) {
      return this.dom(a).color() === this.dom(b).color();
    }
    /**
     * Fills undefined values in obj with default properties with the same name from source object.
     * @param {object} obj - target object
     * @param {object} source - source object with default values
     * @returns {object}
     */
    defaults(obj, source) {
      obj = obj || {};
      for (let prop in source) {
        if (source.hasOwnProperty(prop) && obj[prop] === void 0) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    }
    /**
     * Returns array without duplicated values.
     * @param {Array} arr
     * @returns {Array}
     */
    unique(arr) {
      return arr.filter(function(value, idx, self2) {
        return self2.indexOf(value) === idx;
      });
    }
    /**
     * Takes range object as parameter and refines it boundaries
     * @param range
     * @returns {object} refined boundaries and initial state of highlighting algorithm.
     */
    refineRangeBoundaries(range) {
      let startContainer = range.startContainer, endContainer = range.endContainer, ancestor = range.commonAncestorContainer, goDeeper = true;
      if (range.endOffset === 0) {
        while (!endContainer.previousSibling && endContainer.parentNode !== ancestor) {
          endContainer = endContainer.parentNode;
        }
        endContainer = endContainer.previousSibling;
      } else if (endContainer.nodeType === NODE_TYPE.TEXT_NODE) {
        if (range.endOffset < endContainer.nodeValue.length) {
          endContainer.splitText(range.endOffset);
        }
      } else if (range.endOffset > 0) {
        endContainer = endContainer.childNodes.item(range.endOffset - 1);
      }
      if (startContainer.nodeType === NODE_TYPE.TEXT_NODE) {
        if (range.startOffset === startContainer.nodeValue.length) {
          goDeeper = false;
        } else if (range.startOffset > 0) {
          startContainer = startContainer.splitText(range.startOffset);
          if (endContainer === startContainer.previousSibling) {
            endContainer = startContainer;
          }
        }
      } else if (range.startOffset < startContainer.childNodes.length) {
        startContainer = startContainer.childNodes.item(range.startOffset);
      } else {
        startContainer = startContainer.nextSibling;
      }
      return {
        startContainer,
        endContainer,
        goDeeper
      };
    }
    /**
     * Sorts array of DOM elements by its depth in DOM tree.
     * @param {HTMLElement[]} arr - array to sort.
     * @param {boolean} descending - order of sort.
     */
    sortByDepth(arr, descending) {
      let self2 = this;
      arr.sort(function(a, b) {
        return self2.dom(descending ? b : a).parents().length - self2.dom(descending ? a : b).parents().length;
      });
    }
    /**
     * Groups given highlights by timestamp.
     * @param {Array} highlights
     * @returns {Array} Grouped highlights.
     */
    groupHighlights(highlights) {
      let order = [], chunks = {}, grouped = [];
      highlights.forEach(function(hl) {
        let timestamp = hl.getAttribute(TIMESTAMP_ATTR);
        if (typeof chunks[timestamp] === "undefined") {
          chunks[timestamp] = [];
          order.push(timestamp);
        }
        chunks[timestamp].push(hl);
      });
      order.forEach(function(timestamp) {
        let group = chunks[timestamp];
        grouped.push({
          chunks: group,
          timestamp,
          toString: function() {
            return group.map(function(h) {
              return h.textContent;
            }).join("");
          }
        });
      });
      return grouped;
    }
    /**
     * Utility functions to make DOM manipulation easier.
     * @param {Node|HTMLElement} [el] - base DOM element to manipulate
     * @returns {object}
     */
    dom(el) {
      let self2 = this;
      return (
        /** @lends dom **/
        {
          /**
           * Adds class to element.
           * @param {string} className
           */
          addClass: function(className) {
            if (el.classList) {
              el.classList.add(className);
            } else {
              el.className += " " + className;
            }
          },
          /**
           * Removes class from element.
           * @param {string} className
           */
          removeClass: function(className) {
            if (el.classList) {
              el.classList.remove(className);
            } else {
              el.className = el.className.replace(
                new RegExp("(^|\\b)" + className + "(\\b|$)", "gi"),
                " "
              );
            }
          },
          /**
           * Prepends child nodes to base element.
           * @param {Node[]} nodesToPrepend
           */
          prepend: function(nodesToPrepend) {
            let nodes = Array.prototype.slice.call(nodesToPrepend), i = nodes.length;
            while (i--) {
              el.insertBefore(nodes[i], el.firstChild);
            }
          },
          /**
           * Appends child nodes to base element.
           * @param {Node[]} nodesToAppend
           */
          append: function(nodesToAppend) {
            let nodes = Array.prototype.slice.call(nodesToAppend);
            for (let i = 0, len = nodes.length; i < len; ++i) {
              el.appendChild(nodes[i]);
            }
          },
          /**
           * Inserts base element after refEl.
           * @param {Node} refEl - node after which base element will be inserted
           * @returns {Node} - inserted element
           */
          insertAfter: function(refEl) {
            var _a;
            return (_a = refEl.parentNode) == null ? void 0 : _a.insertBefore(el, refEl.nextSibling);
          },
          /**
           * Inserts base element before refEl.
           * @param {Node} refEl - node before which base element will be inserted
           * @returns {Node} - inserted element
           */
          insertBefore: function(refEl) {
            var _a;
            return (_a = refEl.parentNode) == null ? void 0 : _a.insertBefore(el, refEl);
          },
          /**
           * Removes base element from DOM.
           */
          remove: function() {
            el.parentNode.removeChild(el);
            el = null;
          },
          /**
           * Returns true if base element contains given child.
           * @param {Node|HTMLElement} child
           * @returns {boolean}
           */
          contains: function(child) {
            return el !== child && el.contains(child);
          },
          /**
           * Wraps base element in wrapper element.
           * @param {HTMLElement} wrapper
           * @returns {HTMLElement} wrapper element
           */
          wrap: function(wrapper) {
            if (el.parentNode) {
              el.parentNode.insertBefore(wrapper, el);
            }
            wrapper.appendChild(el);
            return wrapper;
          },
          /**
           * Unwraps base element.
           * @returns {Node[]} - child nodes of unwrapped element.
           */
          unwrap: function() {
            let nodes = Array.prototype.slice.call(el.childNodes), wrapper;
            nodes.forEach(function(node) {
              wrapper = node.parentNode;
              self2.dom(node).insertBefore(node.parentNode);
              self2.dom(wrapper).remove();
            });
            return nodes;
          },
          /**
           * Returns array of base element parents.
           * @returns {HTMLElement[]}
           */
          parents: function() {
            let parent, path = [];
            while (!!(parent = el.parentNode)) {
              path.push(parent);
              el = parent;
            }
            return path;
          },
          /**
           * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every
           * element node has only one text node.
           * It should does the same as standard element.normalize, but IE implements it incorrectly.
           */
          normalizeTextNodes: function() {
            if (!el) {
              return;
            }
            if (el.nodeType === NODE_TYPE.TEXT_NODE) {
              while (el.nextSibling && el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE) {
                el.nodeValue += el.nextSibling.nodeValue;
                el.parentNode.removeChild(el.nextSibling);
              }
            } else {
              self2.dom(el.firstChild).normalizeTextNodes();
            }
            self2.dom(el.nextSibling).normalizeTextNodes();
          },
          /**
           * Returns element background color.
           * @returns {CSSStyleDeclaration.backgroundColor}
           */
          color: function() {
            return el.style.backgroundColor;
          },
          /**
           * Creates dom element from given html string.
           * @param {string} html
           * @returns {NodeList}
           */
          fromHTML: function(html) {
            let div = document.createElement("div");
            div.innerHTML = html;
            return div.childNodes;
          },
          /**
           * Returns first range of the window of base element.
           * @returns {Range}
           */
          getRange: function() {
            var _a;
            let selection = (_a = self2.dom(el)) == null ? void 0 : _a.getSelection(), range;
            if ((selection == null ? void 0 : selection.rangeCount) > 0) {
              range = selection == null ? void 0 : selection.getRangeAt(0);
            }
            return range;
          },
          /**
           * Removes all ranges of the window of base element.
           */
          removeAllRanges: function() {
            var _a;
            let selection = (_a = self2.dom(el)) == null ? void 0 : _a.getSelection();
            selection == null ? void 0 : selection.removeAllRanges();
            self2.toolboxHide();
          },
          /**
           * Returns selection object of the window of base element.
           * @returns {Selection}
           */
          getSelection: function() {
            var _a;
            return (_a = self2.dom(el).getWindow()) == null ? void 0 : _a.getSelection();
          },
          /**
           * Returns window of the base element.
           * @returns {Window}
           */
          getWindow: function() {
            var _a;
            return (_a = self2.dom(el).getDocument()) == null ? void 0 : _a.defaultView;
          },
          /**
           * Returns document of the base element.
           * @returns {HTMLDocument}
           */
          getDocument: function() {
            return (el == null ? void 0 : el.ownerDocument) || el;
          }
        }
      );
    }
    disableContext(e) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
    bindEvents(el, _scope, hasEventListener) {
      let doc = el.ownerDocument;
      el.addEventListener("mouseup", this.toolboxShowDelayed.bind(this));
      el.addEventListener("touchend", this.toolboxShowDelayed.bind(this));
      doc.addEventListener("mouseup", this.toolboxShowDelayed.bind(this));
      doc.addEventListener("touchend", this.toolboxShowDelayed.bind(this));
      if (!hasEventListener) {
        window.addEventListener("resize", this.toolboxPlacement.bind(this));
      }
      doc.addEventListener("selectionchange", this.toolboxPlacement.bind(this));
      doc.addEventListener("selectionchange", this.toolboxShowDelayed.bind(this));
      el.addEventListener("mousedown", this.toolboxHide.bind(this));
      el.addEventListener("touchstart", this.toolboxHide.bind(this));
      if (this.isAndroid()) {
        el.addEventListener("contextmenu", this.disableContext);
      }
      el.addEventListener("mousedown", this.mousedown.bind(this));
      el.addEventListener("mouseup", this.mouseup.bind(this));
      el.addEventListener("touchstart", this.mousedown.bind(this));
      el.addEventListener("touchend", this.mouseup.bind(this));
      this.hasEventListener = true;
    }
    async mousedown(ev) {
      var _a;
      lastMouseDownX = ev.clientX;
      lastMouseDownY = ev.clientY;
      if ((_a = this.properties) == null ? void 0 : _a.preventScrollOnSelection) {
        const wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        wrapper.style.overflow = "hidden";
      }
    }
    async mouseup(ev) {
      if (Math.abs(lastMouseDownX - ev.clientX) < 3 && Math.abs(lastMouseDownY - ev.clientY) < 3) {
        await this.processMouseEvent(ev);
      }
    }
    async mousemove(ev) {
      await this.processMouseEvent(ev);
    }
    unbindEvents(el, _scope) {
      let doc = el.ownerDocument;
      el.removeEventListener("mouseup", this.toolboxShowDelayed.bind(this));
      el.removeEventListener("touchend", this.toolboxShowDelayed.bind(this));
      doc.removeEventListener("mouseup", this.toolboxShowDelayed.bind(this));
      doc.removeEventListener("touchend", this.toolboxShowDelayed.bind(this));
      window.removeEventListener("resize", this.toolboxPlacement.bind(this));
      doc.removeEventListener(
        "selectionchange",
        this.toolboxPlacement.bind(this)
      );
      el.removeEventListener("mousedown", this.toolboxHide.bind(this));
      el.removeEventListener("touchstart", this.toolboxHide.bind(this));
      if (this.isAndroid()) {
        el.removeEventListener("contextmenu", this.disableContext);
      }
      el.removeEventListener("mousedown", this.mousedown.bind(this));
      el.removeEventListener("mouseup", this.mouseup.bind(this));
      el.removeEventListener("mousemove", this.mousemove.bind(this));
      el.removeEventListener("touchstart", this.mousedown.bind(this));
      el.removeEventListener("touchend", this.mouseup.bind(this));
      el.removeEventListener("touchmove", this.mousemove.bind(this));
      this.hasEventListener = false;
    }
    /**
     * Permanently disables highlighting.
     * Unbinds events and remove context element class.
     * @memberof TextHighlighter
     */
    destroy() {
      this.toolboxHide();
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        this.unbindEvents(doc.body, this);
        this.dom(doc.body).removeClass(this.options.contextClass);
      }
    }
    initializeToolbox() {
      let toolboxColorsOptions = document.getElementById(
        "highlight-toolbox-mode-colors"
      );
      let toolboxOptions = document.getElementById("highlight-toolbox-mode-add");
      let colors = [
        "#fce300",
        "#48e200",
        "#00bae5",
        "#157cf9",
        "#6a39b7",
        "#ea426a",
        "#ff8500"
      ];
      let colorIcon = document.getElementById("colorIcon");
      let actionIcon = document.getElementById("actionIcon");
      let dismissIcon = document.getElementById("dismissIcon");
      let collapseIcon = document.getElementById("collapseIcon");
      let highlightIcon = document.getElementById("highlightIcon");
      let self2 = this;
      if (dismissIcon) {
        dismissIcon.innerHTML = icons.close;
        dismissIcon.addEventListener("click", function() {
          self2.toolboxMode("add");
        });
      }
      if (collapseIcon) {
        collapseIcon.innerHTML = icons.close;
        collapseIcon.addEventListener("click", function() {
          self2.toolboxMode("add");
        });
      }
      if (colorIcon) {
        colorIcon.style.position = "relative";
        colorIcon.style.zIndex = "20";
        colors.forEach((color) => {
          let colorButton = document.getElementById(color);
          let cButton = document.getElementById(`c${color}`);
          if (colorButton && (toolboxColorsOptions == null ? void 0 : toolboxColorsOptions.contains(colorButton))) {
            toolboxColorsOptions.removeChild(colorButton);
          }
          if (toolboxOptions && cButton && toolboxOptions.contains(cButton)) {
            toolboxOptions.removeChild(cButton);
          }
        });
        const colorElements = [];
        const colorRainbow = [];
        colorIcon.addEventListener("click", function() {
          self2.toolboxMode("colors");
        });
        if (this.navigator.rights.enableAnnotations) {
          let index2 = 10;
          colors.forEach((color) => {
            index2--;
            const colorButton = colorIcon == null ? void 0 : colorIcon.cloneNode(true);
            const colorButtonSymbol = colorButton.lastChild;
            let c = _TextHighlighter.hexToRgbChannels(color);
            colorButtonSymbol.style.backgroundColor = "rgba(" + [c.red, c.green, c.blue].join(",") + ",.5)";
            colorButton.id = `c${color}`;
            colorButton.style.display = "unset";
            colorButton.style.position = "relative";
            colorButton.style.zIndex = `${index2}`;
            colorButton.style.marginLeft = `-30px`;
            colorRainbow.push(colorButton);
            toolboxOptions == null ? void 0 : toolboxOptions.insertBefore(colorButton, highlightIcon);
          });
        }
        colors.forEach((color) => {
          const colorButton = colorIcon == null ? void 0 : colorIcon.cloneNode(true);
          const colorButtonSymbol = colorButton.lastChild;
          colorButtonSymbol.style.backgroundColor = color;
          colorButton.id = color;
          colorButton.style.position = "relative";
          colorButton.style.display = "unset";
          colorElements.push(colorButton);
          if (colorIcon) {
            colorButton.addEventListener("click", function() {
              var _a, _b, _c;
              self2.setColor(color);
              let colorIconSymbol = colorIcon == null ? void 0 : colorIcon.lastChild;
              if (colorIconSymbol) {
                colorIconSymbol.style.backgroundColor = color;
              }
              const highlightIcon2 = document.getElementById("highlightIcon");
              const underlineIcon = document.getElementById("underlineIcon");
              const noteIcon = document.getElementById("noteIcon");
              if ((((_a = highlightIcon2 == null ? void 0 : highlightIcon2.getElementsByTagName) == null ? void 0 : _a.call(highlightIcon2, "span").length) ?? 0) > 0) {
                (highlightIcon2 == null ? void 0 : highlightIcon2.getElementsByTagName(
                  "span"
                )[0]).style.background = self2.getColor();
              }
              if ((((_b = underlineIcon == null ? void 0 : underlineIcon.getElementsByTagName) == null ? void 0 : _b.call(underlineIcon, "span").length) ?? 0) > 0) {
                (underlineIcon == null ? void 0 : underlineIcon.getElementsByTagName(
                  "span"
                )[0]).style.borderBottomColor = self2.getColor();
              }
              if ((((_c = noteIcon == null ? void 0 : noteIcon.getElementsByTagName) == null ? void 0 : _c.call(noteIcon, "span").length) ?? 0) > 0) {
                (noteIcon == null ? void 0 : noteIcon.getElementsByTagName("span")[0]).style.borderBottomColor = self2.getColor();
              }
              self2.toolboxMode("add");
            });
          }
          toolboxColorsOptions == null ? void 0 : toolboxColorsOptions.insertBefore(colorButton, dismissIcon);
        });
      }
      if (actionIcon) {
        actionIcon.addEventListener("click", function() {
          self2.toolboxMode("action");
        });
      }
      self2.toolboxMode("add");
    }
    toolboxMode(mode) {
      let toolboxColorsOptions = document.getElementById(
        "highlight-toolbox-mode-colors"
      );
      let toolboxAddOptions = document.getElementById(
        "highlight-toolbox-mode-add"
      );
      let toolboxEditOptions = document.getElementById(
        "highlight-toolbox-mode-edit"
      );
      let toolboxMarkOptions = document.getElementById(
        "highlight-toolbox-mode-action"
      );
      switch (mode) {
        case "colors":
          if (toolboxColorsOptions)
            toolboxColorsOptions.style.display = "unset";
          if (toolboxAddOptions)
            toolboxAddOptions.style.display = "none";
          if (toolboxEditOptions)
            toolboxEditOptions.style.display = "none";
          if (toolboxMarkOptions)
            toolboxMarkOptions.style.display = "none";
          break;
        case "edit":
          if (toolboxColorsOptions)
            toolboxColorsOptions.style.display = "none";
          if (toolboxAddOptions)
            toolboxAddOptions.style.display = "none";
          if (toolboxEditOptions)
            toolboxEditOptions.style.display = "unset";
          if (toolboxMarkOptions)
            toolboxMarkOptions.style.display = "none";
          break;
        case "action":
          if (toolboxColorsOptions)
            toolboxColorsOptions.style.display = "none";
          if (toolboxAddOptions)
            toolboxAddOptions.style.display = "none";
          if (toolboxEditOptions)
            toolboxEditOptions.style.display = "none";
          if (toolboxMarkOptions)
            toolboxMarkOptions.style.display = "unset";
          break;
        default:
          if (toolboxColorsOptions)
            toolboxColorsOptions.style.display = "none";
          if (toolboxAddOptions)
            toolboxAddOptions.style.display = "unset";
          if (toolboxEditOptions)
            toolboxEditOptions.style.display = "none";
          if (toolboxMarkOptions)
            toolboxMarkOptions.style.display = "none";
          break;
      }
    }
    toolboxHide() {
      var _a;
      let toolbox = document.getElementById("highlight-toolbox");
      if (toolbox)
        toolbox.style.display = "none";
      this.selectionMenuClosed();
      if ((_a = this.properties) == null ? void 0 : _a.preventScrollOnSelection) {
        const wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        wrapper.style.overflow = "auto";
      }
    }
    // Use short timeout to let the selection updated to 'finish', otherwise some
    // browsers can get wrong or incomplete selection data.
    toolboxShowDelayed(event) {
      this.showTool(event.detail === 1);
    }
    snapSelectionToWord(trimmed = false) {
      var _a;
      let self2 = this;
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        let selection = (_a = self2.dom(doc.body)) == null ? void 0 : _a.getSelection();
        if (self2.dom(doc.body)) {
          if (selection && !(selection == null ? void 0 : selection.isCollapsed)) {
            let removeTrailingPunctuation = function(text2) {
              const match = text2.match(new RegExp(`[^a-zA-Z0-9]+$`));
              if (!match || !match.index) {
                return text2;
              }
              return text2.slice(0, match.index);
            };
            let text = selection.toString();
            let startOffsetTemp = text.length - text.trimStart().length;
            let endOffsetTemp = text.length - text.trimEnd().length;
            let length = text.length;
            var regex_symbols = /[-!$%^&*()_+|~=`{}[\]:/;<>?,.@#]/;
            text = text.replace(regex_symbols, "");
            startOffsetTemp = length - text.trimStart().length;
            text = removeTrailingPunctuation(text);
            endOffsetTemp = length - text.trimEnd().length;
            let range = document.createRange();
            if (trimmed) {
              range.setStart(
                selection.anchorNode,
                selection.anchorOffset + startOffsetTemp
              );
              range.setEnd(
                selection.focusNode,
                selection.focusOffset - endOffsetTemp
              );
            } else {
              range.setStart(selection.anchorNode, selection.anchorOffset);
              range.setEnd(selection.focusNode, selection.focusOffset);
            }
            let backwards = range.collapsed;
            range.detach();
            let endNode = selection.focusNode;
            let endOffset;
            if (trimmed) {
              endOffset = selection.focusOffset - endOffsetTemp;
              selection.collapse(
                selection.anchorNode,
                selection.anchorOffset + startOffsetTemp
              );
            } else {
              endOffset = selection.focusOffset;
              selection.collapse(selection.anchorNode, selection.anchorOffset);
            }
            let direction = ["forward", "backward"];
            if (backwards) {
              direction = ["backward", "forward"];
            }
            if (trimmed) {
              selection.modify("move", direction[0], "character");
              selection.modify("move", direction[1], "word");
              selection.extend(endNode, endOffset);
              selection.modify("extend", direction[1], "character");
              selection.modify("extend", direction[0], "word");
            } else {
              selection.extend(endNode, endOffset);
            }
            this.selection(selection.toString(), selection);
          }
        }
        return selection;
      }
    }
    toolboxShow() {
      var _a;
      if (this.activeAnnotationMarkerId === void 0) {
        let self2 = this;
        let toolboxAddOptions = document.getElementById(
          "highlight-toolbox-mode-add"
        );
        let range = this.dom(
          (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.body
        ).getRange();
        if ((!range || range.collapsed) && toolboxAddOptions) {
          if (getComputedStyle(toolboxAddOptions).display !== "none") {
            self2.toolboxHide();
          }
          return;
        }
        if (this.isIOS()) {
          setTimeout(function() {
            let doc = self2.navigator.iframes[0].contentDocument;
            if (doc) {
              let selection = self2.dom(doc.body).getSelection();
              selection.removeAllRanges();
              setTimeout(function() {
                var _a2, _b;
                selection.addRange(range);
                function getCssSelector(element) {
                  const options = {
                    className: (str) => {
                      return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
                    },
                    idName: (str) => {
                      return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
                    }
                  };
                  let doc2 = self2.navigator.iframes[0].contentDocument;
                  if (doc2) {
                    return uniqueCssSelector(element, doc2, options);
                  } else {
                    return void 0;
                  }
                }
                let win = self2.navigator.iframes[0].contentWindow;
                const selectionInfo = getCurrentSelectionInfo(
                  win,
                  getCssSelector
                );
                (_b = (_a2 = self2.navigator.annotationModule) == null ? void 0 : _a2.annotator) == null ? void 0 : _b.saveTemporarySelectionInfo(
                  selectionInfo
                );
              }, 5);
            }
          }, 100);
        }
        this.toolboxPlacement();
        this.toolboxHandler();
      }
    }
    toolboxPlacement() {
      var _a, _b, _c, _d, _e;
      let range = this.dom(
        (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.body
      ).getRange();
      if (!range || range.collapsed) {
        return;
      }
      let rect = range.getBoundingClientRect();
      let toolbox = document.getElementById("highlight-toolbox");
      if (toolbox) {
        if (((_b = this.properties) == null ? void 0 : _b.menuPosition) === "top" /* TOP */) {
          toolbox.style.left = "0px";
          toolbox.style.transform = "revert";
          toolbox.style.width = "100%";
          toolbox.style.textAlign = "center";
          toolbox.style.position = "absolute";
          toolbox.style.setProperty("--content", "revert");
        } else if (((_c = this.properties) == null ? void 0 : _c.menuPosition) === "bottom" /* BOTTOM */) {
          toolbox.style.bottom = "0px";
          toolbox.style.left = "0px";
          toolbox.style.transform = "revert";
          toolbox.style.width = "100%";
          toolbox.style.textAlign = "center";
          toolbox.style.position = "absolute";
          toolbox.style.setProperty("--content", "revert");
        } else {
          const paginated = (_d = this.navigator.view) == null ? void 0 : _d.isPaginated();
          if (paginated) {
            toolbox.style.top = rect.top + (((_e = this.navigator.attributes) == null ? void 0 : _e.navHeight) ?? 0) + "px";
          } else {
            toolbox.style.top = rect.top + "px";
          }
          toolbox.style.left = (rect.right - rect.left) / 2 + rect.left + "px";
        }
      }
    }
    toolboxHandler() {
      var _a, _b, _c, _d, _e, _f, _g;
      let toolbox = document.getElementById("highlight-toolbox");
      if (toolbox) {
        if (getComputedStyle(toolbox).display === "none") {
          toolbox.style.display = "block";
          const paginated = (_a = this.navigator.view) == null ? void 0 : _a.isPaginated();
          if (paginated) {
            toolbox.style.position = "absolute";
          } else {
            toolbox.style.position = "relative";
          }
          this.selectionMenuOpened();
          let self2 = this;
          self2.toolboxMode("add");
          let highlightIcon = document.getElementById("highlightIcon");
          let collapseIcon = document.getElementById("collapseIcon");
          let underlineIcon = document.getElementById("underlineIcon");
          let noteIcon = document.getElementById("noteIcon");
          let colorIcon = document.getElementById("colorIcon");
          let speakIcon = document.getElementById("speakIcon");
          if (this.navigator.rights.enableAnnotations) {
            if (highlightIcon) {
              highlightIcon.style.display = "unset";
              if (colorIcon) {
                if (highlightIcon.getElementsByTagName("span").length > 0) {
                  highlightIcon.getElementsByTagName(
                    "span"
                  )[0].style.background = this.getColor();
                }
              }
            }
            if (underlineIcon) {
              underlineIcon.style.display = "unset";
              if (colorIcon) {
                if (underlineIcon.getElementsByTagName("span").length > 0) {
                  underlineIcon.getElementsByTagName(
                    "span"
                  )[0].style.borderBottomColor = this.getColor();
                }
              }
            }
            if (noteIcon) {
              noteIcon.style.display = "unset";
              if (colorIcon) {
                if (noteIcon.getElementsByTagName("span").length > 0) {
                  noteIcon.getElementsByTagName("span")[0].style.borderBottomColor = this.getColor();
                }
              }
            }
            if (colorIcon) {
              colorIcon.style.display = "unset";
              let colorIconSymbol = colorIcon.lastChild;
              colorIconSymbol.style.backgroundColor = this.getColor();
            }
            if (highlightIcon) {
              let highlightEvent = function() {
                self2.doHighlight(false, 0 /* Highlight */);
                self2.toolboxHide();
                highlightIcon == null ? void 0 : highlightIcon.removeEventListener("click", highlightEvent);
              };
              const clone2 = highlightIcon.cloneNode(true);
              (_b = highlightIcon == null ? void 0 : highlightIcon.parentNode) == null ? void 0 : _b.replaceChild(clone2, highlightIcon);
              highlightIcon = document.getElementById("highlightIcon");
              highlightIcon == null ? void 0 : highlightIcon.addEventListener("click", highlightEvent);
            }
            if (underlineIcon) {
              let commentEvent = function() {
                self2.doHighlight(false, 1 /* Underline */);
                self2.toolboxHide();
                underlineIcon == null ? void 0 : underlineIcon.removeEventListener("click", commentEvent);
              };
              const clone2 = underlineIcon.cloneNode(true);
              (_c = underlineIcon == null ? void 0 : underlineIcon.parentNode) == null ? void 0 : _c.replaceChild(clone2, underlineIcon);
              underlineIcon = document.getElementById("underlineIcon");
              underlineIcon == null ? void 0 : underlineIcon.addEventListener("click", commentEvent);
            }
            if (noteIcon) {
              let commentEvent = function() {
                self2.doHighlight(false, 4 /* Comment */);
                self2.toolboxHide();
                noteIcon == null ? void 0 : noteIcon.removeEventListener("click", commentEvent);
              };
              const clone2 = noteIcon.cloneNode(true);
              (_d = noteIcon == null ? void 0 : noteIcon.parentNode) == null ? void 0 : _d.replaceChild(clone2, noteIcon);
              noteIcon = document.getElementById("noteIcon");
              noteIcon == null ? void 0 : noteIcon.addEventListener("click", commentEvent);
            }
          } else {
            if (highlightIcon) {
              highlightIcon.style.setProperty("display", "none");
            }
            if (underlineIcon) {
              underlineIcon.style.setProperty("display", "none");
            }
            if (noteIcon) {
              noteIcon.style.setProperty("display", "none");
            }
            if (colorIcon) {
              colorIcon.style.setProperty("display", "none");
            }
            if (collapseIcon) {
              collapseIcon.style.setProperty("display", "none");
            }
          }
          if (this.navigator.rights.enableTTS) {
            if (speakIcon) {
              let speakEvent = function() {
                speakIcon == null ? void 0 : speakIcon.removeEventListener("click", speakEvent);
                self2.speak();
              };
              const clone2 = speakIcon.cloneNode(true);
              (_e = speakIcon == null ? void 0 : speakIcon.parentNode) == null ? void 0 : _e.replaceChild(clone2, speakIcon);
              speakIcon = document.getElementById("speakIcon");
              speakIcon == null ? void 0 : speakIcon.addEventListener("click", speakEvent);
            }
          } else {
            if (speakIcon) {
              speakIcon.style.setProperty("display", "none");
            }
          }
          if (((_f = this.properties) == null ? void 0 : _f.selectionMenuItems) ?? []) {
            (((_g = this.properties) == null ? void 0 : _g.selectionMenuItems) ?? []).forEach((menuItem) => {
              var _a2;
              if (menuItem.icon) {
                menuItem.icon.id = menuItem.id;
              }
              let itemElement = document.getElementById(menuItem.id);
              const self3 = this;
              function itemEvent() {
                var _a3, _b2, _c2, _d2, _e2, _f2, _g2;
                itemElement == null ? void 0 : itemElement.removeEventListener("click", itemEvent);
                function getCssSelector(element) {
                  const options = {
                    className: (str) => {
                      return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
                    },
                    idName: (str) => {
                      return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
                    }
                  };
                  let doc = self3.navigator.iframes[0].contentDocument;
                  if (doc) {
                    return uniqueCssSelector(element, doc, options);
                  } else {
                    return void 0;
                  }
                }
                let win = self3.navigator.iframes[0].contentWindow;
                if (win) {
                  let selectionInfo = getCurrentSelectionInfo(
                    win,
                    getCssSelector
                  );
                  if (selectionInfo === void 0) {
                    let doc = self3.navigator.iframes[0].contentDocument;
                    selectionInfo = (_b2 = (_a3 = self3.navigator.annotationModule) == null ? void 0 : _a3.annotator) == null ? void 0 : _b2.getTemporarySelectionInfo(
                      doc
                    );
                  }
                  if (selectionInfo !== void 0) {
                    if (menuItem.callback) {
                      menuItem.callback(
                        selectionInfo.cleanText,
                        (_c2 = selectionInfo.range) == null ? void 0 : _c2.startContainer.parentElement
                      );
                    } else {
                      let style = (_d2 = menuItem.highlight) == null ? void 0 : _d2.style;
                      let marker = menuItem.marker ? menuItem.marker : 3 /* Custom */;
                      if (marker === 3 /* Custom */ && self3.navigator.rights.enableAnnotations || marker === 2 /* Bookmark */ && self3.navigator.rights.enableBookmarks) {
                        let doc = self3.navigator.iframes[0].contentDocument;
                        if (doc) {
                          let highlight = self3.createHighlight(
                            self3.dom(doc.body).getWindow(),
                            selectionInfo,
                            (_e2 = menuItem.highlight) == null ? void 0 : _e2.color,
                            true,
                            marker,
                            menuItem.icon,
                            menuItem.popup,
                            style
                          );
                          self3.options.onAfterHighlight(highlight, marker);
                          if (self3.navigator.rights.enableAnnotations) {
                            (_f2 = self3.navigator.annotationModule) == null ? void 0 : _f2.saveAnnotation(highlight[0]).then((anno) => {
                              var _a4, _b3;
                              if (menuItem == null ? void 0 : menuItem.note) {
                                if (anno.highlight) {
                                  (_b3 = (_a4 = self3.navigator.annotationModule) == null ? void 0 : _a4.api) == null ? void 0 : _b3.addCommentToAnnotation(anno).then((result) => {
                                    var _a5;
                                    (_a5 = self3.navigator.annotationModule) == null ? void 0 : _a5.updateAnnotation(result).then(async () => {
                                      import_loglevel5.default.log(
                                        "update highlight " + result.id
                                      );
                                    });
                                  });
                                }
                              }
                            });
                          } else if (self3.navigator.rights.enableBookmarks) {
                            (_g2 = self3.navigator.bookmarkModule) == null ? void 0 : _g2.saveAnnotation(
                              highlight[0]
                            );
                          }
                        }
                      }
                    }
                  }
                }
                self3.callbackComplete();
              }
              if (itemElement) {
                const clone2 = itemElement.cloneNode(true);
                (_a2 = itemElement == null ? void 0 : itemElement.parentNode) == null ? void 0 : _a2.replaceChild(clone2, itemElement);
                itemElement = document.getElementById(menuItem.id);
                itemElement == null ? void 0 : itemElement.addEventListener("click", itemEvent);
              }
            });
          }
        }
      }
    }
    /**
     * Highlights current range.
     * @param {boolean} keepRange - Don't remove range after highlighting. Default: false.
     * @param marker
     * @memberof TextHighlighter
     */
    doHighlight(keepRange, marker) {
      var _a, _b, _c, _d, _e, _f;
      let self2 = this;
      function getCssSelector(element) {
        const options = {
          className: (str) => {
            return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
          },
          idName: (str) => {
            return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
          }
        };
        let doc = self2.navigator.iframes[0].contentDocument;
        if (doc) {
          return uniqueCssSelector(element, doc, options);
        } else {
          return void 0;
        }
      }
      let win = self2.navigator.iframes[0].contentWindow;
      if (win) {
        let selectionInfo = getCurrentSelectionInfo(win, getCssSelector);
        if (selectionInfo === void 0) {
          let doc = self2.navigator.iframes[0].contentDocument;
          selectionInfo = (_b = (_a = this.navigator.annotationModule) == null ? void 0 : _a.annotator) == null ? void 0 : _b.getTemporarySelectionInfo(
            doc
          );
        }
        if (selectionInfo) {
          if (this.options.onBeforeHighlight(selectionInfo) === true) {
            let createColor;
            createColor = this.getColor();
            if (_TextHighlighter.isHexColor(createColor)) {
              createColor = _TextHighlighter.hexToRgbChannels(createColor);
            }
            let doc = self2.navigator.iframes[0].contentDocument;
            if (doc) {
              let highlight = this.createHighlight(
                self2.dom(doc.body).getWindow(),
                selectionInfo,
                createColor,
                true,
                marker ?? 0 /* Highlight */
              );
              this.options.onAfterHighlight(highlight, marker);
              if (this.navigator.rights.enableAnnotations && marker !== 2 /* Bookmark */) {
                (_c = this.navigator.annotationModule) == null ? void 0 : _c.saveAnnotation(highlight[0]);
              } else if (this.navigator.rights.enableBookmarks && marker === 2 /* Bookmark */) {
                (_d = this.navigator.bookmarkModule) == null ? void 0 : _d.saveAnnotation(highlight[0]);
              }
            }
          }
          if (!keepRange) {
            this.dom(
              (_e = this.navigator.iframes[0].contentDocument) == null ? void 0 : _e.body
            ).removeAllRanges();
          }
        } else {
          if (!keepRange) {
            this.dom(
              (_f = this.navigator.iframes[0].contentDocument) == null ? void 0 : _f.body
            ).removeAllRanges();
          }
        }
      }
    }
    speak() {
      var _a, _b;
      if (this.navigator.rights.enableTTS) {
        let getCssSelector = function(element) {
          const options = {
            className: (str) => {
              return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
            },
            idName: (str) => {
              return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
            }
          };
          let doc2 = self2.navigator.iframes[0].contentDocument;
          if (doc2) {
            return uniqueCssSelector(element, doc2, options);
          } else {
            return void 0;
          }
        };
        let self2 = this;
        let win = self2.navigator.iframes[0].contentWindow;
        if (win) {
          let selectionInfo = getCurrentSelectionInfo(win, getCssSelector);
          if (selectionInfo === void 0) {
            let doc2 = self2.navigator.iframes[0].contentDocument;
            selectionInfo = (_b = (_a = self2.navigator.annotationModule) == null ? void 0 : _a.annotator) == null ? void 0 : _b.getTemporarySelectionInfo(
              doc2
            );
          }
          if (selectionInfo !== void 0) {
            this.navigator.ttsModule.speak(
              selectionInfo,
              true,
              () => {
              }
            );
          }
        }
        let doc = self2.navigator.iframes[0].contentDocument;
        if (doc) {
          const selection = self2.dom(doc.body).getSelection();
          selection.removeAllRanges();
        }
        const toolbox = document.getElementById("highlight-toolbox");
        if (toolbox) {
          toolbox.style.display = "none";
        }
        this.selectionMenuClosed();
      }
    }
    stopReadAloud() {
      if (this.navigator.rights.enableTTS) {
        this.doneSpeaking();
      }
    }
    callbackComplete() {
      this.toolboxHide();
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        this.dom(doc.body).removeAllRanges();
      }
    }
    isOutsideViewport(rect) {
      let wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      const windowLeft = wrapper.scrollLeft;
      const windowRight = windowLeft + wrapper.clientWidth;
      const right = rect.left + rect.width;
      const bottom = rect.top + rect.height;
      const windowTop = wrapper.scrollTop;
      const windowBottom = windowTop + wrapper.clientHeight;
      const isAbove = bottom < windowTop;
      const isBelow = rect.top > windowBottom;
      const isLeft = right < windowLeft;
      const isRight = rect.left > windowRight;
      return isAbove || isBelow || isLeft || isRight;
    }
    isInsideViewport(rect) {
      let wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      const windowTop = wrapper.scrollTop;
      const windowBottom = windowTop + wrapper.clientHeight;
      const isAbove = rect.top + 20 >= windowTop;
      const isBelow = rect.top <= windowBottom;
      const windowLeft = wrapper.scrollLeft;
      const windowRight = windowLeft + wrapper.clientWidth;
      const right = rect.left + rect.width;
      const isLeft = rect.left > windowLeft;
      const isRight = right < windowRight;
      return isAbove && isBelow && isLeft && isRight;
    }
    get visibleTextRects() {
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        let findTextNodes = function(parentElement, nodes = []) {
          var _a;
          let element = parentElement.firstChild;
          while (element) {
            if (element.nodeType === 1) {
              findTextNodes(element, nodes);
            }
            if (element.nodeType === 3) {
              if ((_a = element.textContent) == null ? void 0 : _a.trim()) {
                nodes.push(element);
              }
            }
            element = element.nextSibling;
          }
          return nodes;
        }, findRects = function(parent) {
          const textNodes2 = findTextNodes(parent);
          return textNodes2.map((node) => {
            const { top, height, left, width } = measureTextNode(node);
            return {
              top,
              height,
              width,
              left,
              node,
              textContent: node.textContent ?? ""
            };
          });
        }, measureTextNode = function(node) {
          try {
            const range = document.createRange();
            range.selectNode(node);
            const rect = range.getBoundingClientRect();
            range.detach();
            return rect;
          } catch (error) {
            import_loglevel5.default.log("measureTextNode " + error);
            import_loglevel5.default.log("measureTextNode " + node);
            import_loglevel5.default.log(`${node.textContent}`);
          }
        };
        const body = findRequiredIframeElement(
          doc,
          "body"
        );
        const textNodes = findRects(body);
        return textNodes.filter((rect) => this.isInsideViewport(rect));
      }
      return [];
    }
    doneSpeaking(reload = false) {
      if (this.navigator.rights.enableTTS) {
        this.toolboxHide();
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          this.dom(doc.body).removeAllRanges();
        }
        this.navigator.ttsModule.cancel();
        if (reload) {
          this.navigator.reload();
        }
      }
    }
    /**
     * Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of
     * wrapping HTML elements.
     * Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights.
     * @param {Array} highlights - highlights to normalize.
     * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than
     * input highlights.
     * @memberof TextHighlighter
     */
    normalizeHighlights(highlights) {
      var normalizedHighlights;
      normalizedHighlights = highlights.filter(function(hl) {
        return hl.parentElement ? hl : null;
      });
      normalizedHighlights = this.unique(normalizedHighlights);
      normalizedHighlights.sort(function(a, b) {
        return a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft;
      });
      return normalizedHighlights;
    }
    /**
     * Flattens highlights structure.
     * Note: this method changes input highlights - their order and number after calling this method may change.
     * @param {Array} highlights - highlights to flatten.
     * @memberof TextHighlighter
     */
    flattenNestedHighlights(highlights) {
      let again;
      let self2 = this;
      self2.sortByDepth(highlights, true);
      function flattenOnce() {
        let again2 = false;
        highlights.forEach(function(hl, i) {
          let parent = hl.parentElement, parentPrev = parent.previousSibling, parentNext = parent.nextSibling;
          if (self2.isHighlight(parent)) {
            if (!self2.haveSameColor(parent, hl)) {
              if (!hl.nextSibling) {
                self2.dom(hl).insertBefore(parentNext || parent);
                again2 = true;
              }
              if (!hl.previousSibling) {
                self2.dom(hl).insertAfter(parentPrev || parent);
                again2 = true;
              }
              if (!parent.hasChildNodes()) {
                self2.dom(parent).remove();
              }
            } else {
              parent.replaceChild(hl.firstChild, hl);
              highlights[i] = parent;
              again2 = true;
            }
          }
        });
        return again2;
      }
      do {
        again = flattenOnce();
      } while (again);
    }
    /**
     * Merges sibling highlights and normalizes descendant text nodes.
     * Note: this method changes input highlights - their order and number after calling this method may change.
     * @param highlights
     * @memberof TextHighlighter
     */
    mergeSiblingHighlights(highlights) {
      let self2 = this;
      function shouldMerge(current, node) {
        return node && node.nodeType === NODE_TYPE.ELEMENT_NODE && self2.haveSameColor(current, node) && self2.isHighlight(node);
      }
      highlights.forEach(function(highlight) {
        let prev = highlight.previousSibling, next = highlight.nextSibling;
        if (shouldMerge(highlight, prev)) {
          self2.dom(highlight).prepend(prev.childNodes);
          self2.dom(prev).remove();
        }
        if (shouldMerge(highlight, next)) {
          self2.dom(highlight).append(next.childNodes);
          self2.dom(next).remove();
        }
        self2.dom(highlight).normalizeTextNodes();
      });
    }
    /**
     * Sets highlighting color.
     * @param {string} color - valid CSS color.
     * @memberof TextHighlighter
     */
    setColor(color) {
      this.options.color = color;
    }
    /**
     * Returns highlighting color.
     * @returns {string}
     * @memberof TextHighlighter
     */
    getColor() {
      return this.options.color;
    }
    /**
     * Returns true if element is a highlight.
     * All highlights have 'data-highlighted' attribute.
     * @param el - element to check.
     * @returns {boolean}
     * @memberof TextHighlighter
     */
    isHighlight(el) {
      return el && el.nodeType === NODE_TYPE.ELEMENT_NODE && el.hasAttribute(DATA_ATTR);
    }
    /**
     * Creates wrapper for highlights.
     * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved
     * in constructor.
     * @returns {HTMLElement}
     * @memberof TextHighlighter
     * @static
     */
    createWrapper() {
      let span = document.createElement("mark");
      span.style.background = "linear-gradient(" + _TextHighlighter.hexToRgbA(this.options.color) + ", " + _TextHighlighter.hexToRgbA(this.options.color) + ")";
      span.className = this.options.highlightedClass;
      return span;
    }
    static isHexColor(hex) {
      return /^#([A-Fa-f0-9]{3}){1,2}$/.test(hex);
    }
    static hexToRgbString(hex) {
      let c;
      c = hex.substring(1).split("");
      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      c = "0x" + c.join("");
      return c;
    }
    static hexToRgbChannels(hex) {
      let c;
      if (this.isHexColor(hex)) {
        c = this.hexToRgbString(hex);
        return {
          red: c >> 16 & 255,
          green: c >> 8 & 255,
          blue: c & 255
        };
      }
      throw new Error("Bad Hex");
    }
    static hexToRgbA(hex) {
      let c;
      if (this.isHexColor(hex)) {
        c = this.hexToRgbChannels(hex);
        return "rgba(" + [c.red, c.green, c.blue].join(",") + ",.5)";
      } else if (typeof hex === "object") {
        let c2 = hex;
        return "rgba(" + [c2.red, c2.green, c2.blue].join(",") + ",.5)";
      }
      throw new Error("Bad Hex");
    }
    static hexToRgbAWithOpacity(hex, opacity) {
      let c;
      if (this.isHexColor(hex)) {
        c = this.hexToRgbChannels(hex);
        return "rgba(" + [c.red, c.green, c.blue].join(",") + "," + opacity + ")";
      } else if (typeof hex === "object") {
        let c2 = hex;
        return "rgba(" + [c2.red, c2.green, c2.blue].join(",") + "," + opacity + ")";
      }
      throw new Error("Bad Hex");
    }
    resetHighlightBoundingStyle(highlightBounding) {
      highlightBounding.style.outline = "none";
      highlightBounding.style.setProperty(
        "background-color",
        "transparent",
        "important"
      );
    }
    resetHighlightAreaStyle(highlightArea, id_container) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      let doc = (_a = this.navigator.iframes[0].contentWindow) == null ? void 0 : _a.document;
      const id2 = highlightArea.parentNode && highlightArea.parentNode.nodeType === Node.ELEMENT_NODE && highlightArea.parentNode.getAttribute ? highlightArea.parentNode.getAttribute("id") : void 0;
      if (id2) {
        const highlight = _highlights.find((h) => {
          return h.id === id2;
        });
        if (highlight) {
          if (highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
            if ((_b = highlight.style) == null ? void 0 : _b.hover) {
              if ((_c = highlight.style) == null ? void 0 : _c.hover) {
                for (let i = 0; i < ((_e = (_d = highlight.style) == null ? void 0 : _d.hover) == null ? void 0 : _e.length); i++) {
                  let style = (_f = highlight.style) == null ? void 0 : _f.hover[i];
                  highlightArea.style.removeProperty(style.property);
                }
              }
              let extra = ``;
              if ((_g = highlight.style) == null ? void 0 : _g.default) {
                for (let i = 0; i < ((_i = (_h = highlight.style) == null ? void 0 : _h.default) == null ? void 0 : _i.length); i++) {
                  let style = (_j = highlight.style) == null ? void 0 : _j.default[i];
                  highlightArea.style.removeProperty(style.property);
                  extra += `${style.property}: ${style.value} !${style.priority};`;
                }
              }
              highlightArea.setAttribute(
                "style",
                `${highlightArea.getAttribute("style")}; ${extra}`
              );
            } else if ((_k = highlight.style) == null ? void 0 : _k.hoverClass) {
              if ((_l = highlight.style) == null ? void 0 : _l.hoverClass) {
                highlightArea.classList.remove((_m = highlight.style) == null ? void 0 : _m.hoverClass);
              }
              let extra = ``;
              if ((_n = highlight.style) == null ? void 0 : _n.defaultClass) {
                highlightArea.classList.add((_o = highlight.style) == null ? void 0 : _o.defaultClass);
              }
              highlightArea.setAttribute(
                "style",
                `${highlightArea.getAttribute("style")}; ${extra}`
              );
            } else {
              if (_TextHighlighter.isHexColor(highlight.color)) {
                let color = _TextHighlighter.hexToRgbChannels(highlight.color);
                highlightArea.style.setProperty(
                  "background-color",
                  `rgba(${color.red}, ${color.green}, ${color.blue}, ${0})`,
                  "important"
                );
              } else {
                highlightArea.classList.remove("hover");
              }
            }
          } else if (highlight.marker === 1 /* Underline */ || highlight.marker === 4 /* Comment */) {
            if (typeof highlight.color === "object") {
              let color = highlight.color;
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${0})`,
                "important"
              );
              highlightArea.style.setProperty(
                "border-bottom",
                `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
                "important"
              );
            } else if (_TextHighlighter.isHexColor(highlight.color)) {
              let color = _TextHighlighter.hexToRgbChannels(highlight.color);
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${0})`,
                "important"
              );
              highlightArea.style.setProperty(
                "border-bottom",
                `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
                "important"
              );
            } else {
              highlightArea.classList.remove("hover");
            }
          } else {
            if (typeof highlight.color === "object") {
              let color = highlight.color;
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                "important"
              );
            } else if (_TextHighlighter.isHexColor(highlight.color)) {
              let color = _TextHighlighter.hexToRgbChannels(highlight.color);
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                "important"
              );
            } else {
              highlightArea.classList.remove("hover");
            }
          }
          let highlightParent;
          if (doc) {
            let container = doc.getElementById(id_container);
            if (container) {
              highlightParent = container.querySelector(`#${highlight.id}`);
            }
          }
          if (highlightParent) {
            let nodeList = highlightParent.getElementsByClassName(CLASS_HIGHLIGHT_ICON);
            if (nodeList.length > 0) {
              const tooltip = nodeList.item(0).getElementsByClassName("icon-tooltip");
              if (tooltip.length > 0) {
                tooltip.item(0).style.removeProperty("display");
              }
            }
          }
        }
      }
    }
    setHighlightAreaStyle(doc, highlightAreas, highlight) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      for (const highlightArea of highlightAreas) {
        if (highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
          if ((_a = highlight.style) == null ? void 0 : _a.hover) {
            if ((_b = highlight.style) == null ? void 0 : _b.default) {
              for (let i = 0; i < ((_d = (_c = highlight.style) == null ? void 0 : _c.default) == null ? void 0 : _d.length); i++) {
                let style = (_e = highlight.style) == null ? void 0 : _e.default[i];
                highlightArea.style.removeProperty(style.property);
              }
            }
            let extra = ``;
            for (let i = 0; i < ((_g = (_f = highlight.style) == null ? void 0 : _f.hover) == null ? void 0 : _g.length); i++) {
              let style = (_h = highlight.style) == null ? void 0 : _h.hover[i];
              highlightArea.style.removeProperty(style.property);
              extra += `${style.property}: ${style.value} !${style.priority};`;
            }
            highlightArea.setAttribute(
              "style",
              `${highlightArea.getAttribute("style")}; ${extra}`
            );
          } else if ((_i = highlight.style) == null ? void 0 : _i.hoverClass) {
            if ((_j = highlight.style) == null ? void 0 : _j.defaultClass) {
              highlightArea.classList.remove((_k = highlight.style) == null ? void 0 : _k.defaultClass);
            }
            let extra = ``;
            highlightArea.classList.add((_l = highlight.style) == null ? void 0 : _l.hoverClass);
            highlightArea.setAttribute(
              "style",
              `${highlightArea.getAttribute("style")}; ${extra}`
            );
          } else {
            if (_TextHighlighter.isHexColor(highlight.color)) {
              let color = _TextHighlighter.hexToRgbChannels(highlight.color);
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${0.1})`,
                "important"
              );
            } else {
              highlightArea.classList.add("hover");
            }
          }
        } else if (highlight.marker === 1 /* Underline */ || highlight.marker === 4 /* Comment */) {
          if (typeof highlight.color === "object") {
            let color = highlight.color;
            highlightArea.style.setProperty(
              "background-color",
              `rgba(${color.red}, ${color.green}, ${color.blue}, ${0.1})`,
              "important"
            );
            highlightArea.style.setProperty(
              "border-bottom",
              `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
              "important"
            );
          } else if (_TextHighlighter.isHexColor(highlight.color)) {
            let color = _TextHighlighter.hexToRgbChannels(highlight.color);
            highlightArea.style.setProperty(
              "background-color",
              `rgba(${color.red}, ${color.green}, ${color.blue}, ${0.1})`,
              "important"
            );
            highlightArea.style.setProperty(
              "border-bottom",
              `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
              "important"
            );
          } else {
            highlightArea.classList.add("hover");
          }
        } else {
          if (typeof highlight.color === "object") {
            let color = highlight.color;
            highlightArea.style.setProperty(
              "background-color",
              `rgba(${color.red}, ${color.green}, ${color.blue}, ${ALT_BACKGROUND_COLOR_OPACITY})`,
              "important"
            );
          } else if (_TextHighlighter.isHexColor(highlight.color)) {
            let color = _TextHighlighter.hexToRgbChannels(highlight.color);
            highlightArea.style.setProperty(
              "background-color",
              `rgba(${color.red}, ${color.green}, ${color.blue}, ${ALT_BACKGROUND_COLOR_OPACITY})`,
              "important"
            );
          } else {
            highlightArea.classList.add("hover");
          }
        }
        if (highlight.type !== 4 /* Definition */) {
          let highlightParent = doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */).querySelector(`#${highlight.id}`);
          let nodeList = highlightParent.getElementsByClassName(CLASS_HIGHLIGHT_ICON);
          if (nodeList.length > 0) {
            const tooltip = nodeList.item(0).getElementsByClassName("icon-tooltip");
            if (tooltip.length > 0) {
              tooltip.item(0).style.setProperty(
                "display",
                "block"
              );
            }
          }
        }
      }
    }
    setAndResetSearchHighlight(highlight, highlights) {
      var _a;
      let doc = (_a = this.navigator.iframes[0].contentWindow) == null ? void 0 : _a.document;
      const allHighlightAreas = Array.from(
        doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */).querySelectorAll(`.${CLASS_HIGHLIGHT_AREA}`)
      );
      for (const highlighta of allHighlightAreas) {
        let highlightArea = highlighta;
        const id2 = highlightArea.parentNode && highlightArea.parentNode.nodeType === Node.ELEMENT_NODE && highlightArea.parentNode.getAttribute ? highlightArea.parentNode.getAttribute("id") : void 0;
        highlights.forEach((highlight2) => {
          if (id2 === highlight2.id) {
            if (highlight2) {
              if (typeof highlight2.color === "object") {
                let color = highlight2.color;
                highlightArea.style.setProperty(
                  "background-color",
                  `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                  "important"
                );
              } else if (_TextHighlighter.isHexColor(highlight2.color)) {
                let color = _TextHighlighter.hexToRgbChannels(highlight2.color);
                highlightArea.style.setProperty(
                  "background-color",
                  `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                  "important"
                );
              } else {
                highlightArea.classList.remove("hover");
              }
              let highlightParent = doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */).querySelector(`#${highlight2.id}`);
              let nodeList = highlightParent.getElementsByClassName(CLASS_HIGHLIGHT_ICON);
              if (nodeList.length > 0) {
                const tooltip = nodeList.item(0).getElementsByClassName("icon-tooltip");
                if (tooltip.length > 0) {
                  tooltip.item(0).style.removeProperty(
                    "display"
                  );
                }
              }
            }
          }
        });
        if (id2 === highlight.id) {
          if (highlight) {
            if (typeof highlight.color === "object") {
              let color = highlight.color;
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                "important"
              );
            } else if (_TextHighlighter.isHexColor(highlight.color)) {
              let color = _TextHighlighter.hexToRgbChannels(highlight.color);
              highlightArea.style.setProperty(
                "background-color",
                `rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY})`,
                "important"
              );
            } else {
              highlightArea.classList.remove("hover");
            }
            let highlightParent = doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */).querySelector(`#${highlight.id}`);
            let nodeList = highlightParent.getElementsByClassName(CLASS_HIGHLIGHT_ICON);
            if (nodeList.length > 0) {
              const tooltip = nodeList.item(0).getElementsByClassName("icon-tooltip");
              if (tooltip.length > 0) {
                tooltip.item(0).style.removeProperty("display");
              }
            }
          }
        }
      }
    }
    isIOS() {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i) != null || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    }
    isAndroid() {
      return navigator.userAgent.match(/Android/i) != null;
    }
    async processMouseEvent(ev) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const doc = (_a = this.navigator.iframes[0].contentWindow) == null ? void 0 : _a.document;
      if (!doc || !(ev.type === "mouseup" || ev.type === "click" || ev.type === "touchup")) {
        return;
      }
      if (!doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */) && !doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */) && !doc.getElementById("R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */) && !doc.getElementById("R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */) && !doc.getElementById("R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */)) {
        return;
      }
      const foundElement = ev.target;
      const foundHighlight = _highlights.find(
        (el) => {
          var _a2;
          return el.id === ((_a2 = ev.target.parentElement) == null ? void 0 : _a2.id);
        }
      );
      if (!foundHighlight || !foundElement) {
        for (let id2 in HighlightContainer) {
          let container = doc.getElementById(id2);
          if (container) {
            const highlightBoundings = container.querySelectorAll(
              `.${CLASS_HIGHLIGHT_BOUNDING_AREA}`
            );
            for (const highlightBounding of highlightBoundings) {
              this.resetHighlightBoundingStyle(highlightBounding);
            }
            const allHighlightAreas = Array.from(
              container.querySelectorAll(`.${CLASS_HIGHLIGHT_AREA}`)
            );
            for (const highlightArea of allHighlightAreas) {
              this.resetHighlightAreaStyle(highlightArea, id2);
            }
          }
        }
        return;
      }
      if (foundElement.getAttribute("data-click")) {
        if ((ev.type === "mouseup" || ev.type === "click" || ev.type === "touchup") && ((_b = foundElement.parentElement) == null ? void 0 : _b.style.display) !== "none") {
          const payload = {
            highlight: foundHighlight
          };
          import_loglevel5.default.log(JSON.stringify(payload));
          let self2 = this;
          let anno;
          if (self2.navigator.rights.enableAnnotations) {
            anno = await ((_c = this.navigator.annotationModule) == null ? void 0 : _c.getAnnotation(
              payload.highlight
            ));
          } else if (self2.navigator.rights.enableBookmarks) {
            anno = await ((_d = this.navigator.bookmarkModule) == null ? void 0 : _d.getAnnotation(
              payload.highlight
            ));
          }
          if (payload.highlight.type === 0 /* Annotation */) {
            (_f = (_e = this.navigator.annotationModule) == null ? void 0 : _e.api) == null ? void 0 : _f.selectedAnnotation(anno).then(async () => {
            });
          }
          if (anno == null ? void 0 : anno.id) {
            import_loglevel5.default.log("selected highlight " + anno.id);
            self2.lastSelectedHighlight = anno.id;
            let toolbox = document.getElementById("highlight-toolbox");
            if (toolbox) {
              toolbox.style.top = ev.clientY + (((_g = this.navigator.attributes) == null ? void 0 : _g.navHeight) ?? 0) + "px";
              toolbox.style.left = ev.clientX + "px";
              if (getComputedStyle(toolbox).display === "none") {
                let noteH = function() {
                  var _a2, _b2;
                  (_b2 = (_a2 = self2.navigator.annotationModule) == null ? void 0 : _a2.api) == null ? void 0 : _b2.addCommentToAnnotation(anno).then((result) => {
                    var _a3;
                    (_a3 = self2.navigator.annotationModule) == null ? void 0 : _a3.updateAnnotation(result).then(async () => {
                      import_loglevel5.default.log("update highlight " + result.id);
                      if (toolbox) {
                        toolbox.style.display = "none";
                      }
                      self2.selectionMenuClosed();
                    });
                    if (toolbox) {
                      toolbox.style.display = "none";
                    }
                    self2.selectionMenuClosed();
                    commentIcon == null ? void 0 : commentIcon.removeEventListener("click", noteH, false);
                  });
                }, deleteH = function() {
                  var _a2, _b2;
                  if (self2.navigator.rights.enableAnnotations) {
                    (_a2 = self2.navigator.annotationModule) == null ? void 0 : _a2.deleteSelectedHighlight(anno).then(async () => {
                      import_loglevel5.default.log("delete highlight " + anno.id);
                      if (toolbox) {
                        toolbox.style.display = "none";
                      }
                      self2.selectionMenuClosed();
                    });
                  } else if (self2.navigator.rights.enableBookmarks) {
                    (_b2 = self2.navigator.bookmarkModule) == null ? void 0 : _b2.deleteSelectedHighlight(anno).then(async () => {
                      import_loglevel5.default.log("delete highlight " + anno.id);
                      if (toolbox) {
                        toolbox.style.display = "none";
                      }
                      self2.selectionMenuClosed();
                    });
                  }
                };
                toolbox.style.display = "block";
                this.toolboxMode("edit");
                let colorIcon = document.getElementById("colorIcon");
                let highlightIcon = document.getElementById("highlightIcon");
                if (colorIcon) {
                  colorIcon.style.display = "none";
                }
                if (highlightIcon) {
                  highlightIcon.style.display = "none";
                }
                let commentIcon = document.getElementById("commentIcon");
                let cloneCommentIcon = document.getElementById("cloneCommentIcon");
                if (cloneCommentIcon) {
                  let parent = cloneCommentIcon.parentElement;
                  if (parent) {
                    parent.removeChild(cloneCommentIcon);
                  }
                }
                if (commentIcon) {
                  commentIcon.style.display = "none";
                  let clone2 = commentIcon.cloneNode(true);
                  let parent = commentIcon.parentElement;
                  clone2.style.display = "unset";
                  clone2.id = "cloneCommentIcon";
                  clone2.addEventListener("click", noteH, false);
                  if (parent) {
                    parent.append(clone2);
                  }
                }
                let deleteIcon = document.getElementById("deleteIcon");
                let cloneDeleteIcon = document.getElementById("cloneDeleteIcon");
                if (cloneDeleteIcon) {
                  let parent = cloneDeleteIcon.parentElement;
                  if (parent) {
                    parent.removeChild(cloneDeleteIcon);
                  }
                }
                if (deleteIcon) {
                  deleteIcon.style.display = "none";
                  let clone2 = deleteIcon.cloneNode(true);
                  let parent = deleteIcon.parentElement;
                  clone2.style.display = "unset";
                  clone2.id = "cloneDeleteIcon";
                  clone2.addEventListener("click", deleteH, false);
                  if (parent) {
                    parent.append(clone2);
                  }
                }
              } else {
                toolbox.style.display = "none";
                this.selectionMenuClosed();
                void toolbox.offsetWidth;
                toolbox.style.display = "block";
              }
            }
          } else {
            if (foundElement.dataset.definition) {
              const popup = new Popup(this.navigator);
              popup.showPopup(foundElement.dataset.definition, ev);
            }
            let result = (_j = (_i = (_h = this.navigator.definitionsModule) == null ? void 0 : _h.properties) == null ? void 0 : _i.definitions) == null ? void 0 : _j.filter(
              (el) => el.order === Number(foundElement == null ? void 0 : foundElement.dataset.order)
            )[0];
            import_loglevel5.default.log(result);
            if ((_l = (_k = this.navigator.definitionsModule) == null ? void 0 : _k.api) == null ? void 0 : _l.click) {
              (_m = this.navigator.definitionsModule.api) == null ? void 0 : _m.click(
                lodash.omit(result, "callbacks"),
                lodash.omit(foundHighlight, "definition")
              );
              this.navigator.emit("definition.click", result, foundHighlight);
            }
          }
        }
      }
    }
    async prepareContainers(win) {
      for (let container in HighlightContainer) {
        await this.ensureHighlightsContainer(win, container);
      }
    }
    async ensureHighlightsContainer(win, id2) {
      var _a, _b;
      const doc = win.document;
      if (!doc.getElementById(id2)) {
        let container = doc.createElement("div");
        container.setAttribute("id", id2);
        if (id2 !== "R2_ID_GUTTER_RIGHT_CONTAINER" /* R2_ID_GUTTER_RIGHT_CONTAINER */) {
          container.style.setProperty("pointer-events", "none");
        }
        if (((_a = this.navigator.view) == null ? void 0 : _a.layout) === "fixed") {
          container.style.setProperty("position", "absolute");
          container.style.setProperty("top", "0");
          container.style.setProperty("left", "0");
        }
        if (doc.body) {
          doc.body.append(container);
        }
        if (((_b = await this.layerSettings.getProperty(id2)) == null ? void 0 : _b.value) === false) {
          container.style.display = "none";
        }
      }
      return doc.getElementById(id2);
    }
    hideAllhighlights(doc) {
      this.removeAllChildNodes(
        doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */)
      );
      this.removeAllChildNodes(
        doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */)
      );
      this.removeAllChildNodes(
        doc.getElementById("R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */)
      );
      this.removeAllChildNodes(
        doc.getElementById("R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */)
      );
      this.removeAllChildNodes(
        doc.getElementById("R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */)
      );
    }
    destroyAllhighlights(doc) {
      this.hideAllhighlights(doc);
      _highlights.splice(0, _highlights.length);
    }
    removeAllChildNodes(parent) {
      while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
      }
    }
    destroyHighlights(type) {
      var _a;
      let doc = (_a = this.navigator.iframes[0].contentWindow) == null ? void 0 : _a.document;
      if (doc) {
        let container;
        switch (type) {
          case 2 /* ReadAloud */:
            container = doc.getElementById(
              "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          case 1 /* Search */:
            container = doc.getElementById(
              "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          case 3 /* PageBreak */:
            container = doc.getElementById(
              "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          case 4 /* Definition */:
            container = doc.getElementById(
              "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          case 5 /* LineFocus */:
            container = doc.getElementById(
              "R2_ID_LINEFOCUS_CONTAINER" /* R2_ID_LINEFOCUS_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          case 6 /* Comment */:
            container = doc.getElementById(
              "R2_ID_GUTTER_RIGHT_CONTAINER" /* R2_ID_GUTTER_RIGHT_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            break;
          default:
            container = doc.getElementById(
              "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */
            );
            if (container) {
              this.removeAllChildNodes(container);
            }
            _highlights.splice(0, _highlights.length);
            break;
        }
      }
    }
    destroyHighlight(doc, id2) {
      if (!doc) {
        return;
      }
      let i = -1;
      const highlight = _highlights.find((h, j) => {
        i = j;
        return h.id === id2;
      });
      if (highlight && i >= 0 && i < _highlights.length) {
        _highlights.splice(i, 1);
      }
      const highlightContainer = doc.getElementById(id2);
      if (highlightContainer) {
        this.removeAllChildNodes(highlightContainer);
      }
    }
    createHighlight(win, selectionInfo, color, pointerInteraction, marker, icon, popup, style, type, prefix) {
      try {
        const uniqueStr = `${selectionInfo.rangeInfo.startContainerElementCssSelector}${selectionInfo.rangeInfo.startContainerChildTextNodeIndex}${selectionInfo.rangeInfo.startOffset}${selectionInfo.rangeInfo.endContainerElementCssSelector}${selectionInfo.rangeInfo.endContainerChildTextNodeIndex}${selectionInfo.rangeInfo.endOffset}`;
        const sha256Hex = SHA256.hash(uniqueStr);
        const id2 = (prefix ? prefix : "R2_HIGHLIGHT_") + sha256Hex;
        this.destroyHighlight(win.document, id2);
        let defaultColor = `rgb(${DEFAULT_BACKGROUND_COLOR.red}, ${DEFAULT_BACKGROUND_COLOR.green}, ${DEFAULT_BACKGROUND_COLOR.blue})`;
        const highlight = {
          color: color ? color : defaultColor,
          id: id2,
          pointerInteraction,
          selectionInfo,
          marker,
          icon,
          popup,
          style,
          type: type ? type : 0 /* Annotation */
        };
        if (type === 0 /* Annotation */ || type === 4 /* Definition */ || type === void 0) {
          _highlights.push(highlight);
        }
        let highlightDom = this.createHighlightDom(win, highlight);
        highlight.position = parseInt(
          ((highlightDom == null ? void 0 : highlightDom.hasChildNodes()) ? highlightDom.childNodes[0] : highlightDom).style.top.replace("px", "")
        );
        return [highlight, highlightDom];
      } catch (e) {
        throw "Can't create highlight: " + e;
      }
    }
    createHighlightDom(win, highlight) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F;
      const doc = win.document;
      const range = convertRangeInfo(doc, highlight.selectionInfo.rangeInfo);
      if (!range) {
        return void 0;
      }
      for (let container in HighlightContainer) {
        this.ensureHighlightsContainer(win, container);
      }
      const highlightParent = doc.createElement("div");
      highlightParent.setAttribute("id", highlight.id);
      highlightParent.setAttribute("class", CLASS_HIGHLIGHT_CONTAINER);
      highlightParent.style.setProperty("pointer-events", "none");
      if (highlight.pointerInteraction) {
        highlightParent.setAttribute("data-click", "1");
        highlightParent.addEventListener("mouseover", (ev) => {
          var _a2;
          if (ev.target.classList.contains(
            "R2_CLASS_HIGHLIGHT_AREA"
          )) {
            const foundElement = ev.currentTarget;
            const foundHighlight = _highlights.find(
              (el) => el.id === ev.currentTarget.id
            );
            if (ev.type === "mouseover" && ((_a2 = foundElement.parentElement) == null ? void 0 : _a2.style.display) !== "none" && foundHighlight) {
              const foundElementHighlightAreas = Array.from(
                foundElement.querySelectorAll(`.${CLASS_HIGHLIGHT_AREA}`)
              );
              this.setHighlightAreaStyle(
                doc,
                foundElementHighlightAreas,
                foundHighlight
              );
            }
          }
        });
        highlightParent.addEventListener("mouseleave", (ev) => {
          const foundElement = ev.currentTarget;
          const foundElementHighlightAreas = Array.from(
            foundElement.querySelectorAll(`.${CLASS_HIGHLIGHT_AREA}`)
          );
          for (const highlightArea of foundElementHighlightAreas) {
            this.resetHighlightAreaStyle(
              highlightArea,
              foundElement.id
            );
          }
          const foundElementHighlightBounding = foundElement.querySelector(
            `.${CLASS_HIGHLIGHT_BOUNDING_AREA}`
          );
          const allHighlightBoundings = foundElement.querySelectorAll(
            `.${CLASS_HIGHLIGHT_BOUNDING_AREA}`
          );
          for (const highlightBounding2 of allHighlightBoundings) {
            if (!foundElementHighlightBounding || highlightBounding2 !== foundElementHighlightBounding) {
              this.resetHighlightBoundingStyle(highlightBounding2);
            }
          }
        });
      }
      const paginated = (_a = this.navigator.view) == null ? void 0 : _a.isPaginated();
      if (paginated) {
        doc.body.style.position = "revert";
      } else {
        doc.body.style.position = "relative";
      }
      const bodyRect = doc.body.getBoundingClientRect();
      const scrollElement = this.getScrollingElement(doc);
      const xOffset = paginated ? -scrollElement.scrollLeft : bodyRect.left;
      const yOffset = paginated ? -scrollElement.scrollTop : bodyRect.top;
      const scale = 1;
      let drawUnderline = false;
      let drawStrikeThrough = false;
      let drawBackground = false;
      let doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough || drawBackground;
      import_loglevel5.default.debug(doNotMergeHorizontallyAlignedRects);
      doNotMergeHorizontallyAlignedRects = true;
      const clientRects = getClientRectsNoOverlap(
        range,
        doNotMergeHorizontallyAlignedRects
      );
      const roundedCorner = 3;
      const underlineThickness = 2;
      const strikeThroughLineThickness = 3;
      let position = 0;
      let size = 24;
      let left, right;
      for (const clientRect of clientRects) {
        const highlightArea = doc.createElement("div");
        highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);
        highlightArea.dataset.marker = "" + highlight.marker;
        let extra = "";
        if (drawUnderline && highlight.marker !== 3 /* Custom */ && highlight.marker !== 2 /* Bookmark */ && highlight.marker !== 4 /* Comment */) {
          let color = highlight.color;
          if (_TextHighlighter.isHexColor(color)) {
            color = _TextHighlighter.hexToRgbChannels(color);
          }
          extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY}) !important`;
        }
        if (highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
          if ((_b = highlight.style) == null ? void 0 : _b.default) {
            for (let i = 0; i < ((_d = (_c = highlight.style) == null ? void 0 : _c.default) == null ? void 0 : _d.length); i++) {
              let style = (_e = highlight.style) == null ? void 0 : _e.default[i];
              extra += `${style.property}: ${style.value} !${style.priority};`;
            }
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; ${extra}`
            );
          } else if ((_f = highlight.style) == null ? void 0 : _f.defaultClass) {
            highlightArea.classList.add((_g = highlight.style) == null ? void 0 : _g.defaultClass);
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; ${extra}`
            );
          }
        } else if (highlight.marker === 1 /* Underline */ || highlight.marker === 4 /* Comment */) {
          if (typeof highlight.color === "object") {
            let color = highlight.color;
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${0}) !important; ${extra}`
            );
            highlightArea.style.setProperty(
              "border-bottom",
              `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
              "important"
            );
          } else if (_TextHighlighter.isHexColor(highlight.color)) {
            let color = _TextHighlighter.hexToRgbChannels(highlight.color);
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${0}) !important; ${extra}`
            );
            highlightArea.style.setProperty(
              "border-bottom",
              `2px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${1})`,
              "important"
            );
          } else {
            highlightArea.setAttribute(
              "style",
              `border-radius: ${roundedCorner}px !important; ${extra}`
            );
          }
        } else {
          if (typeof highlight.color === "object") {
            let color = highlight.color;
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY}) !important; ${extra}`
            );
          } else if (_TextHighlighter.isHexColor(highlight.color)) {
            let color = _TextHighlighter.hexToRgbChannels(highlight.color);
            highlightArea.setAttribute(
              "style",
              `mix-blend-mode: multiply; border-radius: ${roundedCorner}px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY}) !important; ${extra}`
            );
          } else {
            highlightArea.setAttribute(
              "style",
              `border-radius: ${roundedCorner}px !important; ${extra}`
            );
          }
        }
        if (highlight.type === 1 /* Search */ || highlight.type === 2 /* ReadAloud */ || highlight.type === 5 /* LineFocus */ || highlight.type === 3 /* PageBreak */) {
          highlightArea.style.setProperty("pointer-events", "none");
        } else {
          highlightArea.style.setProperty("pointer-events", "all");
          highlightArea.style.setProperty("cursor", "hand");
        }
        highlightArea.style.position = "absolute";
        highlightArea.scale = scale;
        highlightArea.rect = {
          height: clientRect.height,
          left: clientRect.left - xOffset,
          top: clientRect.top - yOffset,
          width: clientRect.width
        };
        if (highlight.pointerInteraction) {
          highlightArea.setAttribute("data-click", "1");
          highlightArea.tabIndex = 0;
        }
        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;
        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;
        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;
        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;
        highlightParent.append(highlightArea);
        let top = parseInt(highlightArea.style.top.replace("px", ""));
        if (top < position || position === 0) {
          position = top;
        }
        size = parseInt(highlightArea.style.height.replace("px", ""));
        if (drawStrikeThrough) {
          const highlightAreaLine = doc.createElement(
            "div"
          );
          highlightAreaLine.setAttribute("class", CLASS_HIGHLIGHT_AREA);
          let color = highlight.color;
          if (_TextHighlighter.isHexColor(color)) {
            color = _TextHighlighter.hexToRgbChannels(color);
          }
          highlightAreaLine.setAttribute(
            "style",
            `background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY}) !important;`
          );
          if (highlight.type === 1 /* Search */ || highlight.type === 2 /* ReadAloud */ || highlight.type === 5 /* LineFocus */ || highlight.type === 3 /* PageBreak */) {
            highlightAreaLine.style.setProperty("pointer-events", "none");
          } else {
            highlightAreaLine.style.setProperty("pointer-events", "all");
            highlightAreaLine.style.setProperty("cursor", "hand");
          }
          highlightAreaLine.style.position = "absolute";
          highlightAreaLine.scale = scale;
          highlightAreaLine.rect = {
            height: clientRect.height,
            left: clientRect.left - xOffset,
            top: clientRect.top - yOffset,
            width: clientRect.width
          };
          highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;
          highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;
          highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;
          highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + highlightAreaLine.rect.height / 2 - strikeThroughLineThickness / 2) * scale}px`;
          highlightParent.append(highlightAreaLine);
        }
        let viewportWidth = (_h = this.navigator.iframes[0].contentWindow) == null ? void 0 : _h.innerWidth;
        let columnCount = parseInt(
          getComputedStyle(doc.documentElement).getPropertyValue("column-count")
        );
        let columnWidth = parseInt(
          getComputedStyle(doc.documentElement).getPropertyValue("column-width")
        );
        let padding = parseInt(
          getComputedStyle(doc.body).getPropertyValue("padding-left")
        );
        let pageWidth = viewportWidth / (columnCount || 1);
        if (pageWidth < columnWidth) {
          pageWidth = viewportWidth;
        }
        if (!paginated) {
          pageWidth = parseInt(
            getComputedStyle(doc.body).width.replace("px", "")
          );
        }
        let ratio = this.navigator.settings.fontSize / 100;
        let addRight = 20 * ratio;
        if (ratio <= 1) {
          addRight = -60;
        }
        let addLeft = 0 * ratio;
        if (ratio <= 1) {
          addLeft = -60;
        }
        left = Math.floor(clientRect.left / pageWidth) * pageWidth + pageWidth - (size < 40 ? 40 : size) + addLeft;
        right = Math.floor(clientRect.left / pageWidth) * pageWidth + (size < 40 ? 40 : size) - addRight;
        let pagemargin = parseInt(
          this.navigator.iframes[0].contentDocument.documentElement.style.getPropertyValue(
            "--USER__pageMargins"
          )
        );
        if (pagemargin >= 2) {
          right = right + padding / columnCount;
          left = left - padding / columnCount;
        }
        if (!paginated) {
          left = parseInt(
            getComputedStyle(
              (_i = this.navigator.iframes[0].contentDocument) == null ? void 0 : _i.body
            ).width.replace("px", "")
          );
          right = parseInt(
            getComputedStyle(
              (_j = this.navigator.iframes[0].contentDocument) == null ? void 0 : _j.body
            ).width.replace("px", "")
          ) - pageWidth;
          if (pagemargin >= 2) {
            right = right + padding / 2;
            left = left - padding / 2;
          }
        }
      }
      const rangeBoundingClientRect = range.getBoundingClientRect();
      const highlightBounding = doc.createElement(
        "div"
      );
      highlightBounding.setAttribute("class", CLASS_HIGHLIGHT_BOUNDING_AREA);
      highlightBounding.style.setProperty("pointer-events", "none");
      highlightBounding.style.position = "absolute";
      highlightBounding.scale = scale;
      highlightBounding.rect = {
        height: rangeBoundingClientRect.height,
        left: rangeBoundingClientRect.left - xOffset,
        top: rangeBoundingClientRect.top - yOffset,
        width: rangeBoundingClientRect.width
      };
      highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;
      highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;
      highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;
      highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;
      highlightParent.append(highlightBounding);
      const highlightAreaIcon = doc.createElement("div");
      highlightAreaIcon.setAttribute("class", CLASS_HIGHLIGHT_ICON);
      if (((_k = highlight.icon) == null ? void 0 : _k.position) === "left") {
        highlightAreaIcon.setAttribute(
          "style",
          `position: absolute;top:${position}px;left:${right + ((_m = (_l = this.navigator.iframes[0].contentDocument) == null ? void 0 : _l.scrollingElement) == null ? void 0 : _m.scrollLeft)}px;height:${size}px; width:${size}px;`
        );
      } else if (((_n = highlight.icon) == null ? void 0 : _n.position) === "inline") {
        highlightAreaIcon.setAttribute(
          "style",
          `position: absolute;top:${position - size / 2}px;left:${parseInt(highlightBounding.style.left.replace("px", "")) + parseInt(highlightBounding.style.width.replace("px", "")) - size / 2}px;height:${size}px; width:${size}px;`
        );
      } else if (((_o = highlight.icon) == null ? void 0 : _o.position) === "center") {
        let third = size / 3;
        let half = third * 2;
        highlightAreaIcon.setAttribute(
          "style",
          `position: absolute;top:${position}px;left:${parseInt(highlightBounding.style.left.replace("px", "")) + parseInt(highlightBounding.style.width.replace("px", "")) - half}px;height:${size}px; width:${size}px;`
        );
      } else {
        if (highlight.note && highlight.marker !== 3 /* Custom */ && highlight.marker !== 2 /* Bookmark */ && highlight.marker !== 4 /* Comment */ && highlight.marker !== 0 /* Highlight */ && highlight.marker !== 1 /* Underline */) {
          highlightAreaIcon.setAttribute(
            "style",
            `position: absolute;top:${position - size / 2}px;left:${parseInt(highlightBounding.style.left.replace("px", "")) + parseInt(highlightBounding.style.width.replace("px", "")) - size / 2}px;height:${size}px; width:${size}px;`
          );
        } else if (highlight.note && highlight.marker === 4 /* Comment */ || highlight.marker === 0 /* Highlight */ || highlight.marker === 1 /* Underline */) {
          highlightAreaIcon.setAttribute(
            "style",
            `position: absolute;top:${position}px;left:${left + ((_q = (_p = this.navigator.iframes[0].contentDocument) == null ? void 0 : _p.scrollingElement) == null ? void 0 : _q.scrollLeft)}px;height:${size}px; width:${size}px;`
          );
        } else {
          highlightAreaIcon.setAttribute(
            "style",
            `position: absolute;top:${position}px;left:${left + ((_s = (_r = this.navigator.iframes[0].contentDocument) == null ? void 0 : _r.scrollingElement) == null ? void 0 : _s.scrollLeft)}px;height:${size}px; width:${size}px;`
          );
        }
      }
      if (highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
        if ((_t = highlight.icon) == null ? void 0 : _t.class) {
          highlightAreaIcon.classList.add((_u = highlight.icon) == null ? void 0 : _u.class);
          highlightAreaIcon.id = (_v = highlight.icon) == null ? void 0 : _v.id;
        } else if ((_w = highlight.icon) == null ? void 0 : _w.svgPath) {
          highlightAreaIcon.innerHTML = iconTemplateColored(
            `${(_x = highlight.icon) == null ? void 0 : _x.id}`,
            `${(_y = highlight.icon) == null ? void 0 : _y.title}`,
            `${(_z = highlight.icon) == null ? void 0 : _z.svgPath}`,
            `icon open`,
            size,
            `${(_A = highlight.icon) == null ? void 0 : _A.color} !important`
          );
        } else if ((_B = highlight.icon) == null ? void 0 : _B.title) {
          highlightAreaIcon.innerHTML = (_C = highlight.icon) == null ? void 0 : _C.title;
        }
      } else {
        if (highlight.note) {
          let color = highlight.color;
          if (_TextHighlighter.isHexColor(color)) {
            color = _TextHighlighter.hexToRgbChannels(color);
          }
          if (highlight.marker === 4 /* Comment */ || highlight.marker === 0 /* Highlight */ || highlight.marker === 1 /* Underline */) {
            highlightAreaIcon.innerHTML = iconTemplateColored(
              ``,
              ``,
              `<path d="M24 24H0V0h24v24z" fill="none"/><circle cx="12" cy="12" r="14"/>`,
              `icon open`,
              size / 2,
              `rgba(${color.red}, ${color.green}, ${color.blue}, 1) !important`
            );
          } else {
            highlightAreaIcon.innerHTML = iconTemplateColored(
              `note-icon`,
              `Note`,
              `<rect fill="none" height="24" width="24"/><path d="M19,5v9l-5,0l0,5H5V5H19 M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h10l6-6V5C21,3.9,20.1,3,19,3z M12,14H7v-2h5V14z M17,10H7V8h10V10z"/>`,
              `icon open`,
              size,
              `rgba(${color.red}, ${color.green}, ${color.blue}, 1) !important`
            );
          }
        }
      }
      if (highlight.type === 1 /* Search */ || highlight.type === 2 /* ReadAloud */ || highlight.type === 5 /* LineFocus */ || highlight.type === 3 /* PageBreak */) {
        highlightAreaIcon.style.setProperty("pointer-events", "none");
      } else {
        highlightAreaIcon.style.setProperty("pointer-events", "all");
        highlightAreaIcon.style.setProperty("cursor", "hand");
      }
      let self2 = this;
      if (highlight.type !== 3 /* PageBreak */ && highlight.type !== 4 /* Definition */) {
        highlightAreaIcon.addEventListener("click", async function(ev) {
          var _a2, _b2, _c2, _d2, _e2;
          let anno;
          if (self2.navigator.rights.enableAnnotations) {
            anno = await ((_a2 = self2.navigator.annotationModule) == null ? void 0 : _a2.getAnnotationByID(
              highlight.id
            ));
            (_c2 = (_b2 = self2.navigator.annotationModule) == null ? void 0 : _b2.api) == null ? void 0 : _c2.selectedAnnotation(anno).then(async () => {
            });
          } else if (self2.navigator.rights.enableBookmarks) {
            anno = await ((_d2 = self2.navigator.bookmarkModule) == null ? void 0 : _d2.getAnnotationByID(
              highlight.id
            ));
          }
          import_loglevel5.default.log("selected highlight " + anno.id);
          self2.lastSelectedHighlight = anno.id;
          let toolbox = document.getElementById("highlight-toolbox");
          if (toolbox) {
            toolbox.style.top = ev.clientY + (((_e2 = self2.navigator.attributes) == null ? void 0 : _e2.navHeight) ?? 0) + "px";
            toolbox.style.left = ev.clientX + "px";
            if (getComputedStyle(toolbox).display === "none") {
              let deleteH = function() {
                var _a3, _b3;
                if (self2.navigator.rights.enableAnnotations) {
                  (_a3 = self2.navigator.annotationModule) == null ? void 0 : _a3.deleteSelectedHighlight(anno).then(async () => {
                    import_loglevel5.default.log("delete highlight " + anno.id);
                    toolbox.style.display = "none";
                    self2.selectionMenuClosed();
                  });
                } else if (self2.navigator.rights.enableBookmarks) {
                  (_b3 = self2.navigator.bookmarkModule) == null ? void 0 : _b3.deleteSelectedHighlight(anno).then(async () => {
                    import_loglevel5.default.log("delete highlight " + anno.id);
                    toolbox.style.display = "none";
                    self2.selectionMenuClosed();
                  });
                }
              };
              toolbox.style.display = "block";
              self2.toolboxMode("edit");
              let colorIcon = document.getElementById("colorIcon");
              let highlightIcon = document.getElementById("highlightIcon");
              if (colorIcon) {
                colorIcon.style.display = "none";
              }
              if (highlightIcon) {
                highlightIcon.style.display = "none";
              }
              let commentIcon = document.getElementById("commentIcon");
              let cloneCommentIcon = document.getElementById("cloneCommentIcon");
              if (cloneCommentIcon) {
                let parent = cloneCommentIcon.parentElement;
                if (parent) {
                  parent.removeChild(cloneCommentIcon);
                }
              }
              if (commentIcon) {
                commentIcon.style.display = "none";
              }
              let deleteIcon = document.getElementById("deleteIcon");
              let cloneDeleteIcon = document.getElementById("cloneDeleteIcon");
              if (cloneDeleteIcon) {
                let parent = cloneDeleteIcon.parentElement;
                if (parent) {
                  parent.removeChild(cloneDeleteIcon);
                }
              }
              if (deleteIcon) {
                deleteIcon.style.display = "none";
                let clone2 = deleteIcon.cloneNode(true);
                let parent = deleteIcon.parentElement;
                clone2.style.display = "unset";
                clone2.id = "cloneDeleteIcon";
                clone2.addEventListener("click", deleteH, false);
                if (parent) {
                  parent.append(clone2);
                }
              }
            } else {
              toolbox.style.display = "none";
              self2.selectionMenuClosed();
              void toolbox.offsetWidth;
              toolbox.style.display = "block";
            }
          }
          const foundElementHighlightAreas = Array.from(
            highlightParent.querySelectorAll(`.${CLASS_HIGHLIGHT_AREA}`)
          );
          self2.setHighlightAreaStyle(
            doc,
            foundElementHighlightAreas,
            highlight
          );
        });
      }
      if (highlight.note) {
        let tooltip = document.createElement("span");
        tooltip.innerHTML = highlight.note;
        tooltip.className = "icon-tooltip";
        if (highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
          if ((_D = highlight.popup) == null ? void 0 : _D.background) {
            tooltip.style.setProperty("background", highlight.popup.background);
          }
          if ((_E = highlight.popup) == null ? void 0 : _E.textColor) {
            tooltip.style.setProperty("color", highlight.popup.textColor);
          }
          if ((_F = highlight.popup) == null ? void 0 : _F.class) {
            tooltip.classList.add(highlight.popup.class);
          }
        } else {
          tooltip.style.setProperty("background", "lightyellow");
          tooltip.style.setProperty("color", "black");
        }
      }
      if (highlight.note || highlight.marker === 3 /* Custom */ || highlight.marker === 2 /* Bookmark */) {
        highlightParent.append(highlightAreaIcon);
      }
      switch (highlight.type) {
        case 1 /* Search */:
          doc.getElementById("R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */).append(highlightParent);
          break;
        case 2 /* ReadAloud */:
          doc.getElementById("R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */).append(highlightParent);
          break;
        case 3 /* PageBreak */:
          doc.getElementById("R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */).append(highlightParent);
          break;
        case 4 /* Definition */:
          doc.getElementById("R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */).append(highlightParent);
          break;
        default:
          doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */).append(highlightParent);
          break;
      }
      return highlightParent;
    }
    addSelectionMenuItem(citationIconMenu) {
      var _a, _b;
      if (((_a = this.properties) == null ? void 0 : _a.selectionMenuItems) ?? []) {
        (((_b = this.properties) == null ? void 0 : _b.selectionMenuItems) ?? []).push(citationIconMenu);
      }
    }
  };

  // src/modules/AnnotationModule.ts
  var import_uuid = __toESM(require_uuid());

  // src/modules/highlight/common/selection.ts
  init_polyfills();
  var import_loglevel6 = __toESM(require_loglevel());
  var _getCssSelectorOptions = {
    className: (_str) => {
      return true;
    },
    idName: (_str) => {
      return true;
    },
    tagName: (_str) => {
      return true;
    }
  };

  // src/modules/AnnotationModule.ts
  var lodash2 = __toESM(require_lodash());
  var import_loglevel8 = __toESM(require_loglevel());

  // src/modules/consumption/ConsumptionModule.ts
  init_polyfills();
  var import_loglevel7 = __toESM(require_loglevel());
  var ConsumptionModule = class {
    constructor(publication, properties, api) {
      this.currSeconds = 0;
      this.publication = publication;
      this.properties = properties;
      this.api = api;
    }
    static async create(config2) {
      const consumption = new this(
        config2.publication,
        config2,
        config2.api
      );
      await consumption.start();
      return consumption;
    }
    async start() {
      this.startResearchSession();
    }
    async stop() {
      import_loglevel7.default.log("Consumption module stop");
      this.endResearchSession();
    }
    initialize() {
      let win = this.navigator.iframes[0].contentWindow;
      if (win) {
        const self2 = this;
        win.onload = function() {
          self2.resetTimer();
        };
        win.onmousemove = function() {
          self2.resetTimer();
        };
        win.onmousedown = function() {
          self2.resetTimer();
        };
        win.ontouchstart = function() {
          self2.resetTimer();
        };
        win.onclick = function() {
          self2.resetTimer();
        };
        win.onkeypress = function() {
          self2.resetTimer();
        };
      }
    }
    trackAction(locator, action) {
      var _a;
      (_a = this.api) == null ? void 0 : _a.actionTracked(locator, action);
    }
    startReadingSession(locator) {
      if (this.firstReadingLocator && this.lastReadingLocator) {
        let progress = this.lastReadingLocator.locations.totalProgression - this.firstReadingLocator.locations.totalProgression;
        let timeElapsed = ((/* @__PURE__ */ new Date()).getTime() - this.startReadingTimer.getTime()) / 1e3;
        this.readingSessions.push({
          lastLocator: this.lastReadingLocator,
          firstLocator: this.firstReadingLocator,
          time: timeElapsed,
          progress: Math.round(progress * 100)
        });
      }
      this.firstReadingLocator = locator;
      this.startReadingTimer = /* @__PURE__ */ new Date();
    }
    continueReadingSession(locator) {
      if (this.properties.enableTrackingSession) {
        if (this.startResearchTimer === void 0) {
          this.startResearchSession();
        }
        if (this.lastReadingLocator === void 0 || this.lastReadingLocator.locations.totalProgression < locator.locations.totalProgression) {
          this.lastReadingLocator = locator;
        }
        if (this.firstReadingLocator === void 0) {
          this.firstReadingLocator = locator;
        }
        if (this.startReadingTimer === void 0) {
          this.startReadingTimer = /* @__PURE__ */ new Date();
        }
      }
    }
    startResearchSession() {
      var _a;
      if (this.properties.enableTrackingSession) {
        this.startResearchTimer = /* @__PURE__ */ new Date();
        this.readingSessions = [];
        clearInterval(this.readingSessionsInterval);
        let timeElapsed = ((/* @__PURE__ */ new Date()).getTime() - this.startResearchTimer.getTime()) / 1e3;
        this.researchSessionId = (_a = this.api) == null ? void 0 : _a.startResearchSession(
          this.readingSessions,
          Math.round(timeElapsed)
        );
        const self2 = this;
        this.readingSessionsInterval = setInterval(function() {
          self2.updateResearchSession();
        }, this.properties.updateSessionInterval * 1e3);
      }
    }
    updateResearchSession() {
      var _a;
      if (this.properties.enableTrackingSession) {
        let timeElapsed = ((/* @__PURE__ */ new Date()).getTime() - this.startResearchTimer.getTime()) / 1e3;
        (_a = this.api) == null ? void 0 : _a.updateResearchSession(
          this.researchSessionId,
          this.readingSessions,
          Math.round(timeElapsed)
        );
      }
    }
    endResearchSession() {
      var _a, _b;
      if (this.properties.enableTrackingSession) {
        if (this.firstReadingLocator && this.lastReadingLocator) {
          let progress = this.lastReadingLocator.locations.totalProgression - this.firstReadingLocator.locations.totalProgression;
          let timeElapsed2 = ((/* @__PURE__ */ new Date()).getTime() - this.startReadingTimer.getTime()) / 1e3;
          this.readingSessions.push({
            lastLocator: this.lastReadingLocator,
            firstLocator: this.firstReadingLocator,
            time: timeElapsed2,
            progress: Math.round(progress * 100)
          });
        }
        let timeElapsed = ((/* @__PURE__ */ new Date()).getTime() - this.startResearchTimer.getTime()) / 1e3;
        (_a = this.api) == null ? void 0 : _a.updateResearchSession(
          this.researchSessionId,
          this.readingSessions,
          Math.round(timeElapsed)
        );
        (_b = this.api) == null ? void 0 : _b.endResearchSession(
          this.researchSessionId,
          this.readingSessions,
          Math.round(timeElapsed)
        );
        this.researchSessionId = void 0;
        this.readingSessions = [];
        this.startResearchTimer = void 0;
        clearInterval(this.readingSessionsInterval);
        clearInterval(this.timer);
      }
    }
    startIdleTimer() {
      var _a;
      this.currSeconds++;
      if (this.currSeconds === this.properties.idleTimeout) {
        (_a = this.api) == null ? void 0 : _a.idleSince(this.currSeconds);
        if (this.startResearchTimer !== void 0) {
          this.updateResearchSession();
        } else {
          this.startResearchSession();
        }
      }
      if (this.currSeconds === this.properties.idleTimeout + this.properties.responseTimeout) {
        this.endResearchSession();
      }
    }
    resetTimer() {
      clearInterval(this.timer);
      this.currSeconds = 0;
      const self2 = this;
      this.timer = setInterval(function() {
        self2.startIdleTimer();
      }, 1e3);
    }
  };

  // src/modules/AnnotationModule.ts
  var AnnotationModule = class _AnnotationModule {
    constructor(annotator, rights, publication, initialAnnotations, properties, highlighter, api, headerMenu) {
      this.hide = findElement(
        document,
        "#menu-button-hide"
      );
      this.show = findElement(
        document,
        "#menu-button-show"
      );
      this.annotator = annotator;
      this.rights = rights;
      this.publication = publication;
      this.headerMenu = headerMenu;
      this.initialAnnotations = initialAnnotations;
      this.highlighter = highlighter;
      this.properties = properties;
      this.api = api;
    }
    static async create(config2) {
      const annotations = new this(
        config2.annotator,
        config2.rights || { enableAnnotations: false, enableTTS: false },
        config2.publication,
        config2.initialAnnotations || null,
        config2,
        config2.highlighter,
        config2.api,
        config2.headerMenu
      );
      await annotations.start();
      return annotations;
    }
    async stop() {
      import_loglevel8.default.log("Annotation module stop");
    }
    async start() {
      var _a;
      if (this.headerMenu)
        this.highlightsView = findElement(
          this.headerMenu,
          "#container-view-highlights"
        );
      if (this.initialAnnotations) {
        var highlights = this.initialAnnotations["highlights"] || null;
        if (highlights) {
          (_a = this.annotator) == null ? void 0 : _a.initAnnotations(highlights);
        }
      }
      setTimeout(() => {
        var _a2;
        ((_a2 = this.properties) == null ? void 0 : _a2.hideLayer) ? this.navigator.hideLayer("highlights") : this.navigator.showLayer("highlights");
      }, 10);
    }
    hideAnnotationLayer() {
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        const container = findElement(
          doc,
          "#R2_ID_HIGHLIGHTS_CONTAINER"
        );
        if (container) {
          container.style.display = "none";
        }
      }
      if (this.show && this.hide) {
        this.show.style.display = "block";
        this.hide.style.display = "none";
      }
    }
    showAnnotationLayer() {
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        const container = findElement(
          doc,
          "#R2_ID_HIGHLIGHTS_CONTAINER"
        );
        if (container) {
          container.style.display = "block";
        }
      }
      if (this.show && this.hide) {
        this.show.style.display = "none";
        this.hide.style.display = "block";
      }
    }
    async handleResize() {
      setTimeout(async () => {
        await this.drawHighlights();
        await this.showHighlights();
      }, 200);
    }
    initialize() {
      return new Promise(async (resolve) => {
        await document.fonts.ready;
        if (this.rights.enableAnnotations) {
          setTimeout(() => {
            var _a;
            this.drawHighlights();
            this.showHighlights();
            addEventListenerOptional(
              (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.body,
              "click",
              this.click.bind(this)
            );
          }, 300);
        }
        resolve(null);
      });
    }
    click(_event) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (this.activeAnnotationMarkerId) {
        let menuItems = (_c = (_b = (_a = this.highlighter) == null ? void 0 : _a.properties) == null ? void 0 : _b.selectionMenuItems) == null ? void 0 : _c.filter(
          (menuItem) => menuItem.id === this.activeAnnotationMarkerId
        );
        if (menuItems && (menuItems == null ? void 0 : menuItems.length) > 0) {
          let menuItem = lodash2.cloneDeep(menuItems[0]);
          menuItem.marker = 3 /* Custom */;
          if (this.activeAnnotationMarkerPosition) {
            menuItem.icon.position = this.activeAnnotationMarkerPosition;
          }
          menuItem.highlight.style.default = null;
          menuItem.highlight.style.hover = null;
          let doc = this.navigator.iframes[0].contentDocument;
          if (doc) {
            let getCssSelector = function(element) {
              try {
                let doc2 = self2.navigator.iframes[0].contentDocument;
                if (doc2) {
                  return uniqueCssSelector(element, doc2, _getCssSelectorOptions);
                } else {
                  return "";
                }
              } catch (err) {
                import_loglevel8.default.log("uniqueCssSelector:");
                import_loglevel8.default.error(err);
                return "";
              }
            };
            const selection = (_d = this.highlighter) == null ? void 0 : _d.dom(doc.body).getSelection();
            let range = selection.getRangeAt(0);
            let node = selection.anchorNode;
            range.setStart(node, range.startOffset);
            range.setEnd(node, range.endOffset + 1);
            selection.removeAllRanges();
            selection.addRange(range);
            let self2 = this;
            const rangeInfo = convertRange(range, getCssSelector);
            selection.removeAllRanges();
            if (rangeInfo) {
              let selectionInfo = {
                rangeInfo
              };
              let book = (_f = this.navigator.highlighter) == null ? void 0 : _f.createHighlight(
                (_e = this.navigator.highlighter) == null ? void 0 : _e.dom(doc.body).getWindow(),
                selectionInfo,
                menuItem.highlight.color,
                true,
                2 /* Bookmark */,
                menuItem.icon,
                menuItem.popup,
                menuItem.highlight.style
              );
              if (book) {
                this.saveAnnotation(book[0]).then((anno) => {
                  import_loglevel8.default.log("saved bookmark " + anno.id);
                });
              }
            }
            (_g = doc.getSelection()) == null ? void 0 : _g.removeAllRanges();
          }
        }
      }
    }
    async scrollToHighlight(id2) {
      var _a;
      import_loglevel8.default.log("still need to scroll to " + id2);
      var element = await ((_a = this.annotator) == null ? void 0 : _a.getAnnotationElement(
        id2,
        this.navigator.iframes[0].contentWindow
      ));
      element.scrollIntoView({
        block: "center",
        behavior: "smooth"
      });
    }
    async updateLocalHighlight(annotation) {
      if (this.annotator) {
        let deleted = await this.annotator.deleteAnnotation(annotation.id);
        let added = await this.addAnnotation(annotation);
        import_loglevel8.default.log("Highlight deleted " + JSON.stringify(deleted));
        import_loglevel8.default.log("Highlight added " + JSON.stringify(added));
        await this.showHighlights();
        await this.drawHighlights();
        return added;
      } else {
        return new Promise((resolve) => resolve(null));
      }
    }
    async deleteLocalHighlight(id2) {
      if (this.annotator) {
        var deleted = await this.annotator.deleteAnnotation(id2);
        import_loglevel8.default.log("Highlight deleted " + JSON.stringify(deleted));
        await this.showHighlights();
        await this.drawHighlights();
        return deleted;
      } else {
        return new Promise((resolve) => resolve(null));
      }
    }
    async deleteAnnotation(highlight) {
      await this.deleteLocalHighlight(highlight.id);
    }
    async addAnnotation(highlight) {
      var _a;
      await ((_a = this.annotator) == null ? void 0 : _a.saveAnnotation(highlight));
      await this.showHighlights();
      await this.drawHighlights();
    }
    async deleteHighlight(highlight) {
      var _a, _b;
      if ((_a = this.api) == null ? void 0 : _a.deleteAnnotation) {
        (_b = this.api) == null ? void 0 : _b.deleteAnnotation(highlight).then(async () => {
          this.deleteLocalHighlight(highlight.id);
        });
      } else {
        this.deleteLocalHighlight(highlight.id);
      }
    }
    async deleteSelectedHighlight(highlight) {
      var _a;
      if ((_a = this.api) == null ? void 0 : _a.deleteAnnotation) {
        this.api.deleteAnnotation(highlight).then(async () => {
          this.deleteLocalHighlight(highlight.id);
        });
      } else {
        this.deleteLocalHighlight(highlight.id);
      }
    }
    async updateAnnotation(highlight) {
      var _a;
      if ((_a = this.api) == null ? void 0 : _a.updateAnnotation) {
        this.api.updateAnnotation(highlight).then(async () => {
          this.updateLocalHighlight(highlight);
        });
      } else {
        this.updateLocalHighlight(highlight);
      }
    }
    // @ts-ignore
    async saveAnnotation(highlight) {
      var _a, _b, _c;
      if (this.annotator) {
        var tocItem = this.publication.getTOCItem(
          this.navigator.currentChapterLink.href
        );
        if (this.navigator.currentTocUrl) {
          tocItem = this.publication.getTOCItem(this.navigator.currentTocUrl);
        }
        if (tocItem === void 0) {
          tocItem = this.publication.getTOCItemAbsolute(
            this.navigator.currentChapterLink.href
          );
        }
        const bookmarkPosition = (_a = this.navigator.view) == null ? void 0 : _a.getCurrentPosition();
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          const body = findRequiredIframeElement(
            doc,
            "body"
          );
          const progression = highlight.position ? highlight.position / body.scrollHeight : bookmarkPosition;
          const id2 = (0, import_uuid.v4)();
          let annotation;
          if (tocItem) {
            let href = tocItem.Href;
            if (href.indexOf("#") > 0) {
              href = href.slice(0, href.indexOf("#"));
            }
            if (this.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
              const positions = this.publication.positionsByHref(
                this.publication.getRelativeHref(
                  this.navigator.currentChapterLink.href
                )
              );
              const positionIndex = Math.ceil(
                (progression ?? 0) * (positions.length - 1)
              );
              const locator = positions[positionIndex];
              annotation = {
                ...locator,
                id: id2,
                href,
                created: /* @__PURE__ */ new Date(),
                title: this.navigator.currentChapterLink.title,
                highlight,
                text: {
                  highlight: highlight.selectionInfo.cleanText
                }
              };
            } else {
              annotation = {
                id: id2,
                href,
                locations: {
                  progression
                },
                created: /* @__PURE__ */ new Date(),
                type: this.navigator.currentChapterLink.type,
                title: this.navigator.currentChapterLink.title,
                highlight,
                text: {
                  highlight: highlight.selectionInfo.cleanText
                }
              };
            }
          }
          if (annotation) {
            (_b = this.navigator.consumptionModule) == null ? void 0 : _b.trackAction(
              annotation,
              "HighlightCreated" /* HighlightCreated */
            );
            if ((_c = this.api) == null ? void 0 : _c.addAnnotation) {
              try {
                let result = await this.api.addAnnotation(annotation);
                const saved = await this.annotator.saveAnnotation(result);
                await this.showHighlights();
                await this.drawHighlights();
                return new Promise((resolve) => resolve(saved));
              } catch (error) {
                await this.showHighlights();
                await this.drawHighlights();
              }
            } else {
              const saved = await this.annotator.saveAnnotation(annotation);
              await this.showHighlights();
              await this.drawHighlights();
              return new Promise((resolve) => resolve(saved));
            }
          }
        }
      }
      return new Promise((resolve) => resolve(null));
    }
    getAnnotations() {
      let highlights = [];
      if (this.annotator) {
        highlights = this.annotator.getAnnotations();
      }
      return highlights;
    }
    showHighlights() {
      let highlights = [];
      if (this.annotator) {
        highlights = this.annotator.getAnnotations();
        if (highlights) {
          highlights = highlights.filter(
            (rangeRepresentation) => rangeRepresentation.highlight.marker !== 2 /* Bookmark */
          );
          highlights.forEach((rangeRepresentation) => {
            _highlights.push(rangeRepresentation.highlight);
          });
        }
      }
      if (this.highlightsView)
        this.createTree(
          1 /* Annotation */,
          highlights,
          this.highlightsView
        );
    }
    async drawHighlights() {
      var _a, _b, _c, _d;
      if (this.rights.enableAnnotations && this.highlighter) {
        if (this.api) {
          let highlights = [];
          if (this.annotator) {
            highlights = this.annotator.getAnnotationsByChapter(
              this.navigator.currentLocator().href
            );
          }
          if (this.highlighter && highlights && ((_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.readyState) === "complete") {
            await this.highlighter.destroyHighlights(0 /* Annotation */);
            for (const rangeRepresentation of highlights) {
              _highlights.push(rangeRepresentation.highlight);
              const annotation = rangeRepresentation;
              let currentLocation = this.navigator.currentChapterLink.href;
              var tocItem = this.publication.getTOCItem(currentLocation);
              if (this.navigator.currentTocUrl !== void 0) {
                tocItem = this.publication.getTOCItem(
                  this.navigator.currentTocUrl
                );
              }
              if (tocItem === null) {
                tocItem = this.publication.getTOCItemAbsolute(
                  this.navigator.currentChapterLink.href
                );
              }
              if (tocItem) {
                let href = tocItem.Href;
                if (href.indexOf("#") > 0) {
                  href = href.slice(0, href.indexOf("#"));
                }
                if (annotation.href === href) {
                  await this.highlighter.createHighlightDom(
                    this.navigator.iframes[0].contentWindow,
                    rangeRepresentation.highlight
                  );
                  setTimeout(async () => {
                    var _a2, _b2;
                    if (((_a2 = annotation.highlight) == null ? void 0 : _a2.marker) === 1 /* Underline */) {
                      const position = await ((_b2 = this.annotator) == null ? void 0 : _b2.getAnnotationPosition(
                        rangeRepresentation.id,
                        this.navigator.iframes[0].contentWindow
                      ));
                      const commentTemplate = `<div class="comment" style="top: ` + position + `px;width:20px"></div>`;
                      let comment = document.createElement("div");
                      comment.innerHTML = commentTemplate;
                      let div = comment.childNodes[0];
                      let icon = document.createElement("i");
                      icon.innerHTML = "sticky_note_2";
                      icon.className = "material-icons";
                      icon.style.color = annotation.highlight.color;
                      div.appendChild(icon);
                      addEventListenerOptional(
                        comment,
                        "click",
                        (event) => {
                          event.preventDefault();
                          event.stopPropagation();
                          this.scrollToHighlight(annotation.id);
                        }
                      );
                    }
                  }, 100);
                }
              }
            }
          }
        } else {
          let highlights = [];
          if (this.annotator) {
            highlights = this.annotator.getAnnotationsByChapter(
              this.navigator.currentLocator().href
            );
          }
          if (this.highlighter && highlights && ((_b = this.navigator.iframes[0].contentDocument) == null ? void 0 : _b.readyState) === "complete") {
            await this.highlighter.destroyHighlights(0 /* Annotation */);
            for (const rangeRepresentation of highlights) {
              _highlights.push(rangeRepresentation.highlight);
              const annotation = rangeRepresentation;
              let currentLocation = this.navigator.currentChapterLink.href;
              let tocItem2 = this.publication.getTOCItem(currentLocation);
              if (this.navigator.currentTocUrl) {
                tocItem2 = this.publication.getTOCItem(
                  this.navigator.currentTocUrl
                );
              }
              if (tocItem2 === null) {
                tocItem2 = this.publication.getTOCItemAbsolute(
                  this.navigator.currentChapterLink.href
                );
              }
              if (tocItem2) {
                let href = tocItem2.Href;
                if (href.indexOf("#") > 0) {
                  href = href.slice(0, href.indexOf("#"));
                }
                if (annotation.href === href) {
                  await this.highlighter.createHighlightDom(
                    this.navigator.iframes[0].contentWindow,
                    rangeRepresentation.highlight
                  );
                  setTimeout(async () => {
                    var _a2, _b2, _c2;
                    if (((_a2 = annotation.highlight) == null ? void 0 : _a2.marker) === 1 /* Underline */) {
                      const position = await ((_b2 = this.annotator) == null ? void 0 : _b2.getAnnotationPosition(
                        rangeRepresentation.id,
                        this.navigator.iframes[0].contentWindow
                      ));
                      const commentTemplate = `<div class="comment" style="top: ` + position + `px;background: ` + ((_c2 = annotation.highlight) == null ? void 0 : _c2.color) + `;width:20px"></div>`;
                      let comment = document.createElement("div");
                      comment.innerHTML = commentTemplate;
                      comment.childNodes[0].innerHTML = icons.note;
                      addEventListenerOptional(
                        comment,
                        "click",
                        (event) => {
                          event.preventDefault();
                          event.stopPropagation();
                          this.scrollToHighlight(annotation.id);
                        }
                      );
                    }
                  }, 100);
                }
              }
            }
          }
        }
        if ((_c = this.properties) == null ? void 0 : _c.initialAnnotationColor) {
          this.highlighter.setColor((_d = this.properties) == null ? void 0 : _d.initialAnnotationColor);
        }
        this.repositionGutters();
      }
    }
    repositionGutters() {
      var _a, _b, _c, _d, _e, _f;
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        this.commentGutter = doc.getElementById(
          "R2_ID_GUTTER_RIGHT_CONTAINER" /* R2_ID_GUTTER_RIGHT_CONTAINER */
        );
        if (((_a = this.navigator.view) == null ? void 0 : _a.isScrollMode()) && ((_b = this.properties) == null ? void 0 : _b.enableComments)) {
          (_c = this.commentGutter) == null ? void 0 : _c.style.removeProperty("display");
        } else {
          (_d = this.commentGutter) == null ? void 0 : _d.style.setProperty("display", "none");
        }
        if (this.commentGutter && ((_e = this.navigator.view) == null ? void 0 : _e.isScrollMode()) && ((_f = this.properties) == null ? void 0 : _f.enableComments)) {
          this.commentGutter.innerHTML = "";
          let highlights = [];
          if (this.annotator) {
            highlights = this.annotator.getAnnotationsByChapter(
              this.navigator.currentLocator().href
            );
            if (highlights) {
              highlights = highlights.filter(
                (rangeRepresentation) => {
                  var _a2, _b2;
                  return ((_b2 = (_a2 = rangeRepresentation.highlight) == null ? void 0 : _a2.note) == null ? void 0 : _b2.length) > 0;
                }
              );
              highlights = this.syncPosition(highlights);
              highlights = this.reposition(highlights);
              highlights.forEach((rangeRepresentation) => {
                var _a2, _b2;
                let icon = document.createElement("i");
                icon.innerHTML = "sticky_note_2";
                icon.className = "material-icons";
                icon.style.color = rangeRepresentation.highlight.color;
                let container = doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER");
                let highlightArea;
                let highlightIcon;
                if (container) {
                  highlightArea = container.querySelector(
                    `#${rangeRepresentation.highlight.id}`
                  );
                }
                let nodeList = highlightArea.getElementsByClassName(CLASS_HIGHLIGHT_AREA);
                highlightIcon = nodeList[0];
                const size = parseInt(
                  highlightIcon.style.height.replace("px", "")
                );
                const position = rangeRepresentation.highlight.position;
                const highlightAreaIcon = doc.createElement("div");
                highlightAreaIcon.setAttribute(
                  "style",
                  `position: absolute;top:${// position - size / 2
                  position}px;display: flex;max-width: 250px !important;height:${size}px;width: 200px;align-items: center;`
                );
                const iconSpan = doc.createElement("div");
                highlightAreaIcon.appendChild(iconSpan);
                let color = rangeRepresentation.highlight.color;
                if (TextHighlighter.isHexColor(color)) {
                  color = TextHighlighter.hexToRgbChannels(color);
                }
                highlightAreaIcon.innerHTML = iconTemplateColored(
                  ``,
                  ``,
                  `<path d="M24 24H0V0h24v24z" fill="none"/><circle cx="12" cy="12" r="8"/>`,
                  `icon open`,
                  10,
                  `rgba(${color.red}, ${color.green}, ${color.blue}, 1) !important`
                );
                const span = doc.createElement("div");
                span.innerHTML = (_a2 = rangeRepresentation.highlight) == null ? void 0 : _a2.note;
                span.setAttribute(
                  "style",
                  `height:${size}px;overflow: hidden;padding-left: 5px;`
                );
                highlightAreaIcon.appendChild(span);
                addEventListenerOptional(
                  highlightAreaIcon,
                  "click",
                  (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.scrollToHighlight(rangeRepresentation.highlight.id);
                  }
                );
                (_b2 = this.commentGutter) == null ? void 0 : _b2.appendChild(highlightAreaIcon);
              });
            }
          }
        }
      }
    }
    createTree(type, annotations, view) {
      if (annotations) {
        const self2 = this;
        const toc = this.publication.readingOrder;
        if (toc.length) {
          const createAnnotationTree = (parentElement, links) => {
            let chapterList = document.createElement("ul");
            chapterList.className = "sidenav-annotations";
            for (const link of links) {
              let chapterHeader = document.createElement("li");
              const linkElement = document.createElement("a");
              const spanElement = document.createElement("span");
              linkElement.tabIndex = -1;
              linkElement.className = "chapter-link";
              if (link.Href) {
                const linkHref = this.publication.getAbsoluteHref(link.Href);
                const tocItemAbs = this.publication.getTOCItemAbsolute(linkHref);
                linkElement.href = linkHref;
                linkElement.innerHTML = (tocItemAbs == null ? void 0 : tocItemAbs.Title) || "";
                chapterHeader.appendChild(linkElement);
              } else {
                spanElement.innerHTML = link.Title || "";
                spanElement.className = "chapter-title";
                chapterHeader.appendChild(spanElement);
              }
              addEventListenerOptional(
                linkElement,
                "click",
                (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  const position = {
                    href: linkElement.href,
                    locations: {
                      progression: 0
                    },
                    type: link.TypeLink,
                    title: linkElement.title
                  };
                  this.navigator.stopReadAloud();
                  this.navigator.navigate(position);
                }
              );
              const bookmarkList = document.createElement("ol");
              annotations.forEach(function(locator) {
                var _a, _b, _c, _d, _e, _f, _g;
                const href = link.Href.indexOf("#") !== -1 ? link.Href.slice(0, link.Href.indexOf("#")) : link.Href;
                if (link.Href && locator.href.endsWith(href)) {
                  let bookmarkItem = document.createElement("li");
                  bookmarkItem.className = "annotation-item";
                  let bookmarkLink = document.createElement("a");
                  bookmarkLink.setAttribute("href", locator.href);
                  if (type === 1 /* Annotation */) {
                    bookmarkLink.className = "highlight-link";
                    let title = document.createElement("span");
                    let marker = document.createElement("span");
                    title.className = "title";
                    marker.innerHTML = locator.highlight.selectionInfo.cleanText;
                    if (((_a = locator.highlight) == null ? void 0 : _a.marker) === 1 /* Underline */) {
                      if (typeof ((_b = locator.highlight) == null ? void 0 : _b.color) === "object") {
                        let color = (_c = locator.highlight) == null ? void 0 : _c.color;
                        if (color) {
                          marker.style.setProperty(
                            "border-bottom",
                            `2px solid ${TextHighlighter.hexToRgbA(color)}`,
                            "important"
                          );
                        }
                      } else {
                        marker.style.setProperty(
                          "border-bottom",
                          `2px solid ${(_d = locator.highlight) == null ? void 0 : _d.color}`,
                          "important"
                        );
                      }
                    } else {
                      if (typeof ((_e = locator.highlight) == null ? void 0 : _e.color) === "object") {
                        let color = (_f = locator.highlight) == null ? void 0 : _f.color;
                        if (color) {
                          marker.style.backgroundColor = TextHighlighter.hexToRgbA(color);
                        }
                      } else {
                        let color = (_g = locator.highlight) == null ? void 0 : _g.color;
                        if (color) {
                          marker.style.backgroundColor = color;
                        }
                      }
                    }
                    title.appendChild(marker);
                    bookmarkLink.appendChild(title);
                    let subtitle = document.createElement("span");
                    let formattedProgression = Math.round((locator.locations.progression ?? 0) * 100) + "% through resource";
                    subtitle.className = "subtitle";
                    subtitle.innerHTML = formattedProgression;
                    bookmarkLink.appendChild(subtitle);
                  }
                  let timestamp = document.createElement("span");
                  timestamp.className = "timestamp";
                  timestamp.innerHTML = _AnnotationModule.readableTimestamp(
                    locator.created
                  );
                  bookmarkLink.appendChild(timestamp);
                  addEventListenerOptional(
                    bookmarkLink,
                    "click",
                    (event) => {
                      event.preventDefault();
                      event.stopPropagation();
                      self2.handleAnnotationLinkClick(event, locator);
                    }
                  );
                  bookmarkItem.appendChild(bookmarkLink);
                  if (self2.navigator.sideNavExpanded) {
                    let bookmarkDeleteLink = document.createElement("button");
                    bookmarkDeleteLink.className = "delete";
                    bookmarkDeleteLink.innerHTML = icons.delete;
                    addEventListenerOptional(
                      bookmarkDeleteLink,
                      "click",
                      (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        self2.handleAnnotationLinkDeleteClick(
                          type,
                          event,
                          locator
                        );
                      }
                    );
                    bookmarkItem.appendChild(bookmarkDeleteLink);
                  }
                  bookmarkList.appendChild(bookmarkItem);
                }
              });
              if (bookmarkList.children.length > 0) {
                chapterList.appendChild(chapterHeader);
                chapterList.appendChild(bookmarkList);
              }
              if (chapterList.children.length > 0) {
                parentElement.appendChild(chapterList);
              }
              if (link.Children && link.Children.length > 0) {
                createAnnotationTree(parentElement, link.Children);
              }
            }
          };
          view.innerHTML = "";
          createAnnotationTree(view, toc);
        }
      }
    }
    handleAnnotationLinkClick(event, locator) {
      if (locator) {
        locator.href = this.publication.getAbsoluteHref(locator.href);
        this.navigator.stopReadAloud();
        this.navigator.navigate(locator);
      } else {
        import_loglevel8.default.log("annotation data missing: ", event);
      }
    }
    handleAnnotationLinkDeleteClick(type, event, locator) {
      import_loglevel8.default.log("annotation data locator: ", locator);
      if (locator) {
        if (type === 1 /* Annotation */) {
          this.deleteHighlight(locator);
        }
      } else {
        import_loglevel8.default.log("annotation data missing: ", event);
      }
    }
    static readableTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toDateString() + " " + date.toLocaleTimeString();
    }
    async getAnnotation(highlight) {
      var _a;
      return (_a = this.annotator) == null ? void 0 : _a.getAnnotation(highlight);
    }
    async getAnnotationByID(id2) {
      var _a;
      return (_a = this.annotator) == null ? void 0 : _a.getAnnotationByID(id2);
    }
    syncPosition(highlights) {
      let doc = this.navigator.iframes[0].contentDocument;
      const positionAnnotations = (newArray, currentElement) => {
        let container = doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER");
        let highlightArea;
        let highlightIcon;
        if (container) {
          highlightArea = container.querySelector(
            `#${currentElement.highlight.id}`
          );
        }
        let nodeList = highlightArea.getElementsByClassName(CLASS_HIGHLIGHT_AREA);
        highlightIcon = nodeList[0];
        const newY = parseInt(highlightIcon.style.top.replace("px", ""));
        const updatedAnnotation = {
          ...currentElement,
          highlight: {
            ...currentElement.highlight,
            position: newY
          }
        };
        return [...newArray, updatedAnnotation];
      };
      return highlights.reduce(positionAnnotations, []);
    }
    reposition(highlights) {
      let doc = this.navigator.iframes[0].contentDocument;
      const positionAnnotations = (newArray, currentElement, currentIndex) => {
        const high = highlights[0];
        let container = doc.getElementById("R2_ID_HIGHLIGHTS_CONTAINER");
        let highlightArea;
        let highlightIcon;
        if (container) {
          highlightArea = container.querySelector(`#${high.highlight.id}`);
        }
        let nodeList = highlightArea.getElementsByClassName(CLASS_HIGHLIGHT_AREA);
        highlightIcon = nodeList[0];
        const size = parseInt(highlightIcon.style.height.replace("px", ""));
        let originY = currentElement.highlight.position;
        const preY = newArray[currentIndex - 1] && newArray[currentIndex - 1].highlight.position;
        const preHeight = size;
        const preBottomY = currentIndex === 0 ? 0 : preY + preHeight + 0;
        const newY = preBottomY > originY ? preBottomY : originY;
        const updatedAnnotation = {
          ...currentElement,
          highlight: {
            ...currentElement.highlight,
            position: newY
          }
        };
        return [...newArray, updatedAnnotation];
      };
      return highlights.sort(function(a, b) {
        return a.highlight.position - b.highlight.position;
      }).reduce(positionAnnotations, []);
    }
  };

  // src/modules/BookmarkModule.ts
  init_polyfills();
  var import_uuid2 = __toESM(require_uuid());
  var import_loglevel9 = __toESM(require_loglevel());
  var BookmarkModule = class _BookmarkModule {
    static async create(config2) {
      const module2 = new this(
        config2.annotator,
        config2.rights || { enableBookmarks: false },
        config2.publication,
        config2,
        config2.initialAnnotations,
        config2.api,
        config2.headerMenu
      );
      await module2.start();
      return new Promise((resolve) => resolve(module2));
    }
    constructor(annotator, rights, publication, properties, initialAnnotations, api, headerMenu) {
      this.annotator = annotator;
      this.rights = rights;
      this.publication = publication;
      this.headerMenu = headerMenu;
      this.initialAnnotations = initialAnnotations;
      this.properties = properties;
      this.api = api;
    }
    stop() {
      import_loglevel9.default.log("Bookmark module stop");
    }
    async start() {
      var _a, _b;
      if (this.headerMenu)
        this.bookmarksView = findElement(
          this.headerMenu,
          "#container-view-bookmarks"
        );
      if (this.headerMenu)
        this.sideNavSectionBookmarks = findElement(
          this.headerMenu,
          "#sidenav-section-bookmarks"
        );
      if (this.headerMenu) {
        const menuBookmark = findElement(
          this.headerMenu,
          "#menu-button-bookmark"
        );
        if (menuBookmark)
          (_a = menuBookmark.parentElement) == null ? void 0 : _a.style.removeProperty("display");
        if (menuBookmark)
          addEventListenerOptional(
            menuBookmark,
            "click",
            this.saveBookmark.bind(this)
          );
      }
      if (this.initialAnnotations) {
        const bookmarks = this.initialAnnotations["bookmarks"] || null;
        if (bookmarks) {
          (_b = this.annotator) == null ? void 0 : _b.initBookmarks(bookmarks);
        }
      }
    }
    async handleResize() {
      setTimeout(async () => {
        await this.drawBookmarks();
        await this.showBookmarks();
        setTimeout(() => {
          this.properties.hideLayer ? this.navigator.hideLayer("highlights") : this.navigator.showLayer("highlights");
        }, 10);
      }, 100);
    }
    initialize() {
      return new Promise(async (resolve) => {
        await document.fonts.ready;
        if (this.rights.enableBookmarks) {
          setTimeout(() => {
            this.drawBookmarks();
            this.showBookmarks();
          }, 300);
        }
        resolve(null);
      });
    }
    async deleteBookmark(bookmark) {
      var _a, _b;
      if (this.annotator) {
        if ((_a = this.api) == null ? void 0 : _a.deleteBookmark) {
          await ((_b = this.api) == null ? void 0 : _b.deleteBookmark(bookmark));
          let deleted = await this.annotator.deleteBookmark(bookmark);
          import_loglevel9.default.log("Bookmark deleted " + JSON.stringify(deleted));
          await this.showBookmarks();
          await this.drawBookmarks();
          return deleted;
        } else {
          let deleted = await this.annotator.deleteBookmark(bookmark);
          import_loglevel9.default.log("Bookmark deleted " + JSON.stringify(deleted));
          await this.showBookmarks();
          await this.drawBookmarks();
          return deleted;
        }
      } else {
        return new Promise((resolve) => resolve(null));
      }
    }
    async saveBookmarkPlus() {
      await this.addBookmarkPlus();
    }
    async saveBookmark() {
      var _a, _b, _c;
      if (this.annotator) {
        var tocItem = this.publication.getTOCItem(
          this.navigator.currentChapterLink.href
        );
        if (this.navigator.currentTocUrl) {
          tocItem = this.publication.getTOCItem(this.navigator.currentTocUrl);
        }
        if (tocItem === void 0) {
          tocItem = this.publication.getTOCItemAbsolute(
            this.navigator.currentChapterLink.href
          );
        }
        if (tocItem) {
          let href = tocItem.Href;
          if (href.indexOf("#") > 0) {
            href = href.slice(0, href.indexOf("#"));
          }
          const progression = (_a = this.navigator.view) == null ? void 0 : _a.getCurrentPosition();
          const id2 = (0, import_uuid2.v4)();
          let bookmark;
          if (this.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
            const positions = this.publication.positionsByHref(
              this.publication.getRelativeHref(
                this.navigator.currentChapterLink.href
              )
            );
            const positionIndex = Math.ceil(
              (progression ?? 0) * (positions.length - 1)
            );
            const locator = positions[positionIndex];
            bookmark = {
              ...locator,
              id: id2,
              href,
              created: /* @__PURE__ */ new Date(),
              title: this.navigator.currentChapterLink.title
            };
          } else {
            bookmark = {
              id: id2,
              href,
              locations: {
                progression
              },
              created: /* @__PURE__ */ new Date(),
              type: this.navigator.currentChapterLink.type,
              title: this.navigator.currentChapterLink.title
            };
          }
          if (!this.annotator.locatorExists(bookmark, 0 /* Bookmark */)) {
            (_b = this.navigator.consumptionModule) == null ? void 0 : _b.trackAction(
              bookmark,
              "BookmarkCreated" /* BookmarkCreated */
            );
            if ((_c = this.api) == null ? void 0 : _c.addBookmark) {
              const result = await this.api.addBookmark(bookmark);
              if (result) {
                bookmark = result;
              }
              import_loglevel9.default.log(bookmark);
              let saved = this.annotator.saveBookmark(bookmark);
              import_loglevel9.default.log("Bookmark added " + JSON.stringify(saved));
              this.showBookmarks();
              await this.drawBookmarks();
              return saved;
            } else {
              let saved = this.annotator.saveBookmark(bookmark);
              import_loglevel9.default.log("Bookmark added " + JSON.stringify(saved));
              this.showBookmarks();
              await this.drawBookmarks();
              return saved;
            }
          }
        }
      }
    }
    async addBookmarkPlus() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      let self2 = this;
      let node = (_a = this.navigator.highlighter) == null ? void 0 : _a.visibleTextRects[0];
      let doc = this.navigator.iframes[0].contentDocument;
      if (doc) {
        const range = (_b = this.navigator.highlighter) == null ? void 0 : _b.dom(doc.body).getWindow().document.createRange();
        const selection = (_d = this.navigator.highlighter) == null ? void 0 : _d.dom((_c = this.navigator.iframes[0].contentDocument) == null ? void 0 : _c.body).getSelection();
        selection.removeAllRanges();
        if (node) {
          range.selectNodeContents(node.node);
        }
        selection.addRange(range);
        const clientRects = getClientRectsNoOverlap(range, false);
        let index2 = 0;
        for (const rect of clientRects) {
          if (!((_e = this.navigator.highlighter) == null ? void 0 : _e.isOutsideViewport(rect))) {
            const endNode = selection.focusNode;
            const endOffset = selection.focusOffset;
            selection.collapse(selection.anchorNode, selection.anchorOffset);
            for (let i = 0; i < index2; i++) {
              selection.modify("move", "forward", "line");
            }
            selection.extend(endNode, endOffset);
            const endNode2 = selection.focusNode;
            const focusNodeLength = selection.focusNode.length;
            selection.collapse(selection.anchorNode, selection.anchorOffset);
            let endOffset2 = focusNodeLength;
            if (selection.anchorOffset > focusNodeLength) {
              endOffset2 = focusNodeLength;
            } else {
              endOffset2 = selection.anchorOffset + 1;
            }
            selection.modify("move", "forward", "character");
            selection.modify("move", "backward", "word");
            selection.extend(endNode2, endOffset2);
            selection.modify("extend", "backward", "character");
            selection.modify("extend", "forward", "word");
            break;
          }
          index2++;
        }
      }
      function getCssSelector(element) {
        var _a2;
        const options = {};
        let doc2 = self2.navigator.iframes[0].contentDocument;
        if (doc2) {
          return uniqueCssSelector(
            element,
            (_a2 = self2.navigator.highlighter) == null ? void 0 : _a2.dom(doc2.body).getDocument(),
            options
          );
        } else {
          return void 0;
        }
      }
      let win = this.navigator.iframes[0].contentWindow;
      let menuItem = {
        id: `bookmarkIcon`,
        marker: 2 /* Bookmark */,
        icon: {
          id: `bookmarkIcon`,
          title: `Bookmark`,
          svgPath: `<path d="M0 0h24v24H0V0z" fill="none"/><path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>`,
          color: `#000000`,
          position: "left"
        },
        popup: {
          background: `#000000`,
          textColor: `#ffffff`
        },
        highlight: {
          color: `#000000`,
          style: {
            default: [
              {
                property: `border-bottom`,
                value: `0px dashed #000000`,
                priority: `important`
              }
            ]
          }
        }
      };
      if (win !== null) {
        let selectionInfo = getCurrentSelectionInfo(win, getCssSelector);
        if (selectionInfo === void 0) {
          let doc3 = self2.navigator.iframes[0].contentDocument;
          selectionInfo = (_g = (_f = this.navigator.annotationModule) == null ? void 0 : _f.annotator) == null ? void 0 : _g.getTemporarySelectionInfo(
            doc3
          );
        }
        let doc2 = self2.navigator.iframes[0].contentDocument;
        if (selectionInfo && doc2) {
          let book = (_k = this.navigator.highlighter) == null ? void 0 : _k.createHighlight(
            (_h = this.navigator.highlighter) == null ? void 0 : _h.dom(doc2.body).getWindow(),
            selectionInfo,
            (_i = menuItem.highlight) == null ? void 0 : _i.color,
            true,
            2 /* Bookmark */,
            menuItem.icon,
            menuItem.popup,
            (_j = menuItem.highlight) == null ? void 0 : _j.style
          );
          (_m = (_l = this.navigator.iframes[0].contentDocument) == null ? void 0 : _l.getSelection()) == null ? void 0 : _m.removeAllRanges();
          if (book) {
            return this.saveAnnotation(book[0]).then((anno) => {
              import_loglevel9.default.log("saved bookmark " + (anno == null ? void 0 : anno.id));
            });
          }
        }
      }
    }
    async saveAnnotation(highlight) {
      var _a, _b, _c;
      if (this.annotator) {
        var tocItem = this.publication.getTOCItem(
          this.navigator.currentChapterLink.href
        );
        if (this.navigator.currentTocUrl) {
          tocItem = this.publication.getTOCItem(this.navigator.currentTocUrl);
        }
        if (tocItem === null) {
          tocItem = this.publication.getTOCItemAbsolute(
            this.navigator.currentChapterLink.href
          );
        }
        const bookmarkPosition = (_a = this.navigator.view) == null ? void 0 : _a.getCurrentPosition();
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          const body = findRequiredIframeElement(
            doc,
            "body"
          );
          const progression = highlight.position ? highlight.position / body.scrollHeight : bookmarkPosition;
          const id2 = (0, import_uuid2.v4)();
          let annotation;
          if (tocItem) {
            let href = tocItem.Href;
            if (href.indexOf("#") > 0) {
              href = href.slice(0, href.indexOf("#"));
            }
            if (this.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
              const positions = this.publication.positionsByHref(
                this.publication.getRelativeHref(
                  this.navigator.currentChapterLink.href
                )
              );
              const positionIndex = Math.ceil(
                (progression ?? 0) * (positions.length - 1)
              );
              const locator = positions[positionIndex];
              annotation = {
                ...locator,
                id: id2,
                href,
                created: /* @__PURE__ */ new Date(),
                title: this.navigator.currentChapterLink.title,
                highlight,
                text: {
                  highlight: highlight.selectionInfo.cleanText
                }
              };
            } else {
              annotation = {
                id: id2,
                href,
                locations: {
                  progression
                },
                created: /* @__PURE__ */ new Date(),
                type: this.navigator.currentChapterLink.type,
                title: this.navigator.currentChapterLink.title,
                highlight,
                text: {
                  highlight: highlight.selectionInfo.cleanText
                }
              };
            }
          }
          if (annotation) {
            (_b = this.navigator.consumptionModule) == null ? void 0 : _b.trackAction(
              annotation,
              "BookmarkCreated" /* BookmarkCreated */
            );
            if ((_c = this.api) == null ? void 0 : _c.addBookmark) {
              let result = await this.api.addBookmark(annotation);
              const saved = await this.annotator.saveAnnotation(result);
              await this.showBookmarks();
              await this.drawBookmarks();
              return new Promise((resolve) => resolve(saved));
            } else {
              const saved = await this.annotator.saveAnnotation(annotation);
              await this.showBookmarks();
              await this.drawBookmarks();
              return new Promise((resolve) => resolve(saved));
            }
          }
        }
      }
      return new Promise((resolve) => resolve(void 0));
    }
    getBookmarks() {
      let bookmarks = [];
      if (this.annotator) {
        bookmarks = this.annotator.getBookmarks();
      }
      return bookmarks;
    }
    showBookmarks() {
      let bookmarks = [];
      if (this.annotator) {
        bookmarks = this.annotator.getBookmarks();
      }
      let highlights = [];
      if (this.annotator) {
        highlights = this.annotator.getAnnotations();
        if (highlights) {
          highlights = highlights.filter(
            (rangeRepresentation) => rangeRepresentation.highlight.marker === 2 /* Bookmark */
          );
          if (bookmarks) {
            bookmarks.push.apply(bookmarks, highlights);
          } else {
            bookmarks = highlights;
          }
        }
      }
      if (this.bookmarksView)
        this.createTree(0 /* Bookmark */, bookmarks, this.bookmarksView);
    }
    async drawBookmarks() {
      var _a, _b;
      if (this.rights.enableBookmarks && this.navigator.highlighter) {
        if (this.api) {
          let highlights = [];
          if (this.annotator) {
            highlights = await this.annotator.getAnnotations();
          }
          if (this.navigator.highlighter && highlights && ((_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.readyState) === "complete") {
            await this.navigator.highlighter.destroyHighlights(
              0 /* Annotation */
            );
            for (const rangeRepresentation of highlights) {
              _highlights.push(rangeRepresentation.highlight);
              const annotation = rangeRepresentation;
              let currentLocation = this.navigator.currentChapterLink.href;
              var tocItem = this.publication.getTOCItem(currentLocation);
              if (this.navigator.currentTocUrl) {
                tocItem = this.publication.getTOCItem(
                  this.navigator.currentTocUrl
                );
              }
              if (tocItem === void 0) {
                tocItem = this.publication.getTOCItemAbsolute(
                  this.navigator.currentChapterLink.href
                );
              }
              if (tocItem) {
                let href = tocItem.Href;
                if (href.indexOf("#") > 0) {
                  href = href.slice(0, href.indexOf("#"));
                }
                if (annotation.href === href) {
                  await this.navigator.highlighter.createHighlightDom(
                    this.navigator.iframes[0].contentWindow,
                    rangeRepresentation.highlight
                  );
                }
              }
            }
          }
        } else {
          let highlights = [];
          if (this.annotator) {
            highlights = await this.annotator.getAnnotations();
          }
          if (this.navigator.highlighter && highlights && ((_b = this.navigator.iframes[0].contentDocument) == null ? void 0 : _b.readyState) === "complete") {
            await this.navigator.highlighter.destroyHighlights(
              0 /* Annotation */
            );
            for (const rangeRepresentation of highlights) {
              _highlights.push(rangeRepresentation.highlight);
              const annotation = rangeRepresentation;
              let currentLocation = this.navigator.currentChapterLink.href;
              let tocItem2 = this.publication.getTOCItem(currentLocation);
              if (this.navigator.currentTocUrl) {
                tocItem2 = this.publication.getTOCItem(
                  this.navigator.currentTocUrl
                );
              }
              if (tocItem2 === void 0) {
                tocItem2 = this.publication.getTOCItemAbsolute(
                  this.navigator.currentChapterLink.href
                );
              }
              if (tocItem2) {
                let href = tocItem2.Href;
                if (href.indexOf("#") > 0) {
                  href = href.slice(0, href.indexOf("#"));
                }
                if (annotation.href === href) {
                  await this.navigator.highlighter.createHighlightDom(
                    this.navigator.iframes[0].contentWindow,
                    rangeRepresentation.highlight
                  );
                }
              }
            }
          }
        }
      }
    }
    async deleteSelectedHighlight(highlight) {
      var _a;
      if ((_a = this.api) == null ? void 0 : _a.deleteBookmark) {
        this.api.deleteBookmark(highlight).then(async () => {
          this.deleteLocalHighlight(highlight.id);
        });
      } else {
        this.deleteLocalHighlight(highlight.id);
      }
    }
    async deleteLocalHighlight(id2) {
      if (this.annotator) {
        var deleted = await this.annotator.deleteAnnotation(id2);
        import_loglevel9.default.log("Highlight deleted " + JSON.stringify(deleted));
        await this.showBookmarks();
        await this.drawBookmarks();
        return deleted;
      } else {
        return new Promise((resolve) => resolve(null));
      }
    }
    createTree(type, annotations, view) {
      if (annotations) {
        const self2 = this;
        const toc = this.publication.readingOrder;
        if (toc.length) {
          const createAnnotationTree = (parentElement, links) => {
            let chapterList = document.createElement("ul");
            chapterList.className = "sidenav-annotations";
            for (const link of links) {
              let chapterHeader = document.createElement("li");
              const linkElement = document.createElement("a");
              const spanElement = document.createElement("span");
              linkElement.tabIndex = -1;
              linkElement.className = "chapter-link";
              if (link.Href) {
                const linkHref = this.publication.getAbsoluteHref(link.Href);
                const tocItemAbs = this.publication.getTOCItemAbsolute(linkHref);
                linkElement.href = linkHref;
                linkElement.innerHTML = (tocItemAbs == null ? void 0 : tocItemAbs.Title) || "";
                chapterHeader.appendChild(linkElement);
              } else {
                spanElement.innerHTML = link.Title || "";
                spanElement.className = "chapter-title";
                chapterHeader.appendChild(spanElement);
              }
              addEventListenerOptional(
                linkElement,
                "click",
                (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  const position = {
                    href: linkElement.href,
                    locations: {
                      progression: 0
                    },
                    type: link.TypeLink,
                    title: linkElement.title
                  };
                  this.navigator.stopReadAloud();
                  this.navigator.navigate(position);
                }
              );
              const bookmarkList = document.createElement("ol");
              annotations.forEach(function(locator) {
                const href = link.Href.indexOf("#") !== -1 ? link.Href.slice(0, link.Href.indexOf("#")) : link.Href;
                if (link.Href && locator.href.endsWith(href)) {
                  let bookmarkItem = document.createElement("li");
                  bookmarkItem.className = "annotation-item";
                  let bookmarkLink = document.createElement("a");
                  bookmarkLink.setAttribute("href", locator.href);
                  if (type === 0 /* Bookmark */) {
                    bookmarkLink.className = "bookmark-link";
                    let title = document.createElement("span");
                    let formattedProgression = Math.round((locator.locations.progression ?? 0) * 100) + "% through resource";
                    title.className = "title";
                    title.innerHTML = formattedProgression;
                    bookmarkLink.appendChild(title);
                  }
                  let timestamp = document.createElement("span");
                  timestamp.className = "timestamp";
                  timestamp.innerHTML = _BookmarkModule.readableTimestamp(
                    locator.created
                  );
                  bookmarkLink.appendChild(timestamp);
                  addEventListenerOptional(
                    bookmarkLink,
                    "click",
                    (event) => {
                      event.preventDefault();
                      event.stopPropagation();
                      self2.handleAnnotationLinkClick(event, locator);
                    }
                  );
                  bookmarkItem.appendChild(bookmarkLink);
                  if (self2.navigator.sideNavExpanded) {
                    let bookmarkDeleteLink = document.createElement("button");
                    bookmarkDeleteLink.className = "delete";
                    bookmarkDeleteLink.innerHTML = icons.delete;
                    addEventListenerOptional(
                      bookmarkDeleteLink,
                      "click",
                      (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        self2.handleAnnotationLinkDeleteClick(
                          type,
                          event,
                          locator
                        );
                      }
                    );
                    bookmarkItem.appendChild(bookmarkDeleteLink);
                  }
                  bookmarkList.appendChild(bookmarkItem);
                }
              });
              if (bookmarkList.children.length > 0) {
                chapterList.appendChild(chapterHeader);
                chapterList.appendChild(bookmarkList);
              }
              if (chapterList.children.length > 0) {
                parentElement.appendChild(chapterList);
              }
              if (link.Children && link.Children.length > 0) {
                createAnnotationTree(parentElement, link.Children);
              }
            }
          };
          view.innerHTML = "";
          createAnnotationTree(view, toc);
        }
      }
    }
    handleAnnotationLinkClick(event, locator) {
      if (locator) {
        locator.href = this.publication.getAbsoluteHref(locator.href);
        this.navigator.stopReadAloud();
        this.navigator.navigate(locator);
      } else {
        import_loglevel9.default.log("bookmark data missing: ", event);
      }
    }
    handleAnnotationLinkDeleteClick(type, event, locator) {
      import_loglevel9.default.log("bookmark data locator: ", locator);
      if (locator) {
        if (type === 0 /* Bookmark */) {
          this.deleteBookmark(locator);
        }
      } else {
        import_loglevel9.default.log("bookmark data missing: ", event);
      }
    }
    static readableTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toDateString() + " " + date.toLocaleTimeString();
    }
    async getAnnotation(highlight) {
      var _a;
      return (_a = this.annotator) == null ? void 0 : _a.getAnnotation(highlight);
    }
    async getAnnotationByID(id2) {
      var _a;
      return (_a = this.annotator) == null ? void 0 : _a.getAnnotationByID(id2);
    }
  };

  // src/modules/mediaoverlays/MediaOverlayModule.ts
  init_polyfills();
  var import_media_overlay = __toESM(require_media_overlay());

  // src/modules/mediaoverlays/MediaOverlaySettings.ts
  init_polyfills();
  var import_loglevel10 = __toESM(require_loglevel());
  var R2_MO_CLASS_ACTIVE = "r2-mo-active";
  var _MEDIAOVERLAYREFS = class _MEDIAOVERLAYREFS {
  };
  _MEDIAOVERLAYREFS.COLOR_REF = "color";
  _MEDIAOVERLAYREFS.AUTO_SCROLL_REF = "autoscroll";
  _MEDIAOVERLAYREFS.AUTO_TURN_REF = "autoturn";
  _MEDIAOVERLAYREFS.VOLUME_REF = "volume";
  _MEDIAOVERLAYREFS.RATE_REF = "rate";
  _MEDIAOVERLAYREFS.COLOR_KEY = "mediaoverlay-" + _MEDIAOVERLAYREFS.COLOR_REF;
  _MEDIAOVERLAYREFS.AUTO_SCROLL_KEY = "mediaoverlay-" + _MEDIAOVERLAYREFS.AUTO_SCROLL_REF;
  _MEDIAOVERLAYREFS.AUTO_TURN_KEY = "mediaoverlay-" + _MEDIAOVERLAYREFS.AUTO_TURN_REF;
  _MEDIAOVERLAYREFS.VOLUME_KEY = "mediaoverlay-" + _MEDIAOVERLAYREFS.VOLUME_REF;
  _MEDIAOVERLAYREFS.RATE_KEY = "mediaoverlay-" + _MEDIAOVERLAYREFS.RATE_REF;
  var MEDIAOVERLAYREFS = _MEDIAOVERLAYREFS;
  var MediaOverlaySettings = class {
    constructor(store, api, headerMenu) {
      this.MEDIAOVERLAYSETTINGS = "mediaOverlaySetting";
      this.color = "r2-mo-active";
      this.autoScroll = true;
      this.autoTurn = true;
      this.volume = 1;
      this.rate = 1;
      this.playing = false;
      this.resourceReady = false;
      this.wait = 1;
      this.settingsChangeCallback = () => {
      };
      this.store = store;
      this.api = api;
      this.headerMenu = headerMenu;
      this.initialise();
      import_loglevel10.default.log(this.api);
    }
    static create(config2) {
      const settings = new this(config2.store, config2.api, config2.headerMenu);
      if (config2.initialMediaOverlaySettings) {
        let initialSettings = config2.initialMediaOverlaySettings;
        if (initialSettings == null ? void 0 : initialSettings.color) {
          settings.color = initialSettings.color;
          import_loglevel10.default.log(settings.color);
        }
        if (initialSettings == null ? void 0 : initialSettings.autoScroll) {
          settings.autoScroll = initialSettings.autoScroll;
          import_loglevel10.default.log(settings.autoScroll);
        }
        if (initialSettings == null ? void 0 : initialSettings.autoTurn) {
          settings.autoTurn = initialSettings.autoTurn;
          import_loglevel10.default.log(settings.autoScroll);
        }
        if (initialSettings == null ? void 0 : initialSettings.volume) {
          settings.volume = initialSettings.volume;
          import_loglevel10.default.log(settings.volume);
        }
        if (initialSettings == null ? void 0 : initialSettings.rate) {
          settings.rate = initialSettings.rate;
          import_loglevel10.default.log(settings.rate);
        }
        if (initialSettings == null ? void 0 : initialSettings.wait) {
          settings.wait = initialSettings.wait;
          import_loglevel10.default.log(settings.wait);
        }
      }
      settings.initializeSelections();
      return settings;
    }
    stop() {
      import_loglevel10.default.log("MediaOverlay settings stop");
    }
    initialise() {
      this.autoScroll = this.getProperty(MEDIAOVERLAYREFS.AUTO_SCROLL_KEY) != null ? this.getProperty(MEDIAOVERLAYREFS.AUTO_SCROLL_KEY).value : this.autoScroll;
      this.autoTurn = this.getProperty(MEDIAOVERLAYREFS.AUTO_TURN_KEY) != null ? this.getProperty(MEDIAOVERLAYREFS.AUTO_TURN_KEY).value : this.autoTurn;
      this.color = this.getProperty(MEDIAOVERLAYREFS.COLOR_KEY) != null ? this.getProperty(MEDIAOVERLAYREFS.COLOR_KEY).value : this.color;
      this.volume = this.getProperty(MEDIAOVERLAYREFS.VOLUME_KEY) != null ? this.getProperty(MEDIAOVERLAYREFS.VOLUME_KEY).value : this.volume;
      this.rate = this.getProperty(MEDIAOVERLAYREFS.RATE_KEY) != null ? this.getProperty(MEDIAOVERLAYREFS.RATE_KEY).value : this.rate;
      this.userProperties = this.getMediaOverlaySettings();
    }
    reset() {
      this.color = "redtext";
      this.autoScroll = true;
      this.autoTurn = true;
      this.volume = 1;
      this.rate = 1;
      this.wait = 1;
      this.userProperties = this.getMediaOverlaySettings();
    }
    initializeSelections() {
      if (this.headerMenu)
        this.settingsView = findElement(
          this.headerMenu,
          "#container-view-mediaoverlay-settings"
        );
    }
    setControls() {
      if (this.settingsView)
        this.renderControls(this.settingsView);
    }
    renderControls(element) {
      if (this.headerMenu)
        this.speechAutoTurn = findElement(
          this.headerMenu,
          "#mediaOverlayAutoTurn"
        );
      if (this.headerMenu)
        this.speechAutoScroll = findElement(
          this.headerMenu,
          "#mediaOverlayAutoScroll"
        );
      if (this.headerMenu)
        this.speechVolume = findElement(
          this.headerMenu,
          "#mediaOverlayVolume"
        );
      if (this.headerMenu)
        this.speechRate = findElement(
          this.headerMenu,
          "#mediaOverlayRate"
        );
      if (this.speechAutoScroll)
        this.speechAutoScroll.checked = this.autoScroll;
      if (this.speechAutoTurn)
        this.speechAutoTurn.checked = this.autoTurn;
      if (this.speechVolume)
        this.speechVolume.value = this.volume.toString();
      if (this.speechRate)
        this.speechRate.value = this.volume.toString();
      addEventListenerOptional(
        findElement(element, "ul"),
        "click",
        (event) => {
          event.stopPropagation();
        }
      );
    }
    onSettingsChange(callback) {
      this.settingsChangeCallback = callback;
    }
    storeProperty(property) {
      this.updateUserSettings();
      this.saveProperty(property);
    }
    updateUserSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      let syncSettings = {
        color: (_a = this.userProperties.getByRef(MEDIAOVERLAYREFS.COLOR_REF)) == null ? void 0 : _a.value,
        autoScroll: (_b = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_SCROLL_REF)) == null ? void 0 : _b.value,
        autoTurn: (_c = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_TURN_REF)) == null ? void 0 : _c.value,
        volume: (_d = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF)) == null ? void 0 : _d.value,
        rate: (_e = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF)) == null ? void 0 : _e.value
      };
      this.applyMediaOverlaySettings(syncSettings);
      if ((_f = this.api) == null ? void 0 : _f.updateSettings) {
        (_g = this.api) == null ? void 0 : _g.updateSettings(syncSettings).then(async (settings) => {
          import_loglevel10.default.log("api updated sync settings", settings);
        });
      }
    }
    getMediaOverlaySettings() {
      let userProperties = new UserProperties();
      userProperties.addSwitchable(
        "mediaoverlay-auto-scroll-off",
        "mediaoverlay-auto-scroll-on",
        this.autoScroll,
        MEDIAOVERLAYREFS.AUTO_SCROLL_REF,
        MEDIAOVERLAYREFS.AUTO_SCROLL_KEY
      );
      userProperties.addSwitchable(
        "mediaoverlay-auto-turn-off",
        "mediaoverlay-auto-turn-on",
        this.autoTurn,
        MEDIAOVERLAYREFS.AUTO_TURN_REF,
        MEDIAOVERLAYREFS.AUTO_TURN_KEY
      );
      userProperties.addStringable(
        this.color,
        MEDIAOVERLAYREFS.COLOR_REF,
        MEDIAOVERLAYREFS.COLOR_KEY
      );
      userProperties.addIncremental(
        this.volume,
        0.1,
        1,
        0.1,
        "",
        MEDIAOVERLAYREFS.VOLUME_REF,
        MEDIAOVERLAYREFS.VOLUME_KEY
      );
      userProperties.addIncremental(
        this.rate,
        0.1,
        3,
        0.1,
        "",
        MEDIAOVERLAYREFS.RATE_REF,
        MEDIAOVERLAYREFS.RATE_KEY
      );
      return userProperties;
    }
    saveProperty(property) {
      let savedProperties = this.store.get(this.MEDIAOVERLAYSETTINGS);
      if (savedProperties) {
        let array = JSON.parse(savedProperties);
        array = array.filter((el) => el.name !== property.name);
        array.push(property);
        this.store.set(this.MEDIAOVERLAYSETTINGS, JSON.stringify(array));
      } else {
        let array = [];
        array.push(property);
        this.store.set(this.MEDIAOVERLAYSETTINGS, JSON.stringify(array));
      }
      return property;
    }
    getProperty(name) {
      let array = this.store.get(this.MEDIAOVERLAYSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        properties = properties.filter((el) => el.name === name);
        if (properties.length === 0) {
          return null;
        }
        return properties[0];
      }
      return null;
    }
    resetMediaOverlaySettings() {
      this.store.remove(this.MEDIAOVERLAYSETTINGS);
      this.reset();
      this.settingsChangeCallback();
    }
    applyMediaOverlaySettings(mediaOverlaySettings) {
      if (mediaOverlaySettings.color) {
        this.color = mediaOverlaySettings.color;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.COLOR_REF);
        if (prop) {
          prop.value = this.color;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (mediaOverlaySettings.autoScroll !== void 0) {
        import_loglevel10.default.log("autoScroll " + this.autoScroll);
        this.autoScroll = mediaOverlaySettings.autoScroll;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_SCROLL_REF);
        if (prop) {
          prop.value = this.autoScroll;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (mediaOverlaySettings.autoTurn !== void 0) {
        import_loglevel10.default.log("autoTurn " + this.autoTurn);
        this.autoTurn = mediaOverlaySettings.autoTurn;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_TURN_REF);
        if (prop) {
          prop.value = this.autoTurn;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (mediaOverlaySettings.volume) {
        import_loglevel10.default.log("volume " + this.volume);
        this.volume = mediaOverlaySettings.volume;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF);
        if (prop) {
          prop.value = this.volume;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (mediaOverlaySettings.rate) {
        import_loglevel10.default.log("rate " + this.rate);
        this.rate = mediaOverlaySettings.rate;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF);
        if (prop) {
          prop.value = this.rate;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
    }
    applyMediaOverlaySetting(key, value) {
      if (key === MEDIAOVERLAYREFS.COLOR_REF) {
        this.color = value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.COLOR_REF);
        if (prop) {
          prop.value = this.color;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      } else if (key === MEDIAOVERLAYREFS.AUTO_SCROLL_REF) {
        this.autoScroll = value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_SCROLL_REF);
        if (prop) {
          prop.value = this.autoScroll;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      } else if (key === MEDIAOVERLAYREFS.AUTO_TURN_REF) {
        this.autoTurn = value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.AUTO_TURN_REF);
        if (prop) {
          prop.value = this.autoTurn;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
    }
    increase(incremental) {
      var _a, _b;
      if (incremental === "mo_volume") {
        this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF).increment();
        this.volume = (_a = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF)) == null ? void 0 : _a.value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
      } else if (incremental === "mo_rate") {
        this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF).increment();
        this.rate = (_b = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF)) == null ? void 0 : _b.value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
      }
    }
    decrease(incremental) {
      var _a, _b;
      if (incremental === "mo_volume") {
        this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF).decrement();
        this.volume = (_a = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF)) == null ? void 0 : _a.value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.VOLUME_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
      } else if (incremental === "mo_rate") {
        this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF).decrement();
        this.rate = (_b = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF)) == null ? void 0 : _b.value;
        let prop = this.userProperties.getByRef(MEDIAOVERLAYREFS.RATE_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
      }
    }
  };

  // src/modules/mediaoverlays/MediaOverlayModule.ts
  var import_loglevel11 = __toESM(require_loglevel());
  var MediaOverlayModule = class {
    constructor(publication, settings, properties) {
      this.play = findElement(
        document,
        "#menu-button-play"
      );
      this.pause = findElement(
        document,
        "#menu-button-pause"
      );
      this.currentLinkIndex = 0;
      this.pid = void 0;
      this.__ontimeupdate = false;
      this.ontimeupdate = async (_v) => {
        import_loglevel11.default.log("ontimeupdate");
        this.trackCurrentTime();
      };
      this.ensureOnTimeUpdate = (remove, replace) => {
        if (remove) {
          if (this.__ontimeupdate) {
            this.__ontimeupdate = false;
            if (this.audioElement) {
              this.audioElement.removeEventListener(
                "timeupdate",
                this.ontimeupdate
              );
            }
            cancelAnimationFrame(this.myReq);
          }
        } else {
          if (!this.__ontimeupdate || replace) {
            this.__ontimeupdate = true;
            if (replace) {
              if (this.audioElement) {
                this.audioElement.removeEventListener(
                  "timeupdate",
                  this.ontimeupdate
                );
              }
              this.audioElement.addEventListener("timeupdate", this.ontimeupdate);
            }
          }
        }
      };
      this.publication = publication;
      this.settings = settings;
      this.properties = properties;
    }
    static create(config2) {
      const mediaOverlay = new this(
        config2.publication,
        config2.settings,
        config2
      );
      mediaOverlay.start();
      return mediaOverlay;
    }
    stop() {
      import_loglevel11.default.log("MediaOverlay module stop");
    }
    start() {
      import_loglevel11.default.log("MediaOverlay module start");
    }
    async initialize() {
      return new Promise(async (resolve) => {
        await document.fonts.ready;
        this.settings.setControls();
        this.settings.onSettingsChange(() => {
          this.audioElement.volume = this.settings.volume;
          this.audioElement.playbackRate = this.settings.rate;
        });
        resolve();
      });
    }
    async initializeResource(links) {
      this.currentLinks = links;
      this.currentLinkIndex = 0;
      await this.playLink();
    }
    async playLink() {
      var _a, _b;
      let link = this.currentLinks[this.currentLinkIndex];
      if ((_a = link == null ? void 0 : link.Properties) == null ? void 0 : _a.MediaOverlay) {
        this.ensureOnTimeUpdate(false, false);
        const moUrl = (_b = link.Properties) == null ? void 0 : _b.MediaOverlay;
        const moUrlObjFull = new URL(moUrl, this.publication.manifestUrl);
        const moUrlFull = moUrlObjFull.toString();
        let response;
        try {
          response = await fetch(moUrlFull, this.navigator.requestConfig);
        } catch (e) {
          console.error(e, moUrlFull);
          return;
        }
        if (!response.ok) {
          import_loglevel11.default.log("BAD RESPONSE?!");
        }
        let moJson;
        try {
          moJson = await response.json();
        } catch (e) {
          console.error(e);
        }
        if (!moJson) {
          import_loglevel11.default.log("## moJson" + moJson);
          return;
        }
        link.MediaOverlays = TaJsonDeserialize(
          moJson,
          import_media_overlay.MediaOverlayNode
        );
        link.MediaOverlays.initialized = true;
        const href = link.HrefDecoded || link.Href;
        const hrefUrlObj = new URL("https://dita.digital/" + href);
        await this.playMediaOverlays(
          hrefUrlObj.pathname.substr(1),
          link.MediaOverlays,
          void 0
        );
      } else {
        if (this.audioElement) {
          await this.audioElement.pause();
        }
        if (this.currentLinks.length > 1 && this.currentLinkIndex === 0) {
          this.currentLinkIndex++;
          await this.playLink();
        } else {
          if (this.settings.autoTurn && this.settings.playing) {
            if (this.audioElement) {
              await this.audioElement.pause();
            }
            this.navigator.nextResource();
          } else {
            await this.stopReadAloud();
          }
        }
      }
    }
    async startReadAloud() {
      var _a;
      if (this.navigator.rights.enableMediaOverlays) {
        this.settings.playing = true;
        if (this.audioElement && ((_a = this.currentLinks[this.currentLinkIndex]) == null ? void 0 : _a.Properties.MediaOverlay)) {
          const timeToSeekTo = this.currentAudioBegin ? this.currentAudioBegin : 0;
          this.audioElement.currentTime = timeToSeekTo;
          await this.audioElement.play();
          this.ensureOnTimeUpdate(false, true);
          this.audioElement.volume = this.settings.volume;
          this.audioElement.playbackRate = this.settings.rate;
        } else {
          if (this.currentLinks.length > 1 && this.currentLinkIndex === 0) {
            this.currentLinkIndex++;
            await this.playLink();
          } else {
            if (this.settings.autoTurn && this.settings.playing) {
              this.navigator.nextResource();
            } else {
              await this.stopReadAloud();
            }
          }
        }
        if (this.play)
          this.play.style.display = "none";
        if (this.pause)
          this.pause.style.removeProperty("display");
      }
    }
    async stopReadAloud() {
      if (this.navigator.rights.enableMediaOverlays) {
        this.settings.playing = false;
        if (this.audioElement)
          this.audioElement.pause();
        if (this.play)
          this.play.style.removeProperty("display");
        if (this.pause)
          this.pause.style.display = "none";
      }
    }
    pauseReadAloud() {
      if (this.navigator.rights.enableMediaOverlays) {
        this.settings.playing = false;
        this.audioElement.pause();
        if (this.play)
          this.play.style.removeProperty("display");
        if (this.pause)
          this.pause.style.display = "none";
      }
    }
    async resumeReadAloud() {
      if (this.navigator.rights.enableMediaOverlays) {
        this.settings.playing = true;
        await this.audioElement.play();
        if (this.play)
          this.play.style.display = "none";
        if (this.pause)
          this.pause.style.removeProperty("display");
      }
    }
    findDepthFirstTextAudioPair(textHref, mo, textFragmentIDChain) {
      import_loglevel11.default.log("findDepthFirstTextAudioPair()");
      let isTextUrlMatch;
      let isFragmentIDMatch;
      if (mo.Text) {
        const hrefUrlObj = new URL("https://dita.digital/" + mo.Text);
        if (hrefUrlObj.pathname.substr(1) === textHref) {
          isTextUrlMatch = true;
          if (hrefUrlObj.hash && textFragmentIDChain) {
            isFragmentIDMatch = false;
            const id2 = hrefUrlObj.hash.substr(1);
            for (const frag of textFragmentIDChain) {
              if (frag === id2) {
                isFragmentIDMatch = true;
                break;
              }
            }
          }
        } else {
          isTextUrlMatch = false;
        }
      }
      import_loglevel11.default.log("isFragmentIDMatch: " + isFragmentIDMatch);
      import_loglevel11.default.log("isTextUrlMatch: " + isTextUrlMatch);
      if (!mo.Children || !mo.Children.length) {
        import_loglevel11.default.log("findDepthFirstTextAudioPair() - leaf text/audio pair");
        if (!isTextUrlMatch) {
          import_loglevel11.default.log("findDepthFirstTextAudioPair() - leaf - !isTextUrlMatch");
          return void 0;
        }
        if (isFragmentIDMatch || isTextUrlMatch && !textFragmentIDChain) {
          import_loglevel11.default.log(
            "findDepthFirstTextAudioPair() - leaf - isFragmentIDMatch || (isTextUrlMatch && !textFragmentIDChain"
          );
          return mo;
        }
        return void 0;
      }
      const textFragmentIDChainOriginal = textFragmentIDChain;
      let frags = textFragmentIDChain;
      for (const child of mo.Children) {
        import_loglevel11.default.log("findDepthFirstTextAudioPair() - child");
        import_loglevel11.default.log(JSON.stringify(child));
        const match = this.findDepthFirstTextAudioPair(textHref, child, frags);
        if (match === null) {
          import_loglevel11.default.log("findDepthFirstTextAudioPair() - child - match null (skip)");
          frags = void 0;
        }
        if (match) {
          import_loglevel11.default.log("findDepthFirstTextAudioPair() - child - match");
          import_loglevel11.default.log(JSON.stringify(match));
          return match;
        }
      }
      if (isFragmentIDMatch) {
        import_loglevel11.default.log("findDepthFirstTextAudioPair() - post isFragmentIDMatch");
        const match = this.findDepthFirstTextAudioPair(textHref, mo, void 0);
        if (match) {
          import_loglevel11.default.log(
            "findDepthFirstTextAudioPair() - post isFragmentIDMatch - match"
          );
          import_loglevel11.default.log(JSON.stringify(match));
          return match;
        } else {
          return match;
        }
      }
      if (textFragmentIDChainOriginal && !frags) {
        return null;
      }
      return void 0;
    }
    trackCurrentTime() {
      cancelAnimationFrame(this.myReq);
      if (this.mediaOverlayTextAudioPair) {
        try {
          if (this.currentAudioEnd && this.audioElement.currentTime >= this.currentAudioEnd - 0.05) {
            import_loglevel11.default.log("ontimeupdate - mediaOverlaysNext()");
            this.mediaOverlaysNext();
          }
          const match_i = this.mediaOverlayTextAudioPair.Text.lastIndexOf("#");
          const match_id = this.mediaOverlayTextAudioPair.Text.substr(
            match_i + 1
          );
          this.mediaOverlayHighlight(match_id);
          this.myReq = requestAnimationFrame(this.trackCurrentTime.bind(this));
        } catch (e) {
        }
      }
    }
    mediaOverlaysNext(escape2) {
      import_loglevel11.default.log("mediaOverlaysNext()");
      if (this.mediaOverlayRoot && this.mediaOverlayTextAudioPair) {
        const nextTextAudioPair = this.findNextTextAudioPair(
          this.mediaOverlayRoot,
          this.mediaOverlayTextAudioPair,
          { prev: void 0 },
          escape2 ? true : false
        );
        if (!nextTextAudioPair) {
          import_loglevel11.default.log("mediaOverlaysNext() - navLeftOrRight()");
          this.mediaOverlaysStop();
          if (this.currentLinks.length > 1 && this.currentLinkIndex === 0) {
            this.currentLinkIndex++;
            this.playLink();
          } else {
            this.audioElement.pause();
            if (this.settings.autoTurn && this.settings.playing) {
              this.audioElement.pause();
              this.navigator.nextResource();
            } else {
              this.stopReadAloud();
            }
          }
        } else {
          let switchDoc = false;
          if (this.mediaOverlayTextAudioPair.Text && nextTextAudioPair.Text) {
            const hrefUrlObj1 = new URL(
              "https://dita.digital/" + this.mediaOverlayTextAudioPair.Text
            );
            const hrefUrlObj2 = new URL(
              "https://dita.digital/" + nextTextAudioPair.Text
            );
            if (hrefUrlObj1.pathname !== hrefUrlObj2.pathname) {
              import_loglevel11.default.log(
                "mediaOverlaysNext() SWITCH! " + hrefUrlObj1.pathname + " != " + hrefUrlObj2.pathname
              );
              switchDoc = true;
            }
          }
          if (switchDoc) {
            this.mediaOverlaysStop();
          } else {
            import_loglevel11.default.log("mediaOverlaysNext() - playMediaOverlaysAudio()");
            setTimeout(async () => {
              await this.playMediaOverlaysAudio(
                nextTextAudioPair,
                void 0,
                void 0
              );
            }, 0);
          }
        }
      } else {
        import_loglevel11.default.log("mediaOverlaysNext() - navLeftOrRight() 2");
        this.mediaOverlaysStop();
        if (this.currentLinks.length > 1 && this.currentLinkIndex === 0) {
          this.currentLinkIndex++;
          this.playLink();
        } else {
          this.audioElement.pause();
          if (this.settings.autoTurn && this.settings.playing) {
            this.audioElement.pause();
            this.navigator.nextResource();
          } else {
            this.stopReadAloud();
          }
        }
      }
    }
    mediaOverlaysStop() {
      import_loglevel11.default.log("mediaOverlaysStop()");
      this.mediaOverlaysPause();
      this.mediaOverlayRoot = void 0;
      this.mediaOverlayTextAudioPair = void 0;
    }
    mediaOverlaysPause() {
      import_loglevel11.default.log("mediaOverlaysPause()");
      this.mediaOverlayHighlight(void 0);
      if (this.audioElement) {
        this.audioElement.pause();
      }
    }
    findNextTextAudioPair(mo, moToMatch, previousMo, escape2) {
      if (!mo.Children || !mo.Children.length) {
        if ((previousMo == null ? void 0 : previousMo.prev) === moToMatch) {
          import_loglevel11.default.log("findNextTextAudioPair() - prevMo === moToMatch");
          return mo;
        }
        import_loglevel11.default.log("findNextTextAudioPair() - set previous");
        import_loglevel11.default.log(JSON.stringify(mo));
        previousMo.prev = mo;
        return void 0;
      }
      for (const child of mo.Children) {
        import_loglevel11.default.log("findNextTextAudioPair() - child");
        import_loglevel11.default.log(JSON.stringify(child));
        const match = this.findNextTextAudioPair(
          child,
          moToMatch,
          previousMo,
          escape2
        );
        if (match) {
          import_loglevel11.default.log("findNextTextAudioPair() - match");
          import_loglevel11.default.log(JSON.stringify(match));
          return match;
        }
      }
      return void 0;
    }
    async playMediaOverlaysAudio(moTextAudioPair, begin, end) {
      import_loglevel11.default.log("playMediaOverlaysAudio()");
      this.mediaOverlayTextAudioPair = moTextAudioPair;
      if (!moTextAudioPair.Audio) {
        return;
      }
      const urlObjFull = new URL(
        moTextAudioPair.Audio,
        this.publication.manifestUrl
      );
      const urlFull = urlObjFull.toString();
      const urlObjNoQuery = new URL(urlFull);
      urlObjNoQuery.hash = "";
      urlObjNoQuery.search = "";
      const urlNoQuery = urlObjNoQuery.toString();
      const hasBegin = typeof begin !== "undefined";
      const hasEnd = typeof end !== "undefined";
      this.previousAudioEnd = this.currentAudioEnd;
      this.currentAudioBegin = void 0;
      this.currentAudioEnd = void 0;
      if (!hasBegin && !hasEnd) {
        if (urlObjFull.hash) {
          const matches = urlObjFull.hash.match(/t=([0-9.]+)(,([0-9.]+))?/);
          if (matches && matches.length >= 1) {
            const b = matches[1];
            try {
              this.currentAudioBegin = parseFloat(b);
            } catch (err) {
              import_loglevel11.default.error(err);
            }
            if (matches.length >= 3) {
              const e = matches[3];
              try {
                this.currentAudioEnd = parseFloat(e);
              } catch (err) {
                import_loglevel11.default.error(err);
              }
            }
          }
        }
      } else {
        this.currentAudioBegin = begin;
        this.currentAudioEnd = end;
      }
      import_loglevel11.default.log(
        `${urlFull} => [${this.currentAudioBegin}-${this.currentAudioEnd}]`
      );
      const playClip = async (initial) => {
        if (!this.audioElement) {
          return;
        }
        const timeToSeekTo = this.currentAudioBegin ? this.currentAudioBegin : 0;
        if (initial || this.audioElement.paused) {
          if (initial && !timeToSeekTo || this.audioElement.currentTime === timeToSeekTo) {
            import_loglevel11.default.log(
              "playMediaOverlaysAudio() - playClip() - _currentAudioElement.play()"
            );
            this.ensureOnTimeUpdate(false, false);
            this.audioElement.playbackRate = this.settings.rate;
            this.audioElement.volume = this.settings.volume;
            if (this.settings.playing) {
              let checkReady = function() {
                if (!self2.settings.resourceReady) {
                  setTimeout(checkReady, 200);
                } else {
                  setTimeout(async () => {
                    await self2.audioElement.play();
                    self2.ensureOnTimeUpdate(false, true);
                  }, self2.settings.wait * 1e3);
                }
              };
              let self2 = this;
              checkReady();
            }
          } else {
            import_loglevel11.default.log("playMediaOverlaysAudio() - playClip() - ontimeupdateSeeked");
            const ontimeupdateSeeked = async (_ev) => {
              this.audioElement.removeEventListener(
                "timeupdate",
                ontimeupdateSeeked
              );
              import_loglevel11.default.log(
                "playMediaOverlaysAudio() - playClip() - ontimeupdateSeeked - .play()"
              );
              this.ensureOnTimeUpdate(false, false);
              if (this.audioElement) {
                this.audioElement.playbackRate = this.settings.rate;
                this.audioElement.volume = this.settings.volume;
                if (this.settings.playing) {
                  let checkReady = function() {
                    if (!self2.settings.resourceReady) {
                      setTimeout(checkReady, 200);
                    } else {
                      setTimeout(async () => {
                        await self2.audioElement.play();
                        self2.ensureOnTimeUpdate(false, true);
                      }, self2.settings.wait * 1e3);
                    }
                  };
                  let self2 = this;
                  checkReady();
                }
              }
            };
            this.audioElement.addEventListener("timeupdate", ontimeupdateSeeked);
            this.audioElement.currentTime = timeToSeekTo;
          }
        } else {
          const contiguous = this.previousAudioUrl === this.currentAudioUrl && typeof this.previousAudioEnd !== "undefined" && this.previousAudioEnd > timeToSeekTo - 0.02 && this.previousAudioEnd <= timeToSeekTo && this.audioElement.currentTime >= timeToSeekTo - 0.1;
          this.ensureOnTimeUpdate(false, false);
          if (contiguous) {
            import_loglevel11.default.log("playMediaOverlaysAudio() - playClip() - ensureOnTimeUpdate");
          } else {
            import_loglevel11.default.log(
              "playMediaOverlaysAudio() - playClip() - currentTime = timeToSeekTo"
            );
            this.audioElement.currentTime = timeToSeekTo;
          }
        }
      };
      this.previousAudioUrl = this.currentAudioUrl;
      if (!this.currentAudioUrl || urlNoQuery !== this.currentAudioUrl) {
        this.currentAudioUrl = urlNoQuery;
        import_loglevel11.default.log(
          "playMediaOverlaysAudio() - RESET: " + this.previousAudioUrl + " => " + this.currentAudioUrl
        );
        this.audioElement = document.getElementById(
          "AUDIO_MO_ID"
        );
        if (this.audioElement) {
          this.audioElement.pause();
          this.audioElement.setAttribute("src", "");
          if (this.audioElement.parentNode) {
            this.audioElement.parentNode.removeChild(this.audioElement);
          }
        }
        this.audioElement = document.createElement("audio");
        this.audioElement.setAttribute("style", "display: none");
        this.audioElement.setAttribute("id", "AUDIO_MO_ID");
        this.audioElement.setAttribute("role", "media-overlays");
        this.audioElement.volume = this.settings.volume;
        this.audioElement.playbackRate = this.settings.rate;
        document.body.appendChild(this.audioElement);
        this.audioElement.addEventListener("error", (ev) => {
          import_loglevel11.default.log(
            "-1) error: " + (this.currentAudioUrl !== ev.currentTarget.src ? this.currentAudioUrl + " -- " : "") + ev.currentTarget.src.substr(
              ev.currentTarget.src.lastIndexOf("/")
            )
          );
          if (this.audioElement && this.audioElement.error) {
            import_loglevel11.default.log(this.audioElement.error.code);
            import_loglevel11.default.log(this.audioElement.error.message);
          }
        });
        const oncanplaythrough = async (ev) => {
          const currentAudioElement = ev.currentTarget;
          currentAudioElement.removeEventListener(
            "canplaythrough",
            oncanplaythrough
          );
          import_loglevel11.default.log("oncanplaythrough");
          await playClip(true);
        };
        this.audioElement.addEventListener("canplaythrough", oncanplaythrough);
        const onended = async (_ev) => {
          import_loglevel11.default.log("onended");
          if (this.currentLinks.length > 1 && this.currentLinkIndex === 0) {
            this.currentLinkIndex++;
            await this.playLink();
          } else {
            if (this.settings.autoTurn && this.settings.playing) {
              this.audioElement.pause();
              this.navigator.nextResource();
            } else {
              this.stopReadAloud();
            }
          }
        };
        this.audioElement.addEventListener("ended", onended);
        this.audioElement.playbackRate = this.settings.rate;
        this.audioElement.setAttribute("src", this.currentAudioUrl);
      } else {
        import_loglevel11.default.log("playMediaOverlaysAudio() - playClip()");
        await playClip(false);
      }
    }
    async playMediaOverlays(textHref, rootMo, textFragmentIDChain) {
      import_loglevel11.default.log("playMediaOverlays()");
      let textFragmentIDChain_ = textFragmentIDChain ? textFragmentIDChain.filter((id2) => id2) : void 0;
      if (textFragmentIDChain_ && textFragmentIDChain_.length === 0) {
        textFragmentIDChain_ = void 0;
      }
      let moTextAudioPair = this.findDepthFirstTextAudioPair(
        textHref,
        rootMo,
        textFragmentIDChain_
      );
      if (!moTextAudioPair && textFragmentIDChain_) {
        import_loglevel11.default.log(
          "playMediaOverlays() - findDepthFirstTextAudioPair() SECOND CHANCE "
        );
        import_loglevel11.default.log(JSON.stringify(textFragmentIDChain_, null, 4));
        import_loglevel11.default.log(JSON.stringify(rootMo, null, 4));
        moTextAudioPair = this.findDepthFirstTextAudioPair(
          textHref,
          rootMo,
          void 0
        );
      }
      if (moTextAudioPair) {
        if (moTextAudioPair.Audio) {
          import_loglevel11.default.log("playMediaOverlays() - playMediaOverlaysAudio()");
          this.mediaOverlayRoot = rootMo;
          await this.playMediaOverlaysAudio(
            moTextAudioPair,
            void 0,
            void 0
          );
        }
      } else {
        import_loglevel11.default.log("playMediaOverlays() - !moTextAudioPair " + textHref);
      }
    }
    mediaOverlayHighlight(id2) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      import_loglevel11.default.log("moHighlight:  ## " + id2);
      let classActive = (_b = (_a = this.publication.Metadata) == null ? void 0 : _a.MediaOverlay) == null ? void 0 : _b.ActiveClass;
      if (!classActive) {
        classActive = this.settings.color;
      }
      const styleAttr = (_c = this.navigator.iframes[0].contentDocument) == null ? void 0 : _c.documentElement.getAttribute(
        "style"
      );
      const isNight = styleAttr ? styleAttr.indexOf("readium-night-on") > 0 : false;
      const isSepia = styleAttr ? styleAttr.indexOf("readium-sepia-on") > 0 : false;
      if ((((_d = this.publication.Metadata.Rendition) == null ? void 0 : _d.Layout) ?? "unknown") !== "fixed") {
        classActive = isNight || isSepia ? R2_MO_CLASS_ACTIVE : classActive ? classActive : R2_MO_CLASS_ACTIVE;
      }
      if (this.pid) {
        let prevElement;
        if (this.currentLinkIndex === 0) {
          prevElement = (_e = this.navigator.iframes[0].contentDocument) == null ? void 0 : _e.getElementById(
            this.pid
          );
        } else {
          prevElement = (_f = this.navigator.iframes[1].contentDocument) == null ? void 0 : _f.getElementById(
            this.pid
          );
        }
        if (prevElement) {
          prevElement.classList.remove(classActive);
        }
      }
      let current;
      if (id2) {
        if (this.currentLinkIndex === 0) {
          current = (_g = this.navigator.iframes[0].contentDocument) == null ? void 0 : _g.getElementById(id2);
        } else {
          current = (_h = this.navigator.iframes[1].contentDocument) == null ? void 0 : _h.getElementById(id2);
        }
        if (current) {
          current.classList.add(classActive);
        }
        this.pid = id2;
      }
      if (current && (((_i = this.publication.Metadata.Rendition) == null ? void 0 : _i.Layout) ?? "unknown") !== "fixed") {
        current.scrollIntoView({
          block: "center",
          behavior: "smooth"
        });
      }
    }
  };

  // src/modules/positions/TimelineModule.ts
  init_polyfills();
  var import_loglevel12 = __toESM(require_loglevel());
  var TimelineModule = class {
    static async create(config2) {
      const timeline = new this(config2.publication);
      await timeline.start();
      return timeline;
    }
    constructor(publication) {
      this.publication = publication;
    }
    async stop() {
      import_loglevel12.default.log("Timeline module stop");
    }
    async start() {
      this.timelineContainer = findElement(
        document,
        "#container-view-timeline"
      );
      this.positionSlider = findElement(
        document,
        "#positionSlider"
      );
      if (this.publication.positions) {
        if (this.positionSlider)
          this.positionSlider.style.display = "block";
      } else {
        if (this.positionSlider)
          this.positionSlider.style.display = "none";
      }
    }
    async initialize() {
      return new Promise(async (resolve) => {
        var _a;
        await document.fonts.ready;
        let locator = this.navigator.currentLocator();
        if (this.navigator.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
          if (this.positionSlider)
            this.positionSlider.value = (locator.locations.position ?? 0).toString();
          if (this.positionSlider)
            this.positionSlider.max = ((locator.locations.totalRemainingPositions ?? 0) + (locator.locations.position ?? 0)).toString();
        }
        if (this.timelineContainer) {
          this.timelineContainer.innerHTML = "";
        }
        (_a = this.publication.readingOrder) == null ? void 0 : _a.forEach((link) => {
          var _a2, _b;
          const linkHref = this.publication.getAbsoluteHref(link.Href);
          const tocItemAbs = this.publication.getTOCItemAbsolute(linkHref);
          const tocHref = (tocItemAbs == null ? void 0 : tocItemAbs.Href.indexOf("#")) !== -1 ? tocItemAbs == null ? void 0 : tocItemAbs.Href.slice(0, tocItemAbs == null ? void 0 : tocItemAbs.Href.indexOf("#")) : tocItemAbs.Href;
          const tocHrefAbs = this.publication.getAbsoluteHref(tocHref ?? "");
          var chapterHeight;
          if (this.publication.positions && ((_a2 = this.navigator.view) == null ? void 0 : _a2.layout) !== "fixed") {
            if (link.contentWeight) {
              chapterHeight = link.contentWeight;
            } else {
              chapterHeight = 1;
            }
          } else {
            chapterHeight = 100 / (((_b = this.publication.readingOrder) == null ? void 0 : _b.length) ?? 0);
          }
          var chapter = document.createElement("div");
          chapter.style.height = chapterHeight + "%";
          chapter.style.width = "100%";
          chapter.className = "chapter";
          if ((tocItemAbs == null ? void 0 : tocItemAbs.Title) !== void 0) {
            var tooltip = document.createElement("span");
            tooltip.innerHTML = tocItemAbs.Title;
            tooltip.className = "chapter-tooltip";
            chapter.appendChild(tooltip);
          }
          addEventListenerOptional(chapter, "click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            var position;
            if (this.publication.positions || this.navigator.rights.autoGeneratePositions && this.publication.positions) {
              position = {
                ...this.publication.positions.filter(
                  (el) => el.href === link.Href
                )[0]
              };
              position.href = this.publication.getAbsoluteHref(position.href);
            } else {
              position = {
                href: tocHrefAbs,
                locations: {
                  progression: 0
                },
                type: link.TypeLink,
                title: link.Title
              };
            }
            import_loglevel12.default.log(position);
            this.navigator.navigate(position);
          });
          if (tocHrefAbs === this.navigator.currentChapterLink.href) {
            chapter.className += " active";
          } else {
            chapter.className = chapter.className.replace(" active", "");
          }
          if (this.timelineContainer) {
            this.timelineContainer.appendChild(chapter);
          }
        });
        resolve();
      });
    }
  };

  // src/modules/protection/ContentProtectionModule.ts
  init_polyfills();
  var import_debounce3 = __toESM(require_debounce());

  // src/utils/index.ts
  init_polyfills();
  var import_loglevel13 = __toESM(require_loglevel());
  function delay(t, v) {
    return new Promise(function(resolve) {
      setTimeout(resolve.bind(null, v), t);
    });
  }
  var IS_DEV = true;
  import_loglevel13.default.setLevel(IS_DEV ? "trace" : "warn", true);

  // src/modules/protection/ContentProtectionModule.ts
  var import_devtools_detector = __toESM(require_devtools_detector());
  var import_loglevel14 = __toESM(require_loglevel());

  // node_modules/browserslist-useragent-regexp/dist/index.js
  init_polyfills();
  var import_browserslist = __toESM(require_browserslist(), 1);
  var import_regexp_tree = __toESM(require_regexp_tree3(), 1);

  // node_modules/ua-regexes-lite/index.js
  init_polyfills();
  var regexes = [
    {
      regex: /IE (\d+)\.(\d+)/,
      family: "ie",
      maxVersion: [
        7,
        Infinity,
        Infinity
      ]
    },
    /**
     * IE can be in Compatability Mode (IE 7.0)
     * so we need to check Trident version
     */
    {
      regex: /Trident\/4\.0/,
      family: "ie",
      version: [
        8,
        0,
        0
      ]
    },
    {
      regex: /Trident\/5\.0/,
      family: "ie",
      version: [
        9,
        0,
        0
      ]
    },
    {
      regex: /Trident\/6\.0/,
      family: "ie",
      version: [
        10,
        0,
        0
      ]
    },
    {
      regex: /Trident\/[78]\.0/,
      family: "ie",
      version: [
        11,
        0,
        0
      ]
    },
    {
      regex: /Edge?\/(\d+)(\.(\d+)|)(\.(\d+)|)/,
      family: "edge"
    },
    {
      regex: /Firefox\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "firefox"
    },
    {
      regex: /Chrom(ium|e)\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "chrome"
    },
    /**
     * Ignore Edge with EdgeHTML engine.
     */
    {
      regex: /Chrom(ium|e)\/(\d+)\.(\d+)(\.(\d+)|)([\d.]+$|.*Safari\/(?![\d.]+ Edge\/[\d.]+$))/,
      family: "chrome",
      maxVersion: [
        70,
        Infinity,
        Infinity
      ]
    },
    /**
     * Safari on iPad have desktop-like useragent
     * Some versions contains letter subversions
     */
    {
      regex: /Maci.+ Version\/(\d+)\.(\d+)([.,](\d+)|)( \(\w+\)|)( Mobile\/\w+|) Safari\//,
      family: "safari"
    },
    /**
     * Presto Opera
     */
    {
      regex: /Opera\/9\.80.+Version\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "opera",
      maxVersion: [
        12,
        15,
        0
      ]
    },
    /**
     * Chromium based Opera
     */
    {
      regex: /Chrome.+OPR\/(\d+)\.(\d+)\.(\d+)/,
      family: "opera",
      minVersion: [
        15,
        0,
        0
      ]
    },
    {
      regex: /(CPU[ +]OS|iPhone[ +]OS|CPU[ +]iPhone|CPU IPhone OS|CPU iPad OS)[ +]+(\d+)[_.](\d+)([_.](\d+)|)/,
      family: "ios_saf"
    },
    /**
     * Ignore IE Mobile 11
     */
    {
      regex: /[^e] (CPU[ +]OS|iPhone[ +]OS|CPU[ +]iPhone|CPU IPhone OS|CPU iPad OS)[ +]+(\d+)[_.](\d+)([_.](\d+)|)/,
      family: "ios_saf",
      version: [
        7,
        0,
        3
      ]
    },
    {
      regex: /Opera Mini/,
      family: "op_mini"
    },
    {
      regex: /Android Donut/,
      family: "android",
      version: [
        1,
        2,
        0
      ]
    },
    {
      regex: /Android Eclair/,
      family: "android",
      version: [
        2,
        1,
        0
      ]
    },
    {
      regex: /Android Froyo/,
      family: "android",
      version: [
        2,
        2,
        0
      ]
    },
    {
      regex: /Android Gingerbread/,
      family: "android",
      version: [
        2,
        3,
        0
      ]
    },
    {
      regex: /Android Honeycomb/,
      family: "android",
      version: [
        3,
        0,
        0
      ]
    },
    {
      regex: /Android:?[ /-](\d+)(\.(\d+)|)(\.(\d+)|)/,
      family: "android"
    },
    /**
     * Ignore IE Mobile 11
     */
    {
      regex: /Android:?[ /-](\d+)(\.(\d+)|)(\.(\d+)|);(?! ARM; Trident)/,
      family: "android",
      version: [
        4,
        0,
        0
      ]
    },
    {
      regex: /PlayBook.+RIM Tablet OS (\d+)\.(\d+)\.(\d+)/,
      family: "bb"
    },
    {
      regex: /(Black[bB]erry|BB10).+Version\/(\d+)\.(\d+)\.(\d+)/,
      family: "bb"
    },
    /**
     * Presto Opera Mobile
     */
    {
      regex: /Opera\/.+Opera Mobi.+Version\/(\d+)\.(\d+)/,
      family: "op_mob",
      maxVersion: [
        12,
        16,
        0
      ]
    },
    /**
     * Chromium based Opera Mobile
     */
    {
      regex: /Mobile Safari.+OPR\/(\d+)\.(\d+)\.(\d+)/,
      family: "op_mob",
      minVersion: [
        14,
        0,
        0
      ]
    },
    {
      regex: /Android.+Firefox\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "and_ff"
    },
    {
      regex: /Android.+Chrom(ium|e)\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "and_chr"
    },
    {
      regex: /IEMobile[ /](\d+)\.(\d+)/,
      family: "ie_mob"
    },
    {
      regex: /Android.+(UC? ?Browser|UCWEB|U3)[ /]?(\d+)\.(\d+)\.(\d+)/,
      family: "and_uc"
    },
    {
      regex: /SamsungBrowser\/(\d+)\.(\d+)/,
      family: "samsung"
    },
    {
      regex: /Android.+MQQBrowser\/(\d+)(\.(\d+)|)(\.(\d+)|)/,
      family: "and_qq"
    },
    {
      regex: /baidubrowser[/\s](\d+)(\.(\d+)|)(\.(\d+)|)/,
      family: "baidu"
    },
    {
      regex: /K[Aa][Ii]OS\/(\d+)\.(\d+)(\.(\d+)|)/,
      family: "kaios"
    }
  ];

  // node_modules/browserslist-useragent-regexp/dist/index.js
  function numbersToRanges(numbers) {
    if (typeof numbers === "number") {
      return numbers;
    }
    if (numbers.length === 1) {
      return numbers[0];
    }
    return [
      numbers[0],
      numbers[numbers.length - 1]
    ];
  }
  var SemverPart;
  (function(SemverPart2) {
    SemverPart2[SemverPart2["Major"] = 0] = "Major";
    SemverPart2[SemverPart2["Minor"] = 1] = "Minor";
    SemverPart2[SemverPart2["Patch"] = 2] = "Patch";
  })(SemverPart || (SemverPart = {}));
  function semverify(version2) {
    const versionParts = Array.isArray(version2) ? version2 : version2.toString().split(".");
    if (versionParts[0] === "all") {
      return [
        Infinity,
        0,
        0
      ];
    }
    let versionPart = null;
    let semverPart = null;
    const semver = [
      0,
      0,
      0
    ];
    for (let i = 0; i < 3; i++) {
      versionPart = versionParts[i];
      if (typeof versionPart === "undefined") {
        continue;
      }
      semverPart = typeof versionPart === "number" ? versionPart : parseInt(versionPart, 10);
      if (isNaN(semverPart)) {
        return null;
      }
      semver[i] = semverPart;
    }
    return semver;
  }
  function rangeSemver(from, to) {
    let partIndex = 0;
    const range = [];
    for (let i = 2; i >= 0; i--) {
      if (from[i] !== to[i]) {
        partIndex = i;
        break;
      }
    }
    for (let i1 = from[partIndex], max = to[partIndex]; i1 <= max; i1++) {
      range.push(from.map((v, j) => j === partIndex ? i1 : v));
    }
    return range;
  }
  function compareSemvers(a, b, options) {
    const [major, minor, patch] = a;
    const [majorBase, minorBase, patchBase] = b;
    const { ignoreMinor, ignorePatch, allowHigherVersions } = options;
    if (majorBase === Infinity) {
      return true;
    }
    const compareMinor = !ignoreMinor;
    const comparePatch = compareMinor && !ignorePatch;
    if (allowHigherVersions) {
      if (comparePatch && patch < patchBase || compareMinor && minor < minorBase) {
        return false;
      }
      return major >= majorBase;
    }
    if (comparePatch && patch !== patchBase || compareMinor && minor !== minorBase) {
      return false;
    }
    return major === majorBase;
  }
  function getRequiredSemverPartsCount(version2, options) {
    const { ignoreMinor, ignorePatch, allowZeroSubversions } = options;
    let shouldRepeatCount = ignoreMinor ? 1 : ignorePatch ? 2 : 3;
    if (allowZeroSubversions) {
      for (let i = shouldRepeatCount - 1; i > 0; i--) {
        if (version2[i] !== 0 || shouldRepeatCount === 1) {
          break;
        }
        shouldRepeatCount--;
      }
    }
    return shouldRepeatCount;
  }
  function parseBrowsersList(browsersList) {
    return browsersList.reduce((browsers, browser) => {
      const [family, versionString, versionStringTo] = browser.split(/ |-/);
      const version2 = semverify(versionString);
      const versions = !version2 ? [] : versionStringTo ? rangeSemver(version2, semverify(versionStringTo)) : [
        version2
      ];
      return versions.reduce((browsers2, semver) => {
        if (semver) {
          browsers2.push({
            family,
            version: semver
          });
        }
        return browsers2;
      }, browsers);
    }, []);
  }
  function getBrowsersList(options = {}) {
    const { browsers, ...browserslistOptions } = options;
    const browsersList = (0, import_browserslist.default)(browsers, browserslistOptions);
    const parsedBrowsers = parseBrowsersList(browsersList);
    return parsedBrowsers;
  }
  function compareArrays(a, b, from = 0) {
    const len = a.length;
    for (let i = from; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  function clone(value) {
    if (value === null || typeof value !== "object") {
      return value;
    }
    const copy = Array.isArray(value) ? [] : {};
    let i;
    for (i in value) {
      copy[i] = clone(value[i]);
    }
    return copy;
  }
  function concat(items) {
    return [].concat(...items);
  }
  function mergeBrowserVersions(browsers) {
    const merge = /* @__PURE__ */ new Map();
    browsers.forEach(({ family, version: version2 }) => {
      const versions = merge.get(family);
      if (versions) {
        const strVersion = version2.join(".");
        if (versions.every((_) => _.join(".") !== strVersion)) {
          versions.push(version2);
        }
        return;
      }
      merge.set(family, [
        version2
      ]);
    });
    merge.forEach((versions) => {
      versions.sort((a, b) => {
        for (const i in a) {
          if (a[i] !== b[i]) {
            return a[i] - b[i];
          }
        }
        return 0;
      });
    });
    return merge;
  }
  function versionsListToRanges(versions) {
    if (versions.length < 2) {
      return versions;
    }
    const max = versions.length + 1;
    const ranges = [];
    let prev = null;
    let current = versions[0];
    let major = [
      current[SemverPart.Major]
    ];
    let minor = [
      current[SemverPart.Minor]
    ];
    let patch = [
      current[SemverPart.Patch]
    ];
    let part = null;
    for (let i = 1; i < max; i++) {
      prev = versions[i - 1];
      current = versions[i] || [];
      for (let p = SemverPart.Major; p <= SemverPart.Patch; p++) {
        if ((p === part || part === null) && prev[p] + 1 === current[p] && compareArrays(prev, current, p + 1)) {
          part = p;
          if (p === SemverPart.Major) {
            major.push(current[SemverPart.Major]);
          } else {
            major = current[SemverPart.Major];
          }
          if (p === SemverPart.Minor) {
            minor.push(current[SemverPart.Minor]);
          } else {
            minor = current[SemverPart.Minor];
          }
          if (p === SemverPart.Patch) {
            patch.push(current[SemverPart.Patch]);
          } else {
            patch = current[SemverPart.Patch];
          }
          break;
        }
        if (part === p || prev[p] !== current[p]) {
          ranges.push([
            numbersToRanges(major),
            numbersToRanges(minor),
            numbersToRanges(patch)
          ]);
          major = [
            current[SemverPart.Major]
          ];
          minor = [
            current[SemverPart.Minor]
          ];
          patch = [
            current[SemverPart.Patch]
          ];
          part = null;
          break;
        }
      }
    }
    return ranges;
  }
  function AstRegExpNode(body) {
    return {
      type: "RegExp",
      body,
      flags: ""
    };
  }
  function AlternativeNode(...expressions) {
    const exps = concat(expressions).filter(Boolean);
    if (exps.length === 1) {
      return exps[0];
    }
    return {
      type: "Alternative",
      expressions: exps
    };
  }
  function SimpleCharNode(value) {
    return {
      type: "Char",
      kind: "simple",
      value: String(value),
      codePoint: NaN
    };
  }
  function MetaCharNode(value) {
    return {
      type: "Char",
      kind: "meta",
      value,
      codePoint: NaN
    };
  }
  function ClassRangeNode(from, to) {
    return {
      type: "ClassRange",
      from,
      to
    };
  }
  function CharacterClassNode(...expressions) {
    return {
      type: "CharacterClass",
      expressions: concat(expressions).filter(Boolean)
    };
  }
  function SimpleQuantifierNode(kind) {
    return {
      type: "Quantifier",
      kind,
      greedy: true
    };
  }
  function RangeQuantifierNode(from, to) {
    return {
      type: "Quantifier",
      kind: "Range",
      from,
      to,
      greedy: true
    };
  }
  function CapturingGroupNode(expression) {
    return {
      type: "Group",
      capturing: true,
      expression,
      number: null
    };
  }
  function RepetitionNode(expression, quantifier) {
    return {
      type: "Repetition",
      expression,
      quantifier
    };
  }
  function DisjunctionNode(...expressions) {
    const exprs = concat(expressions).filter(Boolean);
    if (exprs.length === 1) {
      return exprs[0];
    }
    const disjunction = {
      type: "Disjunction",
      left: null,
      right: exprs.pop()
    };
    exprs.reduceRight((disjunction2, expr, i) => {
      if (i === 0) {
        disjunction2.left = expr;
        return disjunction2;
      }
      disjunction2.left = {
        type: "Disjunction",
        left: null,
        right: expr
      };
      return disjunction2.left;
    }, disjunction);
    return disjunction;
  }
  function DisjunctionCapturingGroupNode(...expressions) {
    const expr = DisjunctionNode(...expressions);
    if (expr.type === "Disjunction") {
      return CapturingGroupNode(expr);
    }
    return expr;
  }
  function DigitPatternNode() {
    return MetaCharNode("\\d");
  }
  function NumberPatternNode(quantifier = SimpleQuantifierNode("+")) {
    const numberPattern = RepetitionNode(DigitPatternNode(), quantifier);
    return numberPattern;
  }
  function NumberCharsNode(value) {
    return AlternativeNode(Array.from(String(value), SimpleCharNode));
  }
  function isNumberPatternNode(node) {
    if (node.type === "Group" && node.expression.type === "Repetition") {
      const { expression, quantifier } = node.expression;
      return expression.type === "Char" && expression.value === "\\d" && quantifier.kind === "+" && quantifier.greedy;
    }
    return false;
  }
  function isCharNode(node, value) {
    if (node && node.type === "Char") {
      return typeof value === "undefined" || value instanceof RegExp && value.test(node.value) || String(value) === node.value;
    }
    return false;
  }
  function isDigitRangeNode(node) {
    if (node.type === "CharacterClass" && node.expressions.length === 1) {
      const [expression] = node.expressions;
      return expression.type === "ClassRange" && isCharNode(expression.from, /\d/) && isCharNode(expression.to, /\d/);
    }
    return false;
  }
  function isExpressionNode(node) {
    return node.type !== "RegExp" && node.type !== "ClassRange" && node.type !== "Quantifier";
  }
  function parseRegex(regex) {
    return typeof regex === "string" ? import_regexp_tree.default.parse(regex.replace(/^([^/])/, "/$1").replace(/([^/])$/, "$1/")) : regex instanceof RegExp ? import_regexp_tree.default.parse(regex) : regex;
  }
  function toRegex(src) {
    return typeof src === "string" ? new RegExp(src) : new RegExp(import_regexp_tree.default.generate(src.body), src.flags);
  }
  function toString(src) {
    return typeof src === "string" ? src : src instanceof RegExp ? src.toString() : import_regexp_tree.default.generate(src);
  }
  var classes = [
    "RegExp",
    "Disjunction",
    "Alternative",
    "Assertion",
    "Char",
    "CharacterClass",
    "ClassRange",
    "Backreference",
    "Group",
    "Repetition",
    "Quantifier"
  ];
  function visitors(visitors2) {
    const { every } = visitors2;
    if (!every) {
      return visitors2;
    }
    if (typeof every === "function") {
      return {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "*": every,
        ...visitors2
      };
    }
    return classes.reduce((newVisitors, className) => {
      const visitor = visitors2[className];
      const visitorPre = visitor ? "pre" in visitor ? visitor.pre : visitor : null;
      const visitorPost = visitor ? "post" in visitor ? visitor.post : null : null;
      newVisitors[className] = {
        pre(nodePath) {
          if (every.pre(nodePath) !== false && visitorPre) {
            return visitorPre(nodePath);
          }
          return true;
        },
        post(nodePath) {
          if (every.post(nodePath) !== false && visitorPost) {
            return visitorPost(nodePath);
          }
          return true;
        }
      };
      return newVisitors;
    }, {});
  }
  function optimizeRegex(regex) {
    const regexAst = import_regexp_tree.default.optimize(parseRegex(toString(regex))).getAST();
    import_regexp_tree.default.traverse(regexAst, {
      Group(nodePath) {
        const { parent, node } = nodePath;
        const { expression } = node;
        node.capturing = true;
        if (parent.type === "RegExp" || expression.type !== "Disjunction" && parent.type !== "Repetition" || expression.type === "Disjunction" && parent.type === "Disjunction") {
          nodePath.replace(nodePath.node.expression);
        }
      }
    });
    return regexAst;
  }
  function mergeDigits(a, b) {
    if (isCharNode(a) && isCharNode(b) && a.value === b.value) {
      return b;
    }
    if (isCharNode(a, /\d/) && isDigitRangeNode(b) && Number(b.expressions[0].from.value) - Number(a.value) === 1) {
      return {
        ...b,
        expressions: [
          {
            ...b.expressions[0],
            from: a
          }
        ]
      };
    }
    if (isDigitRangeNode(a) && isCharNode(b, /\d/) && Number(b.value) - Number(a.expressions[0].to.value) === 1) {
      return {
        ...a,
        expressions: [
          {
            ...a.expressions[0],
            to: b
          }
        ]
      };
    }
    return null;
  }
  function optimizeSegmentNumberPatterns(patterns) {
    return patterns.reduce((patterns2, node) => {
      const prevNode = patterns2[patterns2.length - 1];
      if (prevNode && node.type === "Alternative" && prevNode.type === "Alternative" && node.expressions.length === prevNode.expressions.length) {
        const merged = prevNode.expressions.reduceRight((exps, exp, i) => {
          if (!exps) {
            return exps;
          }
          const merged2 = mergeDigits(exp, node.expressions[i]);
          if (merged2) {
            exps.unshift(merged2);
          } else {
            return null;
          }
          return exps;
        }, []);
        if (merged) {
          node.expressions = merged;
          patterns2.pop();
        }
      }
      patterns2.push(node);
      return patterns2;
    }, []);
  }
  function numberToDigits(num) {
    return Array.from(num.toString(), Number);
  }
  function rayRangeDigitPattern(digit, includes) {
    const rangeStart = digit + Number(!includes);
    if (rangeStart === 0) {
      return DigitPatternNode();
    }
    if (rangeStart === 9) {
      return SimpleCharNode("9");
    }
    if (rangeStart > 9) {
      return null;
    }
    return CharacterClassNode(ClassRangeNode(SimpleCharNode(rangeStart), SimpleCharNode("9")));
  }
  function rayToNumberPatterns(from) {
    if (from === 0) {
      return [
        NumberPatternNode()
      ];
    }
    const digits = numberToDigits(from);
    const digitsCount = digits.length;
    const other = NumberPatternNode(RangeQuantifierNode(digitsCount + 1));
    const zeros = digitsCount - 1;
    if (from / Math.pow(10, zeros) === digits[0]) {
      return [
        AlternativeNode(rayRangeDigitPattern(digits[0], true), Array.from({
          length: zeros
        }, DigitPatternNode)),
        other
      ];
    }
    const raysNumberPatterns = digits.reduce((topNodes, _, i) => {
      const ri = digitsCount - i - 1;
      const d = i === 0;
      let prev = SimpleCharNode("");
      const nodes = digits.reduce((nodes2, digit, j) => {
        if (j < ri) {
          nodes2.push(SimpleCharNode(digit));
        } else if (prev) {
          if (j > ri) {
            nodes2.push(DigitPatternNode());
          } else {
            prev = rayRangeDigitPattern(digit, d);
            if (prev) {
              nodes2.push(prev);
            } else {
              return [];
            }
          }
        }
        return nodes2;
      }, []);
      if (nodes.length) {
        topNodes.push(nodes);
      }
      return topNodes;
    }, []);
    const numberPatterns = raysNumberPatterns.map((_) => AlternativeNode(_));
    numberPatterns.push(other);
    return numberPatterns;
  }
  function segmentRangeNumberPattern(from, to, zeros) {
    if (to < from) {
      return null;
    }
    const fromNode = SimpleCharNode(from);
    const toNode = SimpleCharNode(to);
    const zerosPrefix = typeof zeros === "number" && zeros > 0 ? Array.from({
      length: zeros
    }, () => SimpleCharNode(0)) : [];
    const addPrefix = zerosPrefix.length ? (node) => AlternativeNode(zerosPrefix, node) : (node) => node;
    if (from === to) {
      return addPrefix(fromNode);
    }
    if (from === 0 && to === 9) {
      return addPrefix(DigitPatternNode());
    }
    if (to - from === 1) {
      return addPrefix(CharacterClassNode(fromNode, toNode));
    }
    return addPrefix(CharacterClassNode(ClassRangeNode(fromNode, toNode)));
  }
  function splitToDecadeRanges(from, to) {
    const ranges = [];
    let num = from;
    let decade = 1;
    do {
      decade *= 10;
      if (num < decade) {
        ranges.push([
          num,
          Math.min(decade - 1, to)
        ]);
        num = decade;
      }
    } while (decade <= to);
    return ranges;
  }
  function splitCommonDiff(a, b) {
    const len = a.length;
    if (len !== b.length || a[0] !== b[0]) {
      return null;
    }
    let common = a[0].toString();
    let currA = 0;
    let currB = 0;
    let diffA = "";
    let diffB = "";
    for (let i = 1; i < len; i++) {
      currA = a[i];
      currB = b[i];
      if (currA === currB) {
        common += currA;
      } else {
        diffA += currA;
        diffB += currB;
      }
    }
    return [
      common,
      parseInt(diffA, 10),
      parseInt(diffB, 10)
    ];
  }
  function segmentToNumberPatterns(from, to, digitsInNumber = 0) {
    const fromDigits = numberToDigits(from);
    const digitsCount = fromDigits.length;
    if (from < 10 && to < 10 || from === to) {
      const zeros = digitsInNumber - digitsCount;
      return [
        segmentRangeNumberPattern(from, to, zeros)
      ];
    }
    const toDigits = numberToDigits(to);
    if (digitsCount !== toDigits.length) {
      const decadeRanges = splitToDecadeRanges(from, to);
      const parts = concat(decadeRanges.map(([from2, to2]) => segmentToNumberPatterns(from2, to2, digitsInNumber)));
      return parts;
    }
    const commonStart = splitCommonDiff(fromDigits, toDigits);
    if (Array.isArray(commonStart)) {
      const [common, from1, to1] = commonStart;
      const digitsInNumber1 = digitsCount - common.length;
      const diffParts = segmentToNumberPatterns(from1, to1, digitsInNumber1);
      return [
        AlternativeNode(Array.from(common, SimpleCharNode), DisjunctionCapturingGroupNode(diffParts))
      ];
    }
    const range = Array.from({
      length: digitsCount - 1
    });
    const middleSegment = segmentRangeNumberPattern(fromDigits[0] + 1, toDigits[0] - 1);
    const parts1 = [
      ...range.map((_, i) => {
        const ri = digitsCount - i - 1;
        const d = Number(i > 0);
        return AlternativeNode(fromDigits.map((digit, j) => {
          if (j < ri) {
            return SimpleCharNode(digit);
          }
          if (j > ri) {
            return segmentRangeNumberPattern(0, 9);
          }
          return segmentRangeNumberPattern(digit + d, 9);
        }));
      }),
      // but output more readable
      ...middleSegment ? [
        AlternativeNode(middleSegment, Array.from({
          length: digitsCount - 1
        }, () => DigitPatternNode()))
      ] : [],
      ...range.map((_, i) => {
        const ri = digitsCount - i - 1;
        const d = Number(i > 0);
        return AlternativeNode(toDigits.map((digit, j) => {
          if (j < ri) {
            return SimpleCharNode(digit);
          }
          if (j > ri) {
            return segmentRangeNumberPattern(0, 9);
          }
          return segmentRangeNumberPattern(0, digit - d);
        }));
      })
    ];
    return optimizeSegmentNumberPatterns(parts1);
  }
  function rangeToRegex(from, to = Infinity) {
    if (from === Infinity) {
      return NumberPatternNode();
    }
    const numberPatterns = to === Infinity ? rayToNumberPatterns(from) : segmentToNumberPatterns(from, to);
    const regex = DisjunctionCapturingGroupNode(numberPatterns);
    return regex;
  }
  function findMatchedVersions(minVersion, maxVersion, bases, options) {
    const compareOptions = {
      ...options,
      allowHigherVersions: true
    };
    const minComparator = (ver) => compareSemvers(ver, minVersion, compareOptions);
    const maxComparator = (ver) => compareSemvers(maxVersion, ver, compareOptions);
    const comparator = minVersion && maxVersion ? (ver) => minComparator(ver) && maxComparator(ver) : minVersion ? minComparator : maxVersion ? maxComparator : () => true;
    return bases.filter(comparator);
  }
  function getRegexesForBrowsers(browsers, options, targetRegexes = regexes) {
    const result = [];
    let prevFamily = "";
    let prevRegexIsGlobal = false;
    targetRegexes.forEach((regex) => {
      const requestVersions = browsers.get(regex.family);
      if (!requestVersions) {
        return;
      }
      let { version: version2, minVersion, maxVersion } = regex;
      if (version2) {
        minVersion = version2;
        maxVersion = version2;
      }
      let matchedVersions = findMatchedVersions(minVersion, maxVersion, requestVersions, options);
      if (matchedVersions.length) {
        if (prevFamily === regex.family && prevRegexIsGlobal) {
          version2 = void 0;
          minVersion = void 0;
          maxVersion = void 0;
          matchedVersions = requestVersions;
          result.pop();
        }
        result.push({
          ...regex,
          version: version2,
          minVersion,
          maxVersion,
          requestVersions,
          matchedVersions
        });
      }
      prevRegexIsGlobal = !version2 && !minVersion && !maxVersion;
      prevFamily = regex.family;
    });
    return result;
  }
  function compileRegex(regexes2) {
    const partsRegexes = regexes2.map(({ regexAst: regexAst2 }) => CapturingGroupNode(regexAst2.body));
    const regexAst = optimizeRegex(AstRegExpNode(DisjunctionCapturingGroupNode(partsRegexes)));
    return toRegex(regexAst);
  }
  function getNumberPatternsCount(regex) {
    const regexAst = parseRegex(regex);
    let count = 0;
    import_regexp_tree.default.traverse(regexAst, {
      Group(nodePath) {
        if (isNumberPatternNode(nodePath.node)) {
          count++;
        }
      }
    });
    return count;
  }
  function replaceNumberPatterns(regex, numbers, numberPatternsCount) {
    let regexAst = parseRegex(regex);
    const numbersToReplace = typeof numberPatternsCount === "number" && numberPatternsCount < numbers.length ? numbers.slice(0, numberPatternsCount) : numbers.slice();
    import_regexp_tree.default.traverse(regexAst, visitors({
      every() {
        return Boolean(numbersToReplace.length);
      },
      Group(nodePath) {
        if (isNumberPatternNode(nodePath.node) && numbersToReplace.length) {
          if (regexAst === nodePath.node) {
            regexAst = numbersToReplace.shift();
          } else {
            nodePath.replace(numbersToReplace.shift());
          }
          return false;
        }
        return true;
      }
    }));
    return regexAst;
  }
  function getNumberPatternsPart(regex, numberPatternsCount) {
    const regexAst = parseRegex(regex);
    const maxNumbersCount = Math.min(getNumberPatternsCount(regexAst), numberPatternsCount || Infinity);
    const expressions = [];
    let numbersCounter = 0;
    let containsNumberPattern = false;
    import_regexp_tree.default.traverse(regexAst, visitors({
      every: {
        pre({ node, parent }) {
          if (node === regexAst) {
            return true;
          }
          if (!isExpressionNode(node)) {
            return false;
          }
          if (parent === regexAst) {
            containsNumberPattern = false;
          }
          return numbersCounter < maxNumbersCount;
        },
        post({ node, parent }) {
          if (node !== regexAst && parent === regexAst && isExpressionNode(node) && (containsNumberPattern || numbersCounter > 0 && numbersCounter < maxNumbersCount)) {
            expressions.push(node);
          }
        }
      },
      Group(nodePath) {
        if (isNumberPatternNode(nodePath.node) && numbersCounter < maxNumbersCount) {
          containsNumberPattern = true;
          numbersCounter++;
          return false;
        }
        return true;
      }
    }));
    if (expressions.length === 1 && !isNumberPatternNode(expressions[0])) {
      return getNumberPatternsPart(expressions[0], maxNumbersCount);
    }
    return expressions;
  }
  function rangedSemverToRegex(rangedVersion, options) {
    const { ignoreMinor, ignorePatch, allowHigherVersions } = options;
    const ignoreIndex = rangedVersion[0] === Infinity ? 0 : ignoreMinor ? 1 : ignorePatch ? 2 : 3;
    if (allowHigherVersions) {
      const numberPatterns = [];
      let prevWasZero = true;
      let d = 0;
      let start = 0;
      const createMapper = (i) => (range, j) => {
        if (j >= ignoreIndex) {
          return NumberPatternNode();
        }
        start = Array.isArray(range) ? range[0] : range;
        if (j < i) {
          return NumberCharsNode(start);
        }
        if (j > i) {
          return NumberPatternNode();
        }
        return rangeToRegex(start + d);
      };
      for (let i = ignoreIndex - 1; i >= 0; i--) {
        if (prevWasZero && !rangedVersion[i]) {
          continue;
        }
        prevWasZero = false;
        numberPatterns.push(rangedVersion.map(createMapper(i)));
        d = 1;
      }
      return numberPatterns;
    }
    const numberPatterns1 = rangedVersion.map((range, i) => {
      if (i >= ignoreIndex) {
        return NumberPatternNode();
      }
      if (Array.isArray(range)) {
        return rangeToRegex(range[0], range[1]);
      }
      return NumberCharsNode(range);
    });
    return [
      numberPatterns1
    ];
  }
  function applyVersionsToRegex(regex, versions, options) {
    const { allowHigherVersions } = options;
    const regexAst = parseRegex(regex);
    const finalVersions = allowHigherVersions && versions.length ? [
      versions[0]
    ] : versions;
    const maxRequiredPartsCount = finalVersions.reduce((maxRequiredPartsCount2, version2) => Math.max(maxRequiredPartsCount2, getRequiredSemverPartsCount(version2, options)), 1);
    const numberPatternsPart = getNumberPatternsPart(regexAst, maxRequiredPartsCount);
    const versionsPart = DisjunctionCapturingGroupNode(...finalVersions.map((version2) => rangedSemverToRegex(version2, options).map((parts) => replaceNumberPatterns(AlternativeNode(clone(numberPatternsPart)), parts, maxRequiredPartsCount))));
    import_regexp_tree.default.traverse(regexAst, visitors({
      every(nodePath) {
        if (!numberPatternsPart.length) {
          return false;
        }
        if (nodePath.node === numberPatternsPart[0]) {
          if (numberPatternsPart.length === 1) {
            nodePath.replace(versionsPart);
          } else {
            nodePath.remove();
          }
          numberPatternsPart.shift();
        }
        return true;
      }
    }));
    return regexAst;
  }
  function applyVersionsToRegexes(browserRegexes, options) {
    return browserRegexes.map(({ regex: sourceRegex, version: version2, maxVersion, matchedVersions, ...other }) => {
      let regexAst = parseRegex(sourceRegex);
      if (!version2) {
        regexAst = applyVersionsToRegex(regexAst, versionsListToRanges(matchedVersions), {
          ...options,
          allowHigherVersions: !maxVersion && options.allowHigherVersions
        });
      }
      return {
        regex: null,
        sourceRegex,
        regexAst,
        version: version2,
        maxVersion,
        matchedVersions,
        ...other
      };
    });
  }
  var defaultOptions = {
    ignoreMinor: false,
    ignorePatch: true,
    allowZeroSubversions: false,
    allowHigherVersions: false
  };
  function getPreUserAgentRegexes(options = {}) {
    const finalOptions = {
      ...defaultOptions,
      ...options
    };
    const browsersList = getBrowsersList(finalOptions);
    const mergedBrowsers = mergeBrowserVersions(browsersList);
    const sourceRegexes = getRegexesForBrowsers(mergedBrowsers, finalOptions);
    const versionedRegexes = applyVersionsToRegexes(sourceRegexes, finalOptions);
    return versionedRegexes;
  }
  function getUserAgentRegex(options = {}) {
    return compileRegex(getPreUserAgentRegexes(options));
  }

  // src/modules/protection/ContentProtectionModule.ts
  var ContentProtectionModule = class {
    constructor(properties) {
      this.hasEventListener = false;
      this.isHacked = false;
      this.properties = properties;
    }
    static async setupPreloadProtection(config2) {
      if (this.isCurrentBrowserSupported(config2)) {
        if (config2.detectInspect) {
          await this.startInspectorProtection(config2);
        }
      } else {
        throw new Error("Browser not supported");
      }
    }
    static async create(config2) {
      const security = new this(config2);
      await security.start();
      return security;
    }
    static async startInspectorProtection(config2) {
      const onInspectorOpened = (isOpen) => {
        var _a;
        if (isOpen) {
          if (config2.clearOnInspect) {
            console.clear();
            window.localStorage.clear();
            window.sessionStorage.clear();
            window.location.replace(window.location.origin);
          }
          if (config2.detectInspect && typeof ((_a = config2.api) == null ? void 0 : _a.inspectDetected) === "function") {
            config2.api.inspectDetected();
          }
        }
      };
      (0, import_devtools_detector.addListener)(onInspectorOpened);
      (0, import_devtools_detector.launch)();
      await delay(config2.detectInspectInitDelay ?? 100);
    }
    static isCurrentBrowserSupported(config2) {
      if (!config2.enforceSupportedBrowsers) {
        return true;
      }
      let browsers = [];
      (config2.supportedBrowsers ?? []).forEach((browser) => {
        browsers.push("last 1 " + browser + " version");
      });
      const supportedBrowsers = getUserAgentRegex({
        browsers,
        allowHigherVersions: true
      });
      return supportedBrowsers.test(navigator.userAgent);
    }
    async start() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        this.wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        this.securityContainer = findElement(
          document,
          "#container-view-security"
        );
        var self2 = this;
        this.mutationObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            import_loglevel14.default.log(mutation.type);
            self2.isHacked = true;
          });
        });
      }
    }
    async stop() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      import_loglevel14.default.log("Protection module stop");
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        this.mutationObserver.disconnect();
      }
      if ((_b = this.properties) == null ? void 0 : _b.disableKeys) {
        removeEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.disableSave
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.disableSave
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.disableSave
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.disableSave
          );
        }
        removeEventListenerOptional(window, "keydown", this.disableSave);
        removeEventListenerOptional(document, "keydown", this.disableSave);
      }
      if ((_c = this.properties) == null ? void 0 : _c.disableCopy) {
        removeEventListenerOptional(
          this.navigator.mainElement,
          "copy",
          this.preventCopy
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "copy",
          this.preventCopy
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "copy",
            this.preventCopy
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "copy",
            this.preventCopy
          );
        }
        removeEventListenerOptional(window, "copy", this.preventCopy);
        removeEventListenerOptional(document, "copy", this.preventCopy);
        removeEventListenerOptional(
          this.navigator.mainElement,
          "cut",
          this.preventCopy
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "cut",
          this.preventCopy
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "cut",
            this.preventCopy
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "cut",
            this.preventCopy
          );
        }
        removeEventListenerOptional(window, "cut", this.preventCopy);
        removeEventListenerOptional(document, "cut", this.preventCopy);
        removeEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.preventCopyKey
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.preventCopyKey
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.preventCopyKey
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.preventCopyKey
          );
        }
        removeEventListenerOptional(window, "keydown", this.preventCopyKey);
        removeEventListenerOptional(document, "keydown", this.preventCopyKey);
      } else if ((_d = this.properties) == null ? void 0 : _d.canCopy) {
        removeEventListenerOptional(
          this.navigator.mainElement,
          "copy",
          this.restrictCopy
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "copy",
          this.restrictCopy
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "copy",
            this.restrictCopy
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "copy",
            this.restrictCopy
          );
        }
        removeEventListenerOptional(window, "copy", this.restrictCopy);
        removeEventListenerOptional(document, "copy", this.restrictCopy);
        removeEventListenerOptional(
          this.navigator.mainElement,
          "cut",
          this.restrictCopy
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "cut",
          this.restrictCopy
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "cut",
            this.restrictCopy
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "cut",
            this.restrictCopy
          );
        }
        removeEventListenerOptional(window, "cut", this.restrictCopy);
        removeEventListenerOptional(document, "cut", this.restrictCopy);
        removeEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.restrictCopyKey
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.restrictCopyKey
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.restrictCopyKey
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.restrictCopyKey
          );
        }
        removeEventListenerOptional(window, "keydown", this.restrictCopyKey);
        removeEventListenerOptional(document, "keydown", this.restrictCopyKey);
      }
      if ((_e = this.properties) == null ? void 0 : _e.disablePrint) {
        removeEventListenerOptional(
          this.navigator.mainElement,
          "beforeprint",
          this.beforePrint.bind(this)
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "beforeprint",
          this.beforePrint.bind(this)
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "beforeprint",
            this.beforePrint
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "beforeprint",
            this.beforePrint
          );
        }
        removeEventListenerOptional(window, "beforeprint", this.beforePrint);
        removeEventListenerOptional(document, "beforeprint", this.beforePrint);
        removeEventListenerOptional(
          this.navigator.mainElement,
          "afterprint",
          this.afterPrint.bind(this)
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "afterprint",
          this.afterPrint.bind(this)
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "afterprint",
            this.afterPrint.bind(this)
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "afterprint",
            this.afterPrint.bind(this)
          );
        }
        removeEventListenerOptional(
          window,
          "afterprint",
          this.afterPrint.bind(this)
        );
        removeEventListenerOptional(
          document,
          "afterprint",
          this.afterPrint.bind(this)
        );
      }
      if ((_f = this.properties) == null ? void 0 : _f.disableContextMenu) {
        removeEventListenerOptional(
          this.navigator.mainElement,
          "contextmenu",
          this.disableContext
        );
        removeEventListenerOptional(
          this.navigator.headerMenu,
          "contextmenu",
          this.disableContext
        );
        for (const iframe of this.navigator.iframes) {
          removeEventListenerOptional(
            iframe.contentDocument,
            "contextmenu",
            this.disableContext
          );
          removeEventListenerOptional(
            iframe.contentWindow,
            "contextmenu",
            this.disableContext
          );
        }
        removeEventListenerOptional(window, "contextmenu", this.disableContext);
        removeEventListenerOptional(document, "contextmenu", this.disableContext);
      }
      if ((_g = this.properties) == null ? void 0 : _g.hideTargetUrl) {
        this.hideTargetUrls(false);
      }
      if ((_h = this.properties) == null ? void 0 : _h.disableDrag) {
        this.preventDrag(false);
      }
      removeEventListenerOptional(
        this.wrapper,
        "scroll",
        this.handleScroll.bind(this)
      );
    }
    observe() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        if (this.securityContainer.hasAttribute("style")) {
          this.isHacked = true;
        }
        this.mutationObserver.disconnect();
        var config2 = { attributes: true, childList: true, characterData: true };
        this.mutationObserver.observe(this.securityContainer, config2);
      }
    }
    async deactivate() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        this.observe();
        this.rects.forEach(
          (rect) => this.deactivateRect(rect, this.securityContainer, this.isHacked)
        );
      }
    }
    async activate() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        this.observe();
        for (const iframe of this.navigator.iframes) {
          if (iframe.contentDocument) {
            const body = findRequiredIframeElement(
              iframe.contentDocument,
              "body"
            );
            this.rects = this.findRects(body);
            this.rects.forEach(
              (rect) => this.toggleRect(rect, this.securityContainer, this.isHacked)
            );
          }
        }
      }
    }
    setupEvents() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      if ((_a = this.properties) == null ? void 0 : _a.disableKeys) {
        addEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.disableSave
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.disableSave
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "keydown", this.disableSave);
          addEventListenerOptional(
            iframe.ownerDocument,
            "keydown",
            this.disableSave
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.disableSave
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.disableSave
          );
          addEventListenerOptional(
            (_b = iframe.contentWindow) == null ? void 0 : _b.document,
            "keydown",
            this.disableSave
          );
        }
        addEventListenerOptional(window, "keydown", this.disableSave);
        addEventListenerOptional(document, "keydown", this.disableSave);
      }
      if ((_c = this.properties) == null ? void 0 : _c.disableCopy) {
        addEventListenerOptional(
          this.navigator.mainElement,
          "copy",
          this.preventCopy
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "copy",
          this.preventCopy
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "copy", this.preventCopy);
          addEventListenerOptional(
            iframe.ownerDocument,
            "copy",
            this.preventCopy
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "copy",
            this.preventCopy
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "copy",
            this.preventCopy
          );
          addEventListenerOptional(
            (_d = iframe.contentWindow) == null ? void 0 : _d.document,
            "copy",
            this.preventCopy
          );
        }
        addEventListenerOptional(window, "copy", this.preventCopy);
        addEventListenerOptional(document, "copy", this.preventCopy);
        addEventListenerOptional(
          this.navigator.mainElement,
          "cut",
          this.preventCopy
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "cut",
          this.preventCopy
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "cut", this.preventCopy);
          addEventListenerOptional(iframe.ownerDocument, "cut", this.preventCopy);
          addEventListenerOptional(
            iframe.contentDocument,
            "cut",
            this.preventCopy
          );
          addEventListenerOptional(iframe.contentWindow, "cut", this.preventCopy);
          addEventListenerOptional(
            (_e = iframe.contentWindow) == null ? void 0 : _e.document,
            "cut",
            this.preventCopy
          );
        }
        addEventListenerOptional(window, "cut", this.preventCopy);
        addEventListenerOptional(document, "cut", this.preventCopy);
        addEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.preventCopyKey
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.preventCopyKey
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "keydown", this.preventCopyKey);
          addEventListenerOptional(
            iframe.ownerDocument,
            "keydown",
            this.preventCopyKey
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.preventCopyKey
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.preventCopyKey
          );
          addEventListenerOptional(
            (_f = iframe.contentWindow) == null ? void 0 : _f.document,
            "keydown",
            this.preventCopyKey
          );
        }
        addEventListenerOptional(window, "keydown", this.preventCopyKey);
        addEventListenerOptional(document, "keydown", this.preventCopyKey);
      } else if ((_g = this.properties) == null ? void 0 : _g.canCopy) {
        addEventListenerOptional(
          this.navigator.mainElement,
          "copy",
          this.restrictCopy.bind(this)
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "copy",
          this.restrictCopy.bind(this)
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "copy", this.restrictCopy);
          addEventListenerOptional(
            iframe.ownerDocument,
            "copy",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "copy",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "copy",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            (_h = iframe.contentWindow) == null ? void 0 : _h.document,
            "copy",
            this.restrictCopy.bind(this)
          );
        }
        addEventListenerOptional(window, "copy", this.restrictCopy.bind(this));
        addEventListenerOptional(document, "copy", this.restrictCopy.bind(this));
        addEventListenerOptional(
          this.navigator.mainElement,
          "cut",
          this.restrictCopy.bind(this)
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "cut",
          this.restrictCopy.bind(this)
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "cut", this.restrictCopy.bind(this));
          addEventListenerOptional(
            iframe.ownerDocument,
            "cut",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "cut",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "cut",
            this.restrictCopy.bind(this)
          );
          addEventListenerOptional(
            (_i = iframe.contentWindow) == null ? void 0 : _i.document,
            "cut",
            this.restrictCopy.bind(this)
          );
        }
        addEventListenerOptional(window, "cut", this.restrictCopy.bind(this));
        addEventListenerOptional(document, "cut", this.restrictCopy.bind(this));
        addEventListenerOptional(
          this.navigator.mainElement,
          "keydown",
          this.restrictCopyKey.bind(this)
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "keydown",
          this.restrictCopyKey.bind(this)
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(
            iframe,
            "keydown",
            this.restrictCopyKey.bind(this)
          );
          addEventListenerOptional(
            iframe.ownerDocument,
            "keydown",
            this.restrictCopyKey.bind(this)
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "keydown",
            this.restrictCopyKey.bind(this)
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "keydown",
            this.restrictCopyKey.bind(this)
          );
          addEventListenerOptional(
            (_j = iframe.contentWindow) == null ? void 0 : _j.document,
            "keydown",
            this.restrictCopyKey.bind(this)
          );
        }
        addEventListenerOptional(
          window,
          "keydown",
          this.restrictCopyKey.bind(this)
        );
        addEventListenerOptional(
          document,
          "keydown",
          this.restrictCopyKey.bind(this)
        );
      }
      if ((_k = this.properties) == null ? void 0 : _k.disablePrint) {
        addEventListenerOptional(
          this.navigator.mainElement,
          "beforeprint",
          this.beforePrint
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "beforeprint",
          this.beforePrint
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(
            iframe,
            "beforeprint",
            this.beforePrint.bind(this)
          );
          addEventListenerOptional(
            iframe.ownerDocument,
            "beforeprint",
            this.beforePrint.bind(this)
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "beforeprint",
            this.beforePrint.bind(this)
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "beforeprint",
            this.beforePrint.bind(this)
          );
          addEventListenerOptional(
            (_l = iframe.contentWindow) == null ? void 0 : _l.document,
            "beforeprint",
            this.beforePrint.bind(this)
          );
        }
        addEventListenerOptional(
          window,
          "beforeprint",
          this.beforePrint.bind(this)
        );
        addEventListenerOptional(
          document,
          "beforeprint",
          this.beforePrint.bind(this)
        );
        addEventListenerOptional(
          this.navigator.mainElement,
          "afterprint",
          this.afterPrint
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "afterprint",
          this.afterPrint
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(
            iframe,
            "afterprint",
            this.afterPrint.bind(this)
          );
          addEventListenerOptional(
            iframe.ownerDocument,
            "afterprint",
            this.afterPrint.bind(this)
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "afterprint",
            this.afterPrint.bind(this)
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "afterprint",
            this.afterPrint.bind(this)
          );
          addEventListenerOptional(
            (_m = iframe.contentWindow) == null ? void 0 : _m.document,
            "afterprint",
            this.afterPrint.bind(this)
          );
        }
        addEventListenerOptional(
          window,
          "afterprint",
          this.afterPrint.bind(this)
        );
        addEventListenerOptional(
          document,
          "afterprint",
          this.afterPrint.bind(this)
        );
      }
      if ((_n = this.properties) == null ? void 0 : _n.disableContextMenu) {
        addEventListenerOptional(
          this.navigator.mainElement,
          "contextmenu",
          this.disableContext
        );
        addEventListenerOptional(
          this.navigator.headerMenu,
          "contextmenu",
          this.disableContext
        );
        for (const iframe of this.navigator.iframes) {
          addEventListenerOptional(iframe, "contextmenu", this.disableContext);
          addEventListenerOptional(
            iframe.ownerDocument,
            "contextmenu",
            this.disableContext
          );
          addEventListenerOptional(
            iframe.contentDocument,
            "contextmenu",
            this.disableContext
          );
          addEventListenerOptional(
            iframe.contentWindow,
            "contextmenu",
            this.disableContext
          );
          addEventListenerOptional(
            (_o = iframe.contentWindow) == null ? void 0 : _o.document,
            "contextmenu",
            this.disableContext
          );
        }
        addEventListenerOptional(window, "contextmenu", this.disableContext);
        addEventListenerOptional(document, "contextmenu", this.disableContext);
      }
    }
    initializeResource() {
      var _a, _b;
      if ((_a = this.properties) == null ? void 0 : _a.hideTargetUrl) {
        this.hideTargetUrls(true);
      }
      if ((_b = this.properties) == null ? void 0 : _b.disableDrag) {
        this.preventDrag(true);
      }
    }
    async initialize() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        return new Promise(async (resolve) => {
          await document.fonts.ready;
          for (const iframe of this.navigator.iframes) {
            if (iframe.contentDocument) {
              const body = findRequiredIframeElement(
                iframe.contentDocument,
                "body"
              );
              this.observe();
              setTimeout(() => {
                this.rects = this.findRects(body);
                this.rects.forEach(
                  (rect) => this.toggleRect(rect, this.securityContainer, this.isHacked)
                );
                this.setupEvents();
                if (!this.hasEventListener) {
                  this.hasEventListener = true;
                  addEventListenerOptional(
                    this.wrapper,
                    "scroll",
                    this.handleScroll.bind(this)
                  );
                }
                resolve();
              }, 10);
            }
          }
        });
      }
    }
    handleScroll() {
      this.rects.forEach(
        (rect) => this.toggleRect(rect, this.securityContainer, this.isHacked)
      );
    }
    handleResize() {
      var _a;
      if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
        const onDoResize = (0, import_debounce3.debounce)(() => {
          this.calcRects(this.rects);
          if (this.rects !== void 0) {
            this.rects.forEach(
              (rect) => this.toggleRect(rect, this.securityContainer, this.isHacked)
            );
          }
        }, 10);
        if (this.rects) {
          this.observe();
          onDoResize();
        }
      }
    }
    disableContext(e) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
    disableSave(event) {
      if (navigator.platform === "MacIntel" || navigator.platform.match("Mac") ? event.metaKey : event.ctrlKey && (event.key === "s" || event.keyCode === 83)) {
        event.preventDefault();
        event.stopPropagation();
        return false;
      }
      return true;
    }
    preventCopy(event) {
      import_loglevel14.default.log("copy action initiated");
      event.clipboardData.setData("text/plain", "copy not allowed");
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    preventCopyKey(event) {
      if (navigator.platform === "MacIntel" || navigator.platform.match("Mac") ? event.metaKey : event.ctrlKey && (event.key === "c" || event.keyCode === 67)) {
        event.preventDefault();
        event.stopPropagation();
        return false;
      }
      return true;
    }
    restrictCopy(event) {
      var _a, _b, _c, _d;
      if (this.citation) {
        return;
      }
      import_loglevel14.default.log("copy action initiated");
      let win = this.navigator.iframes[0].contentWindow;
      if (win) {
        let getCssSelector = function(element) {
          const options = {
            className: (str) => {
              return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
            },
            idName: (str) => {
              return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
            }
          };
          let doc = self2.navigator.iframes[0].contentDocument;
          if (doc) {
            return uniqueCssSelector(element, doc, options);
          } else {
            return void 0;
          }
        };
        let self2 = this;
        let selectionInfo = getCurrentSelectionInfo(win, getCssSelector);
        if (selectionInfo === void 0) {
          let doc = this.navigator.iframes[0].contentDocument;
          selectionInfo = (_b = (_a = this.navigator.annotationModule) == null ? void 0 : _a.annotator) == null ? void 0 : _b.getTemporarySelectionInfo(
            doc
          );
        }
        event.clipboardData.setData(
          "text/plain",
          (_d = selectionInfo == null ? void 0 : selectionInfo.cleanText) == null ? void 0 : _d.substring(
            0,
            ((_c = this.properties) == null ? void 0 : _c.charactersToCopy) ?? 0
          )
        );
      } else {
        event.clipboardData.setData("text/plain", "");
      }
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    restrictCopyKey(event) {
      var _a, _b, _c, _d;
      if (navigator.platform === "MacIntel" || navigator.platform.match("Mac") ? event.metaKey : event.ctrlKey && (event.key === "c" || event.keyCode === 67)) {
        let win = this.navigator.iframes[0].contentWindow;
        if (win) {
          let getCssSelector = function(element) {
            const options = {
              className: (str) => {
                return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
              },
              idName: (str) => {
                return _blacklistIdClassForCssSelectors.indexOf(str) < 0;
              }
            };
            let doc = self2.navigator.iframes[0].contentDocument;
            if (doc) {
              return uniqueCssSelector(element, doc, options);
            } else {
              return void 0;
            }
          };
          let self2 = this;
          let selectionInfo = getCurrentSelectionInfo(win, getCssSelector);
          if (selectionInfo === void 0) {
            let doc = this.navigator.iframes[0].contentDocument;
            selectionInfo = (_b = (_a = this.navigator.annotationModule) == null ? void 0 : _a.annotator) == null ? void 0 : _b.getTemporarySelectionInfo(
              doc
            );
          }
          this.copyToClipboard(
            (_d = selectionInfo == null ? void 0 : selectionInfo.cleanText) == null ? void 0 : _d.substring(
              0,
              ((_c = this.properties) == null ? void 0 : _c.charactersToCopy) ?? 0
            )
          );
        } else {
          this.copyToClipboard("");
        }
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
      return true;
    }
    copyToClipboard(textToClipboard) {
      var _a;
      textToClipboard = textToClipboard.substring(
        0,
        ((_a = this.properties) == null ? void 0 : _a.charactersToCopy) ?? 0
      );
      if (window.clipboardData) {
        window.clipboardData.setData("text/plain", textToClipboard);
      } else {
        const forExecElement = this.createElementForExecCommand(textToClipboard);
        this.selectContent(forExecElement);
        try {
          if (window.netscape && netscape.security) {
            netscape.security.PrivilegeManager.enablePrivilege(
              "UniversalXPConnect"
            );
          }
          document.execCommand("copy", false);
        } catch (e) {
        }
        document.body.removeChild(forExecElement);
      }
    }
    createElementForExecCommand(textToClipboard) {
      const forExecElement = document.createElement("div");
      forExecElement.style.position = "absolute";
      forExecElement.style.left = "-10000px";
      forExecElement.style.top = "-10000px";
      forExecElement.innerHTML = textToClipboard;
      document.body.appendChild(forExecElement);
      forExecElement.contentEditable = true;
      return forExecElement;
    }
    selectContent(element) {
      const rangeToSelect = document.createRange();
      rangeToSelect.selectNodeContents(element);
      const selection = window.getSelection();
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(rangeToSelect);
    }
    beforePrint(event) {
      import_loglevel14.default.log("before print");
      if (this.navigator && this.navigator.headerMenu) {
        this.navigator.headerMenu.style.display = "none";
        this.navigator.mainElement.style.display = "none";
      }
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    afterPrint(event) {
      import_loglevel14.default.log("after print");
      if (this.navigator && this.navigator.headerMenu) {
        this.navigator.headerMenu.style.removeProperty("display");
        this.navigator.mainElement.style.removeProperty("display");
      }
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    hideTargetUrls(activate) {
      var _a;
      function onAElementClick(ev) {
        ev.preventDefault();
        const href = ev.currentTarget.getAttribute("data-href-resolved");
        const aElement = document.createElement("a");
        aElement.setAttribute("href", href);
        aElement.click();
      }
      for (const iframe of this.navigator.iframes) {
        const aElements = (_a = iframe.contentDocument) == null ? void 0 : _a.querySelectorAll("a");
        aElements == null ? void 0 : aElements.forEach((aElement) => {
          const dataHref = aElement.getAttribute("data-href");
          const href = aElement.getAttribute("href");
          if (!dataHref && href) {
            aElement.setAttribute("data-href", href);
            aElement.setAttribute("data-href-resolved", aElement.href);
          }
        });
        if (activate) {
          aElements == null ? void 0 : aElements.forEach((aElement) => {
            aElement.setAttribute("href", "");
            aElement.addEventListener("click", onAElementClick);
          });
        } else {
          aElements == null ? void 0 : aElements.forEach((aElement) => {
            const dataHref = aElement.getAttribute("data-href");
            if (dataHref) {
              aElement.setAttribute("href", dataHref);
            }
            aElement.removeEventListener("click", onAElementClick);
          });
        }
      }
    }
    preventDrag(activate) {
      var _a, _b, _c, _d, _e;
      const dragStyle = "-webkit-user-drag: none; -khtml-user-drag: none; -moz-user-drag: none; -ms-user-drag: none; user-drag: none; -webkit-pointer-events: none; -khtml-pointer-events: none; -moz-pointer-events: none; -ms-pointer-events: none; pointer-events: none;";
      const onDragstart = (evt) => {
        evt.preventDefault();
      };
      for (const iframe of this.navigator.iframes) {
        const bodyStyle = ((_a = iframe.contentDocument) == null ? void 0 : _a.body.getAttribute("style")) || "";
        if (activate) {
          (_b = iframe.contentDocument) == null ? void 0 : _b.body.addEventListener("dragstart", onDragstart);
          (_c = iframe.contentDocument) == null ? void 0 : _c.body.setAttribute(
            "style",
            bodyStyle + dragStyle
          );
        } else {
          (_d = iframe.contentDocument) == null ? void 0 : _d.body.removeEventListener(
            "dragstart",
            onDragstart
          );
          (_e = iframe.contentDocument) == null ? void 0 : _e.body.setAttribute(
            "style",
            bodyStyle.replace(dragStyle, "")
          );
        }
      }
    }
    recalculate(delay2 = 0) {
      return new Promise((resolve) => {
        var _a;
        if ((_a = this.properties) == null ? void 0 : _a.enableObfuscation) {
          const onDoResize = (0, import_debounce3.debounce)(() => {
            this.calcRects(this.rects);
            if (this.rects !== void 0) {
              this.rects.forEach(
                (rect) => this.toggleRect(rect, this.securityContainer, this.isHacked)
              );
            }
            resolve(true);
          }, delay2);
          if (this.rects) {
            this.observe();
            onDoResize();
          } else {
            resolve(false);
          }
        } else {
          resolve(false);
        }
      });
    }
    calcRects(rects) {
      if (rects !== void 0) {
        rects.forEach((rect) => {
          try {
            const { top, height, left, width } = this.measureTextNode(rect.node);
            rect.top = top;
            rect.height = height;
            rect.width = width;
            rect.left = left;
          } catch (error) {
            import_loglevel14.default.log("error " + error);
            import_loglevel14.default.log(rect);
            import_loglevel14.default.log(rect.node);
            import_loglevel14.default.log("scrambledTextContent " + rect.scrambledTextContent);
            import_loglevel14.default.log("textContent " + rect.textContent);
            import_loglevel14.default.log("isObfuscated " + rect.isObfuscated);
          }
        });
      }
    }
    deactivateRect(rect, securityContainer, isHacked) {
      const beingHacked = this.isBeingHacked(securityContainer);
      if (beingHacked || isHacked) {
        rect.node.textContent = rect.scrambledTextContent;
        rect.isObfuscated = true;
      } else {
        rect.node.textContent = rect.textContent;
        rect.isObfuscated = false;
      }
    }
    toggleRect(rect, securityContainer, isHacked) {
      const outsideViewport = this.isOutsideViewport(rect);
      const beingHacked = this.isBeingHacked(securityContainer);
      if (rect.isObfuscated && !outsideViewport && !beingHacked && !isHacked) {
        rect.node.textContent = rect.textContent;
        rect.isObfuscated = false;
      }
      if (!rect.isObfuscated && (outsideViewport || beingHacked || isHacked)) {
        rect.node.textContent = rect.scrambledTextContent;
        rect.isObfuscated = true;
      }
    }
    findRects(parent) {
      const textNodes = this.findTextNodes(parent);
      return textNodes.map((node) => {
        var _a, _b, _c, _d;
        const { top, height, left, width } = this.measureTextNode(node);
        const scrambled = node.parentElement && (((_a = this.properties) == null ? void 0 : _a.excludeNodes) && ((_b = this.properties) == null ? void 0 : _b.excludeNodes.indexOf(
          node.parentElement.nodeName.toLowerCase()
        )) > -1 || ((_c = node.parentElement) == null ? void 0 : _c.nodeName.toLowerCase()) === "option" || ((_d = node.parentElement) == null ? void 0 : _d.nodeName.toLowerCase()) === "script") ? node.textContent : this.obfuscateText(node.textContent ?? "");
        let rect = {
          top,
          height,
          width,
          left,
          node,
          textContent: node.textContent ?? "",
          scrambledTextContent: scrambled ?? "",
          isObfuscated: false
        };
        return rect;
      });
    }
    obfuscateText(text) {
      return this.scramble(text, true);
    }
    measureTextNode(node) {
      try {
        const range = document.createRange();
        range.selectNode(node);
        const rect = range.getBoundingClientRect();
        range.detach();
        return rect;
      } catch (error) {
        import_loglevel14.default.log("measureTextNode " + error);
        import_loglevel14.default.log("measureTextNode " + node);
        import_loglevel14.default.log(node.textContent);
      }
    }
    isBeingHacked(element) {
      if (element.style.animation || element.style.transition || element.style.position || element.hasAttribute("style")) {
        import_loglevel14.default.log("content being hacked");
        return true;
      }
      return false;
    }
    isOutsideViewport(rect) {
      const windowLeft = this.wrapper.scrollLeft;
      const windowRight = windowLeft + this.wrapper.clientWidth;
      const right = rect.left + rect.width;
      const bottom = rect.top + rect.height;
      const windowTop = this.wrapper.scrollTop;
      const windowBottom = windowTop + this.wrapper.clientHeight;
      const isAbove = bottom < windowTop;
      const isBelow = rect.top > windowBottom;
      const isLeft = right < windowLeft - window.innerWidth;
      const isRight = rect.left > windowRight + window.innerWidth;
      return isAbove || isBelow || isLeft || isRight;
    }
    findTextNodes(parentElement, nodes = []) {
      var _a;
      let element = parentElement.firstChild;
      while (element) {
        if (element.nodeType === 1) {
          this.findTextNodes(element, nodes);
        }
        if (element.nodeType === 3) {
          if ((_a = element.textContent) == null ? void 0 : _a.trim()) {
            nodes.push(element);
          }
        }
        element = element.nextSibling;
      }
      return nodes;
    }
    scramble(str, letters = false, paragraph = false) {
      var words = str.split(" ");
      function scramble(arr) {
        var len = arr.length;
        var swap;
        var i;
        while (len > 0) {
          i = Math.floor(Math.random() * len);
          len--;
          swap = arr[len];
          arr[len] = arr[i];
          arr[i] = swap;
        }
        return arr;
      }
      if (letters) {
        words = words.map(function(word) {
          return word.includes("-") ? word : scramble(word.split("")).join("");
        });
      }
      return paragraph ? scramble(words).join(" ") : words.join(" ");
    }
  };

  // src/modules/search/SearchModule.ts
  init_polyfills();
  var import_jscrypto = __toESM(require_jscrypto());

  // src/modules/search/searchWithDomSeek.ts
  init_polyfills();
  var collapseWhitespaces = (str) => {
    return str.replace(/\n/g, " ").replace(/\s\s+/g, " ");
  };
  var cleanupStr = (str) => {
    return collapseWhitespaces(str).trim();
  };
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reHasRegExpChar = RegExp(reRegExpChar.source);
  function escapeRegExp(str) {
    return str && reHasRegExpChar.test(str) ? str.replace(reRegExpChar, "\\$&") : str || "";
  }
  var _counter = 0;
  var counter = () => {
    return () => {
      return Number.isSafeInteger(++_counter) ? _counter : _counter = 1;
    };
  };
  var reset = () => {
    _counter = 0;
  };
  var getCount = counter();
  var getCssSelector_ = (doc) => (element) => {
    try {
      return uniqueCssSelector(element, doc, _getCssSelectorOptions);
    } catch (err) {
      console.error("uniqueCssSelector:", err);
      return "";
    }
  };
  async function searchDocDomSeek(searchInput, doc, href, title, fullWordSearch = false) {
    var _a, _b, _c;
    if (!doc) {
      return [];
    }
    const text = (_a = doc.body) == null ? void 0 : _a.textContent;
    if (!text) {
      return [];
    }
    searchInput = cleanupStr(searchInput);
    if (!searchInput.length) {
      return [];
    }
    const iter = doc.createNodeIterator(doc.body, NodeFilter.SHOW_TEXT, {
      acceptNode: (_node) => NodeFilter.FILTER_ACCEPT
    });
    let regexp = new RegExp(
      escapeRegExp(searchInput).replace(/ /g, "\\s+"),
      "gim"
    );
    if (fullWordSearch) {
      regexp = new RegExp(
        "\\b" + escapeRegExp(searchInput).replace(/ /g, "\\s+") + "\\b",
        "gim"
      );
    }
    const searchResults = [];
    const snippetLength = 100;
    const snippetLengthNormalized = 30;
    let accumulated = 0;
    let matches;
    while (matches = regexp.exec(text)) {
      let i = Math.max(0, matches.index - snippetLength);
      let l = Math.min(snippetLength, matches.index);
      let textBefore = collapseWhitespaces(text.substr(i, l));
      textBefore = textBefore.substr(textBefore.length - snippetLengthNormalized);
      i = regexp.lastIndex;
      l = Math.min(snippetLength, text.length - i);
      const textAfter = collapseWhitespaces(text.substr(i, l)).substr(
        0,
        snippetLengthNormalized
      );
      const range = new Range();
      let offset = matches.index;
      while (accumulated <= offset) {
        const nextNode = iter.nextNode();
        if (nextNode && nextNode.nodeValue) {
          accumulated += nextNode.nodeValue.length;
        }
      }
      let localOffset = iter.referenceNode.nodeValue ? ((_b = iter.referenceNode.nodeValue) == null ? void 0 : _b.length) - (accumulated - offset) : 0;
      range.setStart(iter.referenceNode, localOffset);
      offset = matches.index + matches[0].length;
      while (accumulated <= offset) {
        const nextNode = iter.nextNode();
        let nodeValue = nextNode == null ? void 0 : nextNode.nodeValue;
        if (nodeValue) {
          accumulated += nodeValue.length;
        }
      }
      localOffset = iter.referenceNode.nodeValue ? ((_c = iter.referenceNode.nodeValue) == null ? void 0 : _c.length) - (accumulated - offset) : 0;
      range.setEnd(iter.referenceNode, localOffset);
      if (!doc.getCssSelector) {
        doc.getCssSelector = getCssSelector_(doc);
      }
      const rangeInfo = convertRange(range, doc.getCssSelector);
      if (rangeInfo) {
        searchResults.push({
          textMatch: collapseWhitespaces(matches[0]),
          textBefore,
          textAfter,
          rangeInfo,
          href,
          title,
          uuid: getCount().toString()
        });
      }
    }
    return searchResults;
  }

  // src/modules/search/SearchModule.ts
  var import_loglevel15 = __toESM(require_loglevel());
  var SearchModule = class {
    constructor(publication, properties, highlighter, api, headerMenu) {
      this.currentChapterSearchResult = [];
      this.bookSearchResult = [];
      this.currentSearchHighlights = [];
      this.headerMenu = headerMenu;
      this.publication = publication;
      this.properties = properties;
      this.api = api;
      this.highlighter = highlighter;
    }
    static async create(config2) {
      const search = new this(
        config2.publication,
        config2,
        config2.highlighter,
        config2.api,
        config2.headerMenu
      );
      await search.start();
      return search;
    }
    async stop() {
      import_loglevel15.default.log("Search module stop");
      removeEventListenerOptional(
        this.searchInput,
        "keypress",
        this.handleSearch.bind(this)
      );
      removeEventListenerOptional(
        this.searchGo,
        "click",
        this.handleSearch.bind(this)
      );
    }
    async start() {
      var _a;
      if (this.headerMenu) {
        this.searchInput = findElement(
          this.headerMenu,
          "#searchInput"
        );
        addEventListenerOptional(
          this.searchInput,
          "keypress",
          this.handleSearch.bind(this)
        );
        this.searchGo = findElement(this.headerMenu, "#searchGo");
        addEventListenerOptional(
          this.searchGo,
          "click",
          this.handleSearch.bind(this)
        );
        var menuSearch = findElement(
          this.headerMenu,
          "#menu-button-search"
        );
        if (menuSearch)
          (_a = menuSearch.parentElement) == null ? void 0 : _a.style.removeProperty("display");
      }
      setTimeout(() => {
        this.properties.hideLayer ? this.navigator.hideLayer("search") : this.navigator.showLayer("search");
      }, 10);
    }
    async handleSearch(event) {
      if (event.key === "Enter" || event.type === "click") {
        await this.handleSearchChapter();
        await this.handleSearchBook();
      }
    }
    async handleSearchChapter(index2) {
      var self2 = this;
      var searchVal = this.searchInput.value;
      let currentLocation = this.navigator.currentChapterLink.href;
      const spineItem = this.publication.getSpineItem(currentLocation);
      if (this.headerMenu) {
        var searchResultDiv = findElement(
          document,
          "#searchResultChapter"
        );
      }
      self2.currentChapterSearchResult = [];
      self2.currentSearchHighlights = [];
      var localSearchResultChapter = [];
      await this.searchAndPaintChapter(searchVal, index2, async (result) => {
        var _a;
        localSearchResultChapter = result;
        goToResultPage(1);
        if (this.navigator.rights.enableContentProtection) {
          (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(200);
        }
      });
      async function goToResultPage(page) {
        searchResultDiv.innerHTML = "";
        var paginated;
        paginated = self2.paginate(localSearchResultChapter, page, 10);
        if (paginated.total === 0) {
          const linkElement = document.createElement("a");
          linkElement.className = "collection-item";
          linkElement.innerHTML = "nothing found";
          searchResultDiv.appendChild(linkElement);
        } else {
          for (let index3 = 0; index3 < paginated.data.length; index3++) {
            const linkElement = document.createElement("a");
            const element = paginated.data[index3];
            linkElement.className = "collection-item";
            linkElement.href = (spineItem == null ? void 0 : spineItem.Href) ?? "";
            linkElement.innerHTML = "..." + element.textBefore + "<mark>" + element.textMatch + "</mark>" + element.textAfter + "...";
            addEventListenerOptional(
              linkElement,
              "click",
              (event) => {
                event.preventDefault();
                event.stopPropagation();
                self2.jumpToMark(index3 + page * 10 - 10);
              }
            );
            searchResultDiv.appendChild(linkElement);
          }
          let div = document.createElement("div");
          div.style.textAlign = "center";
          div.style.marginTop = "10px";
          let pagination = document.createElement("ul");
          pagination.className = "pagination";
          let previousResultPage = document.createElement("li");
          previousResultPage.className = "disabled";
          previousResultPage.innerHTML = '<a href="#!"> < </a>';
          if (paginated.pre_page !== void 0) {
            const pre_page = paginated.pre_page;
            previousResultPage.className = "waves-effect";
            addEventListenerOptional(
              previousResultPage,
              "click",
              (event) => {
                event.preventDefault();
                event.stopPropagation();
                goToResultPage(pre_page);
              }
            );
          }
          pagination.appendChild(previousResultPage);
          for (let index3 = 1; index3 <= paginated.total_pages; index3++) {
            let activeElement;
            let element = document.createElement("li");
            element.className = "waves-effect";
            if (index3 === paginated.page) {
              element.className = "active";
              activeElement = element;
            }
            element.innerHTML = '<a href="#!">' + index3 + "</a>";
            addEventListenerOptional(element, "click", (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (activeElement)
                activeElement.className = "waves-effect";
              element.className = "active";
              activeElement = element;
              goToResultPage(index3);
            });
            pagination.appendChild(element);
          }
          let nextResultPage = document.createElement("li");
          nextResultPage.className = "disabled";
          nextResultPage.innerHTML = '<a href="#!"> > </a>';
          if (paginated.next_page !== void 0) {
            const next_page = paginated.next_page;
            nextResultPage.className = "waves-effect";
            addEventListenerOptional(
              nextResultPage,
              "click",
              (event) => {
                event.preventDefault();
                event.stopPropagation();
                goToResultPage(next_page);
              }
            );
          }
          pagination.appendChild(nextResultPage);
          div.appendChild(pagination);
          searchResultDiv.appendChild(div);
        }
      }
    }
    // Search Current Resource
    async searchAndPaintChapter(term, index2 = 0, callback) {
      var _a, _b;
      if (this.navigator.rights.enableContentProtection) {
        (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.deactivate();
      }
      const linkHref = this.publication.getAbsoluteHref(
        this.publication.readingOrder[this.navigator.currentResource() ?? 0].Href
      );
      let tocItem = this.publication.getTOCItem(linkHref);
      if (tocItem === null) {
        tocItem = this.publication.readingOrder[this.navigator.currentResource() ?? 0];
      }
      let localSearchResultChapter = [];
      (_b = this.highlighter) == null ? void 0 : _b.destroyHighlights(1 /* Search */);
      if (this.navigator.rights.enableSearch) {
        this.drawSearch();
      }
      let i = 0;
      if (tocItem) {
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          if (tocItem) {
            searchDocDomSeek(term, doc, tocItem.Href, tocItem.Title).then(
              (result) => {
                result.forEach((searchItem) => {
                  let selectionInfo = {
                    rangeInfo: searchItem.rangeInfo
                  };
                  setTimeout(() => {
                    var _a2, _b2;
                    let highlight;
                    if (i === index2) {
                      highlight = this.createSearchHighlight(
                        selectionInfo,
                        (_a2 = this.properties) == null ? void 0 : _a2.current
                      );
                      this.jumpToMark(index2);
                    } else {
                      highlight = this.createSearchHighlight(
                        selectionInfo,
                        (_b2 = this.properties) == null ? void 0 : _b2.color
                      );
                    }
                    searchItem.highlight = highlight;
                    localSearchResultChapter.push(searchItem);
                    this.currentChapterSearchResult.push(searchItem);
                    this.currentSearchHighlights.push(highlight);
                    i++;
                  }, 500);
                });
                setTimeout(() => {
                  callback(localSearchResultChapter);
                }, 500);
              }
            );
          }
        }
      }
    }
    createSearchHighlight(selectionInfo, color) {
      var _a;
      try {
        var createColor = color;
        if (TextHighlighter.isHexColor(createColor)) {
          createColor = TextHighlighter.hexToRgbChannels(createColor);
        }
        const uniqueStr = `${selectionInfo.rangeInfo.startContainerElementCssSelector}${selectionInfo.rangeInfo.startContainerChildTextNodeIndex}${selectionInfo.rangeInfo.startOffset}${selectionInfo.rangeInfo.endContainerElementCssSelector}${selectionInfo.rangeInfo.endContainerChildTextNodeIndex}${selectionInfo.rangeInfo.endOffset}`;
        const sha256Hex = import_jscrypto.SHA256.hash(uniqueStr);
        const id2 = "R2_SEARCH_" + sha256Hex;
        var pointerInteraction = false;
        const highlight = {
          color: createColor ? createColor : DEFAULT_BACKGROUND_COLOR,
          id: id2,
          pointerInteraction,
          selectionInfo,
          marker: 0 /* Highlight */,
          type: 1 /* Search */
        };
        let highlightDom = (_a = this.highlighter) == null ? void 0 : _a.createHighlightDom(
          this.navigator.iframes[0].contentWindow,
          highlight
        );
        highlight.position = parseInt(
          ((highlightDom == null ? void 0 : highlightDom.hasChildNodes()) ? highlightDom.childNodes[0] : highlightDom).style.top.replace("px", "")
        );
        return highlight;
      } catch (e) {
        throw "Can't create highlight: " + e;
      }
    }
    clearSearch() {
      var _a;
      this.currentChapterSearchResult = [];
      this.currentSearchHighlights = [];
      (_a = this.highlighter) == null ? void 0 : _a.destroyHighlights(1 /* Search */);
    }
    async search(term, current) {
      this.currentChapterSearchResult = [];
      this.currentSearchHighlights = [];
      this.bookSearchResult = [];
      reset();
      await this.searchAndPaintChapter(term, 0, async () => {
        var _a;
        if (this.navigator.rights.enableContentProtection) {
          (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(200);
        }
      });
      if (current) {
        await this.searchBook(term);
        return await this.searchChapter(term);
      } else {
        await this.searchChapter(term);
        return await this.searchBook(term);
      }
    }
    async goToSearchID(href, index2, current) {
      var filteredIndex = index2;
      var item;
      let currentLocation = this.navigator.currentChapterLink.href;
      var absolutehref = this.publication.getAbsoluteHref(href);
      let filteredIndexes = this.bookSearchResult.filter(
        (el) => el.href === href
      );
      if (current) {
        item = this.currentChapterSearchResult.filter(
          (el) => el.uuid === index2
        )[0];
        filteredIndex = this.currentChapterSearchResult.findIndex(
          (el) => el.uuid === index2
        );
      } else {
        item = filteredIndexes.filter((el) => el.uuid === index2)[0];
        filteredIndex = filteredIndexes.findIndex((el) => el.uuid === index2);
      }
      if (item !== void 0) {
        if (currentLocation === absolutehref) {
          this.jumpToMark(filteredIndex);
        } else {
          let locations = {
            progression: 0
          };
          const position = {
            href: absolutehref,
            // type: link.type,
            locations,
            title: "title"
          };
          this.navigator.navigate(position);
          setTimeout(() => {
            this.searchAndPaintChapter(
              item.textMatch,
              filteredIndex,
              async () => {
                var _a;
                if (this.navigator.rights.enableContentProtection) {
                  (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(200);
                }
              }
            );
          }, 300);
        }
      }
    }
    async goToSearchIndex(href, index2, current) {
      var filteredIndex = index2;
      var item;
      let currentLocation = this.navigator.currentChapterLink.href;
      var absolutehref = this.publication.getAbsoluteHref(href);
      let filteredIndexes = this.bookSearchResult.filter(
        (el) => el.href === href
      );
      if (current) {
        item = this.currentChapterSearchResult[filteredIndex];
      } else {
        item = filteredIndexes[filteredIndex];
      }
      if (item !== void 0) {
        if (currentLocation === absolutehref) {
          this.jumpToMark(filteredIndex);
        } else {
          let locations = {
            progression: 0
          };
          const position = {
            href: absolutehref,
            // type: link.type,
            locations,
            title: "title"
          };
          this.navigator.navigate(position);
          setTimeout(() => {
            this.searchAndPaintChapter(
              item.textMatch,
              filteredIndex,
              async () => {
                var _a;
                if (this.navigator.rights.enableContentProtection) {
                  (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.recalculate(200);
                }
              }
            );
          }, 300);
        }
      }
    }
    async handleSearchBook() {
      var self2 = this;
      var searchVal = this.searchInput.value;
      if (self2.headerMenu) {
        var searchResultBook = findElement(
          document,
          "#searchResultBook"
        );
      }
      goToResultPage(1);
      async function goToResultPage(page) {
        searchResultBook.innerHTML = "";
        var paginated;
        var localSearchResultBook = await self2.searchBook(searchVal);
        paginated = self2.paginate(localSearchResultBook, page, 10);
        if (paginated.total === 0) {
          const linkElement = document.createElement("a");
          linkElement.className = "collection-item";
          linkElement.innerHTML = "nothing found";
          searchResultBook.appendChild(linkElement);
        } else {
          const paginatedGrouped = groupBy(paginated.data, (item) => item.href);
          paginatedGrouped.forEach((chapter) => {
            const divElement = document.createElement("div");
            divElement.style.marginBottom = "10px";
            if (chapter[0].title) {
              const spanElement = document.createElement("span");
              spanElement.className = "collection-item";
              spanElement.style.display = "block";
              spanElement.innerHTML = chapter[0].title;
              divElement.appendChild(spanElement);
            }
            searchResultBook.appendChild(divElement);
            chapter.forEach((searchItem) => {
              const linkElement = document.createElement("a");
              linkElement.className = "collection-item";
              var href = self2.publication.getAbsoluteHref(searchItem.href);
              linkElement.innerHTML = "..." + searchItem.textBefore + "<mark>" + searchItem.textMatch + "</mark>" + searchItem.textAfter + "...";
              addEventListenerOptional(
                linkElement,
                "click",
                (event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  let filteredIndexes = localSearchResultBook.filter(
                    (el) => el.href === searchItem.href
                  );
                  const filteredIndex = filteredIndexes.findIndex(
                    (el) => el === searchItem
                  );
                  let currentLocation = self2.navigator.currentChapterLink.href;
                  if (currentLocation === href) {
                    self2.jumpToMark(filteredIndex);
                  } else {
                    let locations = {
                      progression: 0
                    };
                    const position = {
                      href,
                      // type: link.type,
                      locations,
                      title: "title"
                    };
                    self2.navigator.navigate(position);
                    setTimeout(() => {
                      self2.handleSearchChapter(filteredIndex);
                    }, 300);
                  }
                }
              );
              divElement.appendChild(linkElement);
            });
          });
          let div = document.createElement("div");
          div.style.textAlign = "center";
          div.style.marginTop = "10px";
          let pagination = document.createElement("ul");
          pagination.className = "pagination";
          let previousResultPage = document.createElement("li");
          previousResultPage.className = "disabled";
          previousResultPage.innerHTML = '<a href="#!"> < </a>';
          if (paginated.pre_page != null) {
            let pre_page = paginated.pre_page;
            previousResultPage.className = "waves-effect";
            addEventListenerOptional(
              previousResultPage,
              "click",
              (event) => {
                event.preventDefault();
                event.stopPropagation();
                goToResultPage(pre_page);
              }
            );
          }
          pagination.appendChild(previousResultPage);
          for (let index2 = 1; index2 <= paginated.total_pages; index2++) {
            let activeElement;
            let element = document.createElement("li");
            element.className = "waves-effect";
            if (index2 === paginated.page) {
              element.className = "active";
              activeElement = element;
            }
            element.innerHTML = '<a href="#!">' + index2 + "</a>";
            addEventListenerOptional(element, "click", (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (activeElement)
                activeElement.className = "waves-effect";
              element.className = "active";
              activeElement = element;
              goToResultPage(index2);
            });
            pagination.appendChild(element);
          }
          let nextResultPage = document.createElement("li");
          nextResultPage.className = "disabled";
          nextResultPage.innerHTML = '<a href="#!"> > </a>';
          if (paginated.next_page != null) {
            let next_page = paginated.next_page;
            nextResultPage.className = "waves-effect";
            addEventListenerOptional(
              nextResultPage,
              "click",
              (event) => {
                event.preventDefault();
                event.stopPropagation();
                goToResultPage(next_page);
              }
            );
          }
          pagination.appendChild(nextResultPage);
          div.appendChild(pagination);
          searchResultBook.appendChild(div);
        }
      }
      function groupBy(list, getKey) {
        const map = /* @__PURE__ */ new Map();
        list.forEach((item) => {
          const key = getKey(item);
          const collection = map.get(key);
          if (!collection) {
            map.set(key, [item]);
          } else {
            collection.push(item);
          }
        });
        return Array.from(map.values());
      }
    }
    // Search Entire Book
    async searchBook(term) {
      var _a, _b;
      this.bookSearchResult = [];
      let localSearchResultBook = [];
      for (let index2 = 0; index2 < this.publication.readingOrder.length; index2++) {
        const linkHref = this.publication.getAbsoluteHref(
          this.publication.readingOrder ? this.publication.readingOrder[index2].Href : ""
        );
        let tocItem = this.publication.getTOCItem(linkHref);
        if (tocItem === void 0 && this.publication.readingOrder) {
          tocItem = this.publication.readingOrder[index2];
        }
        if (tocItem) {
          let href = this.publication.getAbsoluteHref(tocItem.Href);
          if ((_a = this.navigator.api) == null ? void 0 : _a.getContent) {
            await ((_b = this.navigator.api) == null ? void 0 : _b.getContent(href).then((content) => {
              let parser = new DOMParser();
              let doc = parser.parseFromString(content, "application/xhtml+xml");
              if (tocItem) {
                searchDocDomSeek(term, doc, tocItem.Href, tocItem.Title).then(
                  (result) => {
                    result.forEach((searchItem) => {
                      localSearchResultBook.push(searchItem);
                      this.bookSearchResult.push(searchItem);
                    });
                  }
                );
              }
            }));
          } else {
            await fetch(href, this.navigator.requestConfig).then((r) => r.text()).then(async (data) => {
              var _a2;
              let parser = new DOMParser();
              let doc = parser.parseFromString(
                ((_a2 = this.navigator.requestConfig) == null ? void 0 : _a2.encoded) ? this.decodeBase64(data) : data,
                "application/xhtml+xml"
              );
              if (tocItem) {
                searchDocDomSeek(term, doc, tocItem.Href, tocItem.Title).then(
                  (result) => {
                    result.forEach((searchItem) => {
                      localSearchResultBook.push(searchItem);
                      this.bookSearchResult.push(searchItem);
                    });
                  }
                );
              }
            });
          }
        }
        if (index2 === this.publication.readingOrder.length - 1) {
          return localSearchResultBook;
        }
      }
    }
    decodeBase64(base64) {
      const text = atob(base64);
      const length = text.length;
      const bytes = new Uint8Array(length);
      for (let i = 0; i < length; i++) {
        bytes[i] = text.charCodeAt(i);
      }
      const decoder = new TextDecoder();
      return decoder.decode(bytes);
    }
    async searchChapter(term) {
      var _a, _b;
      let localSearchResultBook = [];
      const linkHref = this.publication.getAbsoluteHref(
        this.publication.readingOrder[this.navigator.currentResource() ?? 0].Href
      );
      let tocItem = this.publication.getTOCItem(linkHref);
      if (tocItem === null) {
        tocItem = this.publication.readingOrder[this.navigator.currentResource() ?? 0];
      }
      if (tocItem) {
        let href = this.publication.getAbsoluteHref(tocItem.Href);
        if ((_a = this.navigator.api) == null ? void 0 : _a.getContent) {
          await ((_b = this.navigator.api) == null ? void 0 : _b.getContent(href).then((content) => {
            let parser = new DOMParser();
            let doc = parser.parseFromString(content, "application/xhtml+xml");
            if (tocItem) {
              searchDocDomSeek(term, doc, tocItem.Href, tocItem.Title).then(
                (result) => {
                  result.forEach((searchItem) => {
                    localSearchResultBook.push(searchItem);
                  });
                }
              );
            }
          }));
        } else {
          await fetch(href, this.navigator.requestConfig).then((r) => r.text()).then(async (data) => {
            var _a2;
            let parser = new DOMParser();
            let doc = parser.parseFromString(
              ((_a2 = this.navigator.requestConfig) == null ? void 0 : _a2.encoded) ? this.decodeBase64(data) : data,
              "application/xhtml+xml"
            );
            if (tocItem) {
              searchDocDomSeek(term, doc, tocItem.Href, tocItem.Title).then(
                (result) => {
                  result.forEach((searchItem) => {
                    localSearchResultBook.push(searchItem);
                  });
                }
              );
            }
          });
        }
      }
      return localSearchResultBook;
    }
    drawSearch() {
      setTimeout(() => {
        this.currentSearchHighlights = [];
        this.currentChapterSearchResult.forEach((searchItem) => {
          var _a, _b;
          let selectionInfo = {
            rangeInfo: searchItem.rangeInfo
          };
          if ((_a = this.properties) == null ? void 0 : _a.color) {
            let highlight = this.createSearchHighlight(
              selectionInfo,
              (_b = this.properties) == null ? void 0 : _b.color
            );
            searchItem.highlight = highlight;
            this.currentSearchHighlights.push(highlight);
          }
        });
      }, 100);
    }
    async handleResize() {
      var _a;
      await ((_a = this.highlighter) == null ? void 0 : _a.destroyHighlights(1 /* Search */));
      this.drawSearch();
    }
    jumpToMark(index2) {
      setTimeout(() => {
        var _a, _b, _c;
        if (this.currentChapterSearchResult.length) {
          var current = this.currentChapterSearchResult[index2];
          this.currentSearchHighlights.forEach((highlight) => {
            var _a2;
            var createColor = (_a2 = this.properties) == null ? void 0 : _a2.color;
            if (TextHighlighter.isHexColor(createColor)) {
              createColor = TextHighlighter.hexToRgbChannels(createColor);
            }
            highlight.color = createColor;
          });
          var currentColor = (_a = this.properties) == null ? void 0 : _a.current;
          if (TextHighlighter.isHexColor(currentColor)) {
            currentColor = TextHighlighter.hexToRgbChannels(currentColor);
          }
          current.highlight.color = currentColor;
          (_b = this.highlighter) == null ? void 0 : _b.setAndResetSearchHighlight(
            current.highlight,
            this.currentSearchHighlights
          );
          (_c = this.navigator.view) == null ? void 0 : _c.goToCssSelector(
            current.rangeInfo.startContainerElementCssSelector
          );
          this.navigator.updatePositionInfo();
        }
      }, 200);
    }
    paginate(items, page, per_page) {
      let _page = page || 1, _per_page = per_page || 10, offset = (_page - 1) * _per_page, paginatedItems = items.slice(offset).slice(0, _per_page), total_pages = Math.ceil(items.length / _per_page);
      return {
        page: _page,
        per_page: _per_page,
        pre_page: _page - 1 ? _page - 1 : void 0,
        next_page: total_pages > _page ? _page + 1 : void 0,
        total: items.length,
        total_pages,
        data: paginatedItems
      };
    }
  };

  // src/modules/TTS/TTSSettings.ts
  init_polyfills();
  var import_loglevel16 = __toESM(require_loglevel());
  var _TTSREFS = class _TTSREFS {
  };
  _TTSREFS.COLOR_REF = "color";
  _TTSREFS.AUTO_SCROLL_REF = "autoscroll";
  _TTSREFS.RATE_REF = "rate";
  _TTSREFS.PITCH_REF = "pitch";
  _TTSREFS.VOLUME_REF = "volume";
  _TTSREFS.VOICE_REF = "voice";
  _TTSREFS.COLOR_KEY = "tts-" + _TTSREFS.COLOR_REF;
  _TTSREFS.AUTO_SCROLL_KEY = "tts-" + _TTSREFS.AUTO_SCROLL_REF;
  _TTSREFS.RATE_KEY = "tts-" + _TTSREFS.RATE_REF;
  _TTSREFS.PITCH_KEY = "tts-" + _TTSREFS.PITCH_REF;
  _TTSREFS.VOLUME_KEY = "tts-" + _TTSREFS.VOLUME_REF;
  _TTSREFS.VOICE_KEY = "tts-" + _TTSREFS.VOICE_REF;
  var TTSREFS = _TTSREFS;
  var TTSSettings = class {
    constructor(store, api, headerMenu) {
      this.TTSSETTINGS = "ttsSetting";
      this.color = "orange";
      this.autoScroll = true;
      this.rate = 1;
      this.pitch = 1;
      this.volume = 1;
      this.voice = {
        usePublication: true
      };
      this.settingsChangeCallback = () => {
      };
      this.restartCallback = () => {
      };
      this.store = store;
      this.api = api;
      this.headerMenu = headerMenu;
      this.initialise();
    }
    static create(config2) {
      const settings = new this(config2.store, config2.api, config2.headerMenu);
      if (config2.initialTTSSettings) {
        let initialTTSSettings = config2.initialTTSSettings;
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.rate) {
          settings.rate = initialTTSSettings.rate;
          import_loglevel16.default.log(settings.rate);
        }
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.pitch) {
          settings.pitch = initialTTSSettings.pitch;
          import_loglevel16.default.log(settings.pitch);
        }
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.volume) {
          settings.volume = initialTTSSettings.volume;
          import_loglevel16.default.log(settings.volume);
        }
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.color) {
          settings.color = initialTTSSettings.color;
          import_loglevel16.default.log(settings.color);
        }
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.autoScroll) {
          settings.autoScroll = initialTTSSettings.autoScroll;
          import_loglevel16.default.log(settings.autoScroll);
        }
        if (initialTTSSettings == null ? void 0 : initialTTSSettings.voice) {
          settings.voice = initialTTSSettings.voice;
          import_loglevel16.default.log(settings.voice);
        }
      }
      settings.initializeSelections();
      return settings;
    }
    stop() {
      import_loglevel16.default.log("tts settings stop");
    }
    initialise() {
      this.autoScroll = this.getProperty(TTSREFS.AUTO_SCROLL_KEY) != null ? this.getProperty(TTSREFS.AUTO_SCROLL_KEY).value : this.autoScroll;
      this.rate = this.getProperty(TTSREFS.RATE_KEY) != null ? this.getProperty(TTSREFS.RATE_KEY).value : this.rate;
      this.pitch = this.getProperty(TTSREFS.PITCH_KEY) != null ? this.getProperty(TTSREFS.PITCH_KEY).value : this.pitch;
      this.volume = this.getProperty(TTSREFS.VOLUME_KEY) != null ? this.getProperty(TTSREFS.VOLUME_KEY).value : this.volume;
      this.color = this.getProperty(TTSREFS.COLOR_KEY) != null ? this.getProperty(TTSREFS.COLOR_KEY).value : this.color;
      this.voice = this.getProperty(TTSREFS.VOICE_REF) != null ? this.getProperty(TTSREFS.VOICE_REF).value : this.voice;
      this.userProperties = this.getTTSSettings();
    }
    reset() {
      this.color = "orange";
      this.autoScroll = true;
      this.rate = 1;
      this.pitch = 1;
      this.volume = 1;
      this.voice = {
        usePublication: true
      };
      this.userProperties = this.getTTSSettings();
    }
    initializeSelections() {
      if (this.headerMenu)
        this.settingsView = findElement(
          this.headerMenu,
          "#container-view-tts-settings"
        );
    }
    setControls() {
      if (this.settingsView)
        this.renderControls(this.settingsView);
    }
    renderControls(element) {
      if (this.headerMenu)
        this.speechRate = findElement(
          this.headerMenu,
          "#speechRate"
        );
      if (this.headerMenu)
        this.speechPitch = findElement(
          this.headerMenu,
          "#speechPitch"
        );
      if (this.headerMenu)
        this.speechVolume = findElement(
          this.headerMenu,
          "#speechVolume"
        );
      if (this.headerMenu)
        this.speechAutoScroll = findElement(
          this.headerMenu,
          "#autoScroll"
        );
      if (this.speechRate)
        this.speechRate.value = this.rate.toString();
      if (this.speechPitch)
        this.speechPitch.value = this.pitch.toString();
      if (this.speechVolume)
        this.speechVolume.value = this.volume.toString();
      if (this.speechAutoScroll)
        this.speechAutoScroll.checked = this.autoScroll;
      addEventListenerOptional(
        findElement(element, "ul"),
        "click",
        (event) => {
          event.stopPropagation();
        }
      );
    }
    onSettingsChange(callback) {
      this.settingsChangeCallback = callback;
    }
    onRestart(callback) {
      this.restartCallback = callback;
    }
    storeProperty(property) {
      this.updateUserSettings();
      this.saveProperty(property);
    }
    updateUserSettings() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var ttsSettings = {
        rate: (_a = this.userProperties.getByRef(TTSREFS.RATE_REF)) == null ? void 0 : _a.value,
        pitch: (_b = this.userProperties.getByRef(TTSREFS.PITCH_REF)) == null ? void 0 : _b.value,
        volume: (_c = this.userProperties.getByRef(TTSREFS.VOLUME_REF)) == null ? void 0 : _c.value,
        voice: (_d = this.userProperties.getByRef(TTSREFS.VOLUME_REF)) == null ? void 0 : _d.value,
        color: (_e = this.userProperties.getByRef(TTSREFS.COLOR_REF)) == null ? void 0 : _e.value,
        autoScroll: (_f = this.userProperties.getByRef(TTSREFS.AUTO_SCROLL_REF)) == null ? void 0 : _f.value
      };
      this.applyTTSSettings(ttsSettings);
      if ((_g = this.api) == null ? void 0 : _g.updateSettings) {
        (_h = this.api) == null ? void 0 : _h.updateSettings(ttsSettings).then(async (settings) => {
          import_loglevel16.default.log("api updated tts settings", settings);
        });
      }
    }
    getTTSSettings() {
      var userProperties = new UserProperties();
      userProperties.addSwitchable(
        "tts-auto-scroll-off",
        "tts-auto-scroll-on",
        this.autoScroll,
        TTSREFS.AUTO_SCROLL_REF,
        TTSREFS.AUTO_SCROLL_KEY
      );
      userProperties.addIncremental(
        this.rate,
        0.1,
        10,
        0.1,
        "",
        TTSREFS.RATE_REF,
        TTSREFS.RATE_KEY
      );
      userProperties.addIncremental(
        this.pitch,
        0.1,
        2,
        0.1,
        "",
        TTSREFS.PITCH_REF,
        TTSREFS.PITCH_KEY
      );
      userProperties.addIncremental(
        this.volume,
        0.1,
        1,
        0.1,
        "",
        TTSREFS.VOLUME_REF,
        TTSREFS.VOLUME_KEY
      );
      userProperties.addStringable(
        this.color,
        TTSREFS.COLOR_REF,
        TTSREFS.COLOR_KEY
      );
      userProperties.addJSONable(
        JSON.stringify(this.voice),
        TTSREFS.VOICE_REF,
        TTSREFS.VOICE_KEY
      );
      return userProperties;
    }
    saveProperty(property) {
      let savedProperties = this.store.get(this.TTSSETTINGS);
      if (savedProperties) {
        let array = JSON.parse(savedProperties);
        array = array.filter((el) => el.name !== property.name);
        array.push(property);
        this.store.set(this.TTSSETTINGS, JSON.stringify(array));
      } else {
        let array = [];
        array.push(property);
        this.store.set(this.TTSSETTINGS, JSON.stringify(array));
      }
      return property;
    }
    getProperty(name) {
      let array = this.store.get(this.TTSSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        properties = properties.filter((el) => el.name === name);
        if (properties.length === 0) {
          return void 0;
        }
        return properties[0];
      }
      return void 0;
    }
    resetTTSSettings() {
      this.store.remove(this.TTSSETTINGS);
      this.reset();
      this.settingsChangeCallback();
      this.restartCallback();
    }
    applyTTSSettings(ttsSettings) {
      if (ttsSettings.rate) {
        import_loglevel16.default.log("rate " + this.rate);
        this.rate = ttsSettings.rate;
        let prop = this.userProperties.getByRef(TTSREFS.RATE_REF);
        if (prop) {
          prop.value = this.rate;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
      if (ttsSettings.pitch) {
        import_loglevel16.default.log("pitch " + this.pitch);
        this.pitch = ttsSettings.pitch;
        let prop = this.userProperties.getByRef(TTSREFS.PITCH_REF);
        if (prop) {
          prop.value = this.pitch;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
      if (ttsSettings.volume) {
        import_loglevel16.default.log("volume " + this.volume);
        this.volume = ttsSettings.volume;
        let prop = this.userProperties.getByRef(TTSREFS.VOLUME_REF);
        if (prop) {
          prop.value = this.volume;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
      if (ttsSettings.color) {
        this.color = ttsSettings.color;
        let prop = this.userProperties.getByRef(TTSREFS.COLOR_REF);
        if (prop) {
          prop.value = this.color;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (ttsSettings.autoScroll !== void 0) {
        import_loglevel16.default.log("autoScroll " + this.autoScroll);
        this.autoScroll = ttsSettings.autoScroll;
        let prop = this.userProperties.getByRef(TTSREFS.AUTO_SCROLL_REF);
        if (prop) {
          prop.value = this.autoScroll;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
      }
      if (ttsSettings.voice) {
        import_loglevel16.default.log("voice " + this.voice);
        this.voice = ttsSettings.voice;
        let prop = this.userProperties.getByRef(TTSREFS.VOICE_REF);
        if (prop) {
          prop.value = this.voice;
          this.saveProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
    }
    applyPreferredVoice(value) {
      var name = value.indexOf(":") !== -1 ? value.slice(0, value.indexOf(":")) : void 0;
      var lang = value.indexOf(":") !== -1 ? value.slice(value.indexOf(":") + 1) : value;
      if (name !== void 0 && lang !== void 0) {
        this.applyTTSSettings({
          voice: {
            usePublication: true,
            name,
            lang
          }
        });
      } else if (lang !== void 0 && name === void 0) {
        this.applyTTSSettings({
          voice: { usePublication: true, lang }
        });
      }
    }
    increase(incremental) {
      if (incremental === "rate") {
        this.userProperties.getByRef(TTSREFS.RATE_REF).increment();
        let prop = this.userProperties.getByRef(TTSREFS.RATE_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      } else if (incremental === "pitch") {
        this.userProperties.getByRef(TTSREFS.PITCH_REF).increment();
        let prop = this.userProperties.getByRef(TTSREFS.PITCH_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      } else if (incremental === "volume") {
        this.userProperties.getByRef(TTSREFS.VOLUME_REF).increment();
        let prop = this.userProperties.getByRef(TTSREFS.VOLUME_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
    }
    decrease(incremental) {
      if (incremental === "rate") {
        this.userProperties.getByRef(TTSREFS.RATE_REF).decrement();
        let prop = this.userProperties.getByRef(TTSREFS.RATE_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      } else if (incremental === "pitch") {
        this.userProperties.getByRef(TTSREFS.PITCH_REF).decrement();
        let prop = this.userProperties.getByRef(TTSREFS.PITCH_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      } else if (incremental === "volume") {
        this.userProperties.getByRef(TTSREFS.VOLUME_REF).decrement();
        let prop = this.userProperties.getByRef(TTSREFS.VOLUME_REF);
        if (prop) {
          this.storeProperty(prop);
        }
        this.settingsChangeCallback();
        this.restartCallback();
      }
    }
  };

  // src/navigator/IFrameNavigator.ts
  init_polyfills();

  // src/utils/HTMLTemplates.ts
  init_polyfills();
  var readerLoading = `${icons.loading}`;
  var readerError = `
    <span>
    ${icons.error}
    </span>
    <span>There was an error loading this page.</span>
    <button id="r2d2bc-go-back">Go back</button>
    <button id="r2d2bc-try-again">Try again</button>
`;

  // src/navigator/IFrameNavigator.ts
  var import_debounce7 = __toESM(require_debounce());

  // src/utils/TouchEventHandler.ts
  init_polyfills();
  var _TouchEventHandler = class _TouchEventHandler {
    constructor(navigator2) {
      this.onBackwardSwipe = () => {
      };
      this.onForwardSwipe = () => {
      };
      this.setupEvents = (element) => {
        let touchEventStart = null;
        let touchEventEnd = null;
        let self2 = this;
        if (element) {
          element.addEventListener(
            "touchstart",
            function(event) {
              if (event.changedTouches.length !== 1) {
                return;
              }
              touchEventStart = event;
            },
            false
          );
          element.addEventListener(
            "touchend",
            function(event) {
              if (event.changedTouches.length !== 1) {
                return;
              }
              if (!touchEventStart) {
                return;
              }
              const startTouch = touchEventStart.changedTouches[0];
              const endTouch = event.changedTouches[0];
              if (!startTouch) {
                return;
              }
              const devicePixelRatio = window.devicePixelRatio;
              const xDevicePixels = (startTouch.clientX - endTouch.clientX) / devicePixelRatio;
              const yDevicePixels = (startTouch.clientY - endTouch.clientY) / devicePixelRatio;
              if (Math.abs(xDevicePixels) < _TouchEventHandler.TAP_TOLERANCE && Math.abs(yDevicePixels) < _TouchEventHandler.TAP_TOLERANCE) {
                if (touchEventEnd) {
                  touchEventStart = null;
                  touchEventEnd = null;
                  return;
                }
                if (event.timeStamp - touchEventStart.timeStamp > _TouchEventHandler.LONG_PRESS_MS) {
                  touchEventStart = null;
                  touchEventEnd = null;
                  return;
                }
                touchEventStart = null;
                touchEventEnd = event;
                return;
              }
              touchEventEnd = null;
              if (event.timeStamp - touchEventStart.timeStamp > _TouchEventHandler.SLOW_SWIPE_MS) {
                touchEventStart = null;
                return;
              }
              const slope = (startTouch.clientY - endTouch.clientY) / (startTouch.clientX - endTouch.clientX);
              if (Math.abs(slope) > 0.5) {
                touchEventStart = null;
                return;
              }
              if (xDevicePixels < 0) {
                self2.onBackwardSwipe(event);
              } else {
                self2.onForwardSwipe(event);
              }
              touchEventStart = null;
            },
            false
          );
        }
      };
      this.navigator = navigator2;
    }
  };
  _TouchEventHandler.TAP_TOLERANCE = 10;
  _TouchEventHandler.LONG_PRESS_MS = 500;
  _TouchEventHandler.SLOW_SWIPE_MS = 500;
  var TouchEventHandler = _TouchEventHandler;

  // src/utils/KeyboardEventHandler.ts
  init_polyfills();
  var KeyboardEventHandler = class {
    constructor(navigator2) {
      this.onBackwardSwipe = () => {
      };
      this.onForwardSwipe = () => {
      };
      this.onKeydown = () => {
      };
      this.setupEvents = (element) => {
        if (element) {
          this.focusin(element);
          this.keydown(element);
        }
      };
      this.removeEvents = (element) => {
        if (element) {
          const self2 = this;
          element.removeEventListener("focusin", this.onFocusIn(self2), true);
          element.removeEventListener("keydown", this.onKeyDown(self2), false);
        }
      };
      this.focusin = (element) => {
        const self2 = this;
        element.addEventListener("focusin", this.onFocusIn(self2), true);
      };
      this.keydown = (element) => {
        const self2 = this;
        if (!this.navigator.rights.customKeyboardEvents) {
          element.addEventListener("keydown", this.onKeyDown(self2), false);
        }
      };
      // store the generated event handlers, so they can be returned
      // when removing the event listeners
      this.handlers = {};
      this.navigator = navigator2;
    }
    onFocusIn(self2) {
      return this.handlers["onFocusIn"] || (this.handlers["onFocusIn"] = function(event) {
        var _a;
        (_a = self2.navigator.view) == null ? void 0 : _a.snap(event.target);
      });
    }
    onKeyDown(self2) {
      return this.handlers["onKeyDown"] || (this.handlers["onKeyDown"] = function(event) {
        const eventTarget = event.target;
        if (/input|select|option|textarea/i.test(eventTarget.tagName)) {
          return;
        }
        const ownerDocument = eventTarget.ownerDocument || eventTarget;
        const ownerWindow = ownerDocument.defaultView;
        const selection = ownerWindow.getSelection();
        if (!selection.isCollapsed) {
          return;
        }
        const key = event.key;
        switch (key) {
          case "ArrowRight":
            self2.onForwardSwipe(event);
            return;
          case "ArrowLeft":
            self2.onBackwardSwipe(event);
            return;
        }
        switch (event.code) {
          case "Space":
            if (event.ctrlKey) {
              self2.onBackwardSwipe(event);
              return;
            } else {
              self2.onForwardSwipe(event);
              return;
            }
        }
        self2.onKeydown(event);
      });
    }
  };

  // src/modules/sampleread/SampleReadEventHandler.ts
  init_polyfills();
  var import_debounce4 = __toESM(require_debounce());
  var SampleReadEventHandler = class {
    constructor(navigator2) {
      this.enforceSampleRead = (0, import_debounce4.debounce)((position) => {
        var _a, _b, _c, _d, _e, _f;
        let progress = Math.round(position.locations.totalProgression * 100);
        let valid = false;
        if ((_a = this.navigator.sample) == null ? void 0 : _a.limit) {
          valid = progress <= ((_b = this.navigator.sample) == null ? void 0 : _b.limit);
          if (((_c = this.navigator.view) == null ? void 0 : _c.layout) === "fixed") {
            if (!valid && ((_d = this.navigator.sample) == null ? void 0 : _d.minimum) && position.locations.position <= ((_e = this.navigator.sample) == null ? void 0 : _e.minimum)) {
              valid = true;
            }
          }
        }
        let keys = {
          37: 1,
          38: 0,
          39: 1,
          40: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        };
        function preventDefault(e) {
          e.preventDefault();
        }
        function preventDefaultForScrollKeys(e) {
          if (keys[e.keyCode] && !valid) {
            preventDefault(e);
          }
        }
        let supportsPassive = false;
        let opts = Object.defineProperty && Object.defineProperty({}, "passive", {
          // eslint-disable-next-line getter-return
          get: function() {
            supportsPassive = true;
          }
        });
        window.addEventListener("test", function() {
        }, opts);
        let wheelOpt = supportsPassive ? { passive: false } : false;
        function MouseWheelHandler(e) {
          e = e || window.event;
          let delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
          if (delta === 1) {
          }
          if (delta === -1 && !valid) {
            e.preventDefault();
            return false;
          }
          return false;
        }
        let lastY;
        function TouchMoveHandler(e) {
          e = e || window.event;
          let target = e.target || e.srcElement;
          let currentY = e.touches[0].clientY;
          if (currentY > lastY) {
          } else if (currentY < lastY && !valid) {
            if (!target.className.match(/\baltNav\b/)) {
              e.returnValue = false;
              if (e.cancelable) {
                e.cancelBubble = true;
              }
              if (e.preventDefault && e.cancelable) {
                e.preventDefault();
                e.stopPropagation();
              }
            }
            return false;
          }
          lastY = currentY;
          return false;
        }
        function TouchStartHandler(e) {
          e = e || window.event;
          lastY = e.touches[0].clientY;
          return false;
        }
        window.addEventListener("mousewheel", MouseWheelHandler, wheelOpt);
        window.addEventListener("DOMMouseScroll", MouseWheelHandler, wheelOpt);
        window.addEventListener("keydown", preventDefaultForScrollKeys, wheelOpt);
        window.addEventListener("touchmove", TouchMoveHandler, wheelOpt);
        window.addEventListener("touchstart", TouchStartHandler, wheelOpt);
        if (!valid) {
          this.navigator.iframes[0].blur();
          if (this.navigator.errorMessage) {
            this.navigator.errorMessage.style.display = "block";
            this.navigator.errorMessage.style.backgroundColor = "rgb(255, 255, 255)";
            this.navigator.errorMessage.innerHTML = "<span>" + ((_f = this.navigator.sample) == null ? void 0 : _f.popup) + "</span>";
          }
        } else {
          this.navigator.iframes[0].focus();
          if (this.navigator.errorMessage) {
            this.navigator.errorMessage.style.display = "none";
            this.navigator.errorMessage.style.removeProperty("background-color");
          }
        }
      }, 300);
      this.navigator = navigator2;
    }
  };

  // src/modules/pagebreak/PageBreakModule.ts
  init_polyfills();
  var import_loglevel17 = __toESM(require_loglevel());
  var PageBreakModule = class {
    static async create(config2) {
      const pageBreak = new this(
        config2.publication,
        config2,
        config2.headerMenu
      );
      await pageBreak.start();
      return pageBreak;
    }
    constructor(publication, properties, headerMenu) {
      this.headerMenu = headerMenu;
      this.publication = publication;
      this.properties = properties;
    }
    async stop() {
      import_loglevel17.default.log("Page Break module stop");
    }
    async start() {
      var _a, _b;
      if (this.headerMenu)
        this.goToPageView = findElement(
          this.headerMenu,
          "#sidenav-section-gotopage"
        );
      if (this.headerMenu)
        this.goToPageNumberInput = findElement(
          this.headerMenu,
          "#goToPageNumberInput"
        );
      if (this.headerMenu)
        this.goToPageNumberButton = findElement(
          this.headerMenu,
          "#goToPageNumberButton"
        );
      addEventListenerOptional(
        this.goToPageNumberInput,
        "keypress",
        this.goToPageNumber.bind(this)
      );
      addEventListenerOptional(
        this.goToPageNumberButton,
        "click",
        this.goToPageNumber.bind(this)
      );
      if (this.goToPageView) {
        if ((_a = this.publication.pageList) == null ? void 0 : _a.length) {
        } else {
          (_b = this.goToPageView.parentElement) == null ? void 0 : _b.removeChild(this.goToPageView);
        }
      }
      setTimeout(() => {
        this.properties.hideLayer ? this.navigator.hideLayer("pagebreak") : this.navigator.showLayer("pagebreak");
      }, 10);
    }
    async goToPageNumber(event) {
      var _a;
      if (this.goToPageNumberInput.value && (event.key === "Enter" || event.type === "click")) {
        var filteredPages = (_a = this.publication.pageList) == null ? void 0 : _a.filter(
          (el) => el.Href.slice(el.Href.indexOf("#") + 1).replace(/[^0-9]/g, "") === this.goToPageNumberInput.value
        );
        if (filteredPages && filteredPages.length > 0) {
          var firstPage = filteredPages[0];
          let locations = {
            progression: 0
          };
          if (firstPage.Href.indexOf("#") !== -1) {
            const elementId = firstPage.Href.slice(
              firstPage.Href.indexOf("#") + 1
            );
            if (elementId !== null) {
              locations = {
                fragment: elementId
              };
            }
          }
          const position = {
            href: this.publication.getAbsoluteHref(firstPage.Href),
            locations,
            type: firstPage.TypeLink,
            title: firstPage.Title
          };
          this.navigator.goTo(position);
        }
      }
    }
    async handleResize() {
      var _a;
      await ((_a = this.navigator.highlighter) == null ? void 0 : _a.destroyHighlights(
        3 /* PageBreak */
      ));
      await this.drawPageBreaks();
    }
    async drawPageBreaks() {
      setTimeout(() => {
        var _a, _b, _c;
        const body = (_a = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a.body;
        let pageBreaks = body == null ? void 0 : body.querySelectorAll('[*|type="pagebreak"]');
        if ((pageBreaks == null ? void 0 : pageBreaks.length) === 0) {
          pageBreaks = body == null ? void 0 : body.querySelectorAll("[epub\\:type='pagebreak']");
        }
        let self2 = this;
        function getCssSelector(element) {
          try {
            let doc = self2.navigator.iframes[0].contentDocument;
            if (doc) {
              return uniqueCssSelector(element, doc, _getCssSelectorOptions);
            } else {
              return "";
            }
          } catch (err) {
            import_loglevel17.default.log("uniqueCssSelector:");
            import_loglevel17.default.error(err);
            return "";
          }
        }
        if (pageBreaks) {
          for (let i = 0; i < pageBreaks.length; i++) {
            let img = pageBreaks[i];
            import_loglevel17.default.log(img);
            let title = img.innerHTML;
            let hide = false;
            if (img.innerHTML.length === 0) {
              title = img.getAttribute("title") ?? "";
              img.innerHTML = title;
              hide = true;
            }
            if (img.innerHTML.length === 0) {
              title = (img.getAttribute("id") ?? "").replace(/[^0-9]/g, "");
              img.innerHTML = title;
              hide = true;
            }
            let doc = this.navigator.iframes[0].contentDocument;
            if (doc) {
              const range = (_b = this.navigator.highlighter) == null ? void 0 : _b.dom(doc.body).getWindow().document.createRange();
              const selection = (_c = this.navigator.highlighter) == null ? void 0 : _c.dom(doc.body).getSelection();
              selection.removeAllRanges();
              range.selectNodeContents(img);
              selection.addRange(range);
              if (!selection.isCollapsed) {
                const rangeInfo = convertRange(range, getCssSelector);
                selection.removeAllRanges();
                if (rangeInfo) {
                  this.createPageBreakHighlight(
                    {
                      rangeInfo,
                      cleanText: "",
                      rawText: ""
                    },
                    title
                  );
                }
              }
            }
            if (hide) {
              img.innerHTML = "";
            }
          }
        }
      }, 200);
    }
    createPageBreakHighlight(selectionInfo, title) {
      var _a;
      try {
        const uniqueStr = `${selectionInfo.rangeInfo.startContainerElementCssSelector}${selectionInfo.rangeInfo.startContainerChildTextNodeIndex}${selectionInfo.rangeInfo.startOffset}${selectionInfo.rangeInfo.endContainerElementCssSelector}${selectionInfo.rangeInfo.endContainerChildTextNodeIndex}${selectionInfo.rangeInfo.endOffset}`;
        const sha256Hex = SHA256.hash(uniqueStr);
        const id2 = "R2_PAGEBREAK_" + sha256Hex;
        var pointerInteraction = false;
        const highlight = {
          color: "#000000",
          id: id2,
          pointerInteraction,
          selectionInfo,
          marker: 3 /* Custom */,
          icon: {
            id: `pageBreak`,
            title,
            color: `#000000`,
            position: "left"
          },
          type: 3 /* PageBreak */
        };
        _highlights.push(highlight);
        let highlightDom = (_a = this.navigator.highlighter) == null ? void 0 : _a.createHighlightDom(
          this.navigator.iframes[0].contentWindow,
          highlight
        );
        highlight.position = parseInt(
          ((highlightDom == null ? void 0 : highlightDom.hasChildNodes()) ? highlightDom.childNodes[0] : highlightDom).style.top.replace("px", "")
        );
        return highlight;
      } catch (e) {
        throw "Can't create highlight: " + e;
      }
    }
  };

  // src/modules/TTS/TTSModule2.ts
  init_polyfills();
  var import_sanitize_html2 = __toESM(require_sanitize_html());
  var import_debounce5 = __toESM(require_debounce());
  var import_loglevel18 = __toESM(require_loglevel());
  var TTSModule2 = class {
    constructor(tts, rights, highlighter, properties, api, headerMenu) {
      this.voices = [];
      this.hasEventListener = false;
      this.startX = 0;
      this.startY = 0;
      this.index = 0;
      this.userScrolled = false;
      this.scrollPartial = false;
      this.speaking = false;
      this.restartIndex = -1;
      this.ttsQueueIndex = -1;
      this.ttsQueue = void 0;
      this.ttsPlayQueueIndexDebounced = (0, import_debounce5.debounce)((ttsQueueIndex, ttsQueue) => {
        if (this.restartIndex >= 0) {
          this.ttsQueueIndex = this.restartIndex;
          this.restartIndex = -1;
        } else {
          this.ttsQueueIndex = ttsQueueIndex;
        }
        this.ttsQueue = ttsQueue;
        this.ttsPlayQueueIndex(this.ttsQueueIndex, ttsQueue);
      }, 150);
      this.tts = tts;
      this.headerMenu = headerMenu;
      this.rights = rights;
      this.highlighter = highlighter;
      this.properties = properties;
      this.api = api;
    }
    initialize(body) {
      if (this.highlighter !== void 0) {
        this.tts.setControls();
        this.tts.onRestart(this.restart.bind(this));
        this.body = body;
        this.clean = (0, import_sanitize_html2.default)(this.body.innerHTML, {
          allowedTags: [],
          allowedAttributes: {}
        });
        this.wrapper = findRequiredElement(
          document,
          "#iframe-wrapper"
        );
        window.speechSynthesis.getVoices();
        this.initVoices(true);
        if (!this.hasEventListener) {
          this.hasEventListener = true;
          addEventListenerOptional(document, "wheel", this.wheel.bind(this));
          addEventListenerOptional(this.body, "wheel", this.wheel.bind(this));
          addEventListenerOptional(document, "keydown", this.wheel.bind(this));
          addEventListenerOptional(
            this.navigator.iframes[0].contentDocument,
            "keydown",
            this.wheel.bind(this)
          );
        }
        addEventListenerOptional(
          this.body,
          "mousedown",
          this.clickStart.bind(this)
        );
        addEventListenerOptional(this.body, "mouseup", this.click.bind(this));
      }
    }
    clickStart(event) {
      if ("clientX" in event) {
        this.startX = event.clientX;
      }
      if ("clientY" in event) {
        this.startY = event.clientY;
      }
    }
    click(event) {
      var _a;
      let startX = 0;
      let startY = 0;
      if ("clientX" in event) {
        startX = event.clientX;
      }
      if ("clientY" in event) {
        startY = event.clientY;
      }
      if (window.speechSynthesis.speaking && this.speaking && startX === this.startX && startY === this.startY) {
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          let selection = this.highlighter.dom(doc.body).getSelection();
          let range = selection.getRangeAt(0);
          let node = selection.anchorNode;
          while (range.toString().indexOf(" ") !== 0) {
            try {
              range.setStart(node, range.startOffset - 1);
            } catch (e) {
              break;
            }
          }
          range.setStart(node, range.startOffset + 1);
          do {
            range.setEnd(
              node,
              node.length < range.endOffset ? range.endOffset + 1 : node.length
            );
          } while (range.toString().indexOf(" ") === -1 && range.toString().trim() !== "");
          let iframe = document.querySelector(
            "main#iframe-wrapper iframe"
          );
          let rootEl = (_a = iframe.contentWindow) == null ? void 0 : _a.document.body;
          if (this.ttsQueue && rootEl) {
            const idx = this.findTtsQueueItemIndex(
              this.ttsQueue,
              selection.anchorNode,
              selection.anchorNode,
              selection.anchorOffset,
              rootEl
            );
            selection.removeAllRanges();
            if (idx >= 0) {
              window.speechSynthesis.cancel();
              this.restartIndex = idx;
              this.ttsPlayQueueIndexDebounced(this.restartIndex, this.ttsQueue);
            }
          }
        }
      }
    }
    initVoices(first) {
      function setSpeech() {
        return new Promise(function(resolve, _reject) {
          let synth = window.speechSynthesis;
          let id2;
          id2 = setInterval(() => {
            if (synth.getVoices().length !== 0) {
              resolve(synth.getVoices());
              clearInterval(id2);
            }
          }, 10);
        });
      }
      let s = setSpeech();
      s.then(async (voices) => {
        import_loglevel18.default.log(voices);
        this.voices = [];
        voices.forEach((voice) => {
          if (voice.localService === true) {
            this.voices.push(voice);
          }
        });
        import_loglevel18.default.log(this.voices);
        if (first) {
          if (this.headerMenu) {
            var preferredLanguageSelector = findElement(
              this.headerMenu,
              "#preferred-languages"
            );
            if (preferredLanguageSelector) {
              this.voices.forEach((voice) => {
                var v = document.createElement("option");
                v.value = voice.name + ":" + voice.lang;
                v.innerHTML = voice.name + " (" + voice.lang + ")";
                preferredLanguageSelector.add(v);
              });
            }
          }
        }
      });
    }
    cancel(api = true) {
      var _a, _b, _c;
      if (api) {
        if ((_a = this.api) == null ? void 0 : _a.stopped)
          (_b = this.api) == null ? void 0 : _b.stopped();
        this.navigator.emit("readaloud.stopped", "stopped");
      }
      this.userScrolled = false;
      this.speaking = false;
      setTimeout(() => {
        window.speechSynthesis.cancel();
      }, 0);
      if (this._ttsQueueItemHighlightsWord) {
        (_c = this.navigator.highlighter) == null ? void 0 : _c.destroyHighlights(2 /* ReadAloud */);
        this._ttsQueueItemHighlightsWord = void 0;
      }
    }
    async speak(selectionInfo, partial, callback) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!partial) {
        if (this.navigator.rights.enableContentProtection) {
          (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.deactivate();
        }
      }
      if ((_b = this.api) == null ? void 0 : _b.started)
        (_c = this.api) == null ? void 0 : _c.started();
      this.navigator.emit("readaloud.started", "started");
      const self2 = this;
      this.userScrolled = false;
      this.cancel(false);
      let utterance;
      if (partial) {
        let iframe = document.querySelector(
          "main#iframe-wrapper iframe"
        );
        let rootEl = (_d = iframe.contentWindow) == null ? void 0 : _d.document.body;
        let doc = this.navigator.iframes[0].contentDocument;
        if (doc) {
          let selection = this.highlighter.dom(doc.body).getSelection();
          if (selection.isCollapsed) {
            let doc2 = self2.navigator.iframes[0].contentDocument;
            const selectionInfo2 = (_f = (_e = self2.navigator.annotationModule) == null ? void 0 : _e.annotator) == null ? void 0 : _f.getTemporarySelectionInfo(
              doc2
            );
            selection.addRange(selectionInfo2.range);
          }
          if (rootEl) {
            var ttsQueue = this.generateTtsQueue(rootEl);
            if (!ttsQueue.length) {
              return;
            }
            var idx = this.findTtsQueueItemIndex(
              ttsQueue,
              selection.anchorNode,
              selection.anchorNode,
              selection.anchorOffset,
              rootEl
            );
            var idxEnd = this.findTtsQueueItemIndex(
              ttsQueue,
              selection.focusNode,
              selection.focusNode,
              selection.focusOffset,
              rootEl
            );
            const ttsQueueItem = getTtsQueueItemRef(ttsQueue, idx);
            const ttsQueueItemEnd = getTtsQueueItemRef(ttsQueue, idxEnd);
            var restOfTheText;
            if (ttsQueueItem && selectionInfo && selectionInfo.cleanText) {
              const sentence = getTtsQueueItemRefText(ttsQueueItem);
              let startIndex = selectionInfo.rangeInfo.startOffset;
              let textToBeSpoken = selectionInfo.cleanText;
              if (ttsQueueItemEnd && idx + 1 === idxEnd) {
                const sentenceEnd = getTtsQueueItemRefText(ttsQueueItemEnd);
                startIndex = (sentence + " " + sentenceEnd).indexOf(
                  selectionInfo.cleanText
                );
                textToBeSpoken = sentence.slice(startIndex, sentence.length);
                restOfTheText = selectionInfo.cleanText.replace(textToBeSpoken, "").trim();
              } else if (idxEnd > idx) {
                let mergedSentences = "";
                for (let i = idx + 1; i < idxEnd; i++) {
                  const ttsQueueItemInBetween = getTtsQueueItemRef(ttsQueue, i);
                  if (ttsQueueItemInBetween) {
                    const sentenceInBetween = getTtsQueueItemRefText(
                      ttsQueueItemInBetween
                    );
                    mergedSentences += sentenceInBetween;
                    restOfTheText = selectionInfo.cleanText.replace(
                      sentenceInBetween,
                      ""
                    );
                  }
                }
                if (ttsQueueItemEnd) {
                  const sentenceEnd = getTtsQueueItemRefText(ttsQueueItemEnd);
                  mergedSentences += " " + sentenceEnd;
                }
                startIndex = (sentence + " " + mergedSentences).indexOf(
                  selectionInfo.cleanText
                );
                textToBeSpoken = sentence.slice(startIndex, sentence.length);
                restOfTheText = restOfTheText.replace(textToBeSpoken, "").trim();
              }
              utterance = new SpeechSynthesisUtterance(textToBeSpoken);
              utterance.rate = this.tts.rate;
              utterance.pitch = this.tts.pitch;
              utterance.volume = this.tts.volume;
              this.setVoice(this, utterance);
              import_loglevel18.default.log(selectionInfo);
              import_loglevel18.default.log(
                textToBeSpoken,
                (_g = selectionInfo.range) == null ? void 0 : _g.commonAncestorContainer.textContent
              );
              import_loglevel18.default.log(ttsQueueItem);
              import_loglevel18.default.log(ttsQueueItem.item.textNodes);
              import_loglevel18.default.log(startIndex);
              import_loglevel18.default.log(ttsQueueItem.item.combinedText);
              let node = ttsQueueItem.item.textNodes.filter((node2) => {
                var _a2;
                return node2 === ((_a2 = selectionInfo.range) == null ? void 0 : _a2.commonAncestorContainer);
              })[0];
              import_loglevel18.default.log(node);
              utterance.onboundary = (ev) => {
                this.updateTTSInfo(
                  ttsQueueItem,
                  ev.charIndex,
                  ev.charLength,
                  startIndex,
                  utterance.text
                );
              };
            }
          }
        }
      } else {
        utterance = new SpeechSynthesisUtterance(this.clean);
      }
      utterance.rate = this.tts.rate;
      utterance.pitch = this.tts.pitch;
      utterance.volume = this.tts.volume;
      this.setVoice(self2, utterance);
      this.index = 0;
      function onend() {
        utterance.onend = function() {
          var _a2, _b2;
          if (idxEnd > idx) {
            idx = idx + 1;
            if (idx !== idxEnd) {
              const ttsQueueItem = getTtsQueueItemRef(ttsQueue, idx);
              if (ttsQueueItem) {
                const sentence = getTtsQueueItemRefText(ttsQueueItem);
                utterance = new SpeechSynthesisUtterance(sentence);
                utterance.rate = self2.tts.rate;
                utterance.pitch = self2.tts.pitch;
                utterance.volume = self2.tts.volume;
                self2.setVoice(self2, utterance);
                utterance.onboundary = (ev) => {
                  self2.updateTTSInfo(
                    ttsQueueItem,
                    ev.charIndex,
                    ev.charLength,
                    0,
                    utterance.text
                  );
                };
                setTimeout(() => {
                  window.speechSynthesis.speak(utterance);
                }, 0);
                onend();
              }
            } else {
              const ttsQueueItem = getTtsQueueItemRef(ttsQueue, idx);
              if (ttsQueueItem) {
                utterance = new SpeechSynthesisUtterance(restOfTheText);
                utterance.rate = self2.tts.rate;
                utterance.pitch = self2.tts.pitch;
                utterance.volume = self2.tts.volume;
                self2.setVoice(self2, utterance);
                utterance.onboundary = (ev) => {
                  self2.updateTTSInfo(
                    ttsQueueItem,
                    ev.charIndex,
                    ev.charLength,
                    0,
                    utterance.text
                  );
                };
                setTimeout(() => {
                  window.speechSynthesis.speak(utterance);
                }, 0);
                onend();
              }
              if (idx > idxEnd) {
                import_loglevel18.default.log("utterance ended");
                self2.highlighter.doneSpeaking();
                (_a2 = self2.api) == null ? void 0 : _a2.finished();
                self2.navigator.emit("readaloud.finished", "finished");
              }
            }
          } else {
            import_loglevel18.default.log("utterance ended");
            self2.highlighter.doneSpeaking();
            (_b2 = self2.api) == null ? void 0 : _b2.finished();
            self2.navigator.emit("readaloud.finished", "finished");
          }
        };
      }
      setTimeout(() => {
        var _a2;
        window.speechSynthesis.speak(utterance);
        if (!partial) {
          if (this.navigator.rights.enableContentProtection) {
            (_a2 = this.navigator.contentProtectionModule) == null ? void 0 : _a2.recalculate(200);
          }
        }
      }, 0);
      onend();
      callback();
    }
    setVoice(self2, utterance) {
      import_loglevel18.default.log("this.tts.voice.lang", this.tts.voice.lang);
      let initialVoiceHasHyphen = true;
      if (this.tts.voice && this.tts.voice.lang) {
        initialVoiceHasHyphen = this.tts.voice.lang.indexOf("-") !== -1;
        if (!initialVoiceHasHyphen) {
          this.tts.voice.lang = this.tts.voice.lang.replace("_", "-");
          initialVoiceHasHyphen = true;
        }
      }
      import_loglevel18.default.log("initialVoiceHasHyphen", initialVoiceHasHyphen);
      import_loglevel18.default.log("voices", this.voices);
      let initialVoice;
      if (initialVoiceHasHyphen) {
        initialVoice = this.tts.voice && this.tts.voice.lang && this.tts.voice.name ? this.voices.filter((v) => {
          var lang = v.lang.replace("_", "-");
          return lang === this.tts.voice.lang && v.name === this.tts.voice.name;
        })[0] : void 0;
        if (initialVoice === void 0) {
          initialVoice = this.tts.voice && this.tts.voice.lang ? this.voices.filter(
            (v) => v.lang.replace("_", "-") === this.tts.voice.lang
          )[0] : void 0;
        }
      } else {
        initialVoice = this.tts.voice && this.tts.voice.lang && this.tts.voice.name ? this.voices.filter((v) => {
          return v.lang === this.tts.voice.lang && v.name === this.tts.voice.name;
        })[0] : void 0;
        if (initialVoice === void 0) {
          initialVoice = this.tts.voice && this.tts.voice.lang ? this.voices.filter((v) => v.lang === this.tts.voice.lang)[0] : void 0;
        }
      }
      import_loglevel18.default.log("initialVoice", initialVoice);
      const publicationVoiceHasHyphen = self2.navigator.publication.Metadata.Language[0].indexOf("-") !== -1;
      import_loglevel18.default.log("publicationVoiceHasHyphen", publicationVoiceHasHyphen);
      let publicationVoice;
      if (publicationVoiceHasHyphen) {
        publicationVoice = this.tts.voice && this.tts.voice.usePublication ? this.voices.filter((v) => {
          var lang = v.lang.replace("_", "-");
          return lang.startsWith(
            self2.navigator.publication.Metadata.Language[0]
          ) || lang.endsWith(
            self2.navigator.publication.Metadata.Language[0].toUpperCase()
          );
        })[0] : void 0;
      } else {
        publicationVoice = this.tts.voice && this.tts.voice.usePublication ? this.voices.filter((v) => {
          return v.lang.startsWith(
            self2.navigator.publication.Metadata.Language[0]
          ) || v.lang.endsWith(
            self2.navigator.publication.Metadata.Language[0].toUpperCase()
          );
        })[0] : void 0;
      }
      import_loglevel18.default.log("publicationVoice", publicationVoice);
      const defaultVoiceHasHyphen = navigator.language.indexOf("-") !== -1;
      import_loglevel18.default.log("defaultVoiceHasHyphen", defaultVoiceHasHyphen);
      let defaultVoice;
      if (defaultVoiceHasHyphen) {
        defaultVoice = this.voices.filter((voice) => {
          const lang = voice.lang.replace("_", "-");
          return lang === navigator.language && voice.localService;
        })[0];
      } else {
        defaultVoice = this.voices.filter((voice) => {
          const lang = voice.lang;
          return lang === navigator.language && voice.localService;
        })[0];
      }
      if (defaultVoice === void 0) {
        defaultVoice = this.voices.filter((voice) => {
          const lang = voice.lang;
          return lang.includes(navigator.language) && voice.localService;
        })[0];
      }
      import_loglevel18.default.log("defaultVoice", defaultVoice);
      if (initialVoice) {
        import_loglevel18.default.log("initialVoice");
        utterance.voice = initialVoice;
      } else if (publicationVoice) {
        import_loglevel18.default.log("publicationVoice");
        utterance.voice = publicationVoice;
      } else if (defaultVoice) {
        import_loglevel18.default.log("defaultVoice");
        utterance.voice = defaultVoice;
      }
      if (utterance.voice !== void 0 && utterance.voice !== null) {
        utterance.lang = utterance.voice.lang;
        import_loglevel18.default.log("utterance.voice.lang", utterance.voice.lang);
        import_loglevel18.default.log("utterance.lang", utterance.lang);
      }
      import_loglevel18.default.log("navigator.language", navigator.language);
    }
    speakPlay() {
      var _a, _b, _c, _d, _e;
      if (this.navigator.rights.enableContentProtection) {
        (_a = this.navigator.contentProtectionModule) == null ? void 0 : _a.deactivate();
      }
      this.scrollPartial = true;
      this.cancel(false);
      if ((_b = this.api) == null ? void 0 : _b.started)
        (_c = this.api) == null ? void 0 : _c.started();
      this.navigator.emit("readaloud.started", "started");
      let self2 = this;
      let iframe = document.querySelector(
        "main#iframe-wrapper iframe"
      );
      let rootEl = (_d = iframe.contentWindow) == null ? void 0 : _d.document.body;
      if (rootEl) {
        let findVisibleText = function() {
          var _a2;
          let node = self2.highlighter.visibleTextRects[0];
          let doc = self2.navigator.iframes[0].contentDocument;
          if (doc) {
            const range = self2.highlighter.dom(doc.body).getWindow().document.createRange();
            const selection = self2.highlighter.dom((_a2 = self2.navigator.iframes[0].contentDocument) == null ? void 0 : _a2.body).getSelection();
            selection.removeAllRanges();
            range.selectNodeContents(node.node);
            selection.addRange(range);
            let index2 = 0;
            const endNode = selection.focusNode;
            const endOffset = selection.focusOffset;
            selection.collapse(selection.anchorNode, selection.anchorOffset);
            for (let i = 0; i < index2; i++) {
              selection.modify("move", "forward", "line");
            }
            selection.extend(endNode, endOffset);
            selection.collapse(selection.anchorNode, selection.anchorOffset);
            if (rootEl) {
              const idx = self2.findTtsQueueItemIndex(
                ttsQueue,
                selection.anchorNode,
                selection.anchorNode,
                selection.anchorOffset,
                rootEl
              );
              if (idx >= 0) {
                ttsQueueIndex = idx;
              }
            }
            selection.removeAllRanges();
          }
        };
        const ttsQueue = this.generateTtsQueue(rootEl);
        if (!ttsQueue.length) {
          return;
        }
        let ttsQueueIndex = 0;
        findVisibleText();
        if (ttsQueueIndex < 0) {
          ttsQueueIndex = 0;
        }
        setTimeout(() => {
          this.startTTSSession(ttsQueue, ttsQueueIndex);
        }, 200);
      }
      if (this.navigator.rights.enableContentProtection) {
        (_e = this.navigator.contentProtectionModule) == null ? void 0 : _e.recalculate(200);
      }
    }
    speakPause() {
      var _a, _b, _c;
      if (window.speechSynthesis.speaking) {
        if ((_a = this.api) == null ? void 0 : _a.paused)
          (_b = this.api) == null ? void 0 : _b.paused();
        this.navigator.emit("readaloud.paused", "paused");
        this.userScrolled = false;
        window.speechSynthesis.pause();
        this.speaking = false;
        if (this._ttsQueueItemHighlightsWord) {
          (_c = this.navigator.highlighter) == null ? void 0 : _c.destroyHighlights(2 /* ReadAloud */);
          this._ttsQueueItemHighlightsWord = void 0;
        }
      }
    }
    speakResume() {
      var _a, _b;
      if (window.speechSynthesis.speaking) {
        if ((_a = this.api) == null ? void 0 : _a.resumed)
          (_b = this.api) == null ? void 0 : _b.resumed();
        this.navigator.emit("readaloud.resumed", "resumed");
        this.userScrolled = false;
        window.speechSynthesis.resume();
        this.speaking = true;
      }
    }
    static async create(config2) {
      const tts = new this(
        config2.tts,
        config2.rights,
        config2.highlighter,
        config2,
        config2.api,
        config2.headerMenu
      );
      await tts.start();
      return tts;
    }
    async start() {
      var _a;
      if (this.headerMenu) {
        var menuTTS = findElement(
          this.headerMenu,
          "#menu-button-tts"
        );
        if (menuTTS)
          (_a = menuTTS.parentElement) == null ? void 0 : _a.style.removeProperty("display");
      }
      setTimeout(() => {
        var _a2;
        ((_a2 = this.properties) == null ? void 0 : _a2.hideLayer) ? this.navigator.hideLayer("readaloud") : this.navigator.showLayer("readaloud");
      }, 10);
    }
    wheel(event) {
      if (event instanceof KeyboardEvent) {
        const key = event.key;
        switch (key) {
          case "ArrowUp":
            this.userScrolled = true;
            break;
          case "ArrowDown":
            this.userScrolled = true;
            break;
        }
      } else {
        this.userScrolled = true;
      }
    }
    stop() {
      import_loglevel18.default.log("TTS module stop");
      removeEventListenerOptional(document, "wheel", this.wheel.bind(this));
      removeEventListenerOptional(this.body, "wheel", this.wheel.bind(this));
      removeEventListenerOptional(document, "keydown", this.wheel.bind(this));
      removeEventListenerOptional(
        this.navigator.iframes[0].contentDocument,
        "keydown",
        this.wheel.bind(this)
      );
      removeEventListenerOptional(this.body, "click", this.click.bind(this));
    }
    generateTtsQueue(rootElement) {
      const ttsQueue = [];
      const elementStack = [];
      function processTextNode(textNode) {
        if (textNode.nodeType !== Node.TEXT_NODE) {
          return;
        }
        if (!textNode.nodeValue || !textNode.nodeValue.trim().length) {
          return;
        }
        const parentElement = elementStack[elementStack.length - 1];
        if (!parentElement) {
          return;
        }
        const lang = textNode.parentElement ? getLanguage(textNode.parentElement) : void 0;
        const dir = textNode.parentElement ? getDirection(textNode.parentElement) : void 0;
        let current = ttsQueue[ttsQueue.length - 1];
        if (!current || current.parentElement !== parentElement || current.lang !== lang || current.dir !== dir) {
          current = {
            combinedText: "",
            dir,
            lang,
            parentElement,
            textNodes: []
          };
          ttsQueue.push(current);
        }
        current.textNodes.push(textNode);
      }
      let first = true;
      function processElement(element) {
        if (element.nodeType !== Node.ELEMENT_NODE) {
          return;
        }
        const isIncluded = first || element.matches(
          "h1, h2, h3, h4, h5, h6, p, th, td, caption, li, blockquote, q, dt, dd, figcaption, div, pre"
        );
        first = false;
        if (isIncluded) {
          elementStack.push(element);
        }
        for (const childNode of element.childNodes) {
          switch (childNode.nodeType) {
            case Node.ELEMENT_NODE:
              const childElement = childNode;
              const isExcluded = childElement.matches(
                "img, sup, sub, audio, video, source, button, canvas, del, dialog, embed, form, head, iframe, meter, noscript, object, s, script, select, style, textarea"
              );
              if (!isExcluded) {
                processElement(childElement);
              } else if (childElement.tagName && childElement.tagName.toLowerCase() === "img" && childElement.src) {
                const altAttr = childElement.getAttribute("alt");
                if (altAttr) {
                  const txt = altAttr.trim();
                  if (txt) {
                    const lang = getLanguage(childElement);
                    const dir = void 0;
                    ttsQueue.push({
                      combinedText: txt,
                      dir,
                      lang,
                      parentElement: childElement,
                      textNodes: []
                    });
                  }
                }
              }
              break;
            case Node.TEXT_NODE:
              if (elementStack.length !== 0) {
                processTextNode(childNode);
              }
              break;
            default:
              break;
          }
        }
        if (isIncluded) {
          elementStack.pop();
        }
      }
      processElement(rootElement);
      function finalizeTextNodes(ttsQueueItem) {
        if (!ttsQueueItem.textNodes || !ttsQueueItem.textNodes.length) {
          if (!ttsQueueItem.combinedText || !ttsQueueItem.combinedText.length) {
            ttsQueueItem.combinedText = "";
          }
          return;
        }
        ttsQueueItem.combinedText = combineTextNodes(
          ttsQueueItem.textNodes,
          true
        ).replace(/[\r\n]/g, " ");
        let parent = ttsQueueItem.parentElement;
        while (parent) {
          if (parent.tagName) {
            const tag = parent.tagName.toLowerCase();
            if (tag === "pre" || tag === "code" || tag === "video" || tag === "audio") {
              break;
            }
          }
          parent = parent.parentElement;
        }
      }
      for (const ttsQueueItem of ttsQueue) {
        finalizeTextNodes(ttsQueueItem);
      }
      return ttsQueue;
    }
    findTtsQueueItemIndex(ttsQueue, element, startTextNode, startTextNodeOffset, rootElem) {
      let i = 0;
      for (const ttsQueueItem of ttsQueue) {
        if (startTextNode && ttsQueueItem.textNodes) {
          if (ttsQueueItem.textNodes.includes(startTextNode)) {
            return i;
          }
        } else if (element === ttsQueueItem.parentElement || ttsQueueItem.parentElement !== element.ownerDocument.body && ttsQueueItem.parentElement !== rootElem && ttsQueueItem.parentElement.contains(element) || element.contains(ttsQueueItem.parentElement)) {
          return i;
        }
        i++;
      }
      return -1;
    }
    restart() {
      if (window.speechSynthesis.speaking) {
        window.speechSynthesis.cancel();
        this.restartIndex = this.ttsQueueIndex;
        this.ttsPlayQueueIndexDebounced(this.restartIndex, this.ttsQueue);
      }
    }
    startTTSSession(ttsQueue, ttsQueueIndexStart) {
      const ttsQueueItemStart = getTtsQueueItemRef(ttsQueue, ttsQueueIndexStart);
      if (!ttsQueueItemStart) {
        this.cancel();
        return;
      }
      this.speaking = true;
      this.ttsPlayQueueIndexDebounced(ttsQueueIndexStart, ttsQueue);
    }
    ttsPlayQueueIndex(ttsQueueIndex, ttsQueue) {
      if (ttsQueueIndex < 0) {
        this.cancel();
        return;
      }
      const ttsQueueItem = getTtsQueueItemRef(ttsQueue, ttsQueueIndex);
      if (!ttsQueueItem) {
        this.cancel();
        return;
      }
      const txtStr = getTtsQueueItemRefText(ttsQueueItem);
      if (!txtStr) {
        this.cancel();
        return;
      }
      const utterance = new SpeechSynthesisUtterance(txtStr);
      utterance.rate = this.tts.rate;
      utterance.pitch = this.tts.pitch;
      utterance.volume = this.tts.volume;
      const self2 = this;
      this.setVoice(self2, utterance);
      utterance.onboundary = (ev) => {
        import_loglevel18.default.log(ev.name);
        this.updateTTSInfo(
          ttsQueueItem,
          ev.charIndex,
          ev.charLength,
          0,
          utterance.text
        );
      };
      setTimeout(() => {
        window.speechSynthesis.speak(utterance);
        if (!self2.speaking) {
          window.speechSynthesis.pause();
        }
      }, 0);
      utterance.onend = function() {
        if (self2.speaking) {
          self2.ttsPlayQueueIndexDebounced(ttsQueueIndex + 1, ttsQueue);
        }
      };
    }
    updateTTSInfo(ttsQueueItem, charIndex, charLength, startIndex, utteranceText) {
      if (!ttsQueueItem) {
        return void 0;
      }
      import_loglevel18.default.log(ttsQueueItem, charIndex, charLength, utteranceText);
      const ttsQueueItemText = utteranceText ? utteranceText : getTtsQueueItemRefText(ttsQueueItem);
      if (charIndex >= 0 && utteranceText) {
        const start = utteranceText.slice(0, charIndex + 1).search(/\S+$/);
        const right = utteranceText.slice(charIndex).search(/\s/);
        const word = right < 0 ? utteranceText.slice(start) : utteranceText.slice(start, right + charIndex);
        const end = start + word.length;
        if (charLength === void 0) {
          const match = utteranceText.substring(charIndex).match(/^[a-z\d']*/i);
          if (match) {
            charLength = match[0].length;
          }
        }
        if (charLength === void 0) {
          charLength = word.length;
        }
        this.wrapHighlightWord(
          ttsQueueItem,
          utteranceText,
          charIndex + startIndex,
          charLength,
          word,
          start,
          end
        );
      }
      return ttsQueueItemText;
    }
    wrapHighlightWord(ttsQueueItemRef, utteranceText, charIndex, charLength, word, start, end) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      import_loglevel18.default.log(ttsQueueItemRef);
      import_loglevel18.default.log(utteranceText);
      import_loglevel18.default.log(charIndex, charLength, word, start, end);
      if (this._ttsQueueItemHighlightsWord) {
        (_a = this.navigator.highlighter) == null ? void 0 : _a.destroyHighlights(2 /* ReadAloud */);
        this._ttsQueueItemHighlightsWord = void 0;
      }
      const ttsQueueItem = ttsQueueItemRef.item;
      let charIndexAdjusted = charIndex;
      let acc = 0;
      let rangeStartNode;
      let rangeStartOffset = -1;
      let rangeEndNode;
      let rangeEndOffset = -1;
      const charIndexEnd = charIndexAdjusted + charLength;
      for (const txtNode of ttsQueueItem.textNodes) {
        if (!txtNode.nodeValue && txtNode.nodeValue !== "") {
          continue;
        }
        const l = txtNode.nodeValue.length;
        acc += l;
        if (!rangeStartNode) {
          if (charIndexAdjusted < acc) {
            rangeStartNode = txtNode;
            rangeStartOffset = l - (acc - charIndexAdjusted);
          }
        }
        if (rangeStartNode && charIndexEnd <= acc) {
          rangeEndNode = txtNode;
          rangeEndOffset = l - (acc - charIndexEnd);
        }
        if (rangeEndNode) {
          break;
        }
      }
      if (rangeStartNode && rangeEndNode) {
        let getCssSelector = function(element) {
          try {
            let doc = self2.navigator.iframes[0].contentDocument;
            if (doc) {
              return uniqueCssSelector(element, doc, _getCssSelectorOptions);
            } else {
              return "";
            }
          } catch (err) {
            import_loglevel18.default.log("uniqueCssSelector:");
            import_loglevel18.default.error(err);
            return "";
          }
        };
        const range = new Range();
        range.setStart(rangeStartNode, rangeStartOffset);
        range.setEnd(rangeEndNode, rangeEndOffset);
        const self2 = this;
        const rangeInfo = convertRange(range, getCssSelector);
        if (!rangeInfo) {
          return;
        }
        let result = (_b = this.navigator.highlighter) == null ? void 0 : _b.createHighlight(
          this.navigator.iframes[0].contentWindow,
          {
            rangeInfo,
            cleanText: "",
            rawText: "",
            range: void 0
          },
          this.tts.color,
          false,
          3 /* Custom */,
          {
            id: "tts",
            title: "",
            position: "right"
          },
          void 0,
          {
            defaultClass: this.tts.color
          },
          2 /* ReadAloud */,
          "R2_READALOUD_"
        );
        if (result) {
          this._ttsQueueItemHighlightsWord = result[0];
          const viewportOffset = (_d = (_c = result[1]) == null ? void 0 : _c.firstChild) == null ? void 0 : _d.getBoundingClientRect();
          const top = viewportOffset.top - this.wrapper.scrollTop;
          const shouldScroll = top > window.innerHeight / 2 - 65;
          if (((_e = this.navigator.view) == null ? void 0 : _e.isScrollMode()) && this.tts.autoScroll && !this.userScrolled && this.scrollPartial && shouldScroll) {
            (_g = (_f = result[1]) == null ? void 0 : _f.firstChild) == null ? void 0 : _g.scrollIntoView({
              block: "center",
              behavior: "smooth"
            });
          } else if ((_h = this.navigator.view) == null ? void 0 : _h.isPaginated()) {
            (_j = self2.navigator.view) == null ? void 0 : _j.snap((_i = result[1]) == null ? void 0 : _i.firstChild);
          }
        }
      }
    }
  };
  function getLanguage(el) {
    let currentElement = el;
    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
      let lang = currentElement.getAttribute("xml:lang");
      if (!lang) {
        lang = currentElement.getAttributeNS(
          "http://www.w3.org/XML/1998/namespace",
          "lang"
        );
      }
      if (!lang) {
        lang = currentElement.getAttribute("lang");
      }
      if (lang) {
        return lang;
      }
      currentElement = currentElement.parentNode;
    }
    return void 0;
  }
  function getDirection(el) {
    let currentElement = el;
    while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
      const dir = currentElement.getAttribute("dir");
      if (dir) {
        return dir;
      }
      currentElement = currentElement.parentNode;
    }
    return void 0;
  }
  function combineTextNodes(textNodes, skipNormalize) {
    if (textNodes && textNodes.length) {
      let str = "";
      for (const textNode of textNodes) {
        if (textNode.nodeValue) {
          str += skipNormalize ? textNode.nodeValue : normalizeText(textNode.nodeValue);
        }
      }
      return str;
    }
    return "";
  }
  function normalizeHtmlText(str) {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function normalizeText(str) {
    return normalizeHtmlText(str).replace(/\n/g, " ").replace(/\s\s+/g, " ");
  }
  function getTtsQueueItemRef(items, index2) {
    let i = -1;
    let k = -1;
    for (const it of items) {
      k++;
      i++;
      if (index2 === i) {
        return { item: it, iArray: k, iGlobal: i, iSentence: -1 };
      }
    }
    return void 0;
  }
  function getTtsQueueItemRefText(obj) {
    return obj.item.combinedText;
  }

  // src/modules/search/DefinitionsModule.ts
  init_polyfills();
  var lodash3 = __toESM(require_lodash());
  var import_debounce6 = __toESM(require_debounce());
  var import_loglevel19 = __toESM(require_loglevel());
  var DefinitionsModule = class {
    constructor(publication, properties, highlighter, api) {
      this.currentChapterPopupResult = [];
      this.currentPopupHighlights = [];
      this.definitions = (0, import_debounce6.debounce)(async () => {
        await this.highlighter.destroyHighlights(4 /* Definition */);
        if (this.properties.definitions) {
          for (const item of this.properties.definitions) {
            await this.define(item);
          }
        }
      }, 200);
      this.publication = publication;
      this.properties = properties;
      this.api = api;
      this.highlighter = highlighter;
    }
    static async create(config2) {
      const search = new this(
        config2.publication,
        config2,
        config2.highlighter,
        config2.api
      );
      await search.start();
      return search;
    }
    async stop() {
      import_loglevel19.default.log("Definitions module stop");
    }
    async start() {
      setTimeout(() => {
        this.properties.hideLayer ? this.navigator.hideLayer("definitions") : this.navigator.showLayer("definitions");
      }, 10);
    }
    async searchAndPaint(item, callback) {
      var _a;
      const linkHref = this.publication.getAbsoluteHref(
        this.publication.readingOrder ? this.publication.readingOrder[this.navigator.currentResource() ?? 0].Href : ""
      );
      let tocItem = this.publication.getTOCItem(linkHref);
      if (tocItem === void 0 && this.publication.readingOrder) {
        tocItem = this.publication.readingOrder[this.navigator.currentResource() ?? 0];
      }
      let localSearchDefinitions = [];
      if (tocItem) {
        for (const termKey of item.terms) {
          const tindex = item.terms.indexOf(termKey);
          if (tocItem) {
            await searchDocDomSeek(
              termKey,
              this.navigator.iframes[0].contentDocument,
              tocItem.Href,
              tocItem.Title,
              (_a = this.navigator.definitionsModule) == null ? void 0 : _a.properties.fullWordSearch
            ).then((result) => {
              let i = void 0;
              if (item.result === 1) {
                i = 0;
              } else if (item.result === 2) {
                i = Math.floor(Math.random() * result.length - 1) + 1;
              }
              result.forEach((searchItem, index2) => {
                if (i === void 0 || i === index2) {
                  const selectionInfo = {
                    rangeInfo: searchItem.rangeInfo
                  };
                  const highlight = this.createDefinitionHighlight(
                    selectionInfo,
                    item
                  );
                  searchItem.highlight = highlight;
                  localSearchDefinitions.push(
                    lodash3.omit(highlight, "definition")
                  );
                  this.currentChapterPopupResult.push(searchItem);
                  this.currentPopupHighlights.push(highlight);
                }
              });
              if (tindex === item.terms.length - 1) {
                callback(localSearchDefinitions);
              }
            });
          }
        }
      }
    }
    async define(item) {
      await this.searchAndPaint(item, async (result) => {
        var _a, _b, _c;
        if ((_a = this.api) == null ? void 0 : _a.success) {
          (_b = this.api) == null ? void 0 : _b.success(lodash3.omit(item, "callbacks"), result);
          this.navigator.emit("definition.success", result);
          if ((_c = this.api) == null ? void 0 : _c.visible) {
            result.forEach((highlight) => {
              var _a2;
              let highlightParent = (_a2 = this.navigator.iframes[0].contentDocument) == null ? void 0 : _a2.querySelector(
                `#${highlight.id}`
              );
              const highlightFragments = highlightParent == null ? void 0 : highlightParent.querySelectorAll(
                `.${CLASS_HIGHLIGHT_AREA}`
              );
              let observer = new IntersectionObserver(
                (entries, _observer) => {
                  entries.forEach((entry) => {
                    var _a3;
                    if (entry.intersectionRatio === 1) {
                      (_a3 = this.api) == null ? void 0 : _a3.visible(
                        lodash3.omit(item, "callbacks"),
                        lodash3.omit(highlight, "definition")
                      );
                      this.navigator.emit("definition.visible", item, highlight);
                    }
                  });
                },
                { threshold: 1 }
              );
              if (highlightFragments && highlightFragments.length > 0) {
                observer.observe(highlightFragments[0]);
              }
            });
          }
        }
      });
    }
    async drawDefinitions() {
      setTimeout(async () => {
        await this.definitions();
      }, 100);
    }
    async handleResize() {
      await this.drawDefinitions();
    }
    createDefinitionHighlight(selectionInfo, item) {
      var _a;
      try {
        let createColor = (_a = this.navigator.definitionsModule) == null ? void 0 : _a.properties.color;
        if (TextHighlighter.isHexColor(createColor)) {
          createColor = TextHighlighter.hexToRgbChannels(createColor);
        }
        const uniqueStr = `${selectionInfo.rangeInfo.startContainerElementCssSelector}${selectionInfo.rangeInfo.startContainerChildTextNodeIndex}${selectionInfo.rangeInfo.startOffset}${selectionInfo.rangeInfo.endContainerElementCssSelector}${selectionInfo.rangeInfo.endContainerChildTextNodeIndex}${selectionInfo.rangeInfo.endOffset}`;
        const sha256Hex = SHA256.hash(uniqueStr);
        const id2 = "R2_DEFINITION_" + sha256Hex;
        this.highlighter.destroyHighlight(
          this.navigator.iframes[0].contentDocument,
          id2
        );
        const highlight = {
          color: createColor ? createColor : DEFAULT_BACKGROUND_COLOR,
          id: id2,
          pointerInteraction: true,
          selectionInfo,
          marker: 1 /* Underline */,
          type: 4 /* Definition */
        };
        _highlights.push(highlight);
        let highlightDom = this.highlighter.createHighlightDom(
          this.navigator.iframes[0].contentWindow,
          highlight
        );
        if (highlightDom) {
          if (item.definition) {
            highlightDom.dataset.definition = item.definition;
          }
          highlightDom.dataset.order = String(item.order);
          highlight.definition = item;
          highlight.position = parseInt(
            ((highlightDom == null ? void 0 : highlightDom.hasChildNodes()) ? highlightDom.childNodes[0] : highlightDom).style.top.replace("px", "")
          );
        }
        return highlight;
      } catch (e) {
        throw "Can't create definitions highlight: " + e;
      }
    }
    async addDefinition(definition) {
      await this.define(definition);
    }
    async clearDefinitions() {
      await this.highlighter.destroyHighlights(4 /* Definition */);
    }
  };

  // node_modules/eventemitter3/index.mjs
  init_polyfills();
  var import_index = __toESM(require_eventemitter3(), 1);
  var eventemitter3_default = import_index.default;

  // src/modules/linefocus/LineFocusModule.ts
  init_polyfills();
  var import_loglevel20 = __toESM(require_loglevel());
  var DEFAULT_BACKGROUND_COLOR_OPACITY2 = 0.5;
  var LineFocusModule = class {
    constructor(properties, highlighter, api) {
      this.hasEventListener = false;
      this.lines = [];
      this.index = 0;
      this.isActive = false;
      this.isDebug = false;
      this.lineFocusContainer = document.getElementById(`lineFocusContainer`);
      this.readerContainer = document.getElementById(`D2Reader-Container`);
      this.lineFocusTopBlinder = document.getElementById(`lineFocusTopBlinder`);
      this.lineFocusBottomBlinder = document.getElementById(`lineFocusBottomBlinder`);
      this.wrapperHeight = void 0;
      this.properties = properties;
      this.api = api;
      this.highlighter = highlighter;
    }
    static async create(config2) {
      const search = new this(
        config2,
        config2.highlighter,
        config2.api
      );
      await search.start();
      return search;
    }
    async stop() {
      import_loglevel20.default.log("Definitions module stop");
      this.hasEventListener = false;
      removeEventListenerOptional(document, "keydown", this.keydown.bind(this));
      removeEventListenerOptional(document, "keyup", this.keyup.bind(this));
      removeEventListenerOptional(
        this.navigator.iframes[0].contentDocument,
        "keydown",
        this.keydown.bind(this)
      );
      removeEventListenerOptional(
        this.navigator.iframes[0].contentDocument,
        "keyup",
        this.keyup.bind(this)
      );
    }
    async start() {
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (wrapper.style.height.length > 0) {
        this.wrapperHeight = wrapper.style.height;
        if (this.lineFocusContainer && this.lineFocusContainer.style.height.length === 0)
          this.lineFocusContainer.style.height = this.wrapperHeight;
        if (this.readerContainer && this.readerContainer.style.height.length === 0) {
          this.readerContainer.style.height = this.wrapperHeight;
        }
        if (this.readerContainer) {
          this.readerContainer.style.overflow = "hidden";
        }
      }
    }
    initialize() {
      return new Promise(async (resolve) => {
        await document.fonts.ready;
        if (!this.hasEventListener) {
          this.hasEventListener = true;
          addEventListenerOptional(document, "keydown", this.keydown.bind(this));
          addEventListenerOptional(document, "keyup", this.keyup.bind(this));
          addEventListenerOptional(
            this.navigator.iframes[0].contentDocument,
            "keydown",
            this.keydown.bind(this)
          );
          addEventListenerOptional(
            this.navigator.iframes[0].contentDocument,
            "keyup",
            this.keyup.bind(this)
          );
        }
        resolve(null);
      });
    }
    keydown(event) {
      if (event instanceof KeyboardEvent && this.isActive) {
        const key = event.key;
        switch (key) {
          case "ArrowUp":
            event.stopPropagation();
            break;
          case "ArrowDown":
            event.stopPropagation();
            break;
        }
      }
    }
    keyup(event) {
      if (event instanceof KeyboardEvent && this.isActive) {
        const key = event.key;
        switch (key) {
          case "ArrowUp":
            this.lineUp();
            break;
          case "ArrowDown":
            this.lineDown();
            break;
        }
      }
    }
    handleResize() {
      if (this.isActive) {
        this.lineFocus();
      }
    }
    async enableLineFocus() {
      this.isActive = true;
      await this.navigator.settings.scroll(true);
      this.lineFocus();
    }
    disableLineFocus(resetHeight = true) {
      this.isActive = false;
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      if (this.wrapperHeight) {
        wrapper.style.height = this.wrapperHeight;
      }
      if (!resetHeight) {
        this.index = 0;
      }
      const doc = this.navigator.iframes[0].contentDocument;
      const html = findIframeElement(
        doc,
        "html"
      );
      html.style.removeProperty("--USER__maxMediaHeight");
      this.wrapperHeight = void 0;
      if (this.lineFocusContainer)
        this.lineFocusContainer.style.display = "none";
      let timeline = document.getElementById("container-view-timeline");
      if (timeline) {
        timeline.style.removeProperty("display");
      }
      let divBefore = document.getElementById("divBefore");
      if (divBefore) {
        divBefore.remove();
      }
      let divAfter = document.getElementById("divAfter");
      if (divAfter) {
        divAfter.remove();
      }
      this.highlighter.destroyHighlights(5 /* LineFocus */);
    }
    lineFocus() {
      var _a;
      const wrapper = findRequiredElement(
        document,
        "#iframe-wrapper"
      );
      const doc = this.navigator.iframes[0].contentDocument;
      const html = findIframeElement(
        doc,
        "html"
      );
      let maxHeight = this.properties.maxHeight ? getHeight() * this.properties.maxHeight / 100 : getHeight() / 2;
      html.style.setProperty("--USER__maxMediaHeight", maxHeight + "px");
      function insertAfter(referenceNode, newNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
      }
      function insertBefore(referenceNode, newNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode);
      }
      let timeline = document.getElementById("container-view-timeline");
      if (timeline) {
        timeline.style.display = "none";
      }
      if (this.lineFocusContainer)
        this.lineFocusContainer.style.removeProperty("display");
      let divBefore = document.getElementById("divBefore");
      if (divBefore) {
        divBefore.style.height = wrapper.clientHeight / 2 + "px";
      } else {
        let divBefore2 = document.createElement("div");
        divBefore2.style.height = wrapper.clientHeight / 2 + "px";
        divBefore2.id = "divBefore";
        insertBefore(wrapper, divBefore2);
      }
      let divAfter = document.getElementById("divAfter");
      if (divAfter) {
        divAfter.style.height = wrapper.clientHeight / 2 + "px";
      } else {
        let divAfter2 = document.createElement("div");
        divAfter2.style.height = wrapper.clientHeight / 2 + "px";
        divAfter2.id = "divAfter";
        insertAfter(wrapper, divAfter2);
      }
      this.lines = [];
      if (doc) {
        let random_rgba = function() {
          const o = Math.round, r = Math.random, s = 255;
          return {
            blue: o(r() * s),
            green: o(r() * s),
            red: o(r() * s)
          };
        }, groupArr = function(data, n) {
          let group = [];
          for (let i = 0, j = 0; i < data.length; i++) {
            if (i >= n && i % n === 0)
              j++;
            group[j] = group[j] || [];
            group[j].push(data[i]);
          }
          return group;
        }, getBoundingRect2 = function(rect1, rect2) {
          const left = Math.min(rect1.left, rect2.left);
          const right = Math.max(rect1.right, rect2.right);
          const top = Math.min(rect1.top, rect2.top);
          const bottom = Math.max(rect1.bottom, rect2.bottom);
          return {
            bottom,
            height: bottom - top,
            left,
            right,
            top,
            width: right - left
          };
        }, mergeArr = function(data) {
          if (data.length > 1) {
            let first = getBoundingRect2(data[0], data[1]);
            if (data.length > 2) {
              let second = getBoundingRect2(first, data[2]);
              if (data.length > 3) {
                let third = getBoundingRect2(second, data[3]);
                if (data.length > 4) {
                  return getBoundingRect2(third, data[4]);
                }
                return third;
              }
              return second;
            }
            return first;
          }
          return data[0];
        };
        let textNodes = this.findRects(doc.body);
        textNodes = getClientRectsNoOverlap_(textNodes, true);
        textNodes = textNodes.sort(function(a, b) {
          return a.top - b.top;
        });
        let dups = [];
        textNodes = textNodes.filter(function(el) {
          const center = el.top;
          if (dups.indexOf(center) === -1 && dups.indexOf(center + 1) === -1 && dups.indexOf(center + 2) === -1 && dups.indexOf(center + 3) === -1 && dups.indexOf(center + 4) === -1 && dups.indexOf(center - 1) === -1 && dups.indexOf(center - 2) === -1 && dups.indexOf(center - 3) === -1 && dups.indexOf(center - 4) === -1) {
            dups.push(center);
            return true;
          }
          return false;
        });
        this.highlighter.destroyHighlights(5 /* LineFocus */);
        let newGroupedLines = [];
        if (this.properties.lines && this.properties.lines > 1) {
          let threes = groupArr(textNodes, this.properties.lines);
          threes.forEach((data) => {
            newGroupedLines.push(mergeArr(data));
          });
        } else {
          newGroupedLines = textNodes;
        }
        const container = findElement(
          doc,
          "#" + "R2_ID_LINEFOCUS_CONTAINER" /* R2_ID_LINEFOCUS_CONTAINER */
        );
        if (container) {
          for (const clientRect of newGroupedLines) {
            const highlightArea = document.createElement(
              "div"
            );
            highlightArea.setAttribute("class", CLASS_HIGHLIGHT_AREA);
            let color = random_rgba();
            if (TextHighlighter.isHexColor(color)) {
              color = TextHighlighter.hexToRgbChannels(color);
            }
            if (this.isDebug) {
              let extra = `border-bottom: 1px solid rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY2}) !important`;
              highlightArea.setAttribute(
                "style",
                `mix-blend-mode: multiply; border-radius: 1px !important; background-color: rgba(${color.red}, ${color.green}, ${color.blue}, ${DEFAULT_BACKGROUND_COLOR_OPACITY2}) !important; ${extra}`
              );
            }
            highlightArea.style.outline = "none";
            highlightArea.tabIndex = 0;
            const documant = this.navigator.iframes[0].contentWindow.document;
            const paginated = this.navigator.view.isPaginated();
            if (paginated) {
              documant.body.style.position = "revert";
            } else {
              documant.body.style.position = "relative";
            }
            const bodyRect = documant.body.getBoundingClientRect();
            const scrollElement = this.highlighter.getScrollingElement(documant);
            const xOffset = paginated ? -scrollElement.scrollLeft : bodyRect.left;
            const yOffset = paginated ? -scrollElement.scrollTop : bodyRect.top;
            const scale = 1;
            let size = 24;
            let left, right;
            let viewportWidth = (_a = this.navigator.iframes[0].contentWindow) == null ? void 0 : _a.innerWidth;
            let columnCount = parseInt(
              getComputedStyle(doc.documentElement).getPropertyValue(
                "column-count"
              )
            );
            let columnWidth = parseInt(
              getComputedStyle(doc.documentElement).getPropertyValue(
                "column-width"
              )
            );
            let padding = parseInt(
              getComputedStyle(doc.body).getPropertyValue("padding-left")
            );
            if (viewportWidth) {
              let pageWidth = viewportWidth / (columnCount || 1);
              if (pageWidth < columnWidth) {
                pageWidth = viewportWidth;
              }
              if (!paginated) {
                pageWidth = parseInt(
                  getComputedStyle(doc.body).width.replace("px", "")
                );
              }
              let ratio = this.navigator.settings.fontSize / 100;
              let addRight = 20 * ratio;
              if (ratio <= 1) {
                addRight = -60;
              }
              let addLeft = 0;
              if (ratio <= 1) {
                addLeft = -60;
              }
              left = Math.floor(clientRect.left / pageWidth) * pageWidth + pageWidth - (size < 40 ? 40 : size) + addLeft;
              right = Math.floor(clientRect.left / pageWidth) * pageWidth + (size < 40 ? 40 : size) - addRight;
              let pagemargin = parseInt(
                doc.documentElement.style.getPropertyValue("--USER__pageMargins")
              );
              if (pagemargin >= 2) {
                right = right + padding / columnCount;
                left = left - padding / columnCount;
              }
              if (!paginated) {
                left = parseInt(
                  getComputedStyle(doc.body).width.replace("px", "")
                );
                right = parseInt(getComputedStyle(doc.body).width.replace("px", "")) - pageWidth;
                if (pagemargin >= 2) {
                  right = right + padding / 2;
                  left = left - padding / 2;
                }
              }
            }
            highlightArea.style.setProperty("pointer-events", "none");
            highlightArea.style.position = "absolute";
            highlightArea.scale = scale;
            highlightArea.rect = {
              height: clientRect.height,
              left: clientRect.left - xOffset,
              top: clientRect.top - yOffset,
              width: clientRect.width
            };
            highlightArea.style.width = `${highlightArea.rect.width * scale}px`;
            highlightArea.style.height = `${highlightArea.rect.height * scale}px`;
            highlightArea.style.left = `${highlightArea.rect.left * scale}px`;
            highlightArea.style.top = `${highlightArea.rect.top * scale}px`;
            this.lines.push(highlightArea);
            container.append(highlightArea);
          }
        }
        setTimeout(() => {
          this.currentLine();
        }, 100);
      }
    }
    currentLine() {
      let current = this.lines[this.index];
      let top = current.style.top;
      let bottom = parseInt(current.style.top.replace("px", "")) + parseInt(current.style.height.replace("px", ""));
      let height = bottom - parseInt(top.replace("px", ""));
      if (this.lineFocusContainer) {
        let lineFocusHeight = parseInt(
          getComputedStyle(this.lineFocusContainer).height.replace("px", "")
        );
        let blindersHeight = (lineFocusHeight - height) / 2;
        if (this.lineFocusTopBlinder)
          this.lineFocusTopBlinder.style.height = blindersHeight + "px";
        if (this.lineFocusBottomBlinder)
          this.lineFocusBottomBlinder.style.height = blindersHeight + "px";
      }
      current.scrollIntoView({
        block: "center",
        behavior: "smooth"
      });
    }
    lineDown() {
      if (this.index < this.lines.length - 1) {
        this.index += 1;
        if (this.index > this.lines.length - 1) {
          this.index = this.lines.length - 1;
        }
        let current = this.lines[this.index];
        let top = current.style.top;
        let bottom = parseInt(current.style.top.replace("px", "")) + parseInt(current.style.height.replace("px", ""));
        let height = bottom - parseInt(top.replace("px", ""));
        if (this.lineFocusContainer) {
          let lineFocusHeight = parseInt(
            getComputedStyle(this.lineFocusContainer).height.replace("px", "")
          );
          let blindersHeight = (lineFocusHeight - height) / 2;
          if (this.lineFocusTopBlinder)
            this.lineFocusTopBlinder.style.height = blindersHeight + "px";
          if (this.lineFocusBottomBlinder)
            this.lineFocusBottomBlinder.style.height = blindersHeight + "px";
        }
        current.scrollIntoView({
          block: "center",
          behavior: "smooth"
        });
      }
    }
    lineUp() {
      if (this.index > 0) {
        this.index -= 1;
        if (this.index < 0) {
          this.index = 0;
        }
        let current = this.lines[this.index];
        let top = current.style.top;
        let bottom = parseInt(current.style.top.replace("px", "")) + parseInt(current.style.height.replace("px", ""));
        let height = bottom - parseInt(top.replace("px", ""));
        if (this.lineFocusContainer) {
          let lineFocusHeight = parseInt(
            getComputedStyle(this.lineFocusContainer).height.replace("px", "")
          );
          let blindersHeight = (lineFocusHeight - height) / 2;
          if (this.lineFocusTopBlinder)
            this.lineFocusTopBlinder.style.height = blindersHeight + "px";
          if (this.lineFocusBottomBlinder)
            this.lineFocusBottomBlinder.style.height = blindersHeight + "px";
        }
        current.scrollIntoView({
          block: "center",
          behavior: "smooth"
        });
      }
    }
    almostEqual(a, b, tolerance) {
      return Math.abs(a - b) <= tolerance;
    }
    findRects(parent) {
      const textNodes = this.findTextNodes(parent);
      const imageNodes = Array.from(parent.getElementsByTagName("img"));
      let newNodes = [];
      textNodes.forEach((node) => {
        newNodes.push(...this.measureTextNodes(node));
      });
      imageNodes.forEach((node) => {
        newNodes.push(...this.measureImageNodes(node));
      });
      return newNodes;
    }
    findTextNodes(parentElement, nodes = []) {
      var _a, _b, _c, _d, _e, _f, _g;
      let element = parentElement.firstChild;
      while (element) {
        if (element.nodeType === 1) {
          this.findTextNodes(element, nodes);
        }
        if (element.nodeType === 3) {
          if (((_a = element.textContent) == null ? void 0 : _a.trim()) && (element.textContent.trim().length > 1 || ((_b = element.parentElement) == null ? void 0 : _b.tagName.toLowerCase()) === "h1" || ((_c = element.parentElement) == null ? void 0 : _c.tagName.toLowerCase()) === "h2" || ((_d = element.parentElement) == null ? void 0 : _d.tagName.toLowerCase()) === "h3" || ((_e = element.parentElement) == null ? void 0 : _e.tagName.toLowerCase()) === "h4" || ((_f = element.parentElement) == null ? void 0 : _f.tagName.toLowerCase()) === "h5" || ((_g = element.parentElement) == null ? void 0 : _g.tagName.toLowerCase()) === "h6") && element.parentElement && getComputedStyle(element.parentElement).verticalAlign === "baseline") {
            nodes.push(element);
          }
        }
        element = element.nextSibling;
      }
      return nodes;
    }
    measureTextNodes(node) {
      try {
        const range = document.createRange();
        range.selectNodeContents(node);
        const rect = Array.from(range.getClientRects());
        range.detach();
        return rect;
      } catch (error) {
        import_loglevel20.default.log("measureTextNode " + error);
        import_loglevel20.default.log("measureTextNode " + node);
        import_loglevel20.default.log(`${node.textContent}`);
      }
    }
    measureImageNodes(node) {
      try {
        const range = document.createRange();
        range.selectNode(node);
        const rect = Array.from(range.getClientRects());
        range.detach();
        return rect;
      } catch (error) {
        import_loglevel20.default.log("measureTextNode " + error);
        import_loglevel20.default.log("measureTextNode " + node);
        import_loglevel20.default.log(`${node.textContent}`);
      }
    }
  };

  // src/modules/history/HistoryModule.ts
  init_polyfills();
  var import_loglevel21 = __toESM(require_loglevel());
  var HistoryModule = class {
    constructor(annotator, publication, properties, headerMenu) {
      this.history = [];
      this.headerMenu = headerMenu;
      this.publication = publication;
      this.properties = properties;
      this.annotator = annotator;
    }
    static async create(config2) {
      const history = new this(
        config2.annotator,
        config2.publication,
        config2,
        config2.headerMenu
      );
      await history.start();
      return history;
    }
    async stop() {
      import_loglevel21.default.log("Page Break module stop");
      removeEventListenerOptional(
        this.historyForwardAnchorElement,
        "click",
        this.handleHistoryForwardClick.bind(this)
      );
      removeEventListenerOptional(
        this.historyBackAnchorElement,
        "click",
        this.handleHistoryBackClick.bind(this)
      );
    }
    async handleResize() {
      await this.setup();
    }
    setup() {
      if (this.history.length > 0) {
        if (this.historyForwardAnchorElement && this.historyCurrentIndex + 1 < this.history.length) {
          this.historyForwardAnchorElement.className = this.historyForwardAnchorElement.className.replace(" disabled", "");
        } else {
          if (this.historyForwardAnchorElement) {
            this.historyForwardAnchorElement.removeAttribute("href");
            this.historyForwardAnchorElement.className += " disabled";
          }
        }
        if (this.historyBackAnchorElement && this.historyCurrentIndex > 0) {
          this.historyBackAnchorElement.className = this.historyBackAnchorElement.className.replace(" disabled", "");
        } else {
          if (this.historyBackAnchorElement) {
            this.historyBackAnchorElement.removeAttribute("href");
            this.historyBackAnchorElement.className += " disabled";
          }
        }
      }
    }
    async push(locator, history) {
      let lastInHistory;
      if (history && this.annotator) {
        let lastReadingPosition = await this.annotator.getLastReadingPosition();
        if (lastReadingPosition) {
          const linkHref = this.publication.getAbsoluteHref(
            lastReadingPosition.href
          );
          lastReadingPosition.href = linkHref;
          if (this.historyCurrentIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyCurrentIndex);
            this.history.push(lastReadingPosition);
            this.historyCurrentIndex = this.history.length - 1;
          } else {
            this.history.push(lastReadingPosition);
            this.historyCurrentIndex = this.history.length - 1;
          }
        }
        if (this.historyCurrentIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyCurrentIndex);
        }
        lastInHistory = this.history[this.history.length - 1];
        if (lastInHistory && lastInHistory.href !== locator.href || lastInHistory === void 0) {
          this.history.push(locator);
          this.historyCurrentIndex = this.history.length - 1;
        }
      }
    }
    async start() {
      if (this.headerMenu)
        this.historyForwardAnchorElement = findElement(
          this.headerMenu,
          "#history-forward"
        );
      if (this.headerMenu)
        this.historyBackAnchorElement = findElement(
          this.headerMenu,
          "#history-back"
        );
      this.historyCurrentIndex = this.history.length - 1;
      addEventListenerOptional(
        this.historyForwardAnchorElement,
        "click",
        this.handleHistoryForwardClick.bind(this)
      );
      addEventListenerOptional(
        this.historyBackAnchorElement,
        "click",
        this.handleHistoryBackClick.bind(this)
      );
    }
    async handleHistoryForwardClick(event) {
      await this.historyForward();
      event.preventDefault();
      event.stopPropagation();
    }
    async historyForward() {
      if (this.history.length > 0) {
        if (this.historyCurrentIndex + 1 < this.history.length) {
          this.historyCurrentIndex = this.historyCurrentIndex + 1;
          await this.navigator.navigate(
            this.history[this.historyCurrentIndex],
            false
          );
        }
      }
    }
    async handleHistoryBackClick(event) {
      await this.historyBack();
      event.preventDefault();
      event.stopPropagation();
    }
    async historyBack() {
      if (this.history.length > 0) {
        if (this.historyCurrentIndex > 0) {
          this.historyCurrentIndex = this.historyCurrentIndex - 1;
          await this.navigator.navigate(
            this.history[this.historyCurrentIndex],
            false
          );
        }
      }
    }
  };

  // src/modules/citation/CitationModule.ts
  init_polyfills();
  var import_loglevel22 = __toESM(require_loglevel());
  var CitationStyle = /* @__PURE__ */ ((CitationStyle2) => {
    CitationStyle2[CitationStyle2["Chicago"] = 0] = "Chicago";
    CitationStyle2[CitationStyle2["MLA"] = 1] = "MLA";
    CitationStyle2[CitationStyle2["APA"] = 2] = "APA";
    return CitationStyle2;
  })(CitationStyle || {});
  var CitationModule = class {
    constructor(publication, highlighter, properties, api) {
      this.highlighter = highlighter;
      this.properties = properties;
      this.publication = publication;
      this.api = api;
    }
    static async create(config2) {
      const module2 = new this(
        config2.publication,
        config2.highlighter,
        config2,
        config2.api
      );
      await module2.start();
      return module2;
    }
    async stop() {
      import_loglevel22.default.log("Citation module stop");
    }
    copyToClipboard(textToClipboard) {
      var _a, _b, _c;
      if ((_a = this.navigator) == null ? void 0 : _a.contentProtectionModule) {
        this.navigator.contentProtectionModule.citation = true;
      }
      let success = true;
      if (window.clipboardData) {
        window.clipboardData.setData("text/plain", textToClipboard);
      } else {
        const forExecElement = this.createElementForExecCommand(textToClipboard);
        this.selectContent(forExecElement);
        try {
          if (window.netscape && netscape.security) {
            netscape.security.PrivilegeManager.enablePrivilege(
              "UniversalXPConnect"
            );
          }
          success = document.execCommand("copy", false);
        } catch (e) {
          success = false;
        }
        document.body.removeChild(forExecElement);
      }
      if (success) {
        (_b = this.api) == null ? void 0 : _b.citationCreated("The text was copied to the clipboard!");
      } else {
        (_c = this.api) == null ? void 0 : _c.citationFailed("Your browser doesn't allow clipboard access!");
      }
    }
    createElementForExecCommand(textToClipboard) {
      const forExecElement = document.createElement("div");
      forExecElement.style.position = "absolute";
      forExecElement.style.left = "-10000px";
      forExecElement.style.top = "-10000px";
      forExecElement.innerHTML = textToClipboard;
      document.body.appendChild(forExecElement);
      forExecElement.contentEditable = true;
      return forExecElement;
    }
    selectContent(element) {
      const rangeToSelect = document.createRange();
      rangeToSelect.selectNodeContents(element);
      const selection = window.getSelection();
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(rangeToSelect);
    }
    async start() {
      var _a;
      const self2 = this;
      const citationIconMenu = {
        id: "citationIcon",
        callback: function(selection) {
          var _a2, _b, _c;
          let authorsFormatted = function() {
            var _a3;
            let chicagoString = "";
            let mlaString = "";
            let apaString = "";
            if (self2.properties.author) {
              apaString = apaString + self2.properties.author;
              mlaString = mlaString + self2.properties.author;
              chicagoString = chicagoString + self2.properties.author;
            } else if (((_a3 = self2.publication.Metadata.Author) == null ? void 0 : _a3.length) > 0) {
              let authorIndex = 0;
              if (authorIndex === 0) {
                if (self2.publication.Metadata.Author[0].Name && self2.publication.Metadata.Author[0].Name instanceof String) {
                  if (self2.publication.Metadata.Author[0].Name.length > 0) {
                    apaString = apaString + self2.publication.Metadata.Author[0].Name;
                    mlaString = mlaString + self2.publication.Metadata.Author[0].Name;
                    chicagoString = chicagoString + self2.publication.Metadata.Author[0].Name;
                  }
                }
              }
            }
            if (apaString.length > 0 && mlaString.length > 0 && chicagoString.length > 0) {
              return [chicagoString + ". ", mlaString + ". ", apaString + ". "];
            }
            return ["", "", ""];
          };
          let yearPublishedFormatted = function() {
            let chicagoString = "";
            let mlaString = "";
            let apaString = "";
            if (self2.properties.publisher) {
              mlaString = mlaString + self2.properties.publisher;
              chicagoString = chicagoString + self2.properties.publisher;
            } else if (self2.publication.Metadata.Publisher && self2.publication.Metadata.Publisher[0].Name) {
              mlaString = mlaString + self2.publication.Metadata.Publisher[0].Name;
              chicagoString = chicagoString + self2.publication.Metadata.Publisher[0].Name;
            }
            if (self2.properties.published) {
              apaString = apaString + "(" + self2.properties.published + ")";
              mlaString = mlaString + ", " + self2.properties.published;
              chicagoString = chicagoString + ", " + self2.properties.published;
            } else if (self2.publication.Metadata.PublicationDate) {
              if (self2.publication.Metadata.PublicationDate.getFullYear() > 0) {
                apaString = apaString + "(" + self2.publication.Metadata.PublicationDate.getFullYear() + ")";
                mlaString = mlaString + ", " + self2.publication.Metadata.PublicationDate.getFullYear();
                chicagoString = chicagoString + ", " + self2.publication.Metadata.PublicationDate.getFullYear();
              }
            }
            if (apaString.length > 0 && mlaString.length > 0 && chicagoString.length > 0) {
              return [chicagoString + ". ", mlaString + ". ", apaString + ". "];
            }
            return ["", "", ""];
          };
          let bookTitleFormatted = function() {
            if (self2.properties.title) {
              return [
                "<em>" + self2.properties.title + "</em>. ",
                "<em>" + self2.properties.title + "</em>. ",
                "<em>" + self2.properties.title + "</em>. "
              ];
            } else if (self2.publication.Metadata.Title) {
              return [
                "<em>" + self2.publication.Metadata.Title + "</em>. ",
                "<em>" + self2.publication.Metadata.Title + "</em>. ",
                "<em>" + self2.publication.Metadata.Title + "</em>. "
              ];
            } else {
              return ["", "", ""];
            }
          };
          let editionFormatted = function() {
            return ["", "", ""];
          };
          let publisherFormatted = function() {
            let chicagoString = "";
            let mlaString = "";
            let apaString = "";
            if (self2.properties.publisher) {
              mlaString = mlaString + self2.properties.publisher + ", ";
              chicagoString = chicagoString + self2.properties.publisher + ", ";
              apaString = apaString + self2.properties.publisher;
            } else if (self2.publication.Metadata.Publisher && self2.publication.Metadata.Publisher[0].Name) {
              mlaString = mlaString + self2.publication.Metadata.Publisher[0].Name + ", ";
              chicagoString = chicagoString + self2.publication.Metadata.Publisher[0].Name + ", ";
              apaString = apaString + self2.publication.Metadata.Publisher[0].Name;
            }
            if (apaString.length > 0 && mlaString.length > 0 && chicagoString.length > 0) {
              return [chicagoString + ". ", mlaString + ". ", apaString + ". "];
            }
            return ["", "", ""];
          };
          let contributorsFormatted = function() {
            return ["", "", ""];
          };
          let eBookVersionFormatted = function() {
            return ["", "", ""];
          };
          let locationFormatted = function() {
            return ["", "", ""];
          };
          let libraryFormatted = function() {
            if (self2.properties.library) {
              return [
                "Retrieved from " + self2.properties.library + ". ",
                "Retrieved from " + self2.properties.library + ". ",
                "Retrieved from " + self2.properties.library + ". "
              ];
            }
            return ["", "", ""];
          };
          let appNameFormatted = function() {
            if (self2.properties.appName) {
              return [
                self2.properties.appName + ". ",
                self2.properties.appName + ". ",
                self2.properties.appName + ". "
              ];
            }
            return ["", "", ""];
          };
          let appLinkFormatted = function() {
            if (self2.properties.appLink) {
              return [
                self2.properties.appLink + ". ",
                self2.properties.appLink + ". ",
                self2.properties.appLink + ". "
              ];
            }
            return ["", "", ""];
          };
          let seriesFormatted = function() {
            return ["", "", ""];
          };
          let selectedText = function(string, length) {
            return string.length > length ? string.substring(0, length) + "..." : string;
          };
          const chicago = authorsFormatted()[0 /* Chicago */] + bookTitleFormatted()[0 /* Chicago */] + contributorsFormatted()[0 /* Chicago */] + editionFormatted()[0 /* Chicago */] + locationFormatted()[0 /* Chicago */] + yearPublishedFormatted()[0 /* Chicago */] + eBookVersionFormatted()[0 /* Chicago */] + libraryFormatted()[0 /* Chicago */] + appNameFormatted()[0 /* Chicago */] + appLinkFormatted()[0 /* Chicago */];
          const apa = authorsFormatted()[2 /* APA */] + yearPublishedFormatted()[2 /* APA */] + bookTitleFormatted()[2 /* APA */] + editionFormatted()[2 /* APA */] + publisherFormatted()[2 /* APA */] + contributorsFormatted()[2 /* APA */] + eBookVersionFormatted()[2 /* APA */] + locationFormatted()[2 /* APA */] + libraryFormatted()[2 /* APA */] + appNameFormatted()[2 /* APA */] + appLinkFormatted()[2 /* APA */];
          const mla = authorsFormatted()[1 /* MLA */] + bookTitleFormatted()[1 /* MLA */] + contributorsFormatted()[1 /* MLA */] + editionFormatted()[1 /* MLA */] + locationFormatted()[1 /* MLA */] + yearPublishedFormatted()[1 /* MLA */] + seriesFormatted()[1 /* MLA */] + libraryFormatted()[1 /* MLA */] + appNameFormatted()[1 /* MLA */] + appLinkFormatted()[1 /* MLA */];
          const citationChicago = "\u201C" + selectedText(selection, self2.properties.characters) + "\u201C<br><br>" + chicago;
          const citationApa = "\u201C" + selectedText(selection, self2.properties.characters) + "\u201C<br><br>" + apa;
          const citationMla = "\u201C" + selectedText(selection, self2.properties.characters) + "\u201C<br><br>" + mla;
          let citation = "";
          if ((_a2 = self2.properties.styles) == null ? void 0 : _a2.includes(CitationStyle[0 /* Chicago */])) {
            if (self2.properties.styles.length > 1) {
              citation = citation + "Chicago: <br>";
            }
            citation = citation + citationChicago + "<br><br>";
          }
          if ((_b = self2.properties.styles) == null ? void 0 : _b.includes(CitationStyle[2 /* APA */])) {
            if (self2.properties.styles.length > 1) {
              citation = citation + "APA: <br>";
            }
            citation = citation + citationApa + "<br><br>";
          }
          if ((_c = self2.properties.styles) == null ? void 0 : _c.includes(CitationStyle[1 /* MLA */])) {
            if (self2.properties.styles.length > 1) {
              citation = citation + "MLA: <br>";
            }
            citation = citation + citationMla + "<br><br>";
          }
          self2.copyToClipboard(citation);
        }
      };
      (_a = this.highlighter) == null ? void 0 : _a.addSelectionMenuItem(citationIconMenu);
    }
  };

  // src/navigator/IFrameNavigator.ts
  var import_loglevel23 = __toESM(require_loglevel());
  var IFrameNavigator = class _IFrameNavigator extends eventemitter3_default {
    constructor(settings, annotator = void 0, initialLastReadingPosition = void 0, publication, api, rights, tts, injectables, attributes, services, sample, requestConfig, highlighter, modules) {
      super();
      this.iframes = [];
      this.sideNavExpanded = false;
      this.currentChapterLink = { href: "" };
      this.currentSpreadLinks = {};
      this.rights = {
        autoGeneratePositions: false,
        enableAnnotations: false,
        enableBookmarks: false,
        enableContentProtection: false,
        enableDefinitions: false,
        enableLineFocus: false,
        enableMediaOverlays: false,
        enablePageBreaks: false,
        enableSearch: false,
        enableTTS: false,
        enableTimeline: false,
        customKeyboardEvents: false,
        enableHistory: false,
        enableCitations: false
      };
      this.didInitKeyboardEventHandler = false;
      this.onResize = () => {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(this.handleResize.bind(this), 200);
      };
      this.reload = async () => {
        let lastReadingPosition = void 0;
        if (this.annotator) {
          lastReadingPosition = await this.annotator.getLastReadingPosition();
        }
        if (lastReadingPosition) {
          const linkHref = this.publication.getAbsoluteHref(
            lastReadingPosition.href
          );
          import_loglevel23.default.log(lastReadingPosition.href);
          import_loglevel23.default.log(linkHref);
          lastReadingPosition.href = linkHref;
          await this.navigate(lastReadingPosition);
        }
      };
      this.savePosition = (0, import_debounce7.debounce)(() => {
        if (this.annotator) {
          this.saveCurrentReadingPosition();
        }
      }, 200);
      this.checkResourcePosition = (0, import_debounce7.debounce)(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        if (((_a = this.view) == null ? void 0 : _a.atStart()) && ((_b = this.view) == null ? void 0 : _b.atEnd())) {
          if ((_c = this.api) == null ? void 0 : _c.resourceFitsScreen)
            (_d = this.api) == null ? void 0 : _d.resourceFitsScreen();
          this.emit("resource.fits");
        } else if ((_e = this.view) == null ? void 0 : _e.atEnd()) {
          if ((_f = this.api) == null ? void 0 : _f.resourceAtEnd)
            (_g = this.api) == null ? void 0 : _g.resourceAtEnd();
          this.emit("resource.end");
        } else if ((_h = this.view) == null ? void 0 : _h.atStart()) {
          if ((_i = this.api) == null ? void 0 : _i.resourceAtStart)
            (_j = this.api) == null ? void 0 : _j.resourceAtStart();
          this.emit("resource.start");
        }
      }, 200);
      this.highlighter = highlighter;
      if (this.highlighter) {
        this.highlighter.navigator = this;
      }
      for (const index2 in modules) {
        let module2 = modules[index2];
        if (module2) {
          module2.navigator = this;
        }
        if (modules[index2] instanceof AnnotationModule) {
          this.annotationModule = module2;
        }
        if (modules[index2] instanceof BookmarkModule) {
          this.bookmarkModule = module2;
        }
        if (modules[index2] instanceof TTSModule2) {
          this.ttsModule = module2;
        }
        if (modules[index2] instanceof TTSModule2) {
          this.ttsModule = module2;
        }
        if (modules[index2] instanceof SearchModule) {
          this.searchModule = module2;
        }
        if (modules[index2] instanceof DefinitionsModule) {
          this.definitionsModule = module2;
        }
        if (modules[index2] instanceof TimelineModule) {
          this.timelineModule = module2;
        }
        if (modules[index2] instanceof ContentProtectionModule) {
          this.contentProtectionModule = module2;
        }
        if (modules[index2] instanceof CitationModule) {
          this.citationModule = module2;
        }
        if (modules[index2] instanceof MediaOverlayModule) {
          this.mediaOverlayModule = module2;
        }
        if (modules[index2] instanceof PageBreakModule) {
          this.pageBreakModule = module2;
        }
        if (modules[index2] instanceof LineFocusModule) {
          this.lineFocusModule = module2;
        }
        if (modules[index2] instanceof HistoryModule) {
          this.historyModule = module2;
        }
        if (modules[index2] instanceof ConsumptionModule) {
          this.consumptionModule = module2;
        }
      }
      this.settings = settings;
      this.annotator = annotator;
      this.view = settings.view;
      this.view.attributes = attributes;
      this.view.navigator = this;
      this.eventHandler = new EventHandler(this);
      this.touchEventHandler = new TouchEventHandler(this);
      this.keyboardEventHandler = new KeyboardEventHandler(this);
      this.initialLastReadingPosition = initialLastReadingPosition;
      this.publication = publication;
      this.api = api;
      this.rights = rights ?? {
        autoGeneratePositions: false,
        enableAnnotations: false,
        enableBookmarks: false,
        enableContentProtection: false,
        enableDefinitions: false,
        enableLineFocus: false,
        enableMediaOverlays: false,
        enablePageBreaks: false,
        enableSearch: false,
        enableTTS: false,
        enableTimeline: false,
        customKeyboardEvents: false,
        enableHistory: false,
        enableCitations: false
      };
      this.tts = tts;
      this.injectables = injectables;
      this.attributes = attributes || { margin: 0 };
      this.services = services;
      this.sample = sample;
      this.requestConfig = requestConfig;
      this.sampleReadEventHandler = new SampleReadEventHandler(this);
    }
    static async create(config2) {
      const navigator2 = new this(
        config2.settings,
        config2.annotator || void 0,
        config2.initialLastReadingPosition || void 0,
        config2.publication,
        config2.api,
        config2.rights,
        config2.tts,
        config2.injectables,
        config2.attributes || { margin: 0 },
        config2.services,
        config2.sample,
        config2.requestConfig,
        config2.highlighter,
        config2.modules
      );
      await navigator2.start(
        config2.mainElement,
        config2.headerMenu,
        config2.footerMenu
      );
      return new Promise((resolve) => resolve(navigator2));
    }
    stop() {
      import_loglevel23.default.log("Iframe navigator stop");
      removeEventListenerOptional(
        this.previousChapterAnchorElement,
        "click",
        this.handlePreviousChapterClick.bind(this)
      );
      removeEventListenerOptional(
        this.nextChapterAnchorElement,
        "click",
        this.handleNextChapterClick.bind(this)
      );
      removeEventListenerOptional(
        this.previousChapterTopAnchorElement,
        "click",
        this.handlePreviousPageClick.bind(this)
      );
      removeEventListenerOptional(
        this.nextChapterBottomAnchorElement,
        "click",
        this.handleNextPageClick.bind(this)
      );
      removeEventListenerOptional(
        this.previousPageAnchorElement,
        "click",
        this.handlePreviousPageClick.bind(this)
      );
      removeEventListenerOptional(
        this.nextPageAnchorElement,
        "click",
        this.handleNextPageClick.bind(this)
      );
      removeEventListenerOptional(
        this.tryAgainButton,
        "click",
        this.tryAgain.bind(this)
      );
      removeEventListenerOptional(
        this.goBackButton,
        "click",
        _IFrameNavigator.goBack.bind(this)
      );
      removeEventListenerOptional(
        this.espandMenuIcon,
        "click",
        this.handleEditClick.bind(this)
      );
      removeEventListenerOptional(window, "resize", this.onResize);
      this.iframes.forEach((iframe) => {
        removeEventListenerOptional(iframe, "resize", this.onResize);
      });
      if (this.didInitKeyboardEventHandler)
        this.keyboardEventHandler.removeEvents(document);
    }
    async start(mainElement, headerMenu, footerMenu) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
      this.headerMenu = headerMenu;
      this.mainElement = mainElement;
      try {
        const wrapper = findRequiredElement(
          mainElement,
          "main#iframe-wrapper"
        );
        wrapper.style.overflow = "auto";
        let iframe = findElement(
          mainElement,
          "main#iframe-wrapper iframe"
        );
        let iframe2 = findElement(mainElement, "#second");
        if (iframe) {
          this.iframes.push(iframe);
        }
        if (iframe2) {
          this.iframes.push(iframe2);
        }
        if (window.matchMedia("screen and (max-width: 600px)").matches) {
          this.settings.columnCount = 1;
        }
        if (this.iframes.length === 0) {
          wrapper.style.overflow = "auto";
          let iframe3 = document.createElement("iframe");
          iframe3.setAttribute("SCROLLING", "no");
          iframe3.setAttribute("allowtransparency", "true");
          this.iframes.push(iframe3);
          if (this.publication.isFixedLayout) {
            this.spreads = document.createElement("div");
            this.firstSpread = document.createElement("div");
            this.spreads.style.display = "flex";
            this.spreads.style.alignItems = "center";
            this.spreads.style.justifyContent = "center";
            this.spreads.appendChild(this.firstSpread);
            this.firstSpread.appendChild(this.iframes[0]);
            wrapper.appendChild(this.spreads);
          } else {
            iframe3.setAttribute("height", "100%");
            iframe3.setAttribute("width", "100%");
            wrapper.appendChild(this.iframes[0]);
          }
          if (this.publication.isFixedLayout) {
            if (this.settings.columnCount !== 1 && !window.matchMedia("screen and (max-width: 600px)").matches) {
              let secondSpread = document.createElement("div");
              this.spreads.appendChild(secondSpread);
              let iframe22 = document.createElement("iframe");
              iframe22.setAttribute("SCROLLING", "no");
              iframe22.setAttribute("allowtransparency", "true");
              iframe22.style.opacity = "1";
              iframe22.style.border = "none";
              iframe22.style.overflow = "hidden";
              this.iframes.push(iframe22);
              secondSpread.appendChild(this.iframes[1]);
              this.firstSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 100% 120%, -20% 120%)";
              this.firstSpread.style.boxShadow = "0 0 8px 2px #ccc";
              secondSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 120% 100%, 0% 120%)";
              secondSpread.style.boxShadow = "0 0 8px 2px #ccc";
            } else {
              this.firstSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 120% 100%, -20% 120%)";
              this.firstSpread.style.boxShadow = "0 0 8px 2px #ccc";
            }
          } else {
            this.iframes[0].style.paddingTop = (((_a = this.attributes) == null ? void 0 : _a.iframePaddingTop) ?? 0) + "px";
          }
        }
        if (this.publication.isFixedLayout) {
          const minHeight = wrapper.clientHeight;
          var iframeParent = (_b = this.iframes[0].parentElement) == null ? void 0 : _b.parentElement;
          iframeParent.style.height = minHeight + 40 + "px";
        } else {
          if (this.iframes.length === 2) {
            this.iframes.pop();
          }
        }
        this.loadingMessage = findElement(
          mainElement,
          "#reader-loading"
        );
        if (this.loadingMessage) {
          this.loadingMessage.innerHTML = readerLoading;
          this.loadingMessage.style.display = "none";
        }
        this.errorMessage = findElement(
          mainElement,
          "#reader-error"
        );
        if (this.errorMessage) {
          this.errorMessage.innerHTML = readerError;
          this.errorMessage.style.display = "none";
        }
        this.tryAgainButton = findElement(
          mainElement,
          "#r2d2bc-try-again"
        );
        this.goBackButton = findElement(
          mainElement,
          "#r2d2bc-go-back"
        );
        this.infoTop = findElement(mainElement, "#reader-info-top") || findElement(mainElement, "div[class='info top']");
        this.infoBottom = findElement(mainElement, "#reader-info-bottom") || findElement(mainElement, "div[class='info bottom']");
        if (this.headerMenu)
          this.bookTitle = findElement(
            this.headerMenu,
            "#book-title"
          );
        if (this.infoBottom)
          this.chapterTitle = findElement(this.infoBottom, "#chapter-title") || findElement(
            this.infoBottom,
            "span[class=chapter-title]"
          );
        if (this.infoBottom)
          this.chapterPosition = findElement(this.infoBottom, "#chapter-position") || findElement(
            this.infoBottom,
            "span[class=chapter-position]"
          );
        if (this.infoBottom)
          this.remainingPositions = findElement(this.infoBottom, "#remaining-positions") || findElement(
            this.infoBottom,
            "span[class=remaining-positions]"
          );
        if (this.headerMenu)
          this.espandMenuIcon = findElement(
            this.headerMenu,
            "#expand-menu"
          );
        if (this.headerMenu)
          this.links = findElement(this.headerMenu, "ul.links.top");
        if (this.headerMenu)
          this.linksTopLeft = findElement(
            this.headerMenu,
            "#nav-mobile-left"
          );
        if (this.headerMenu)
          this.tocView = findElement(
            this.headerMenu,
            "#container-view-toc"
          );
        if (this.headerMenu)
          this.landmarksView = findElement(
            this.headerMenu,
            "#container-view-landmarks"
          );
        if (this.headerMenu)
          this.landmarksSection = findElement(
            this.headerMenu,
            "#sidenav-section-landmarks"
          );
        if (this.headerMenu)
          this.pageListView = findElement(
            this.headerMenu,
            "#container-view-pagelist"
          );
        if (footerMenu)
          this.linksBottom = findElement(
            footerMenu,
            "ul.links.bottom"
          );
        if (footerMenu)
          this.linksMiddle = findElement(
            footerMenu,
            "ul.links.middle"
          );
        if (this.headerMenu)
          this.nextChapterAnchorElement = findElement(
            this.headerMenu,
            "a[rel=next]"
          );
        if (this.headerMenu)
          this.nextChapterBottomAnchorElement = findElement(
            mainElement,
            "#next-chapter"
          );
        if (footerMenu)
          this.nextPageAnchorElement = findElement(
            footerMenu,
            "a[rel=next]"
          );
        if (this.headerMenu)
          this.previousChapterAnchorElement = findElement(
            this.headerMenu,
            "a[rel=prev]"
          );
        if (this.headerMenu)
          this.previousChapterTopAnchorElement = findElement(
            mainElement,
            "#previous-chapter"
          );
        if (footerMenu)
          this.previousPageAnchorElement = findElement(
            footerMenu,
            "a[rel=prev]"
          );
        if (this.nextChapterBottomAnchorElement)
          this.nextChapterBottomAnchorElement.style.display = "none";
        if (this.previousChapterTopAnchorElement)
          this.previousChapterTopAnchorElement.style.display = "none";
        this.newPosition = void 0;
        this.newElementId = void 0;
        this.isBeingStyled = true;
        this.isLoading = true;
        this.settings.setIframe(this.iframes[0]);
        this.settings.onSettingsChange(this.handleResize.bind(this));
        this.settings.onColumnSettingsChange(
          this.handleNumberOfIframes.bind(this)
        );
        this.settings.onViewChange(this.updateBookView.bind(this));
        if (this.initialLastReadingPosition) {
          (_c = this.annotator) == null ? void 0 : _c.initLastReadingPosition(
            this.initialLastReadingPosition
          );
        }
        if (this.headerMenu) {
          var menuSearch = findElement(
            this.headerMenu,
            "#menu-button-search"
          );
          var menuTTS = findElement(
            this.headerMenu,
            "#menu-button-tts"
          );
          var menuBookmark = findElement(
            this.headerMenu,
            "#menu-button-bookmark"
          );
          var play = findElement(
            this.headerMenu,
            "#menu-button-play"
          );
          var pause = findElement(
            this.headerMenu,
            "#menu-button-pause"
          );
          var menu = findElement(
            this.headerMenu,
            "#menu-button-mediaoverlay"
          );
          if (!this.rights.enableBookmarks) {
            if (menuBookmark)
              (_d = menuBookmark.parentElement) == null ? void 0 : _d.style.setProperty("display", "none");
            var sideNavSectionBookmarks = findElement(
              this.headerMenu,
              "#sidenav-section-bookmarks"
            );
            if (sideNavSectionBookmarks)
              sideNavSectionBookmarks.style.setProperty("display", "none");
          }
          if (!this.rights.enableAnnotations) {
            var sideNavSectionHighlights = findElement(
              this.headerMenu,
              "#sidenav-section-highlights"
            );
            if (sideNavSectionHighlights)
              sideNavSectionHighlights.style.setProperty("display", "none");
          }
          if (!this.rights.enableTTS) {
            if (menuTTS)
              (_e = menuTTS.parentElement) == null ? void 0 : _e.style.setProperty("display", "none");
          }
          if (!this.rights.enableSearch) {
            if (menuSearch)
              (_f = menuSearch.parentElement) == null ? void 0 : _f.style.setProperty("display", "none");
          }
          if (menuSearch && ((_g = this.view) == null ? void 0 : _g.navigator.publication.isFixedLayout)) {
            (_h = menuSearch.parentElement) == null ? void 0 : _h.style.setProperty("display", "none");
          }
          if (this.hasMediaOverlays) {
            if (play)
              (_i = play.parentElement) == null ? void 0 : _i.style.removeProperty("display");
            if (pause)
              (_j = pause.parentElement) == null ? void 0 : _j.style.removeProperty("display");
            if (menu)
              (_k = menu.parentElement) == null ? void 0 : _k.style.removeProperty("display");
          } else {
            if (play)
              (_l = play.parentElement) == null ? void 0 : _l.style.setProperty("display", "none");
            if (pause)
              (_m = pause.parentElement) == null ? void 0 : _m.style.setProperty("display", "none");
            if (menu)
              (_n = menu.parentElement) == null ? void 0 : _n.style.setProperty("display", "none");
          }
        } else {
          if (menuSearch)
            (_o = menuSearch.parentElement) == null ? void 0 : _o.style.setProperty("display", "none");
          if (menuTTS)
            (_p = menuTTS.parentElement) == null ? void 0 : _p.style.setProperty("display", "none");
          if (menuBookmark)
            (_q = menuBookmark.parentElement) == null ? void 0 : _q.style.setProperty("display", "none");
        }
        this.setupEvents();
        return await this.loadManifest();
      } catch (err) {
        import_loglevel23.default.error(err);
        this.abortOnError(err);
        return Promise.reject(err);
      }
    }
    setupEvents() {
      for (const iframe of this.iframes) {
        addEventListenerOptional(
          iframe,
          "load",
          this.handleIFrameLoad.bind(this)
        );
      }
      addEventListenerOptional(
        this.previousChapterAnchorElement,
        "click",
        this.handlePreviousChapterClick.bind(this)
      );
      addEventListenerOptional(
        this.nextChapterAnchorElement,
        "click",
        this.handleNextChapterClick.bind(this)
      );
      addEventListenerOptional(
        this.previousChapterTopAnchorElement,
        "click",
        this.handlePreviousPageClick.bind(this)
      );
      addEventListenerOptional(
        this.nextChapterBottomAnchorElement,
        "click",
        this.handleNextPageClick.bind(this)
      );
      addEventListenerOptional(
        this.previousPageAnchorElement,
        "click",
        this.handlePreviousPageClick.bind(this)
      );
      addEventListenerOptional(
        this.nextPageAnchorElement,
        "click",
        this.handleNextPageClick.bind(this)
      );
      addEventListenerOptional(
        this.tryAgainButton,
        "click",
        this.tryAgain.bind(this)
      );
      addEventListenerOptional(
        this.goBackButton,
        "click",
        _IFrameNavigator.goBack.bind(this)
      );
      addEventListenerOptional(
        this.espandMenuIcon,
        "click",
        this.handleEditClick.bind(this)
      );
      addEventListenerOptional(window, "resize", this.onResize);
      for (const iframe of this.iframes) {
        addEventListenerOptional(iframe, "resize", this.onResize);
      }
    }
    updateBookView(options) {
      var _a;
      if (((_a = this.view) == null ? void 0 : _a.layout) === "fixed") {
        if (this.nextPageAnchorElement)
          this.nextPageAnchorElement.style.display = "none";
        if (this.previousPageAnchorElement)
          this.previousPageAnchorElement.style.display = "none";
        if (this.nextChapterBottomAnchorElement)
          this.nextChapterBottomAnchorElement.style.display = "none";
        if (this.previousChapterTopAnchorElement)
          this.previousChapterTopAnchorElement.style.display = "none";
        if (this.keyboardEventHandler) {
          this.keyboardEventHandler.onBackwardSwipe = this.handlePreviousChapterClick.bind(this);
          this.keyboardEventHandler.onForwardSwipe = this.handleNextChapterClick.bind(this);
          this.keyboardEventHandler.onKeydown = this.handleKeydownFallthrough.bind(this);
        }
        if (this.touchEventHandler) {
          this.touchEventHandler.onBackwardSwipe = this.handlePreviousPageClick.bind(this);
          this.touchEventHandler.onForwardSwipe = this.handleNextPageClick.bind(this);
        }
      } else {
        this.settings.isPaginated().then((paginated) => {
          var _a2, _b, _c, _d, _e, _f;
          if (paginated) {
            this.view.height = getHeight() - 40 - (((_a2 = this.attributes) == null ? void 0 : _a2.margin) ?? 0);
            if (this.infoBottom)
              this.infoBottom.style.removeProperty("display");
            document.body.onscroll = () => {
            };
            if (this.nextChapterBottomAnchorElement)
              this.nextChapterBottomAnchorElement.style.display = "none";
            if (this.previousChapterTopAnchorElement)
              this.previousChapterTopAnchorElement.style.display = "none";
            if (this.nextPageAnchorElement)
              this.nextPageAnchorElement.style.display = "unset";
            if (this.previousPageAnchorElement)
              this.previousPageAnchorElement.style.display = "unset";
            if (this.chapterTitle)
              this.chapterTitle.style.display = "inline";
            if (this.chapterPosition)
              this.chapterPosition.style.display = "inline";
            if (this.remainingPositions)
              this.remainingPositions.style.display = "inline";
            if (this.eventHandler) {
              this.eventHandler.onInternalLink = this.handleInternalLink.bind(this);
              this.eventHandler.onClickThrough = this.handleClickThrough.bind(this);
            }
            if (this.touchEventHandler) {
              this.touchEventHandler.onBackwardSwipe = this.handlePreviousPageClick.bind(this);
              this.touchEventHandler.onForwardSwipe = this.handleNextPageClick.bind(this);
            }
            if (this.keyboardEventHandler) {
              this.keyboardEventHandler.onBackwardSwipe = this.handlePreviousPageClick.bind(this);
              this.keyboardEventHandler.onForwardSwipe = this.handleNextPageClick.bind(this);
              this.keyboardEventHandler.onKeydown = this.handleKeydownFallthrough.bind(this);
            }
          } else {
            if (this.infoBottom)
              this.infoBottom.style.display = "none";
            if (this.nextPageAnchorElement)
              this.nextPageAnchorElement.style.display = "none";
            if (this.previousPageAnchorElement)
              this.previousPageAnchorElement.style.display = "none";
            if (((_b = this.view) == null ? void 0 : _b.layout) === "fixed") {
              if (this.nextChapterBottomAnchorElement)
                this.nextChapterBottomAnchorElement.style.display = "none";
              if (this.previousChapterTopAnchorElement)
                this.previousChapterTopAnchorElement.style.display = "none";
            } else {
              if (((_c = this.view) == null ? void 0 : _c.atStart()) && ((_d = this.view) == null ? void 0 : _d.atEnd())) {
                if (this.nextChapterBottomAnchorElement)
                  this.nextChapterBottomAnchorElement.style.display = "unset";
                if (this.previousChapterTopAnchorElement)
                  this.previousChapterTopAnchorElement.style.display = "unset";
              } else if ((_e = this.view) == null ? void 0 : _e.atEnd()) {
                if (this.previousChapterTopAnchorElement)
                  this.previousChapterTopAnchorElement.style.display = "none";
                if (this.nextChapterBottomAnchorElement)
                  this.nextChapterBottomAnchorElement.style.display = "unset";
              } else if ((_f = this.view) == null ? void 0 : _f.atStart()) {
                if (this.nextChapterBottomAnchorElement)
                  this.nextChapterBottomAnchorElement.style.display = "none";
                if (this.previousChapterTopAnchorElement)
                  this.previousChapterTopAnchorElement.style.display = "unset";
              } else {
                if (this.nextChapterBottomAnchorElement)
                  this.nextChapterBottomAnchorElement.style.display = "none";
                if (this.previousChapterTopAnchorElement)
                  this.previousChapterTopAnchorElement.style.display = "none";
              }
            }
            const onDoScrolling = (0, import_debounce7.debounce)(() => {
              this.isScrolling = false;
            }, 200);
            const wrapper = findRequiredElement(
              document,
              "#iframe-wrapper"
            );
            wrapper.onscroll = async () => {
              var _a3, _b2;
              this.isScrolling = true;
              await this.savePosition();
              if ((_a3 = this.view) == null ? void 0 : _a3.atEnd()) {
              } else {
              }
              if (((_b2 = this.view) == null ? void 0 : _b2.layout) === "fixed") {
                if (this.nextChapterBottomAnchorElement)
                  this.nextChapterBottomAnchorElement.style.display = "none";
                if (this.previousChapterTopAnchorElement)
                  this.previousChapterTopAnchorElement.style.display = "none";
              } else {
                this.settings.isPaginated().then((paginated2) => {
                  var _a4, _b3, _c2, _d2;
                  if (!paginated2) {
                    if (((_a4 = this.view) == null ? void 0 : _a4.atStart()) && ((_b3 = this.view) == null ? void 0 : _b3.atEnd())) {
                      if (this.nextChapterBottomAnchorElement)
                        this.nextChapterBottomAnchorElement.style.display = "unset";
                      if (this.previousChapterTopAnchorElement)
                        this.previousChapterTopAnchorElement.style.display = "unset";
                    } else if ((_c2 = this.view) == null ? void 0 : _c2.atEnd()) {
                      if (this.previousChapterTopAnchorElement)
                        this.previousChapterTopAnchorElement.style.display = "none";
                      if (this.nextChapterBottomAnchorElement)
                        this.nextChapterBottomAnchorElement.style.display = "unset";
                    } else if ((_d2 = this.view) == null ? void 0 : _d2.atStart()) {
                      if (this.nextChapterBottomAnchorElement)
                        this.nextChapterBottomAnchorElement.style.display = "none";
                      if (this.previousChapterTopAnchorElement)
                        this.previousChapterTopAnchorElement.style.display = "unset";
                    } else {
                      if (this.nextChapterBottomAnchorElement)
                        this.nextChapterBottomAnchorElement.style.display = "none";
                      if (this.previousChapterTopAnchorElement)
                        this.previousChapterTopAnchorElement.style.display = "none";
                    }
                  }
                });
                this.checkResourcePosition();
              }
              onDoScrolling();
            };
            if (this.chapterTitle)
              this.chapterTitle.style.display = "none";
            if (this.chapterPosition)
              this.chapterPosition.style.display = "none";
            if (this.remainingPositions)
              this.remainingPositions.style.display = "none";
            if (this.eventHandler) {
              this.eventHandler.onInternalLink = this.handleInternalLink.bind(this);
              this.eventHandler.onClickThrough = this.handleClickThrough.bind(this);
            }
            if (this.touchEventHandler) {
              this.touchEventHandler.onBackwardSwipe = this.handlePreviousPageClick.bind(this);
              this.touchEventHandler.onForwardSwipe = this.handleNextPageClick.bind(this);
            }
            if (this.keyboardEventHandler) {
              this.keyboardEventHandler.onBackwardSwipe = this.handlePreviousPageClick.bind(this);
              this.keyboardEventHandler.onForwardSwipe = this.handleNextPageClick.bind(this);
              this.keyboardEventHandler.onKeydown = this.handleKeydownFallthrough.bind(this);
            }
          }
        });
        if (!(options == null ? void 0 : options.skipDrawingAnnotations)) {
          setTimeout(async () => {
            var _a2;
            await ((_a2 = this.highlighter) == null ? void 0 : _a2.prepareContainers(
              this.iframes[0].contentWindow
            ));
            if (this.highlighter) {
              if (this.rights.enableAnnotations && this.annotationModule) {
                await this.annotationModule.drawHighlights();
              }
              if (this.rights.enableBookmarks && this.bookmarkModule) {
                await this.bookmarkModule.drawBookmarks();
              }
              if (this.rights.enableSearch && this.searchModule) {
                await this.highlighter.destroyHighlights(1 /* Search */);
                this.searchModule.drawSearch();
              }
              if (this.rights.enablePageBreaks && this.pageBreakModule) {
                await this.highlighter.destroyHighlights(3 /* PageBreak */);
                await this.pageBreakModule.drawPageBreaks();
              }
              if (this.rights.enableDefinitions && this.definitionsModule) {
                await this.definitionsModule.drawDefinitions();
              }
            }
          }, 200);
        }
      }
    }
    async loadManifest() {
      var _a, _b, _c, _d, _e;
      try {
        const createSubmenu = (parentElement, links, ol = false) => {
          var listElement = document.createElement("ul");
          if (ol) {
            listElement = document.createElement("ol");
          }
          listElement.className = "sidenav-toc";
          for (const link of links) {
            const listItemElement = document.createElement("li");
            const linkElement = document.createElement("a");
            const spanElement = document.createElement("span");
            linkElement.className = "chapter-link";
            linkElement.tabIndex = -1;
            let href = "";
            if (link.Href) {
              href = this.publication.getAbsoluteHref(link.Href);
              linkElement.href = href;
              linkElement.innerHTML = link.Title || "";
              listItemElement.appendChild(linkElement);
            } else {
              spanElement.innerHTML = link.Title || "";
              spanElement.className = "chapter-title";
              listItemElement.appendChild(spanElement);
            }
            if (link.Children && link.Children.length > 0) {
              createSubmenu(listItemElement, link.Children, true);
            }
            listElement.appendChild(listItemElement);
          }
          addEventListenerOptional(listElement, "click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (event.target && event.target.tagName.toLowerCase() === "a") {
              let linkElement = event.target;
              if (linkElement.className.indexOf("active") !== -1) {
                this.hideView();
              } else {
                let locations = {
                  progression: 0
                };
                if (linkElement.href.indexOf("#") !== -1) {
                  const elementId = linkElement.href.slice(
                    linkElement.href.indexOf("#") + 1
                  );
                  if (elementId !== void 0) {
                    locations = {
                      fragment: elementId
                    };
                  }
                }
                const position = {
                  href: linkElement.href,
                  locations,
                  type: linkElement.type,
                  title: linkElement.title
                };
                this.hideView();
                this.navigate(position);
              }
            }
          });
          parentElement.appendChild(listElement);
        };
        const toc = this.publication.tableOfContents;
        const landmarks = this.publication.landmarks;
        const pageList = this.publication.pageList;
        if (this.tocView) {
          if (toc.length) {
            createSubmenu(this.tocView, toc);
          } else {
            (_b = (_a = this.tocView.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.removeChild(
              this.tocView.parentElement
            );
          }
        }
        if (this.pageListView) {
          if (pageList == null ? void 0 : pageList.length) {
            createSubmenu(this.pageListView, pageList);
          } else {
            (_d = (_c = this.pageListView.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.removeChild(
              this.pageListView.parentElement
            );
          }
        }
        if (this.landmarksView) {
          if (landmarks == null ? void 0 : landmarks.length) {
            createSubmenu(this.landmarksView, landmarks);
          } else {
            (_e = this.landmarksSection.parentElement) == null ? void 0 : _e.removeChild(
              this.landmarksSection
            );
          }
        }
        let lastReadingPosition = void 0;
        if (this.annotator) {
          lastReadingPosition = await this.annotator.getLastReadingPosition();
        }
        const startLink = this.publication.getStartLink();
        let startUrl = void 0;
        if (startLink && startLink.Href) {
          startUrl = this.publication.getAbsoluteHref(startLink.Href);
        }
        if (lastReadingPosition) {
          const linkHref = this.publication.getAbsoluteHref(
            lastReadingPosition.href
          );
          import_loglevel23.default.log(lastReadingPosition.href);
          import_loglevel23.default.log(linkHref);
          lastReadingPosition.href = linkHref;
          await this.navigate(lastReadingPosition);
        } else if (startUrl) {
          const position = {
            href: startUrl,
            locations: {
              progression: 0
            },
            created: /* @__PURE__ */ new Date(),
            title: startLink == null ? void 0 : startLink.Title
          };
          await this.navigate(position);
        }
        return new Promise((resolve) => resolve());
      } catch (err) {
        import_loglevel23.default.error(err);
        this.abortOnError(err);
        return new Promise((_, reject) => reject(err)).catch(() => {
        });
      }
    }
    async handleIFrameLoad() {
      var _a, _b, _c, _d, _e, _f;
      if (this.errorMessage)
        this.errorMessage.style.display = "none";
      this.showLoadingMessageAfterDelay();
      try {
        let bookViewPosition = 0;
        if (this.newPosition) {
          bookViewPosition = this.newPosition.locations.progression;
        }
        await this.handleResize();
        this.updateBookView({ skipDrawingAnnotations: true });
        await this.settings.applyProperties();
        let currentLocation = this.currentChapterLink.href;
        if (currentLocation) {
          const previous = this.publication.getPreviousSpineItem(currentLocation);
          if (previous && previous.Href) {
            this.previousChapterLink = {
              href: previous.Href,
              title: previous.Title,
              type: previous.TypeLink
            };
          }
        }
        if (this.previousChapterAnchorElement) {
          if (this.previousChapterLink && this.previousChapterLink.href) {
            this.previousChapterAnchorElement.href = this.publication.getAbsoluteHref(this.previousChapterLink.href);
            this.previousChapterAnchorElement.className = this.previousChapterAnchorElement.className.replace(
              " disabled",
              ""
            );
          } else {
            this.previousChapterAnchorElement.removeAttribute("href");
            this.previousChapterAnchorElement.className += " disabled";
          }
        }
        let res = this.publication.getNextSpineItem(currentLocation);
        if (res) {
          this.nextChapterLink = {
            href: res.Href,
            title: res.Title,
            type: res.TypeLink
          };
        } else {
          this.nextChapterLink = void 0;
        }
        if (this.nextChapterAnchorElement) {
          if (this.nextChapterLink && this.nextChapterLink.href) {
            this.nextChapterAnchorElement.href = this.publication.getAbsoluteHref(
              this.nextChapterLink.href
            );
            this.nextChapterAnchorElement.className = this.nextChapterAnchorElement.className.replace(" disabled", "");
          } else {
            this.nextChapterAnchorElement.removeAttribute("href");
            this.nextChapterAnchorElement.className += " disabled";
          }
        }
        if (this.historyModule) {
          this.historyModule.setup();
        }
        if (this.currentTocUrl !== void 0) {
          this.setActiveTOCItem(this.currentTocUrl);
        } else {
          this.setActiveTOCItem(currentLocation);
        }
        if (this.publication.Metadata.Title) {
          if (this.bookTitle)
            this.bookTitle.innerHTML = this.publication.Metadata.Title.toString();
        }
        const spineItem = this.publication.getSpineItem(currentLocation);
        if (spineItem !== void 0) {
          this.currentChapterLink.title = spineItem.Title;
          this.currentChapterLink.type = spineItem.TypeLink;
        }
        let tocItem = this.publication.getTOCItem(currentLocation);
        if (this.currentTocUrl !== void 0) {
          tocItem = this.publication.getTOCItem(this.currentTocUrl);
        }
        if (!this.currentChapterLink.title && tocItem !== void 0 && tocItem.Title) {
          this.currentChapterLink.title = tocItem.Title;
        }
        if (!this.currentChapterLink.type && tocItem !== void 0 && tocItem.TypeLink) {
          this.currentChapterLink.title = tocItem.Title;
        }
        if (this.currentChapterLink.title) {
          if (this.chapterTitle)
            this.chapterTitle.innerHTML = "(" + this.currentChapterLink.title + ")";
        } else {
          if (this.chapterTitle)
            this.chapterTitle.innerHTML = "(Current Chapter)";
        }
        await this.injectInjectablesIntoIframeHead();
        if (this.highlighter !== void 0) {
          await this.highlighter.initialize();
        }
        const body = (_a = this.iframes[0].contentDocument) == null ? void 0 : _a.body;
        let details = body == null ? void 0 : body.querySelector("details");
        if (details) {
          let self2 = this;
          details.addEventListener("toggle", async (_event) => {
            var _a2, _b2;
            await ((_b2 = (_a2 = self2.view) == null ? void 0 : _a2.setIframeHeight) == null ? void 0 : _b2.call(_a2, this.iframes[0]));
          });
        }
        if (this.eventHandler) {
          for (const iframe of this.iframes) {
            this.eventHandler.setupEvents(iframe.contentDocument);
            this.touchEventHandler.setupEvents(iframe.contentDocument);
            this.keyboardEventHandler.setupEvents(iframe.contentDocument);
          }
          this.touchEventHandler.setupEvents(this.errorMessage);
          if (!this.didInitKeyboardEventHandler) {
            this.keyboardEventHandler.keydown(document);
            this.didInitKeyboardEventHandler = true;
          }
        }
        if (((_b = this.view) == null ? void 0 : _b.layout) !== "fixed") {
          if ((_c = this.view) == null ? void 0 : _c.isScrollMode()) {
            this.iframes[0].height = "0";
            (_e = (_d = this.view) == null ? void 0 : _d.setIframeHeight) == null ? void 0 : _e.call(_d, this.iframes[0]);
          }
        }
        if (this.rights.enableContentProtection && this.contentProtectionModule) {
          await this.contentProtectionModule.initialize();
        }
        if (this.rights.enableConsumption && this.consumptionModule) {
          await this.consumptionModule.initialize();
        }
        if (this.rights.enableAnnotations && this.annotationModule) {
          await this.annotationModule.initialize();
        }
        if (this.rights.enableBookmarks && this.bookmarkModule) {
          await this.bookmarkModule.initialize();
        }
        if (this.rights.enableLineFocus && this.lineFocusModule) {
          await this.lineFocusModule.initialize();
        }
        if (this.rights.enableTTS && this.ttsModule) {
          const body2 = (_f = this.iframes[0].contentDocument) == null ? void 0 : _f.body;
          const ttsModule = this.ttsModule;
          await ttsModule.initialize(body2);
        }
        if (this.rights.enableTimeline && this.timelineModule) {
          await this.timelineModule.initialize();
        }
        if (this.rights.enableMediaOverlays && this.mediaOverlayModule && this.hasMediaOverlays) {
          await this.mediaOverlayModule.initialize();
        }
        setTimeout(async () => {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h;
          if (this.newElementId) {
            const element = this.iframes[0].contentDocument.getElementById(this.newElementId);
            (_b2 = (_a2 = this.view) == null ? void 0 : _a2.goToElement) == null ? void 0 : _b2.call(_a2, element);
            this.newElementId = void 0;
          } else if (this.newPosition && this.newPosition.highlight) {
            let startContainer = (_c2 = this.newPosition.highlight) == null ? void 0 : _c2.selectionInfo.rangeInfo.startContainerElementCssSelector;
            if (startContainer) {
              (_d2 = this.view) == null ? void 0 : _d2.goToCssSelector(startContainer);
            }
          } else if (bookViewPosition && bookViewPosition >= 0) {
            (_e2 = this.view) == null ? void 0 : _e2.goToProgression(bookViewPosition);
          }
          this.newPosition = void 0;
          if ((_f2 = this.rights) == null ? void 0 : _f2.enableContentProtection) {
            if (this.contentProtectionModule !== void 0) {
              await this.contentProtectionModule.recalculate(10);
            }
          }
          this.hideLoadingMessage();
          this.showIframeContents();
          if (this.rights.enableMediaOverlays && this.mediaOverlayModule && this.hasMediaOverlays) {
            let link = this.currentLink();
            await ((_g = this.mediaOverlayModule) == null ? void 0 : _g.initializeResource(link));
          }
          await this.updatePositionInfo();
          await ((_h = this.view) == null ? void 0 : _h.setSize());
          setTimeout(() => {
            if (this.mediaOverlayModule) {
              this.mediaOverlayModule.settings.resourceReady = true;
            }
          }, 300);
        }, 200);
        return new Promise((resolve) => resolve());
      } catch (err) {
        import_loglevel23.default.error(err);
        this.abortOnError(err);
        return Promise.reject(err);
      }
    }
    async injectInjectablesIntoIframeHead() {
      var _a, _b;
      const injectablesToLoad = [];
      const addLoadingInjectable = (injectable) => {
        const loadPromise = new Promise((resolve, reject) => {
          injectable.onload = () => {
            resolve(true);
          };
          injectable.onerror = (e) => {
            const message = typeof e === "string" ? e : `Injectable failed to load at: ${"href" in injectable ? injectable.href : injectable.src}`;
            reject(new Error(message));
          };
        });
        injectablesToLoad.push(loadPromise);
      };
      for (const iframe of this.iframes) {
        const head = (_a = iframe.contentDocument) == null ? void 0 : _a.head;
        if (head) {
          const bases = iframe.contentDocument.getElementsByTagName("base");
          if (bases.length === 0) {
            head.insertBefore(
              _IFrameNavigator.createBase(this.currentChapterLink.href),
              head.firstChild
            );
          }
          (_b = this.injectables) == null ? void 0 : _b.forEach((injectable) => {
            if (injectable.type === "style") {
              if (injectable.fontFamily) {
                this.settings.initAddedFont();
                if (!injectable.systemFont && injectable.url) {
                  const link = _IFrameNavigator.createCssLink(injectable.url);
                  head.appendChild(link);
                  addLoadingInjectable(link);
                }
              } else if (injectable.r2before && injectable.url) {
                const link = _IFrameNavigator.createCssLink(injectable.url);
                head.insertBefore(link, head.firstChild);
                addLoadingInjectable(link);
              } else if (injectable.r2default && injectable.url) {
                const link = _IFrameNavigator.createCssLink(injectable.url);
                head.insertBefore(link, head.childNodes[1]);
                addLoadingInjectable(link);
              } else if (injectable.r2after && injectable.url) {
                if (injectable.appearance) {
                  this.settings.initAddedAppearance();
                }
                const link = _IFrameNavigator.createCssLink(injectable.url);
                head.appendChild(link);
                addLoadingInjectable(link);
              } else if (injectable.url) {
                const link = _IFrameNavigator.createCssLink(injectable.url);
                head.appendChild(link);
                addLoadingInjectable(link);
              }
            } else if (injectable.type === "script" && injectable.url) {
              const script = _IFrameNavigator.createJavascriptLink(
                injectable.url,
                injectable.async ?? false
              );
              head.appendChild(script);
              addLoadingInjectable(script);
            }
          });
        }
      }
      if (injectablesToLoad.length === 0) {
        return;
      }
      await Promise.all(injectablesToLoad);
    }
    /**
     * Displays standard error UI.
     */
    abortOnError(e) {
      var _a;
      if ((_a = this.api) == null ? void 0 : _a.onError) {
        const trueError = e instanceof Error ? e : typeof e === "string" ? new Error(e) : new Error("An unknown error occurred in the IFrameNavigator.");
        this.api.onError(trueError);
      } else {
        if (this.errorMessage)
          this.errorMessage.style.display = "block";
        if (this.isLoading) {
          this.hideLoadingMessage();
        }
      }
    }
    tryAgain() {
      this.precessContentForIframe();
    }
    precessContentForIframe() {
      var _a, _b, _c, _d, _e, _f;
      const self2 = this;
      var index2 = this.publication.getSpineIndex(this.currentChapterLink.href);
      var even = (index2 ?? 0) % 2 === 1;
      this.showLoadingMessageAfterDelay();
      function writeIframeDoc(content, href) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, "application/xhtml+xml");
        if (doc.head) {
          const bases = doc.getElementsByTagName("base");
          if (bases.length === 0) {
            doc.head.insertBefore(
              _IFrameNavigator.createBase(href),
              doc.head.firstChild
            );
          }
        }
        const newHTML = doc.documentElement.outerHTML;
        const iframeDoc = self2.iframes[0].contentDocument;
        if (iframeDoc) {
          iframeDoc.open();
          iframeDoc.write(newHTML);
          iframeDoc.close();
        }
      }
      function writeIframe2Doc(content, href) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, "application/xhtml+xml");
        if (doc.head) {
          const bases = doc.getElementsByTagName("base");
          if (bases.length === 0) {
            doc.head.insertBefore(
              _IFrameNavigator.createBase(href),
              doc.head.firstChild
            );
          }
        }
        const newHTML = doc.documentElement.outerHTML;
        const iframeDoc = self2.iframes[1].contentDocument;
        if (iframeDoc) {
          iframeDoc.open();
          iframeDoc.write(newHTML);
          iframeDoc.close();
        }
      }
      const link = new URL(this.currentChapterLink.href);
      const isSameOrigin = window.location.protocol === link.protocol && window.location.port === link.port && window.location.hostname === link.hostname;
      if ((_a = this.api) == null ? void 0 : _a.getContent) {
        if (this.publication.isFixedLayout) {
          if (this.settings.columnCount !== 1) {
            if (even) {
              this.currentSpreadLinks.left = {
                href: this.currentChapterLink.href
              };
              (_b = this.api) == null ? void 0 : _b.getContent(this.currentChapterLink.href).then((content) => {
                if (content === void 0) {
                  if (isSameOrigin) {
                    this.iframes[0].src = this.currentChapterLink.href;
                  } else {
                    fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                      writeIframeDoc.call(
                        this,
                        content2,
                        this.currentChapterLink.href
                      );
                    });
                  }
                } else {
                  writeIframeDoc.call(
                    this,
                    content,
                    this.currentChapterLink.href
                  );
                }
              });
              if (this.iframes.length === 2) {
                if ((index2 ?? 0) < this.publication.readingOrder.length - 1) {
                  const next = this.publication.getNextSpineItem(
                    this.currentChapterLink.href
                  );
                  if (next) {
                    const href = this.publication.getAbsoluteHref(next.Href);
                    this.currentSpreadLinks.right = {
                      href
                    };
                    (_c = this.api) == null ? void 0 : _c.getContent(href).then((content) => {
                      if (content === void 0) {
                        if (isSameOrigin) {
                          this.iframes[1].src = href;
                        } else {
                          fetch(href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                            writeIframe2Doc.call(this, content2, href);
                            this.currentSpreadLinks.right = {
                              href
                            };
                          });
                        }
                      } else {
                        writeIframe2Doc.call(this, content, href);
                      }
                    });
                  }
                } else {
                  this.iframes[1].src = "about:blank";
                }
              }
            } else {
              if ((index2 ?? 0) > 0) {
                const prev = this.publication.getPreviousSpineItem(
                  this.currentChapterLink.href
                );
                if (prev) {
                  const href = this.publication.getAbsoluteHref(prev.Href);
                  this.currentSpreadLinks.left = {
                    href
                  };
                  (_d = this.api) == null ? void 0 : _d.getContent(href).then((content) => {
                    if (content === void 0) {
                      if (isSameOrigin) {
                        this.iframes[0].src = href;
                      } else {
                        fetch(href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                          writeIframeDoc.call(this, content2, href);
                        });
                      }
                    } else {
                      writeIframeDoc.call(this, content, href);
                    }
                  });
                }
              } else {
                this.iframes[0].src = "about:blank";
              }
              if (this.iframes.length === 2 && this.publication.isFixedLayout) {
                this.currentSpreadLinks.right = {
                  href: this.currentChapterLink.href
                };
                this.api.getContent(this.currentChapterLink.href).then((content) => {
                  if (content === void 0) {
                    if (isSameOrigin) {
                      this.iframes[1].src = this.currentChapterLink.href;
                    } else {
                      fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                        writeIframe2Doc.call(
                          this,
                          content2,
                          this.currentChapterLink.href
                        );
                      });
                    }
                  } else {
                    writeIframe2Doc.call(
                      this,
                      content,
                      this.currentChapterLink.href
                    );
                  }
                });
              }
            }
          } else {
            this.currentSpreadLinks.left = {
              href: this.currentChapterLink.href
            };
            (_e = this.api) == null ? void 0 : _e.getContent(this.currentChapterLink.href).then((content) => {
              if (content === void 0) {
                if (isSameOrigin) {
                  this.iframes[0].src = this.currentChapterLink.href;
                } else {
                  fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                    writeIframeDoc.call(
                      this,
                      content2,
                      this.currentChapterLink.href
                    );
                  });
                }
              } else {
                writeIframeDoc.call(this, content, this.currentChapterLink.href);
              }
            });
          }
        } else {
          (_f = this.api) == null ? void 0 : _f.getContent(this.currentChapterLink.href).then((content) => {
            this.currentSpreadLinks.left = {
              href: this.currentChapterLink.href
            };
            if (content === void 0) {
              if (isSameOrigin) {
                this.iframes[0].src = this.currentChapterLink.href;
              } else {
                fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content2) => {
                  writeIframeDoc.call(
                    this,
                    content2,
                    this.currentChapterLink.href
                  );
                });
              }
            } else {
              writeIframeDoc.call(this, content, this.currentChapterLink.href);
            }
          });
        }
      } else {
        if (this.publication.isFixedLayout) {
          if (this.settings.columnCount !== 1) {
            if (even) {
              if (isSameOrigin) {
                this.iframes[0].src = this.currentChapterLink.href;
                this.currentSpreadLinks.left = {
                  href: this.currentChapterLink.href
                };
                if (this.iframes.length === 2) {
                  if ((index2 ?? 0) < this.publication.readingOrder.length - 1) {
                    const next = this.publication.getNextSpineItem(
                      this.currentChapterLink.href
                    );
                    if (next) {
                      const href = this.publication.getAbsoluteHref(next.Href);
                      this.iframes[1].src = href;
                      this.currentSpreadLinks.right = {
                        href
                      };
                    }
                  } else {
                    this.iframes[1].src = "about:blank";
                  }
                }
              } else {
                fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                  writeIframeDoc.call(
                    this,
                    content,
                    this.currentChapterLink.href
                  );
                });
                if (this.iframes.length === 2) {
                  if ((index2 ?? 0) < this.publication.readingOrder.length - 1) {
                    const next = this.publication.getNextSpineItem(
                      this.currentChapterLink.href
                    );
                    if (next) {
                      const href = this.publication.getAbsoluteHref(next.Href);
                      this.currentSpreadLinks.right = {
                        href
                      };
                      fetch(href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                        writeIframe2Doc.call(this, content, href);
                      });
                    }
                  } else {
                    this.iframes[1].src = "about:blank";
                  }
                }
              }
            } else {
              if ((index2 ?? 0) > 0) {
                const prev = this.publication.getPreviousSpineItem(
                  this.currentChapterLink.href
                );
                if (prev) {
                  const href = this.publication.getAbsoluteHref(prev.Href);
                  this.currentSpreadLinks.left = {
                    href
                  };
                  if (isSameOrigin) {
                    this.iframes[0].src = href;
                    if (this.iframes.length === 2) {
                      this.iframes[1].src = this.currentChapterLink.href;
                    }
                  } else {
                    fetch(href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                      writeIframeDoc.call(this, content, href);
                    });
                    if (this.iframes.length === 2) {
                      this.currentSpreadLinks.right = {
                        href: this.currentChapterLink.href
                      };
                      fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                        writeIframe2Doc.call(
                          this,
                          content,
                          this.currentChapterLink.href
                        );
                      });
                    }
                  }
                }
              } else {
                this.iframes[0].src = "about:blank";
              }
              if (this.iframes.length === 2) {
                this.currentSpreadLinks.right = {
                  href: this.currentChapterLink.href
                };
                if (isSameOrigin) {
                  this.iframes[1].src = this.currentChapterLink.href;
                } else {
                  fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                    writeIframe2Doc.call(
                      this,
                      content,
                      this.currentChapterLink.href
                    );
                  });
                }
              }
            }
          } else {
            this.currentSpreadLinks.left = {
              href: this.currentChapterLink.href
            };
            if (isSameOrigin) {
              this.iframes[0].src = this.currentChapterLink.href;
            } else {
              fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content) => {
                writeIframeDoc.call(
                  this,
                  content,
                  this.currentChapterLink.href
                );
              });
            }
          }
        } else {
          this.currentSpreadLinks.left = {
            href: this.currentChapterLink.href
          };
          if (isSameOrigin) {
            this.iframes[0].src = this.currentChapterLink.href;
          } else {
            fetch(this.currentChapterLink.href, this.requestConfig).then((r) => r.text()).then(async (content) => {
              writeIframeDoc.call(this, content, this.currentChapterLink.href);
            });
          }
        }
      }
      if (this.publication.isFixedLayout) {
        setTimeout(() => {
          var _a2, _b2, _c2;
          let height, width;
          let doc;
          if (index2 === 0 && ((_a2 = this.iframes) == null ? void 0 : _a2.length) === 2) {
            doc = this.iframes[1].contentDocument;
          } else {
            doc = this.iframes[0].contentDocument;
          }
          if (doc && doc.body) {
            height = getComputedStyle(doc.body).height;
            width = getComputedStyle(doc.body).width;
            if (parseInt(height == null ? void 0 : height.replace("px", "")) === 0 || parseInt(width == null ? void 0 : width.replace("px", "")) === 0) {
              const head = findIframeElement(
                doc,
                "head"
              );
              if (head) {
                const viewport = findElement(
                  head,
                  "meta[name=viewport]"
                );
                if (viewport) {
                  var dimensionsStr = viewport.content;
                  var obj = dimensionsStr.split(",").reduce((obj2, s) => {
                    var [key, value] = s.match(/[^\s;=]+/g);
                    obj2[key] = isNaN(Number(value)) ? value : +value;
                    return obj2;
                  }, {});
                  height = obj["height"] + "px";
                  width = obj["width"] + "px";
                }
              }
            }
          }
          var iframeParent = index2 === 0 && this.iframes.length === 2 ? (_b2 = this.iframes[1].parentElement) == null ? void 0 : _b2.parentElement : (_c2 = this.iframes[0].parentElement) == null ? void 0 : _c2.parentElement;
          if (iframeParent && width) {
            var widthRatio = (parseInt(getComputedStyle(iframeParent).width) - 100) / (this.iframes.length === 2 ? parseInt(width == null ? void 0 : width.replace("px", "")) * 2 + 200 : parseInt(width == null ? void 0 : width.replace("px", "")));
            var heightRatio = (parseInt(getComputedStyle(iframeParent).height) - 100) / parseInt(height == null ? void 0 : height.replace("px", ""));
            var scale = Math.min(widthRatio, heightRatio);
            iframeParent.style.transform = "scale(" + scale + ")";
            for (const iframe of this.iframes) {
              iframe.style.height = height;
              iframe.style.width = width;
              if (iframe.parentElement) {
                iframe.parentElement.style.height = height;
              }
            }
          }
        }, 400);
      }
    }
    static goBack() {
      window.history.back();
    }
    handleEditClick(event) {
      var _a, _b, _c, _d;
      var element = event.target;
      if (this.headerMenu) {
        var sidenav = findElement(document, ".sidenav");
        if (element.className.indexOf(" active") === -1) {
          element.className += " active";
          sidenav.className += " expanded";
          element.innerText = "unfold_less";
          this.sideNavExpanded = true;
          (_a = this.bookmarkModule) == null ? void 0 : _a.showBookmarks();
          (_b = this.annotationModule) == null ? void 0 : _b.showHighlights();
        } else {
          element.className = element.className.replace(" active", "");
          sidenav.className = sidenav.className.replace(" expanded", "");
          element.innerText = "unfold_more";
          this.sideNavExpanded = false;
          (_c = this.bookmarkModule) == null ? void 0 : _c.showBookmarks();
          (_d = this.annotationModule) == null ? void 0 : _d.showHighlights();
        }
      }
      event.preventDefault();
      event.stopPropagation();
    }
    get hasMediaOverlays() {
      return this.publication.hasMediaOverlays;
    }
    startReadAloud() {
      if (this.rights.enableTTS) {
        const ttsModule = this.ttsModule;
        ttsModule.speakPlay();
      }
    }
    startReadAlong() {
      var _a;
      if (this.rights.enableMediaOverlays && this.mediaOverlayModule !== void 0 && this.hasMediaOverlays) {
        (_a = this.mediaOverlayModule) == null ? void 0 : _a.startReadAloud();
      }
    }
    stopReadAloud() {
      var _a;
      if (this.rights.enableTTS) {
        (_a = this.highlighter) == null ? void 0 : _a.stopReadAloud();
      }
    }
    stopReadAlong() {
      var _a;
      if (this.rights.enableMediaOverlays && this.mediaOverlayModule !== void 0 && this.hasMediaOverlays) {
        (_a = this.mediaOverlayModule) == null ? void 0 : _a.stopReadAloud();
      }
    }
    pauseReadAloud() {
      if (this.rights.enableTTS) {
        const ttsModule = this.ttsModule;
        ttsModule.speakPause();
        if (this.annotationModule !== void 0) {
          this.annotationModule.drawHighlights();
        }
      }
    }
    pauseReadAlong() {
      var _a;
      if (this.rights.enableMediaOverlays && this.mediaOverlayModule !== void 0 && this.hasMediaOverlays) {
        (_a = this.mediaOverlayModule) == null ? void 0 : _a.pauseReadAloud();
      }
    }
    resumeReadAloud() {
      if (this.rights.enableTTS) {
        const ttsModule = this.ttsModule;
        ttsModule.speakResume();
      }
    }
    resumeReadAlong() {
      var _a;
      if (this.rights.enableMediaOverlays && this.mediaOverlayModule !== void 0 && this.hasMediaOverlays) {
        (_a = this.mediaOverlayModule) == null ? void 0 : _a.resumeReadAloud();
      }
    }
    totalResources() {
      return this.publication.readingOrder.length;
    }
    mostRecentNavigatedTocItem() {
      return this.publication.getRelativeHref(this.currentTOCRawLink);
    }
    currentResource() {
      let currentLocation = this.currentChapterLink.href;
      return this.publication.getSpineIndex(currentLocation);
    }
    currentLink() {
      if (this.settings.columnCount !== 1) {
        if (this.currentSpreadLinks.left !== void 0 && this.currentSpreadLinks.right !== void 0) {
          let left = this.publication.getSpineItem(
            this.currentSpreadLinks.left.href
          );
          let right = this.publication.getSpineItem(
            this.currentSpreadLinks.right.href
          );
          return [left, right];
        }
      }
      let currentLocation = this.currentChapterLink.href;
      return [this.publication.getSpineItem(currentLocation)];
    }
    tableOfContents() {
      return this.publication.tableOfContents;
    }
    landmarks() {
      return this.publication.landmarks;
    }
    pageList() {
      return this.publication.pageList;
    }
    readingOrder() {
      return this.publication.readingOrder;
    }
    atStart() {
      var _a;
      return ((_a = this.view) == null ? void 0 : _a.atStart()) ?? false;
    }
    atEnd() {
      var _a;
      return ((_a = this.view) == null ? void 0 : _a.atEnd()) ?? false;
    }
    previousPage() {
      this.handlePreviousPageClick(void 0);
    }
    nextPage() {
      this.handleNextPageClick(void 0);
    }
    previousResource() {
      this.handlePreviousChapterClick(void 0);
    }
    nextResource() {
      this.handleNextChapterClick(void 0);
    }
    goTo(locator) {
      let locations = locator.locations ?? { progression: 0 };
      if (locator.href.indexOf("#") !== -1) {
        const elementId = locator.href.slice(locator.href.indexOf("#") + 1);
        if (elementId !== void 0) {
          locations = {
            ...locations,
            fragment: elementId
          };
        }
      }
      const position = { ...locator };
      position.locations = locations;
      const linkHref = this.publication.getAbsoluteHref(locator.href);
      import_loglevel23.default.log(locator.href);
      import_loglevel23.default.log(linkHref);
      position.href = linkHref;
      this.stopReadAloud();
      this.navigate(position);
    }
    currentLocator() {
      var _a, _b, _c, _d;
      let position;
      if (this.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
        let positions = this.publication.positionsByHref(
          this.publication.getRelativeHref(this.currentChapterLink.href)
        );
        let positionIndex = Math.ceil(
          (((_a = this.view) == null ? void 0 : _a.getCurrentPosition()) ?? 0) * (positions.length - 1)
        );
        position = positions[positionIndex];
      } else {
        let tocItem = this.publication.getTOCItem(this.currentChapterLink.href);
        if (tocItem) {
          if (this.currentTocUrl !== void 0) {
            tocItem = this.publication.getTOCItem(this.currentTocUrl);
          }
          if (tocItem === void 0) {
            tocItem = this.publication.getTOCItemAbsolute(
              this.currentChapterLink.href
            );
          }
          if (tocItem) {
            position = {
              href: tocItem.Href,
              type: this.currentChapterLink.type,
              title: this.currentChapterLink.title,
              locations: {}
            };
          }
        }
      }
      if (position) {
        position.locations.progression = (_b = this.view) == null ? void 0 : _b.getCurrentPosition();
        position.displayInfo = {
          resourceScreenIndex: Math.round(((_c = this.view) == null ? void 0 : _c.getCurrentPage()) ?? 0),
          resourceScreenCount: Math.round(((_d = this.view) == null ? void 0 : _d.getPageCount()) ?? 0)
        };
      }
      return position;
    }
    positions() {
      return this.publication.positions ? this.publication.positions : [];
    }
    goToPosition(position) {
      if (this.publication.positions) {
        let locator = this.publication.positions.filter(
          (el) => el.locations.position === parseInt(String(position))
        )[0];
        this.goTo(locator);
      }
    }
    async goToPage(page) {
      if (this.pageBreakModule !== void 0) {
        await this.pageBreakModule.goToPageNumber(page);
      }
    }
    snapToSelector(selector2) {
      var _a;
      const doc = this.iframes[0].contentDocument;
      if (doc) {
        import_loglevel23.default.log(selector2);
        let result = doc.querySelectorAll(selector2);
        if (result.length > 0)
          (_a = this.view) == null ? void 0 : _a.snap(result[0]);
      }
    }
    applyAttributes(attributes) {
      this.attributes = attributes;
      this.view.attributes = attributes;
      this.handleResize();
    }
    handlePreviousPageClick(event) {
      var _a, _b, _c, _d;
      this.stopReadAloud();
      if (((_a = this.view) == null ? void 0 : _a.layout) === "fixed") {
        this.handlePreviousChapterClick(event);
      } else {
        if ((_b = this.view) == null ? void 0 : _b.atStart()) {
          this.handlePreviousChapterClick(event);
        } else {
          (_d = (_c = this.view) == null ? void 0 : _c.goToPreviousPage) == null ? void 0 : _d.call(_c);
          this.updatePositionInfo();
          this.savePosition();
        }
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }
    handleNextPageClick(event) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      let valid = true;
      if (((_a = this.sample) == null ? void 0 : _a.isSampleRead) && this.publication.positions) {
        const locator = this.currentLocator();
        let progress = Math.round(
          (locator.locations.totalProgression ?? 0) * 100
        );
        if ((_b = this.sample) == null ? void 0 : _b.limit) {
          valid = progress <= ((_c = this.sample) == null ? void 0 : _c.limit);
          if (((_d = this.view) == null ? void 0 : _d.layout) === "fixed") {
            if ((!valid && ((_e = this.sample) == null ? void 0 : _e.minimum) && locator.locations.position) ?? 0 <= (((_f = this.sample) == null ? void 0 : _f.minimum) ?? 0)) {
              valid = true;
            }
          }
        }
      }
      if (valid && ((_g = this.sample) == null ? void 0 : _g.isSampleRead) && this.publication.positions || !((_h = this.sample) == null ? void 0 : _h.isSampleRead) || !this.publication.positions) {
        this.stopReadAloud();
        if (((_i = this.view) == null ? void 0 : _i.layout) === "fixed") {
          this.handleNextChapterClick(event);
        } else {
          if ((_j = this.view) == null ? void 0 : _j.atEnd()) {
            this.handleNextChapterClick(event);
          } else {
            (_l = (_k = this.view) == null ? void 0 : _k.goToNextPage) == null ? void 0 : _l.call(_k);
            this.updatePositionInfo();
            this.savePosition();
          }
          if (event) {
            event.preventDefault();
            event.stopPropagation();
          }
        }
      }
      if (!valid && ((_m = this.sample) == null ? void 0 : _m.isSampleRead) && this.publication.positions) {
        if (event) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }
    handleClickThrough(event) {
      var _a, _b;
      if ((_a = this.api) == null ? void 0 : _a.clickThrough)
        (_b = this.api) == null ? void 0 : _b.clickThrough(event);
      this.emit("click", event);
    }
    handleInternalLink(event) {
      const element = event.target;
      let locations = {
        progression: 0
      };
      const linkElement = element;
      if (linkElement.href.indexOf("#") !== -1) {
        const elementId = linkElement.href.slice(
          linkElement.href.indexOf("#") + 1
        );
        if (elementId !== void 0) {
          locations = {
            fragment: elementId
          };
        }
      }
      const position = {
        href: linkElement.href,
        locations,
        type: linkElement.type,
        title: linkElement.title
      };
      event.preventDefault();
      event.stopPropagation();
      this.stopReadAloud();
      this.navigate(position);
    }
    handleNumberOfIframes() {
      if (this.publication.isFixedLayout) {
        if (this.settings.columnCount !== 1 && !window.matchMedia("screen and (max-width: 600px)").matches) {
          if (this.iframes.length === 1) {
            var iframe = document.createElement("iframe");
            iframe.setAttribute("SCROLLING", "no");
            iframe.setAttribute("allowtransparency", "true");
            iframe.style.opacity = "1";
            iframe.style.border = "none";
            iframe.style.overflow = "hidden";
            this.iframes.push(iframe);
          }
          let secondSpread = document.createElement("div");
          this.spreads.appendChild(secondSpread);
          secondSpread.appendChild(this.iframes[1]);
          this.firstSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 100% 120%, -20% 120%)";
          this.firstSpread.style.boxShadow = "0 0 8px 2px #ccc";
          secondSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 120% 100%, 0% 120%)";
          secondSpread.style.boxShadow = "0 0 8px 2px #ccc";
        } else {
          if (this.iframes.length === 2) {
            this.iframes.pop();
            if (this.spreads.lastChild) {
              this.spreads.removeChild(this.spreads.lastChild);
            }
          }
          this.firstSpread.style.clipPath = "polygon(0% -20%, 100% -20%, 120% 100%, -20% 120%)";
          this.firstSpread.style.boxShadow = "0 0 8px 2px #ccc";
        }
        this.precessContentForIframe();
      }
    }
    async handleResize() {
      var _a, _b, _c, _d, _e, _f, _g;
      if (this.isScrolling) {
        return;
      }
      if (this.publication.isFixedLayout) {
        var index2 = this.publication.getSpineIndex(this.currentChapterLink.href);
        const minHeight = getHeight() - 40 - (((_a = this.attributes) == null ? void 0 : _a.margin) ?? 0);
        var iframeParent = index2 === 0 && this.iframes.length === 2 ? (_b = this.iframes[1].parentElement) == null ? void 0 : _b.parentElement : (_c = this.iframes[0].parentElement) == null ? void 0 : _c.parentElement;
        if (iframeParent) {
          iframeParent.style.height = minHeight + 40 + "px";
          let height, width;
          let doc;
          if (index2 === 0 && ((_d = this.iframes) == null ? void 0 : _d.length) === 2) {
            doc = this.iframes[1].contentDocument;
          } else {
            doc = this.iframes[0].contentDocument;
          }
          if (doc && doc.body) {
            height = getComputedStyle(doc.body).height;
            width = getComputedStyle(doc.body).width;
          }
          const head = findIframeElement(
            doc,
            "head"
          );
          if (head) {
            const viewport = findElement(
              head,
              "meta[name=viewport]"
            );
            if (viewport) {
              var dimensionsStr = viewport.content;
              var obj = dimensionsStr.split(",").reduce((obj2, s) => {
                var [key, value] = s.match(/[^\s;=]+/g);
                obj2[key] = isNaN(Number(value)) ? value : +value;
                return obj2;
              }, {});
              if (parseInt(obj["height"]) !== 0 || parseInt(obj["width"]) !== 0) {
                height = obj["height"] + "px";
                width = obj["width"] + "px";
              }
            }
          }
          var widthRatio = (parseInt(getComputedStyle(iframeParent).width) - 100) / (this.iframes.length === 2 ? parseInt(width == null ? void 0 : width.replace("px", "")) * 2 + 200 : parseInt(width == null ? void 0 : width.replace("px", "")));
          var heightRatio = (parseInt(getComputedStyle(iframeParent).height) - 100) / parseInt(height == null ? void 0 : height.replace("px", ""));
          var scale = Math.min(widthRatio, heightRatio);
          iframeParent.style.transform = "scale(" + scale + ")";
          for (const iframe of this.iframes) {
            iframe.style.height = height;
            iframe.style.width = width;
            if (iframe.parentElement) {
              iframe.parentElement.style.height = height;
            }
          }
        }
      }
      const oldPosition = (_e = this.view) == null ? void 0 : _e.getCurrentPosition();
      await this.settings.applyProperties();
      if (this.infoTop)
        this.infoTop.style.height = "0px";
      if (this.infoTop)
        this.infoTop.style.minHeight = "0px";
      if (this.infoBottom)
        this.infoBottom.style.height = ((_f = this.attributes) == null ? void 0 : _f.bottomInfoHeight) ? this.attributes.bottomInfoHeight + "px" : "40px";
      if (((_g = this.view) == null ? void 0 : _g.layout) !== "fixed") {
        this.settings.isPaginated().then((paginated) => {
          var _a2;
          if (paginated) {
            this.view.height = getHeight() - 40 - (((_a2 = this.attributes) == null ? void 0 : _a2.margin) ?? 0);
            if (this.infoBottom)
              this.infoBottom.style.removeProperty("display");
          } else {
            if (this.infoBottom)
              this.infoBottom.style.display = "none";
          }
        });
      }
      setTimeout(() => {
        var _a2, _b2, _c2, _d2;
        if (((_a2 = this.view) == null ? void 0 : _a2.layout) !== "fixed") {
          if ((_b2 = this.view) == null ? void 0 : _b2.isScrollMode()) {
            (_d2 = (_c2 = this.view) == null ? void 0 : _c2.setIframeHeight) == null ? void 0 : _d2.call(_c2, this.iframes[0]);
          }
        }
      }, 100);
      setTimeout(async () => {
        var _a2;
        if (oldPosition) {
          (_a2 = this.view) == null ? void 0 : _a2.goToProgression(oldPosition);
        }
        await this.updatePositionInfo(false);
        if (this.annotationModule !== void 0) {
          await this.annotationModule.handleResize();
        }
        if (this.bookmarkModule !== void 0) {
          await this.bookmarkModule.handleResize();
        }
        if (this.searchModule !== void 0) {
          await this.searchModule.handleResize();
        }
        if (this.definitionsModule !== void 0) {
          await this.definitionsModule.handleResize();
        }
        if (this.pageBreakModule !== void 0) {
          await this.pageBreakModule.handleResize();
        }
        if (this.contentProtectionModule !== void 0) {
          this.contentProtectionModule.handleResize();
        }
        if (this.lineFocusModule !== void 0) {
          this.lineFocusModule.handleResize();
        }
        if (this.historyModule !== void 0) {
          this.historyModule.handleResize();
        }
      }, 150);
    }
    updatePositionInfo(save = true) {
      var _a, _b;
      if (((_a = this.view) == null ? void 0 : _a.layout) === "fixed") {
        if (this.chapterPosition)
          this.chapterPosition.innerHTML = "";
        if (this.remainingPositions)
          this.remainingPositions.innerHTML = "";
      } else {
        if ((_b = this.view) == null ? void 0 : _b.isPaginated()) {
          const locator = this.currentLocator();
          if (locator) {
            const currentPage = locator.displayInfo.resourceScreenIndex;
            const pageCount = locator.displayInfo.resourceScreenCount;
            if (this.chapterPosition) {
              this.chapterPosition.innerHTML = "Page " + currentPage + " of " + pageCount;
            }
          }
        } else {
          if (this.chapterPosition)
            this.chapterPosition.innerHTML = "";
          if (this.remainingPositions)
            this.remainingPositions.innerHTML = "";
        }
      }
      if (save) {
        this.savePosition();
      }
    }
    handlePreviousChapterClick(event) {
      var _a;
      if (((_a = this.view) == null ? void 0 : _a.layout) === "fixed" && this.settings.columnCount !== 1) {
        let index2 = this.publication.getSpineIndex(this.currentChapterLink.href) ?? 0;
        index2 = index2 - 2;
        if (index2 < 0)
          index2 = 0;
        const previous = this.publication.readingOrder[index2];
        const position = {
          href: this.publication.getAbsoluteHref(previous.Href),
          locations: {
            progression: 0
          },
          type: previous.TypeLink,
          title: previous.Title
        };
        this.stopReadAloud();
        this.navigate(position, false);
      } else {
        if (this.previousChapterLink) {
          const position = {
            href: this.publication.getAbsoluteHref(this.previousChapterLink.href),
            locations: {
              progression: 1
            },
            type: this.previousChapterLink.type,
            title: this.previousChapterLink.title
          };
          this.stopReadAloud();
          this.navigate(position, false);
        }
      }
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    handleNextChapterClick(event) {
      var _a;
      if (((_a = this.view) == null ? void 0 : _a.layout) === "fixed" && this.settings.columnCount !== 1) {
        let index2 = this.publication.getSpineIndex(this.currentChapterLink.href) ?? 0;
        index2 = index2 + 2;
        if (index2 >= this.publication.readingOrder.length - 1)
          index2 = this.publication.readingOrder.length - 1;
        const next = this.publication.readingOrder[index2];
        const position = {
          href: this.publication.getAbsoluteHref(next.Href),
          locations: {
            progression: 0
          },
          type: next.TypeLink,
          title: next.Title
        };
        this.stopReadAloud();
        this.navigate(position, false);
      } else {
        if (this.nextChapterLink) {
          const position = {
            href: this.publication.getAbsoluteHref(this.nextChapterLink.href),
            locations: {
              progression: 0
            },
            type: this.nextChapterLink.type,
            title: this.nextChapterLink.title
          };
          this.stopReadAloud();
          this.navigate(position, false);
        }
      }
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    handleKeydownFallthrough(event) {
      var _a, _b;
      if ((_a = this.api) == null ? void 0 : _a.keydownFallthrough)
        (_b = this.api) == null ? void 0 : _b.keydownFallthrough(event);
      this.emit("keydown", event);
    }
    hideView() {
      var _a, _b;
      if (((_a = this.view) == null ? void 0 : _a.layout) !== "fixed") {
        if ((_b = this.view) == null ? void 0 : _b.isScrollMode()) {
          document.body.style.overflow = "auto";
        }
      }
    }
    setActiveTOCItem(resource) {
      if (this.tocView) {
        const allItems = Array.prototype.slice.call(
          this.tocView.querySelectorAll("li > a")
        );
        for (const item of allItems) {
          item.className = item.className.replace(" active", "");
        }
        const activeItem = this.tocView.querySelector(
          'li > a[href^="' + resource + '"]'
        );
        if (activeItem) {
          activeItem.className += " active";
        }
      }
    }
    async navigate(locator, history = true) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      if (this.rights.enableConsumption && this.consumptionModule) {
        if (history) {
          this.consumptionModule.startReadingSession(locator);
        }
      }
      if (this.historyModule) {
        await this.historyModule.push(locator, history);
      }
      const exists = this.publication.getTOCItem(locator.href);
      if (exists) {
        var isCurrentLoaded = false;
        if (locator.href.indexOf("#") !== -1) {
          const newResource = locator.href.slice(0, locator.href.indexOf("#"));
          if (newResource === this.currentChapterLink.href) {
            isCurrentLoaded = true;
          }
          this.currentChapterLink.href = newResource;
          this.currentChapterLink.type = locator.type;
          this.currentChapterLink.title = locator.title;
        } else {
          if (locator.href === this.currentChapterLink.href) {
            isCurrentLoaded = true;
          }
          this.currentChapterLink.href = locator.href;
          this.currentChapterLink.type = locator.type;
          this.currentChapterLink.title = locator.title;
        }
        if (this.currentSpreadLinks.left !== void 0 && this.currentSpreadLinks.right !== void 0) {
          if (locator.href === this.currentSpreadLinks.left.href || locator.href === this.currentSpreadLinks.right.href) {
            return;
          }
        }
        if (isCurrentLoaded) {
          if (locator.href.indexOf("#") !== -1) {
            const elementId = locator.href.slice(locator.href.indexOf("#") + 1);
            locator.locations = {
              fragment: elementId
            };
          }
          this.newPosition = locator;
          this.currentTOCRawLink = locator.href;
          if (locator.locations.fragment === void 0) {
            this.currentTocUrl = void 0;
          } else {
            this.newElementId = locator.locations.fragment;
            this.currentTocUrl = this.currentChapterLink.href + "#" + this.newElementId;
          }
          if (this.newElementId) {
            for (const iframe of this.iframes) {
              const element = iframe.contentDocument.getElementById(
                this.newElementId
              );
              (_b = (_a = this.view) == null ? void 0 : _a.goToElement) == null ? void 0 : _b.call(_a, element);
            }
            this.newElementId = void 0;
          } else {
            if (locator.highlight) {
              let startContainer = (_c = locator.highlight) == null ? void 0 : _c.selectionInfo.rangeInfo.startContainerElementCssSelector;
              if (startContainer) {
                (_d = this.view) == null ? void 0 : _d.goToCssSelector(startContainer);
              }
            } else {
              (_e = this.view) == null ? void 0 : _e.goToProgression(locator.locations.progression ?? 0);
            }
          }
          let currentLocation = this.currentChapterLink.href;
          const previous = this.publication.getPreviousSpineItem(currentLocation);
          if (previous && previous.Href) {
            this.previousChapterLink = {
              href: previous.Href,
              type: previous.TypeLink,
              title: previous.Title
            };
          }
          if (this.previousChapterAnchorElement) {
            if (this.previousChapterLink) {
              this.previousChapterAnchorElement.href = this.publication.getAbsoluteHref(this.previousChapterLink.href);
              this.previousChapterAnchorElement.className = this.previousChapterAnchorElement.className.replace(
                " disabled",
                ""
              );
            } else {
              this.previousChapterAnchorElement.removeAttribute("href");
              this.previousChapterAnchorElement.className += " disabled";
            }
          }
          let res = this.publication.getNextSpineItem(currentLocation);
          if (res) {
            this.nextChapterLink = {
              href: res.Href,
              type: res.TypeLink,
              title: res.Title
            };
          } else {
            this.nextChapterLink = void 0;
          }
          if (this.nextChapterAnchorElement) {
            if (this.nextChapterLink) {
              this.nextChapterAnchorElement.href = this.publication.getAbsoluteHref(this.nextChapterLink.href);
              this.nextChapterAnchorElement.className = this.nextChapterAnchorElement.className.replace(" disabled", "");
            } else {
              this.nextChapterAnchorElement.removeAttribute("href");
              this.nextChapterAnchorElement.className += " disabled";
            }
          }
          if (this.currentTocUrl !== void 0) {
            this.setActiveTOCItem(this.currentTocUrl);
          } else {
            this.setActiveTOCItem(currentLocation);
          }
          if (this.publication.Metadata.Title) {
            if (this.bookTitle)
              this.bookTitle.innerHTML = this.publication.Metadata.Title.toString();
          }
          const spineItem = this.publication.getSpineItem(currentLocation);
          if (spineItem !== void 0) {
            this.currentChapterLink.title = spineItem.Title;
            this.currentChapterLink.type = spineItem.TypeLink;
          }
          let tocItem = this.publication.getTOCItem(currentLocation);
          if (this.currentTocUrl !== void 0) {
            tocItem = this.publication.getTOCItem(this.currentTocUrl);
          }
          if (!this.currentChapterLink.title && tocItem !== void 0 && tocItem.Title) {
            this.currentChapterLink.title = tocItem.Title;
          }
          if (!this.currentChapterLink.type && tocItem !== void 0 && tocItem.TypeLink) {
            this.currentChapterLink.title = tocItem.Title;
          }
          if (this.currentChapterLink.title) {
            if (this.chapterTitle)
              this.chapterTitle.innerHTML = "(" + this.currentChapterLink.title + ")";
          } else {
            if (this.chapterTitle)
              this.chapterTitle.innerHTML = "(Current Chapter)";
          }
          await this.updatePositionInfo();
        } else {
          if (this.lineFocusModule !== void 0) {
            this.lineFocusModule.disableLineFocus(false);
          }
          if (this.searchModule !== void 0) {
            this.searchModule.clearSearch();
          }
          if (locator.locations.fragment === void 0) {
            this.currentTocUrl = void 0;
          } else {
            this.newElementId = locator.locations.fragment;
            this.currentTocUrl = this.currentChapterLink.href + "#" + this.newElementId;
          }
          this.hideIframeContents();
          this.showLoadingMessageAfterDelay();
          if (locator.locations === void 0) {
            locator.locations = {
              progression: 0
            };
          }
          this.newPosition = locator;
          this.currentTOCRawLink = locator.href;
          this.precessContentForIframe();
          if (this.rights.enableContentProtection && this.contentProtectionModule !== void 0) {
            await this.contentProtectionModule.initializeResource();
          }
          if (this.rights.enableMediaOverlays && this.mediaOverlayModule !== void 0 && this.hasMediaOverlays) {
            await this.mediaOverlayModule.initializeResource(this.currentLink());
          }
          if (this.rights.enableContentProtection && this.contentProtectionModule !== void 0) {
            await this.contentProtectionModule.recalculate(300);
          }
          if (this.bookmarkModule) {
            await this.bookmarkModule.drawBookmarks();
            await this.bookmarkModule.showBookmarks();
          }
          if (this.pageBreakModule) {
            await ((_f = this.highlighter) == null ? void 0 : _f.destroyHighlights(3 /* PageBreak */));
            await this.pageBreakModule.drawPageBreaks();
          }
          if (this.rights.enableSearch && this.searchModule !== void 0 && this.highlighter !== void 0) {
            await this.highlighter.destroyHighlights(1 /* Search */);
            this.searchModule.drawSearch();
          }
          if (this.rights.enableDefinitions && this.definitionsModule && this.highlighter) {
            await this.definitionsModule.drawDefinitions();
          }
          if (this.rights.enableConsumption && this.consumptionModule) {
            this.consumptionModule.continueReadingSession(locator);
          }
          if (((_g = this.view) == null ? void 0 : _g.layout) === "fixed") {
            if (this.nextChapterBottomAnchorElement)
              this.nextChapterBottomAnchorElement.style.display = "none";
            if (this.previousChapterTopAnchorElement)
              this.previousChapterTopAnchorElement.style.display = "none";
            if ((_h = this.api) == null ? void 0 : _h.resourceFitsScreen)
              (_i = this.api) == null ? void 0 : _i.resourceFitsScreen();
            this.emit("resource.fits");
          } else {
            this.settings.isPaginated().then((paginated) => {
              var _a2, _b2, _c2, _d2;
              if (!paginated) {
                if (((_a2 = this.view) == null ? void 0 : _a2.atStart()) && ((_b2 = this.view) == null ? void 0 : _b2.atEnd())) {
                  if (this.nextChapterBottomAnchorElement)
                    this.nextChapterBottomAnchorElement.style.display = "unset";
                  if (this.previousChapterTopAnchorElement)
                    this.previousChapterTopAnchorElement.style.display = "unset";
                } else if ((_c2 = this.view) == null ? void 0 : _c2.atEnd()) {
                  if (this.previousChapterTopAnchorElement)
                    this.previousChapterTopAnchorElement.style.display = "none";
                  if (this.nextChapterBottomAnchorElement)
                    this.nextChapterBottomAnchorElement.style.display = "unset";
                } else if ((_d2 = this.view) == null ? void 0 : _d2.atStart()) {
                  if (this.nextChapterBottomAnchorElement)
                    this.nextChapterBottomAnchorElement.style.display = "none";
                  if (this.previousChapterTopAnchorElement)
                    this.previousChapterTopAnchorElement.style.display = "unset";
                } else {
                  if (this.nextChapterBottomAnchorElement)
                    this.nextChapterBottomAnchorElement.style.display = "none";
                  if (this.previousChapterTopAnchorElement)
                    this.previousChapterTopAnchorElement.style.display = "none";
                }
              }
            });
          }
        }
      } else {
        const startLink = this.publication.getStartLink();
        let startUrl = void 0;
        if (startLink && startLink.Href) {
          startUrl = this.publication.getAbsoluteHref(startLink.Href);
          if (startUrl) {
            const position = {
              href: startUrl,
              locations: {
                progression: 0
              },
              created: /* @__PURE__ */ new Date(),
              title: startLink.Title
            };
            await this.navigate(position);
          }
        }
      }
    }
    showIframeContents() {
      this.isBeingStyled = false;
      setTimeout(() => {
        if (!this.isBeingStyled) {
          this.iframes.forEach((iframe) => {
            iframe.style.opacity = "1";
            iframe.style.border = "none";
            iframe.style.overflow = "hidden";
          });
        }
      }, 150);
    }
    showLoadingMessageAfterDelay() {
      this.isLoading = true;
      if (this.isLoading && this.loadingMessage) {
        this.loadingMessage.style.display = "block";
        this.loadingMessage.classList.add("is-loading");
      }
      if (this.mediaOverlayModule !== void 0) {
        this.mediaOverlayModule.settings.resourceReady = false;
      }
    }
    hideIframeContents() {
      this.isBeingStyled = true;
      this.iframes.forEach((iframe) => {
        iframe.style.opacity = "0";
        iframe.style.border = "none";
        iframe.style.overflow = "hidden";
      });
    }
    hideLoadingMessage() {
      setTimeout(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        this.isLoading = false;
        if (this.loadingMessage) {
          this.loadingMessage.style.display = "none";
          this.loadingMessage.classList.remove("is-loading");
        }
        if (((_a = this.view) == null ? void 0 : _a.layout) !== "fixed") {
          if (((_b = this.view) == null ? void 0 : _b.atStart()) && ((_c = this.view) == null ? void 0 : _c.atEnd())) {
            if ((_d = this.api) == null ? void 0 : _d.resourceFitsScreen)
              (_e = this.api) == null ? void 0 : _e.resourceFitsScreen();
            this.emit("resource.fits");
          } else if ((_f = this.view) == null ? void 0 : _f.atEnd()) {
            if ((_g = this.api) == null ? void 0 : _g.resourceAtEnd)
              (_h = this.api) == null ? void 0 : _h.resourceAtEnd();
            this.emit("resource.end");
          } else if ((_i = this.view) == null ? void 0 : _i.atStart()) {
            if ((_j = this.api) == null ? void 0 : _j.resourceAtStart)
              (_k = this.api) == null ? void 0 : _k.resourceAtStart();
            this.emit("resource.start");
          }
        }
        if ((_l = this.api) == null ? void 0 : _l.resourceReady)
          (_m = this.api) == null ? void 0 : _m.resourceReady();
        this.emit("resource.ready");
      }, 150);
    }
    saveCurrentReadingPosition() {
      var _a, _b, _c, _d, _e, _f;
      if (this.annotator) {
        var tocItem = this.publication.getTOCItem(this.currentChapterLink.href);
        if (this.currentTocUrl !== void 0) {
          tocItem = this.publication.getTOCItem(this.currentTocUrl);
        }
        if (tocItem === void 0) {
          tocItem = this.publication.getTOCItemAbsolute(
            this.currentChapterLink.href
          );
        }
        let locations = {
          progression: (_a = this.view) == null ? void 0 : _a.getCurrentPosition()
        };
        if (tocItem) {
          if (tocItem.Href.indexOf("#") !== -1) {
            const elementId = tocItem.Href.slice(tocItem.Href.indexOf("#") + 1);
            if (elementId !== void 0) {
              locations = {
                progression: (_b = this.view) == null ? void 0 : _b.getCurrentPosition(),
                fragment: elementId
              };
            }
          }
          let position;
          if (this.rights.autoGeneratePositions && this.publication.positions || this.publication.positions) {
            const positions = this.publication.positionsByHref(
              this.publication.getRelativeHref(tocItem.Href)
            );
            if (positions.length > 0) {
              const positionIndex = Math.ceil(
                (locations.progression ?? 0) * (positions.length - 1)
              );
              const locator = positions[positionIndex];
              if (locator) {
                locator.locations.fragment = locations.fragment;
                position = {
                  ...locator,
                  href: tocItem.Href,
                  created: /* @__PURE__ */ new Date(),
                  title: this.currentChapterLink.title
                };
              }
            }
          } else {
            position = {
              href: tocItem.Href,
              locations,
              created: /* @__PURE__ */ new Date(),
              type: this.currentChapterLink.type,
              title: this.currentChapterLink.title
            };
          }
          if (position) {
            if (((_c = this.sample) == null ? void 0 : _c.isSampleRead) && this.publication.positions) {
              (_d = this.sampleReadEventHandler) == null ? void 0 : _d.enforceSampleRead(position);
            }
            if ((_e = this.api) == null ? void 0 : _e.updateCurrentLocation) {
              (_f = this.api) == null ? void 0 : _f.updateCurrentLocation(position).then(async (_) => {
                var _a2;
                import_loglevel23.default.log("api updated current location", position);
                return (_a2 = this.annotator) == null ? void 0 : _a2.saveLastReadingPosition(position);
              });
            } else {
              import_loglevel23.default.log("save last reading position", position);
              this.annotator.saveLastReadingPosition(position);
            }
            if (this.consumptionModule) {
              this.consumptionModule.continueReadingSession(position);
            }
          }
        }
      }
    }
    static createBase(href) {
      const base = document.createElement("base");
      base.target = "_self";
      base.href = href;
      return base;
    }
    static createCssLink(href) {
      const cssLink = document.createElement("link");
      cssLink.rel = "stylesheet";
      cssLink.type = "text/css";
      cssLink.href = href;
      return cssLink;
    }
    static createJavascriptLink(href, isAsync) {
      const jsLink = document.createElement("script");
      jsLink.type = "text/javascript";
      jsLink.src = href;
      jsLink.async = isAsync;
      return jsLink;
    }
    activateMarker(id2, position) {
      if (this.annotationModule !== void 0) {
        if (this.annotationModule.activeAnnotationMarkerId === void 0 || this.annotationModule.activeAnnotationMarkerId !== id2) {
          this.annotationModule.activeAnnotationMarkerId = id2;
          this.annotationModule.activeAnnotationMarkerPosition = position;
          if (this.highlighter) {
            this.highlighter.activeAnnotationMarkerId = id2;
          }
        } else {
          this.deactivateMarker();
        }
      }
    }
    deactivateMarker() {
      if (this.annotationModule !== void 0) {
        this.annotationModule.activeAnnotationMarkerId = void 0;
        this.annotationModule.activeAnnotationMarkerPosition = void 0;
        if (this.highlighter) {
          this.highlighter.activeAnnotationMarkerId = void 0;
        }
      }
    }
    showLayer(layer) {
      var _a;
      let ID = "#";
      let prop = new Switchable(
        "layer-on",
        "layer-off",
        true,
        layer,
        "layer-" + layer
      );
      switch (layer) {
        case "annotations":
        case "highlights":
          ID += "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */;
          prop.name = "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */;
          break;
        case "readaloud":
          ID += "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */;
          prop.name = "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */;
          break;
        case "pagebreak":
          ID += "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */;
          prop.name = "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */;
          break;
        case "search":
          ID += "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */;
          prop.name = "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */;
          break;
        case "definitions":
          ID += "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */;
          prop.name = "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */;
          break;
      }
      (_a = this.highlighter) == null ? void 0 : _a.layerSettings.saveProperty(prop);
      let doc = this.iframes[0].contentDocument;
      if (doc) {
        const container = findElement(doc, ID);
        if (container) {
          container.style.display = "block";
        }
      }
    }
    hideLayer(layer) {
      var _a;
      let ID = "#";
      let prop = new Switchable(
        "layer-on",
        "layer-off",
        false,
        layer,
        "layer-" + layer
      );
      switch (layer) {
        case "annotations":
        case "highlights":
          ID += "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */;
          prop.name = "R2_ID_HIGHLIGHTS_CONTAINER" /* R2_ID_HIGHLIGHTS_CONTAINER */;
          break;
        case "readaloud":
          ID += "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */;
          prop.name = "R2_ID_READALOUD_CONTAINER" /* R2_ID_READALOUD_CONTAINER */;
          break;
        case "pagebreak":
          ID += "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */;
          prop.name = "R2_ID_PAGEBREAK_CONTAINER" /* R2_ID_PAGEBREAK_CONTAINER */;
          break;
        case "search":
          ID += "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */;
          prop.name = "R2_ID_SEARCH_CONTAINER" /* R2_ID_SEARCH_CONTAINER */;
          break;
        case "definitions":
          ID += "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */;
          prop.name = "R2_ID_DEFINITIONS_CONTAINER" /* R2_ID_DEFINITIONS_CONTAINER */;
          break;
      }
      (_a = this.highlighter) == null ? void 0 : _a.layerSettings.saveProperty(prop);
      let doc = this.iframes[0].contentDocument;
      if (doc) {
        const container = findElement(doc, ID);
        if (container) {
          container.style.display = "none";
        }
      }
    }
  };

  // src/store/LocalAnnotator.ts
  init_polyfills();
  var _LocalAnnotator = class _LocalAnnotator {
    constructor(config2) {
      this.store = config2.store;
    }
    getLastReadingPosition() {
      const positionString = this.store.get(_LocalAnnotator.LAST_READING_POSITION);
      if (positionString) {
        const position = JSON.parse(positionString);
        return position;
      }
      return null;
    }
    initLastReadingPosition(position) {
      if (typeof position === "string") {
        this.store.set(_LocalAnnotator.LAST_READING_POSITION, position);
      } else {
        const positionString = JSON.stringify(position);
        this.store.set(_LocalAnnotator.LAST_READING_POSITION, positionString);
      }
    }
    saveLastReadingPosition(position) {
      if (typeof position === "string") {
        this.store.set(_LocalAnnotator.LAST_READING_POSITION, position);
      } else {
        const positionString = JSON.stringify(position);
        this.store.set(_LocalAnnotator.LAST_READING_POSITION, positionString);
      }
    }
    initBookmarks(list) {
      if (typeof list === "string") {
        let savedBookmarksObj = JSON.parse(list);
        this.store.set(
          _LocalAnnotator.BOOKMARKS,
          JSON.stringify(savedBookmarksObj)
        );
      } else {
        this.store.set(_LocalAnnotator.BOOKMARKS, JSON.stringify(list));
      }
      return list;
    }
    saveBookmark(bookmark) {
      let savedBookmarks = this.store.get(_LocalAnnotator.BOOKMARKS);
      if (savedBookmarks) {
        let savedBookmarksObj = JSON.parse(savedBookmarks);
        savedBookmarksObj.push(bookmark);
        this.store.set(
          _LocalAnnotator.BOOKMARKS,
          JSON.stringify(savedBookmarksObj)
        );
      } else {
        let bookmarksAry = [];
        bookmarksAry.push(bookmark);
        this.store.set(_LocalAnnotator.BOOKMARKS, JSON.stringify(bookmarksAry));
      }
      return bookmark;
    }
    locatorExists(locator, type) {
      let storeType;
      switch (type) {
        case 0 /* Bookmark */:
          storeType = _LocalAnnotator.BOOKMARKS;
          break;
      }
      const locatorsString = this.store.get(storeType);
      if (locatorsString) {
        const locators = JSON.parse(locatorsString);
        const filteredLocators = locators.filter(
          (el) => el.href === locator.href && el.locations.progression === locator.locations.progression
        );
        if (filteredLocators.length > 0) {
          return locator;
        }
      }
      return null;
    }
    deleteBookmark(bookmark) {
      let savedBookmarks = this.store.get(_LocalAnnotator.BOOKMARKS);
      if (savedBookmarks) {
        let savedBookmarksObj = JSON.parse(savedBookmarks);
        savedBookmarksObj = savedBookmarksObj.filter(
          (el) => el.id !== bookmark.id
        );
        this.store.set(
          _LocalAnnotator.BOOKMARKS,
          JSON.stringify(savedBookmarksObj)
        );
      }
      return bookmark;
    }
    getBookmarks(href) {
      const bookmarksString = this.store.get(_LocalAnnotator.BOOKMARKS);
      if (bookmarksString) {
        let bookmarks = JSON.parse(bookmarksString);
        if (href) {
          let filteredResult = bookmarks.filter((el) => el.href === href);
          filteredResult = filteredResult.sort((n1, n2) => {
            if (n1.locations.progression && n2.locations.progression) {
              return n1.locations.progression - n2.locations.progression;
            } else {
              return void 0;
            }
          });
          return filteredResult;
        }
        bookmarks = bookmarks.sort((n1, n2) => {
          if (n1.locations.progression && n2.locations.progression) {
            return n1.locations.progression - n2.locations.progression;
          } else {
            return void 0;
          }
        });
        return bookmarks;
      }
      return [];
    }
    initAnnotations(list) {
      let annotations;
      if (typeof list === "string") {
        annotations = JSON.parse(list);
      } else {
        annotations = list;
      }
      let annotationsToStore = [];
      annotations.forEach((rangeRepresentation) => {
        const uniqueStr = `${rangeRepresentation.highlight.selectionInfo.rangeInfo.startContainerElementCssSelector}${rangeRepresentation.highlight.selectionInfo.rangeInfo.startContainerChildTextNodeIndex}${rangeRepresentation.highlight.selectionInfo.rangeInfo.startOffset}${rangeRepresentation.highlight.selectionInfo.rangeInfo.endContainerElementCssSelector}${rangeRepresentation.highlight.selectionInfo.rangeInfo.endContainerChildTextNodeIndex}${rangeRepresentation.highlight.selectionInfo.rangeInfo.endOffset}`;
        const sha256Hex = SHA256.hash(uniqueStr);
        rangeRepresentation.highlight.id = "R2_HIGHLIGHT_" + sha256Hex;
        let rangeColor;
        if (rangeRepresentation.highlight.color) {
          rangeColor = rangeRepresentation.highlight.color;
        } else if (rangeRepresentation.color) {
          rangeColor = rangeRepresentation.color;
        }
        if (TextHighlighter.isHexColor(rangeColor)) {
          rangeColor = TextHighlighter.hexToRgbString(rangeColor);
        }
        rangeRepresentation.highlight.color = rangeColor;
        rangeRepresentation.highlight.pointerInteraction = true;
        rangeRepresentation.highlight.selectionInfo.cleanText = rangeRepresentation.highlight.selectionInfo.rawText.trim().replace(/\n/g, " ").replace(/\s\s+/g, " ");
        annotationsToStore.push(rangeRepresentation);
      });
      this.store.set(
        _LocalAnnotator.ANNOTATIONS,
        JSON.stringify(annotationsToStore)
      );
      return annotationsToStore;
    }
    saveTemporarySelectionInfo(selectionInfo) {
      this.store.set(_LocalAnnotator.SELECTIONINFO, JSON.stringify(selectionInfo));
    }
    getTemporarySelectionInfo(doc) {
      const selectionInfos = this.store.get(_LocalAnnotator.SELECTIONINFO);
      if (selectionInfos) {
        let selectionInfo = JSON.parse(selectionInfos);
        selectionInfo.range = convertRangeInfo(doc, selectionInfo.rangeInfo);
        return selectionInfo;
      }
      return [];
    }
    deleteTemporarySelectionInfo() {
      this.store.remove(_LocalAnnotator.SELECTIONINFO);
    }
    saveAnnotation(annotation) {
      let savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        let annotations = JSON.parse(savedAnnotations);
        annotations.push(annotation);
        this.store.set(_LocalAnnotator.ANNOTATIONS, JSON.stringify(annotations));
      } else {
        let annotations = [];
        annotations.push(annotation);
        this.store.set(_LocalAnnotator.ANNOTATIONS, JSON.stringify(annotations));
      }
      return annotation;
    }
    deleteAnnotation(id2) {
      let savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        let annotations = JSON.parse(savedAnnotations);
        annotations = annotations.filter((el) => el.id !== id2);
        this.store.set(_LocalAnnotator.ANNOTATIONS, JSON.stringify(annotations));
      }
      return id2;
    }
    deleteSelectedAnnotation(annotation) {
      let savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        let annotations = JSON.parse(savedAnnotations);
        annotations = annotations.filter(
          (el) => {
            var _a;
            return ((_a = el.highlight) == null ? void 0 : _a.id) !== annotation.highlight.id;
          }
        );
        this.store.set(_LocalAnnotator.ANNOTATIONS, JSON.stringify(annotations));
      }
      return annotation;
    }
    getAnnotations() {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        let annotations = JSON.parse(savedAnnotations);
        annotations = annotations.sort((n1, n2) => {
          if (n1.locations.progression && n2.locations.progression) {
            return n1.locations.progression - n2.locations.progression;
          } else {
            return void 0;
          }
        });
        return annotations;
      }
      return [];
    }
    getAnnotationsByChapter(chapter) {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        let annotations = JSON.parse(savedAnnotations);
        annotations = annotations.filter(
          (annotation) => annotation.href === chapter
        );
        annotations = annotations.sort((n1, n2) => {
          if (n1.locations.progression && n2.locations.progression) {
            return n1.locations.progression - n2.locations.progression;
          } else {
            return void 0;
          }
        });
        return annotations;
      }
      return [];
    }
    getAnnotationPosition(id2, iframeWin) {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        const annotations = JSON.parse(savedAnnotations);
        const filtered = annotations.filter(
          (el) => {
            var _a;
            return ((_a = el.highlight) == null ? void 0 : _a.id) === id2 || el.id === id2;
          }
        );
        if (filtered.length > 0) {
          let foundElement = iframeWin.document.getElementById(
            `${filtered[0].highlight.id}`
          );
          if (foundElement) {
            let position = 0;
            if (foundElement.hasChildNodes) {
              for (let i = 0; i < foundElement.childNodes.length; i++) {
                let childNode = foundElement.childNodes[i];
                let top = parseInt(childNode.style.top.replace("px", ""));
                if (top < position || position === 0) {
                  position = top;
                }
              }
            } else {
              position = parseInt(
                foundElement.style.top.replace("px", "")
              );
            }
            return position;
          }
        }
      }
      return null;
    }
    getAnnotationElement(id2, iframeWin) {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        const annotations = JSON.parse(savedAnnotations);
        const filtered = annotations.filter(
          (el) => {
            var _a;
            return ((_a = el.highlight) == null ? void 0 : _a.id) === id2;
          }
        );
        if (filtered.length > 0) {
          let foundElement = iframeWin.document.getElementById(
            `${filtered[0].highlight.id}`
          );
          if (foundElement) {
            let position = 0;
            if (foundElement.hasChildNodes) {
              for (let i = 0; i < foundElement.childNodes.length; i++) {
                let childNode = foundElement.childNodes[i];
                let top = parseInt(childNode.style.top.replace("px", ""));
                if (top < position || position === 0) {
                  position = top;
                  return childNode;
                }
              }
            } else {
              position = parseInt(
                foundElement.style.top.replace("px", "")
              );
            }
            return foundElement;
          }
        }
      }
      return null;
    }
    getAnnotation(highlight) {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        const annotations = JSON.parse(savedAnnotations);
        const filtered = annotations.filter(
          (el) => {
            var _a;
            return ((_a = el.highlight) == null ? void 0 : _a.id) === highlight.id;
          }
        );
        if (filtered.length > 0) {
          return filtered[0];
        }
      }
      return null;
    }
    getAnnotationByID(id2) {
      const savedAnnotations = this.store.get(_LocalAnnotator.ANNOTATIONS);
      if (savedAnnotations) {
        const annotations = JSON.parse(savedAnnotations);
        const filtered = annotations.filter(
          (el) => {
            var _a;
            return ((_a = el.highlight) == null ? void 0 : _a.id) === id2;
          }
        );
        if (filtered.length > 0) {
          return filtered[0];
        }
      }
      return null;
    }
  };
  _LocalAnnotator.LAST_READING_POSITION = "last-reading-position";
  _LocalAnnotator.BOOKMARKS = "bookmarks";
  _LocalAnnotator.ANNOTATIONS = "annotations";
  _LocalAnnotator.SELECTIONINFO = "selectionInfo";
  var LocalAnnotator = _LocalAnnotator;

  // src/store/LocalStorageStore.ts
  init_polyfills();

  // src/store/MemoryStore.ts
  init_polyfills();
  var MemoryStore = class {
    constructor() {
      this.store = {};
    }
    get(key) {
      return this.store[key] || null;
    }
    set(key, value) {
      this.store[key] = value;
    }
    remove(key) {
      this.store[key] = null;
    }
  };

  // src/store/LocalStorageStore.ts
  var LocalStorageStore = class {
    constructor(config2) {
      this.prefix = config2.prefix;
      this.useLocalStorage = config2.useLocalStorage;
      try {
        const testKey = config2.prefix + "-" + String(Math.random());
        if (this.useLocalStorage) {
          window.localStorage.setItem(testKey, "test");
          window.localStorage.removeItem(testKey);
        } else {
          window.sessionStorage.setItem(testKey, "test");
          window.sessionStorage.removeItem(testKey);
        }
        this.fallbackStore = null;
      } catch (e) {
        this.fallbackStore = new MemoryStore();
      }
    }
    getLocalStorageKey(key) {
      return this.prefix + "-" + key;
    }
    get(key) {
      let value;
      if (!this.fallbackStore) {
        if (this.useLocalStorage) {
          value = window.localStorage.getItem(this.getLocalStorageKey(key));
        } else {
          value = window.sessionStorage.getItem(this.getLocalStorageKey(key));
        }
      } else {
        value = this.fallbackStore.get(key);
      }
      return value;
    }
    set(key, value) {
      if (!this.fallbackStore) {
        if (this.useLocalStorage) {
          window.localStorage.setItem(this.getLocalStorageKey(key), value);
        } else {
          window.sessionStorage.setItem(this.getLocalStorageKey(key), value);
        }
      } else {
        this.fallbackStore.set(key, value);
      }
    }
    remove(key) {
      if (!this.fallbackStore) {
        if (this.useLocalStorage) {
          window.localStorage.removeItem(this.getLocalStorageKey(key));
        } else {
          window.sessionStorage.removeItem(this.getLocalStorageKey(key));
        }
      } else {
        this.fallbackStore.remove(key);
      }
    }
  };

  // src/model/Link.ts
  init_polyfills();
  var import_publication_link = __toESM(require_publication_link());
  var import_ta_json_x3 = __toESM(require_cjs());
  var Link = class extends import_publication_link.Link {
  };
  Link = __decorateClass([
    (0, import_ta_json_x3.JsonObject)()
  ], Link);
  function convertAndCamel(o) {
    let newO, origKey, newKey, value;
    if (o instanceof Array) {
      return o.map(function(value2) {
        if (typeof value2 === "object") {
          value2 = convertAndCamel(value2);
        }
        return value2;
      });
    } else {
      newO = {};
      for (origKey in o) {
        if (o.hasOwnProperty(origKey)) {
          newKey = (origKey.charAt(0).toLowerCase() + origKey.slice(1) || origKey).toString();
          value = o[origKey];
          if (value instanceof Array || value !== null && value !== void 0 && value.constructor === Object) {
            value = convertAndCamel(value);
          }
          if (newKey === "href1") {
            newO["href"] = value;
          } else if (newKey === "typeLink") {
            newO["type"] = value;
          } else {
            newO[newKey] = value;
          }
        }
      }
    }
    return newO;
  }

  // src/modules/highlight/LayerSettings.ts
  init_polyfills();
  var import_loglevel24 = __toESM(require_loglevel());
  var LayerSettings = class {
    constructor(store) {
      this.LAYERSETTINGS = "layerSetting";
      this.store = store;
      this.initialize();
    }
    static async create(config2) {
      const settings = new this(config2.store);
      return new Promise((resolve) => resolve(settings));
    }
    async stop() {
      import_loglevel24.default.log("MediaOverlay settings stop");
    }
    async initialize() {
      this.userProperties = await this.getLayerSettings();
    }
    async getLayerSettings() {
      let userProperties = new UserProperties();
      let array = await this.store.get(this.LAYERSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        userProperties.properties = properties;
      }
      return userProperties;
    }
    async saveProperty(property) {
      let savedProperties = await this.store.get(this.LAYERSETTINGS);
      if (savedProperties) {
        let array = JSON.parse(savedProperties);
        array = array.filter((el) => el.name !== property.name);
        array.push(property);
        await this.store.set(this.LAYERSETTINGS, JSON.stringify(array));
      } else {
        let array = [];
        array.push(property);
        await this.store.set(this.LAYERSETTINGS, JSON.stringify(array));
      }
      return new Promise((resolve) => resolve(property));
    }
    async getProperty(name) {
      let array = await this.store.get(this.LAYERSETTINGS);
      if (array) {
        let properties = JSON.parse(array);
        properties = properties.filter((el) => el.name === name);
        if (properties.length === 0) {
          return null;
        }
        return properties[0];
      }
      return null;
    }
  };

  // src/navigator/PDFNavigator.ts
  init_polyfills();
  var import_pdfjs_dist = __toESM(require_pdf());

  // src/utils/GrabToPan.ts
  init_polyfills();
  var CSS_CLASS_GRAB = "grab-to-pan-grab";
  var _onMouseDown, onMouseDown_fn, _onMouseMove, onMouseMove_fn, _endPan, endPan_fn;
  var GrabToPan = class {
    /**
     * Construct a GrabToPan instance for a given HTML element.
     * @param {Element} options.element
     * @param {function} [options.ignoreTarget] - See `ignoreTarget(node)`.
     * @param {function(boolean)} [options.onActiveChanged] - Called when
     *   grab-to-pan is (de)activated. The first argument is a boolean that
     *   shows whether grab-to-pan is activated.
     */
    constructor(options) {
      __privateAdd(this, _onMouseDown);
      __privateAdd(this, _onMouseMove);
      __privateAdd(this, _endPan);
      this.element = options.element;
      this.document = options.element.ownerDocument;
      if (typeof options.ignoreTarget === "function") {
        this.ignoreTarget = options.ignoreTarget;
      }
      this.onActiveChanged = options.onActiveChanged;
      this.activate = this.activate.bind(this);
      this.deactivate = this.deactivate.bind(this);
      this.toggle = this.toggle.bind(this);
      this._onMouseDown = __privateMethod(this, _onMouseDown, onMouseDown_fn).bind(this);
      this._onMouseMove = __privateMethod(this, _onMouseMove, onMouseMove_fn).bind(this);
      this._endPan = __privateMethod(this, _endPan, endPan_fn).bind(this);
      const overlay = this.overlay = document.createElement("div");
      overlay.className = "grab-to-pan-grabbing";
    }
    /**
     * Bind a mousedown event to the element to enable grab-detection.
     */
    activate() {
      var _a;
      if (!this.active) {
        this.active = true;
        this.element.addEventListener("mousedown", this._onMouseDown, true);
        this.element.classList.add(CSS_CLASS_GRAB);
        (_a = this.onActiveChanged) == null ? void 0 : _a.call(this, true);
      }
    }
    /**
     * Removes all events. Any pending pan session is immediately stopped.
     */
    deactivate() {
      var _a;
      if (this.active) {
        this.active = false;
        this.element.removeEventListener("mousedown", this._onMouseDown, true);
        this._endPan();
        this.element.classList.remove(CSS_CLASS_GRAB);
        (_a = this.onActiveChanged) == null ? void 0 : _a.call(this, false);
      }
    }
    toggle() {
      if (this.active) {
        this.deactivate();
      } else {
        this.activate();
      }
    }
    /**
     * Whether to not pan if the target element is clicked.
     * Override this method to change the default behaviour.
     *
     * @param {Element} node - The target of the event.
     * @returns {boolean} Whether to not react to the click event.
     */
    ignoreTarget(node) {
      return node.matches(
        "a[href], a[href] *, input, textarea, button, button *, select, option"
      );
    }
  };
  _onMouseDown = new WeakSet();
  onMouseDown_fn = function(event) {
    if (event.button !== 0 || this.ignoreTarget(event.target)) {
      return;
    }
    if (event.originalTarget) {
      try {
        event.originalTarget.tagName;
      } catch (e) {
        return;
      }
    }
    this.scrollLeftStart = this.element.scrollLeft;
    this.scrollTopStart = this.element.scrollTop;
    this.clientXStart = event.clientX;
    this.clientYStart = event.clientY;
    this.document.addEventListener("mousemove", this._onMouseMove, true);
    this.document.addEventListener("mouseup", this._endPan, true);
    this.element.addEventListener("scroll", this._endPan, true);
    event.preventDefault();
    event.stopPropagation();
    const focusedElement = document.activeElement;
    if (focusedElement && !focusedElement.contains(event.target)) {
      focusedElement.blur();
    }
  };
  _onMouseMove = new WeakSet();
  onMouseMove_fn = function(event) {
    this.element.removeEventListener("scroll", this._endPan, true);
    if (!(event.buttons & 1)) {
      this._endPan();
      return;
    }
    const xDiff = event.clientX - this.clientXStart;
    const yDiff = event.clientY - this.clientYStart;
    const scrollTop = this.scrollTopStart - yDiff;
    const scrollLeft = this.scrollLeftStart - xDiff;
    if (this.element.scrollTo) {
      this.element.scrollTo({
        top: scrollTop,
        left: scrollLeft,
        behavior: "instant"
      });
    } else {
      this.element.scrollTop = scrollTop;
      this.element.scrollLeft = scrollLeft;
    }
    if (!this.overlay.parentNode) {
      document.body.append(this.overlay);
    }
  };
  _endPan = new WeakSet();
  endPan_fn = function() {
    this.element.removeEventListener("scroll", this._endPan, true);
    this.document.removeEventListener("mousemove", this._onMouseMove, true);
    this.document.removeEventListener("mouseup", this._endPan, true);
    this.overlay.remove();
  };

  // src/navigator/PDFNavigator.ts
  var PDFNavigator = class extends eventemitter3_default {
    constructor(settings, publication, api) {
      super();
      this.pdfDoc = null;
      this.pageNum = 1;
      this.scaleType = 0 /* Page */;
      this.pageRendering = false;
      this.pageNumPending = null;
      this.scale = 1;
      this.resourceIndex = 0;
      this.onResize = () => {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(this.handleResize.bind(this), 200);
      };
      this.settings = settings;
      this.publication = publication;
      this.api = api;
    }
    static async create(config2) {
      const navigator2 = new this(config2.settings, config2.publication, config2.api);
      await navigator2.start(
        config2.mainElement,
        config2.headerMenu,
        config2.footerMenu
      );
      return new Promise((resolve) => resolve(navigator2));
    }
    async start(mainElement, headerMenu, footerMenu) {
      this.headerMenu = headerMenu;
      this.footerMenu = footerMenu;
      this.mainElement = mainElement;
      this.resourceIndex = 0;
      this.resource = this.publication.readingOrder[this.resourceIndex];
      import_pdfjs_dist.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.js`;
      this.wrapper = findRequiredElement(
        this.mainElement,
        "main#iframe-wrapper"
      );
      this.pdfContainer = findRequiredElement(
        this.mainElement,
        "#pdf-container"
      );
      this.handTool = new GrabToPan({
        element: this.pdfContainer
      });
      const self2 = this;
      let loadingMessage = document.createElement("div");
      loadingMessage.id = "loadingpdf";
      loadingMessage.innerHTML = readerLoading;
      loadingMessage.style.width = getComputedStyle(this.wrapper).width;
      loadingMessage.style.height = getComputedStyle(this.wrapper).height;
      loadingMessage.style.display = "flex";
      loadingMessage.style.zIndex = "100";
      loadingMessage.style.position = "absolute";
      loadingMessage.style.alignItems = "center";
      loadingMessage.style.justifyContent = "center";
      loadingMessage.style.background = "white";
      loadingMessage.className = "r2d2bc-loading is-loading";
      this.pdfContainer.appendChild(loadingMessage);
      (0, import_pdfjs_dist.getDocument)(
        this.publication.getAbsoluteHref(this.resource.Href)
      ).promise.then(function(pdfDoc_) {
        self2.pdfDoc = pdfDoc_;
        self2.loadPDFJS(self2.pageNum);
      });
      this.setupEvents();
    }
    async handleResize() {
      this.loadPDFJS(this.pageNum);
    }
    setupEvents() {
      addEventListenerOptional(window, "resize", this.onResize);
    }
    loadPDFJS(num) {
      const self2 = this;
      let currentPage = 1;
      this.wrapper.style.height = "calc(100vh - 10px)";
      this.pdfContainer.style.height = "calc(100vh - 10px)";
      this.pdfContainer.style.flexDirection = "column";
      let collection = document.getElementsByTagName("canvas");
      Array.from(collection).forEach(function(element) {
        var _a;
        (_a = element == null ? void 0 : element.parentNode) == null ? void 0 : _a.removeChild(element);
      });
      function renderPage(page) {
        const canvas = document.createElement("canvas");
        canvas.id = String(currentPage);
        canvas.style.border = "1px solid gray";
        canvas.style.margin = "1px";
        let viewport = page.getViewport({ scale: self2.scale });
        if (self2.scale === 1) {
          const fitPage = self2.wrapper.clientHeight / viewport.height;
          const fitWidth = self2.wrapper.clientWidth / viewport.width;
          if (self2.scaleType === 0 /* Page */) {
            viewport = page.getViewport({
              scale: fitPage < fitWidth ? fitPage : fitWidth
            });
          } else {
            viewport = page.getViewport({ scale: fitWidth });
          }
        }
        self2.pdfContainer.appendChild(canvas);
        const context = canvas.getContext("2d");
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        const renderContext = {
          canvasContext: context,
          viewport
        };
        let pdfload = document.getElementById("loadingpdf");
        pdfload.style.display = "flex";
        pdfload.style.width = getComputedStyle(self2.wrapper).width;
        pdfload.style.height = getComputedStyle(self2.wrapper).height;
        const renderTask = page.render(renderContext);
        renderTask.promise.then(function() {
          var _a, _b, _c;
          if (currentPage < self2.pdfDoc.numPages) {
            currentPage++;
            self2.pdfDoc.getPage(currentPage).then(renderPage);
          } else {
            (_a = document.getElementById(String(num))) == null ? void 0 : _a.scrollIntoView();
            pdfload.style.display = "none";
            if ((_b = self2.api) == null ? void 0 : _b.resourceReady)
              (_c = self2.api) == null ? void 0 : _c.resourceReady();
            self2.emit("resource.ready");
          }
        });
      }
      this.pdfDoc.getPage(currentPage).then(renderPage);
    }
    queueRenderPage(num) {
      var _a;
      const self2 = this;
      if (self2.pageRendering) {
        self2.pageNumPending = num;
      } else {
        this.pageNum = num;
        (_a = document.getElementById(String(num))) == null ? void 0 : _a.scrollIntoView();
      }
    }
    readingOrder() {
      return this.publication.readingOrder;
    }
    tableOfContents() {
      return this.publication.tableOfContents;
    }
    landmarks() {
    }
    pageList() {
    }
    //TODO:
    currentResource() {
    }
    totalResources() {
      return this.publication.readingOrder.length;
    }
    //TODO:
    currentLocator() {
    }
    positions() {
      return this.publication.positions ? this.publication.positions : [];
    }
    nextPage() {
      const self2 = this;
      if (self2.pageNum >= self2.pdfDoc.numPages) {
        this.nextResource();
        return;
      }
      this.pageNum++;
      this.queueRenderPage(self2.pageNum);
    }
    previousPage() {
      const self2 = this;
      if (self2.pageNum <= 1) {
        this.previousResource();
        return;
      }
      self2.pageNum--;
      self2.queueRenderPage(self2.pageNum);
    }
    nextResource() {
      const self2 = this;
      if (this.resourceIndex >= this.publication.readingOrder.length - 1) {
        return;
      }
      self2.resourceIndex++;
      self2.resource = this.publication.readingOrder[self2.resourceIndex];
      (0, import_pdfjs_dist.getDocument)(
        this.publication.getAbsoluteHref(this.resource.Href)
      ).promise.then(function(pdfDoc_) {
        self2.pdfDoc = pdfDoc_;
        self2.pageNum = 1;
        self2.loadPDFJS(self2.pageNum);
      });
    }
    previousResource() {
      const self2 = this;
      if (this.resourceIndex === 0) {
        return;
      }
      self2.resourceIndex--;
      self2.resource = this.publication.readingOrder[self2.resourceIndex];
      (0, import_pdfjs_dist.getDocument)(
        this.publication.getAbsoluteHref(this.resource.Href)
      ).promise.then(function(pdfDoc_) {
        self2.pdfDoc = pdfDoc_;
        self2.pageNum = self2.pdfDoc.numPages;
        self2.loadPDFJS(self2.pageNum);
      });
    }
    goTo(locator) {
      const url = new URL(locator.href);
      if (url.searchParams.has("start")) {
        const page = url.searchParams.get("start");
        if (page) {
          this.queueRenderPage(parseInt(page));
        }
      } else {
        this.queueRenderPage(1);
      }
    }
    goToPosition(value) {
      this.queueRenderPage(value);
    }
    async goToPage(page) {
      this.queueRenderPage(page);
    }
    fitToWidth() {
      this.scale = 1;
      this.scaleType = 1 /* Width */;
      this.loadPDFJS(this.pageNum);
    }
    fitToPage() {
      this.scale = 1;
      this.scaleType = 0 /* Page */;
      this.loadPDFJS(this.pageNum);
    }
    zoomIn() {
      this.scale = this.scale + 0.2;
      this.loadPDFJS(this.pageNum);
    }
    zoomOut() {
      this.scale = this.scale - 0.2;
      this.loadPDFJS(this.pageNum);
    }
    activateHand() {
      this.handTool.activate();
    }
    deactivateHand() {
      this.handTool.deactivate();
    }
    async scroll(scroll, direction) {
      if (scroll) {
        if (direction === "horizontal") {
          this.pdfContainer.style.flexDirection = "row";
        } else {
          this.pdfContainer.style.flexDirection = "column";
        }
        this.pdfContainer.style.overflow = "auto";
      } else {
        this.pdfContainer.style.flexDirection = "column";
        this.pdfContainer.style.overflow = "hidden";
      }
    }
    stop() {
      removeEventListenerOptional(window, "resize", this.onResize);
    }
  };

  // src/reader.ts
  var D2Reader = class _D2Reader {
    constructor(settings, navigator2, highlighter, bookmarkModule, annotationModule, ttsSettings, ttsModule, searchModule, definitionsModule, contentProtectionModule, timelineModule, mediaOverlaySettings, mediaOverlayModule, pageBreakModule, lineFocusModule, historyModule, citationModule, consumptionModule) {
      this.settings = settings;
      this.navigator = navigator2;
      this.highlighter = highlighter;
      this.bookmarkModule = bookmarkModule;
      this.annotationModule = annotationModule;
      this.ttsSettings = ttsSettings;
      this.ttsModule = ttsModule;
      this.searchModule = searchModule;
      this.definitionsModule = definitionsModule;
      this.contentProtectionModule = contentProtectionModule;
      this.timelineModule = timelineModule;
      this.mediaOverlaySettings = mediaOverlaySettings;
      this.mediaOverlayModule = mediaOverlayModule;
      this.pageBreakModule = pageBreakModule;
      this.lineFocusModule = lineFocusModule;
      this.historyModule = historyModule;
      this.citationModule = citationModule;
      this.consumptionModule = consumptionModule;
      /**
       * Read Aloud
       */
      /** Start TTS Read Aloud */
      this.startReadAloud = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.startReadAloud();
        }
      };
      /** Start TTS Read Aloud */
      this.stopReadAloud = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.stopReadAloud();
        }
      };
      /** Start TTS Read Aloud */
      this.pauseReadAloud = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.pauseReadAloud();
        }
      };
      /** Start TTS Read Aloud */
      this.resumeReadAloud = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.resumeReadAloud();
        }
      };
      /**
       * Read Along
       */
      /** Start Media Overlay Read Along */
      this.startReadAlong = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.startReadAlong();
        }
      };
      /** Stop Media Overlay Read Along */
      this.stopReadAlong = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.stopReadAlong();
        }
      };
      /** Pause Media Overlay Read Along */
      this.pauseReadAlong = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.pauseReadAlong();
        }
      };
      /** Resume Media Overlay Read Along */
      this.resumeReadAlong = () => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.resumeReadAlong();
        }
      };
      /**
       * Bookmarks and annotations
       */
      /** Save bookmark by progression */
      this.saveBookmark = async () => {
        var _a;
        return await ((_a = this.bookmarkModule) == null ? void 0 : _a.saveBookmark()) ?? false;
      };
      /** Save bookmark by annotation */
      this.saveBookmarkPlus = async () => {
        var _a;
        return (_a = this.bookmarkModule) == null ? void 0 : _a.saveBookmarkPlus();
      };
      /** Delete bookmark */
      this.deleteBookmark = async (bookmark) => {
        var _a;
        return await ((_a = this.bookmarkModule) == null ? void 0 : _a.deleteBookmark(bookmark)) ?? false;
      };
      /** Delete annotation */
      this.deleteAnnotation = async (highlight) => {
        var _a;
        return await ((_a = this.annotationModule) == null ? void 0 : _a.deleteAnnotation(highlight)) ?? false;
      };
      /** Add annotation */
      this.addAnnotation = async (highlight) => {
        var _a;
        return await ((_a = this.annotationModule) == null ? void 0 : _a.addAnnotation(highlight)) ?? false;
      };
      /** Hide Annotation Layer */
      this.hideAnnotationLayer = () => {
        var _a;
        return (_a = this.annotationModule) == null ? void 0 : _a.hideAnnotationLayer();
      };
      /** Show Annotation Layer */
      this.showAnnotationLayer = () => {
        var _a;
        return (_a = this.annotationModule) == null ? void 0 : _a.showAnnotationLayer();
      };
      /** Hide  Layer */
      this.hideLayer = (layer) => {
        var _a;
        return this.navigator instanceof IFrameNavigator ? (_a = this.navigator) == null ? void 0 : _a.hideLayer(layer) : false;
      };
      /** Show  Layer */
      this.showLayer = (layer) => {
        var _a;
        return this.navigator instanceof IFrameNavigator ? (_a = this.navigator) == null ? void 0 : _a.showLayer(layer) : false;
      };
      /** Activate Marker <br>
       * Activated Marker will be used for active annotation creation */
      this.activateMarker = (id2, position) => {
        var _a;
        return this.navigator instanceof IFrameNavigator ? (_a = this.navigator) == null ? void 0 : _a.activateMarker(id2, position) : false;
      };
      /** Deactivate Marker */
      this.deactivateMarker = () => {
        var _a;
        return this.navigator instanceof IFrameNavigator ? (_a = this.navigator) == null ? void 0 : _a.deactivateMarker() : false;
      };
      /**
       * Definitions
       */
      /** Clear current definitions */
      this.clearDefinitions = async () => {
        var _a;
        await ((_a = this.definitionsModule) == null ? void 0 : _a.clearDefinitions());
      };
      /** Add newt definition */
      this.addDefinition = async (definition) => {
        var _a;
        await ((_a = this.definitionsModule) == null ? void 0 : _a.addDefinition(definition));
      };
      /** History Back */
      this.historyBack = async () => {
        var _a;
        return (_a = this.historyModule) == null ? void 0 : _a.historyBack();
      };
      /** History Forward */
      this.historyForward = async () => {
        var _a;
        return (_a = this.historyModule) == null ? void 0 : _a.historyForward();
      };
      /**
       * Search
       */
      /** Search by term and current resource or entire book <br>
       * current = true, will search only current resource <br>
       * current = false, will search entire publication */
      this.search = async (term, current) => {
        var _a;
        return await ((_a = this.searchModule) == null ? void 0 : _a.search(term, current)) ?? [];
      };
      this.goToSearchIndex = async (href, index2, current) => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableSearch) {
          await ((_a = this.searchModule) == null ? void 0 : _a.goToSearchIndex(href, index2, current));
        }
      };
      this.goToSearchID = async (href, index2, current) => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableSearch) {
          await ((_a = this.searchModule) == null ? void 0 : _a.goToSearchID(href, index2, current));
        }
      };
      this.clearSearch = async () => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableSearch) {
          await ((_a = this.searchModule) == null ? void 0 : _a.clearSearch());
        }
      };
      this.resetUserSettings = async () => {
        return await this.settings.resetUserSettings();
      };
      this.applyUserSettings = async (userSettings) => {
        return await this.settings.applyUserSettings(userSettings);
      };
      this.scroll = async (value, direction) => {
        if (this.navigator instanceof PDFNavigator) {
          return this.navigator.scroll(value, direction);
        }
        return await this.settings.scroll(value);
      };
      /**
       * Used to increase anything that can be increased,
       * such as pitch, rate, volume, fontSize
       */
      this.increase = async (incremental) => {
        var _a, _b;
        if (this.isTTSIncrementable(incremental)) {
          if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableTTS) {
            await ((_a = this.ttsSettings) == null ? void 0 : _a.increase(incremental));
          }
        } else if (this.isMOIncrementable(incremental)) {
          if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableMediaOverlays) {
            await ((_b = this.mediaOverlaySettings) == null ? void 0 : _b.increase(incremental));
          }
        } else {
          await this.settings.increase(incremental);
        }
      };
      /**
       * Used to decrease anything that can be decreased,
       * such as pitch, rate, volume, fontSize
       */
      this.decrease = async (incremental) => {
        var _a, _b;
        if (this.isTTSIncrementable(incremental)) {
          if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableTTS) {
            await ((_a = this.ttsSettings) == null ? void 0 : _a.decrease(incremental));
          }
        } else if (this.isMOIncrementable(incremental)) {
          if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableMediaOverlays) {
            await ((_b = this.mediaOverlaySettings) == null ? void 0 : _b.decrease(incremental));
          }
        } else {
          await this.settings.decrease(incremental);
        }
      };
      /**
       * Publisher?
       * Disabled
       */
      // publisher = (on) => {
      //   this.settings.publisher(on);
      // };
      /**
       * TTS Settings
       */
      this.resetTTSSettings = () => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableTTS) {
          (_a = this.ttsSettings) == null ? void 0 : _a.resetTTSSettings();
        }
      };
      this.applyTTSSettings = async (ttsSettings) => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableTTS) {
          await ((_a = this.ttsSettings) == null ? void 0 : _a.applyTTSSettings(ttsSettings));
        }
      };
      /**
       * Disabled
       */
      // applyTTSSetting = (key: string, value: any) => {
      //   if (this.navigator.rights.enableTTS) {
      //     this.ttsSettings.applyTTSSetting(key, value);
      //   }
      // };
      this.applyPreferredVoice = async (value) => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableTTS) {
          await ((_a = this.ttsSettings) == null ? void 0 : _a.applyPreferredVoice(value));
        }
      };
      /**
       * Media Overlay Settings
       */
      this.resetMediaOverlaySettings = async () => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableMediaOverlays) {
          await ((_a = this.mediaOverlaySettings) == null ? void 0 : _a.resetMediaOverlaySettings());
        }
      };
      this.applyMediaOverlaySettings = async (settings) => {
        var _a;
        if (this.navigator instanceof IFrameNavigator && this.navigator.rights.enableMediaOverlays) {
          await ((_a = this.mediaOverlaySettings) == null ? void 0 : _a.applyMediaOverlaySettings(settings));
        }
      };
      this.goTo = async (locator) => {
        this.navigator.goTo(locator);
      };
      this.goToPosition = async (value) => {
        return this.navigator.goToPosition(value);
      };
      this.goToPage = async (page) => {
        await this.navigator.goToPage(page);
      };
      this.fitToPage = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.fitToPage();
        }
      };
      this.fitToWidth = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.fitToWidth();
        }
      };
      this.zoomIn = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.zoomIn();
        }
      };
      this.zoomOut = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.zoomOut();
        }
      };
      this.activateHand = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.activateHand();
        }
      };
      this.deactivateHand = () => {
        if (this.navigator instanceof PDFNavigator) {
          this.navigator.deactivateHand();
        }
      };
      this.copyToClipboard = (text) => {
        var _a;
        (_a = this.contentProtectionModule) == null ? void 0 : _a.copyToClipboard(text);
      };
      this.nextResource = () => {
        this.navigator.nextResource();
      };
      this.previousResource = () => {
        this.navigator.previousResource();
      };
      this.nextPage = async () => {
        this.navigator.nextPage();
      };
      this.previousPage = async () => {
        this.navigator.previousPage();
      };
      this.snapToSelector = async (selector2) => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.snapToSelector(selector2);
        }
      };
      /**
       * You have attributes in the reader when you initialize it. You can set margin, navigationHeight etc...
       * This is in case you change the attributes after initializing the reader.
       */
      this.applyAttributes = (value) => {
        if (this.navigator instanceof IFrameNavigator) {
          this.navigator.applyAttributes(value);
        }
      };
      /**
       * Destructor:
       * Only used in react applications because when they re-visit the page
       * it tried to create a new reader, which interfered with the first one.
       */
      this.stop = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        document.body.onscroll = () => {
        };
        this.navigator.stop();
        this.settings.stop();
        (_a = this.ttsSettings) == null ? void 0 : _a.stop();
        (_b = this.ttsModule) == null ? void 0 : _b.stop();
        (_c = this.bookmarkModule) == null ? void 0 : _c.stop();
        (_d = this.annotationModule) == null ? void 0 : _d.stop();
        (_e = this.searchModule) == null ? void 0 : _e.stop();
        (_f = this.definitionsModule) == null ? void 0 : _f.stop();
        (_g = this.contentProtectionModule) == null ? void 0 : _g.stop();
        (_h = this.timelineModule) == null ? void 0 : _h.stop();
        (_i = this.mediaOverlaySettings) == null ? void 0 : _i.stop();
        (_j = this.mediaOverlayModule) == null ? void 0 : _j.stop();
        (_k = this.pageBreakModule) == null ? void 0 : _k.stop();
        (_l = this.lineFocusModule) == null ? void 0 : _l.stop();
        (_m = this.citationModule) == null ? void 0 : _m.stop();
        (_n = this.consumptionModule) == null ? void 0 : _n.stop();
      };
    }
    addEventListener() {
      if (this.navigator instanceof IFrameNavigator) {
        this.navigator.addListener(arguments[0], arguments[1]);
      }
    }
    /**
     * The async builder.
     */
    static async load(initialConfig) {
      var _a, _b, _c, _d, _e, _f, _g;
      let rights = initialConfig.rights ?? {
        autoGeneratePositions: false,
        enableAnnotations: false,
        enableBookmarks: false,
        enableContentProtection: false,
        enableDefinitions: false,
        enableLineFocus: false,
        enableMediaOverlays: false,
        enablePageBreaks: false,
        enableSearch: false,
        enableTTS: false,
        enableTimeline: false,
        customKeyboardEvents: false,
        enableHistory: false,
        enableCitations: false
      };
      if (rights.enableContentProtection && initialConfig.protection) {
        await ContentProtectionModule.setupPreloadProtection(
          initialConfig.protection
        );
      }
      const mainElement = findRequiredElement(document, "#D2Reader-Container");
      const headerMenu = findElement(document, "#headerMenu");
      const footerMenu = findElement(document, "#footerMenu");
      let webPubManifestUrl = initialConfig.url;
      let publication;
      if (initialConfig.publication) {
        publication = TaJsonDeserialize(
          initialConfig.publication,
          Publication
        );
        publication.manifestUrl = new URL(webPubManifestUrl);
      } else {
        publication = await Publication.fromUrl(
          webPubManifestUrl,
          initialConfig.requestConfig
        );
      }
      let store;
      if (initialConfig.storageType === "memory") {
        store = new MemoryStore();
      } else {
        store = new LocalStorageStore({
          prefix: publication.manifestUrl,
          useLocalStorage: initialConfig.useLocalStorage ?? false
        });
      }
      let settingsStore;
      if (initialConfig.storageType === "memory") {
        settingsStore = new MemoryStore();
      } else {
        settingsStore = new LocalStorageStore({
          prefix: "r2d2bc-reader",
          useLocalStorage: initialConfig.useLocalStorage ?? false
        });
      }
      let layerStore;
      if (initialConfig.storageType === "memory") {
        layerStore = new MemoryStore();
      } else {
        layerStore = new LocalStorageStore({
          prefix: "r2d2bc-layers",
          useLocalStorage: initialConfig.useLocalStorage ?? false
        });
      }
      const annotator = new LocalAnnotator({ store });
      publication.sample = initialConfig.sample;
      rights = updateConfig(rights, publication);
      if (publication.Metadata.ConformsTo && publication.Metadata.ConformsTo.includes(
        "https://readium.org/webpub-manifest/profiles/pdf"
      )) {
        const settings = await UserSettings.create({
          store: settingsStore,
          initialUserSettings: initialConfig.userSettings,
          layout: ""
        });
        const navigator2 = await PDFNavigator.create({
          mainElement,
          publication,
          settings,
          api: initialConfig.api
        });
        return new _D2Reader(settings, navigator2);
      } else {
        if (rights.autoGeneratePositions) {
          await publication.autoGeneratePositions(initialConfig.requestConfig);
        } else {
          if ((_a = initialConfig.services) == null ? void 0 : _a.positions) {
            await publication.fetchPositionsFromService(
              (_b = initialConfig.services) == null ? void 0 : _b.positions.href,
              initialConfig.requestConfig
            );
          }
          if ((_c = initialConfig.services) == null ? void 0 : _c.weight) {
            await publication.fetchWeightsFromService(
              (_d = initialConfig.services) == null ? void 0 : _d.weight.href,
              initialConfig.requestConfig
            );
          }
        }
        const layers = await LayerSettings.create({ store: layerStore });
        const settings = await UserSettings.create({
          store: settingsStore,
          initialUserSettings: initialConfig.userSettings,
          headerMenu,
          api: initialConfig.api,
          injectables: (((_e = publication.Metadata.Rendition) == null ? void 0 : _e.Layout) ?? "unknown") === "fixed" ? initialConfig.injectablesFixed : initialConfig.injectables,
          layout: (((_f = publication.Metadata.Rendition) == null ? void 0 : _f.Layout) ?? "unknown") === "fixed" ? "fixed" : "reflowable"
        });
        const highlighter = await TextHighlighter.create({
          layerSettings: layers,
          ...initialConfig.highlighter
        });
        const bookmarkModule = rights.enableBookmarks ? await BookmarkModule.create({
          annotator,
          headerMenu,
          rights,
          publication,
          initialAnnotations: initialConfig.initialAnnotations,
          ...initialConfig.bookmarks
        }) : void 0;
        const annotationModule = rights.enableAnnotations ? await AnnotationModule.create({
          annotator,
          rights,
          publication,
          initialAnnotations: initialConfig.initialAnnotations,
          highlighter,
          headerMenu,
          ...initialConfig.annotations
        }) : void 0;
        const ttsEnabled = rights.enableTTS;
        const ttsSettings = ttsEnabled ? await TTSSettings.create({
          store: settingsStore,
          initialTTSSettings: initialConfig.tts,
          headerMenu
        }) : void 0;
        let ttsModule = void 0;
        if (ttsEnabled && ttsSettings) {
          ttsModule = await TTSModule2.create({
            tts: ttsSettings,
            headerMenu,
            rights,
            highlighter,
            ...initialConfig.tts
          });
        }
        const searchModule = rights.enableSearch ? await SearchModule.create({
          headerMenu,
          publication,
          highlighter,
          ...initialConfig.search
        }) : void 0;
        const definitionsModule = rights.enableDefinitions ? await DefinitionsModule.create({
          publication,
          highlighter,
          ...initialConfig.define
        }) : void 0;
        const timelineModule = rights.enableTimeline ? await TimelineModule.create({
          publication
        }) : void 0;
        const contentProtectionModule = rights.enableContentProtection ? await ContentProtectionModule.create({
          ...initialConfig.protection
        }) : void 0;
        const citationModule = rights.enableCitations ? await CitationModule.create({
          publication,
          highlighter,
          ...initialConfig.citations
        }) : void 0;
        const enableMediaOverlays = rights.enableMediaOverlays;
        const mediaOverlaySettings = enableMediaOverlays ? await MediaOverlaySettings.create({
          store: settingsStore,
          initialMediaOverlaySettings: initialConfig.mediaOverlays,
          headerMenu,
          ...initialConfig.mediaOverlays
        }) : void 0;
        const mediaOverlayModule = enableMediaOverlays ? await MediaOverlayModule.create({
          publication,
          settings: mediaOverlaySettings,
          ...initialConfig.mediaOverlays
        }) : void 0;
        const enablePageBreaks = rights.enablePageBreaks;
        const pageBreakModule = enablePageBreaks && publication.isReflowable ? await PageBreakModule.create({
          publication,
          headerMenu,
          ...initialConfig.pagebreak
        }) : void 0;
        const lineFocusModule = rights.enableLineFocus ? await LineFocusModule.create({
          publication,
          highlighter,
          ...initialConfig.lineFocus
        }) : void 0;
        const historyModule = rights.enableHistory ? await HistoryModule.create({
          annotator,
          publication,
          headerMenu
        }) : void 0;
        const consumptionModule = rights.enableConsumption ? await ConsumptionModule.create({
          publication,
          ...initialConfig.consumption
        }) : void 0;
        const navigator2 = await IFrameNavigator.create({
          mainElement,
          headerMenu,
          footerMenu,
          publication,
          settings,
          annotator,
          initialLastReadingPosition: initialConfig.lastReadingPosition,
          api: initialConfig.api,
          rights,
          tts: initialConfig.tts,
          sample: initialConfig.sample,
          requestConfig: initialConfig.requestConfig,
          injectables: (((_g = publication.Metadata.Rendition) == null ? void 0 : _g.Layout) ?? "unknown") === "fixed" ? initialConfig.injectablesFixed ?? [] : initialConfig.injectables,
          attributes: initialConfig.attributes,
          services: initialConfig.services,
          highlighter,
          modules: [
            bookmarkModule,
            annotationModule,
            ttsModule,
            searchModule,
            definitionsModule,
            timelineModule,
            contentProtectionModule,
            citationModule,
            mediaOverlayModule,
            pageBreakModule,
            lineFocusModule,
            historyModule,
            consumptionModule
          ]
        });
        return new _D2Reader(
          settings,
          navigator2,
          highlighter,
          bookmarkModule,
          annotationModule,
          ttsSettings,
          ttsModule,
          searchModule,
          definitionsModule,
          contentProtectionModule,
          timelineModule,
          mediaOverlaySettings,
          mediaOverlayModule,
          pageBreakModule,
          lineFocusModule,
          historyModule,
          citationModule,
          consumptionModule
        );
      }
    }
    get hasMediaOverlays() {
      if (this.navigator instanceof IFrameNavigator) {
        return this.navigator.hasMediaOverlays;
      }
      return false;
    }
    /** Table of Contents */
    get tableOfContents() {
      return convertAndCamel(this.navigator.tableOfContents()) ?? [];
    }
    /** Landmarks */
    get landmarks() {
      return convertAndCamel(this.navigator.landmarks()) ?? [];
    }
    /** Page List */
    get pageList() {
      return convertAndCamel(this.navigator.pageList()) ?? [];
    }
    /** Reading Order or Spine */
    get readingOrder() {
      return convertAndCamel(this.navigator.readingOrder()) ?? [];
    }
    /** Current Bookmarks */
    get bookmarks() {
      var _a;
      return ((_a = this.bookmarkModule) == null ? void 0 : _a.getBookmarks()) ?? [];
    }
    /** Current Annotations */
    get annotations() {
      var _a;
      return (_a = this.annotationModule) == null ? void 0 : _a.getAnnotations();
    }
    /** History */
    get history() {
      var _a;
      return (_a = this.historyModule) == null ? void 0 : _a.history;
    }
    /** Current index of history */
    get historyCurrentIndex() {
      var _a;
      return (_a = this.historyModule) == null ? void 0 : _a.historyCurrentIndex;
    }
    /**
     * Resources
     */
    get currentResource() {
      return this.navigator.currentResource();
    }
    get mostRecentNavigatedTocItem() {
      return this.navigator instanceof IFrameNavigator ? this.navigator.mostRecentNavigatedTocItem() : false;
    }
    get totalResources() {
      return this.navigator.totalResources();
    }
    get publicationLanguage() {
      return this.navigator.publication.Metadata.Language;
    }
    /**
     * Settings
     */
    get currentSettings() {
      return this.settings.currentSettings;
    }
    isTTSIncrementable(incremental) {
      return incremental === "pitch" || incremental === "rate" || incremental === "volume";
    }
    isMOIncrementable(incremental) {
      return incremental === "mo_rate" || incremental === "mo_volume";
    }
    /**
     * Navigation
     * @TODO : These should return promises that complete when they are done.
     */
    get currentLocator() {
      return this.navigator.currentLocator();
    }
    get positions() {
      return this.navigator.positions();
    }
    get atStart() {
      return this.navigator instanceof IFrameNavigator ? this.navigator.atStart() : false;
    }
    get atEnd() {
      return this.navigator instanceof IFrameNavigator ? this.navigator.atEnd() : false;
    }
    async applyLineFocusSettings(userSettings) {
      if (userSettings.lines) {
        if (this.lineFocusModule) {
          const lines = this.lineFocusModule.properties.lines ?? 1;
          this.lineFocusModule.index = this.lineFocusModule.index * lines / parseInt(userSettings.lines);
          this.lineFocusModule.index = Math.abs(
            parseInt(this.lineFocusModule.index.toFixed())
          );
          this.lineFocusModule.properties.lines = parseInt(userSettings.lines);
          if (this.lineFocusModule.isActive) {
            await this.lineFocusModule.enableLineFocus();
          }
        }
      }
      if (userSettings.debug !== void 0) {
        if (this.lineFocusModule) {
          this.lineFocusModule.isDebug = userSettings.debug;
          if (this.lineFocusModule.isActive) {
            await this.lineFocusModule.enableLineFocus();
          }
        }
      }
    }
    lineUp() {
      var _a;
      (_a = this.lineFocusModule) == null ? void 0 : _a.lineUp();
    }
    lineDown() {
      var _a;
      (_a = this.lineFocusModule) == null ? void 0 : _a.lineDown();
    }
    async enableLineFocus() {
      var _a;
      await ((_a = this.lineFocusModule) == null ? void 0 : _a.enableLineFocus());
    }
    async lineFocus(active) {
      var _a, _b;
      if (active) {
        await ((_a = this.lineFocusModule) == null ? void 0 : _a.enableLineFocus());
      } else {
        (_b = this.lineFocusModule) == null ? void 0 : _b.disableLineFocus();
      }
    }
    disableLineFocus() {
      var _a;
      (_a = this.lineFocusModule) == null ? void 0 : _a.disableLineFocus();
    }
  };
  function updateConfig(rights, publication) {
    var _a;
    if (publication.isFixedLayout) {
      rights.enableAnnotations = false;
      rights.enableSearch = false;
      rights.enableTTS = false;
      rights.enableDefinitions = false;
      rights.enablePageBreaks = false;
      rights.enableLineFocus = false;
    }
    if ((_a = publication.sample) == null ? void 0 : _a.isSampleRead) {
      rights.enableAnnotations = false;
      rights.enableSearch = false;
      rights.enableTTS = false;
      rights.enableDefinitions = false;
      rights.enableTimeline = false;
      rights.enableMediaOverlays = false;
      rights.enablePageBreaks = false;
      rights.enableLineFocus = false;
    }
    return rights;
  }

  // src/index.ts
  var src_default = D2Reader;
  var load = D2Reader.load;
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

is-plain-object/dist/is-plain-object.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=reader.js.map
